<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Invisible XML</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">What if you could see everything as XML? XML has many
strengths for data exchange, strengths both inherent in the nature
of XML markup and strengths that derive from the ubiquity of tools
that can process XML. For authoring, however, other forms are
preferred: no one writes CSS or Javascript in XML. It does not
follow, however, that there is no value in representing such
information in XML. </textual><emphasis class="po-inline e8 e8"><textual class="po-textual">Invisible XML</textual></emphasis><textual class="po-textual"> is a method
for treating non-XML documents as if they were XML, enabling
authors to write in a format they prefer while providing XML for
processes that are more effective with XML content. There is really
no reason why XML cannot be more ubiquitous than it is.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Steven</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Pemberton</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Researcher</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">CWI, Amsterdam</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">steven.pemberton@cwi.nl</textual></email></author><legalnotice class="po-container e19 e19"><para class="po-block e20 e20"><textual class="po-textual">Copyright Â© Steven Pemberton 2013, all rights reserved.</textual></para></legalnotice></info><section class="po-hcontainer e21 e21" xml:id="XML_and_Authorin"><title class="po-block e22 e22"><textual class="po-textual">XML and
Authoring</textual></title><para class="po-block e23 e23"><textual class="po-textual">XML is a popular format. It is widely and successfully used
for document and data storage, exchange and presentation. A major
advantage of using XML is the toolchain and pipeline available for
generic XML processing. You can easily use new formats within the
generic framework.</textual></para><para class="po-block e24 e24"><textual class="po-textual">However, for authoring purposes XML is seldom preferred over
a notation more directly suited to the purpose. Few would prefer to
write their CSS rules as</textual></para><programlisting class="po-block e25 e25" xml:space="preserve"><textual class="po-textual">
&lt;rule&gt;&lt;simple-selector name="body"/&gt;&lt;block&gt;&lt;property name="color" value="blue"/&gt;&lt;/block&gt;&lt;/rule&gt;
</textual></programlisting><para class="po-block e26 e26"><textual class="po-textual">to the more direct</textual></para><programlisting class="po-block e27 e27" xml:space="preserve"><textual class="po-textual">
body {color: blue}
</textual></programlisting><para class="po-block e28 e28"><textual class="po-textual">and even less would prefer to write</textual></para><programlisting class="po-block e29 e29" xml:space="preserve"><textual class="po-textual">
&lt;statement&gt;&lt;if&gt;&lt;condition&gt;&lt;comparison name="&amp;lt;"&gt;&lt;var name="max"&gt;&lt;var name="a"&gt;&lt;/comparison&gt;&lt;/condition&gt;&lt;then&gt;&lt;statement&gt;&lt;assign&gt;&lt;var name="max"/&gt;&lt;expression&gt;&lt;var name="a"/&gt;&lt;/expression&gt;&lt;/assign&gt;&lt;/statement&gt;&lt;/then&gt;&lt;/if&gt;&lt;/statement&gt;
</textual></programlisting><para class="po-block e30 e30"><textual class="po-textual">to the much more direct</textual></para><programlisting class="po-block e31 e31" xml:space="preserve"><textual class="po-textual">
if (max&lt;a) then max=a;
</textual></programlisting><para class="po-block e32 e32"><textual class="po-textual">And, of course it should be noted that even RELAX NG has both
an XML syntax and a 'compact' syntax </textual><xref class="po-milestone e33 e33" linkend="RelaxNG"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> </textual><xref class="po-milestone e34 e34" linkend="RelaxNGCOMPACT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e35 e35"><textual class="po-textual">In fact if we are to be brutally honest, even XML formats
take short cuts for authoring ease. Take for instance an
</textual><code class="po-atom e36 e36"><textual class="po-textual">&lt;a&gt;</textual></code><textual class="po-textual"> element in XHTML:</textual></para><programlisting class="po-block e37 e37" xml:space="preserve"><textual class="po-textual">
&lt;a href="http://www.w3.org/TR/1999/xhtml"&gt;XHTML&lt;/a&gt;
</textual></programlisting><para class="po-block e38 e38"><textual class="po-textual">This does not surface the </textual><emphasis class="po-inline e39 e39"><textual class="po-textual">real</textual></emphasis><textual class="po-textual"> structure
of the underlying data. If we were to be completely faithful to the
principle of making all relevant structure explicit, we should
really write something along the lines of</textual></para><programlisting class="po-block e40 e40" xml:space="preserve"><textual class="po-textual">
&lt;a&gt;&lt;href&gt;&lt;method type="href"/&gt;&lt;domain name="org"/&gt;&lt;site name="w3"/&gt;&lt;sub name="www"/&gt;&lt;path&gt;&lt;root&gt;&lt;sub name="TR"&gt;&lt;sub name="1999"&gt;&lt;sub name="xhtml"&lt;/sub&gt;&lt;/sub&gt;&lt;/sub&gt;&lt;/root&gt;&lt;/path&gt;&lt;/href&gt;&lt;text&gt;XHTML&lt;/text&gt;&lt;/a&gt;
</textual></programlisting><para class="po-block e41 e41"><textual class="po-textual">You might argue about the details here, but this example is
only to show that there are parts of XML documents that could be
further structured, but that we choose not to, possibly for
authoring ease, possibly for fear of being laughed out of
town.</textual></para><para class="po-block e42 e42"><textual class="po-textual">The reasons for this are obvious: despite the disadvantages
of not being able to use the generic toolchain any more, or only to
a lesser degree, the increased readability of the source, and its
closer relation to the problem domain makes authoring so much
easier.</textual></para></section><section class="po-hcontainer e43 e43" xml:id="Parsing_and_Parse_tree"><title class="po-block e44 e44"><textual class="po-textual">Parsing and Parse
trees</textual></title><para class="po-block e45 e45"><textual class="po-textual">Part of the advantage of XML is that there is a single parser
needed to be able to deal with any kind of document. This can be
contrasted with for instance the situation for HTML, where you need
a parser for the HTML, with separate parsers for CSS and Javascript
at least, (and URLs), creating extra complexity and
brittleness.</textual></para><para class="po-block e46 e46"><textual class="po-textual">But looked at through a suitable pair of glasses, what is XML
apart from a description of a parse tree for some format (with some
special treatment for text nodes)? And frankly, what is so
difficult about general-purpose parsing? It is a widely understood
and easily solved problem. Is it not possible to combine the best
of both worlds, and have authorable formats, that can still use the
XML tool chain? Couldn't XML become the underlying format for
</textual><emphasis class="po-inline e47 e47"><textual class="po-textual">everything?</textual></emphasis></para></section><section class="po-hcontainer e48 e48" xml:id="The_Approac"><title class="po-block e49 e49"><textual class="po-textual">The Approach</textual></title><para class="po-block e50 e50"><textual class="po-textual">The approach presented here is to add one more step to the
XML processing chain, an initial one. This step takes any textual
document, and a (reference to) a suitable syntax description,
parses the document using the syntax description, and produces as
output a parse tree that can be treated as an XML document with no
further parsing necessary (or alternatively, the document can be
serialised out to XML).</textual></para><para class="po-block e51 e51"><textual class="po-textual">In other words, the input document might be</textual></para><programlisting class="po-block e52 e52" xml:space="preserve"><textual class="po-textual">
body {color: blue}
</textual></programlisting><para class="po-block e53 e53"><textual class="po-textual">but the result of the parse will be the same as if an XML
parser had been presented with the XML document</textual></para><programlisting class="po-block e54 e54" xml:space="preserve"><textual class="po-textual">
&lt;css&gt;
   &lt;rule&gt;&lt;simple-selector name="body"/&gt;
      &lt;block&gt;&lt;property name="color" value="blue"/&gt;&lt;/block&gt;
   &lt;/rule&gt;
&lt;/css&gt;
</textual></programlisting><para class="po-block e55 e55"><textual class="po-textual">We call this method </textual><emphasis class="po-inline e56 e56"><textual class="po-textual">Invisible XML</textual></emphasis><textual class="po-textual">, since
the document is treated as XML, but it is not visibly an XML
document.</textual></para></section><section class="po-hcontainer e57 e57" xml:id="Syntax_Descriptio"><title class="po-block e58 e58"><textual class="po-textual">Syntax
Description</textual></title><para class="po-block e59 e59"><textual class="po-textual">The requirement is to find a suitable way to describe the
syntax of the input document so that the resultant parse-tree is of
the form suitable for use in our XML chain. If we were to use BNF
</textual><xref class="po-milestone e60 e60" linkend="BNF"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, arguably the most well-known syntax-description format, it
might look like this (in what follows "..." is used for parts of
the definition that have been elided and will be defined
later):</textual></para><programlisting class="po-block e61 e61" xml:space="preserve"><textual class="po-textual">
&lt;css&gt; ::= &lt;rules&gt;
&lt;rules&gt; ::= &lt;rule&gt; | &lt;rules&gt; &lt;rule&gt;
&lt;rule&gt; ::= &lt;selector&gt; &lt;block&gt;
&lt;block&gt; ::= "{" &lt;properties&gt; "}"
&lt;properties&gt; ::= &lt;property&gt; | &lt;property&gt; ";" &lt;properties&gt;
&lt;property&gt; ::= &lt;name&gt; ":" &lt;value&gt; | &lt;empty&gt;
&lt;selector&gt; ::= &lt;name&gt;
</textual></programlisting><para class="po-block e62 e62"><textual class="po-textual">etc, etc. But it is quickly apparent that this has some
shortcomings. Firstly a surface problem that since we are using
this for XML, we could quickly go crazy with the use of angle
brackets for two different purposes. Although there is a certain
charm to defining the </textual><code class="po-atom e63 e63"><textual class="po-textual">&lt;css&gt;</textual></code><textual class="po-textual"> element with a
syntax rule whose name is </textual><code class="po-atom e64 e64"><textual class="po-textual">&lt;css&gt;</textual></code><textual class="po-textual">, let us
rather use a different format. Therefore we shall use a variant of
VWG format  </textual><xref class="po-milestone e65 e65" linkend="VWG"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. This looks like:</textual></para><programlisting class="po-block e66 e66" xml:space="preserve"><textual class="po-textual">
css: rules.
rules: rule; rules, rule.
rule: selector, block.
block: "{", properties, "}".
properties:  property; property, ";", properties.
property:  name, ":", value; empty.
selector: name.
name: ...
value: ...
empty: .
</textual></programlisting><para class="po-block e67 e67"><textual class="po-textual">(We shall restrict ourselves to a simplified CSS grammar for
the sake of this article).</textual></para><para class="po-block e68 e68"><textual class="po-textual">Note that ";" signifies alternatives, and as is normal in
syntax definitions, if one alternative is empty (or reduces to
empty), the rule is optional.</textual></para><para class="po-block e69 e69"><textual class="po-textual">If we parse the snippet of CSS above with this, and then
represent the resulting parse tree in an XML style (so that each
nonterminal is represented as an XML element), a second problem
becomes apparent:</textual></para><programlisting class="po-block e70 e70" xml:space="preserve"><textual class="po-textual">
&lt;css&gt;
   &lt;rules&gt;
      &lt;rule&gt;
         &lt;selector&gt;body&lt;/selector&gt;
         &lt;block&gt;
            &lt;properties&gt;
               &lt;property&gt;
                  &lt;name&gt;color&lt;/name&gt;
                  &lt;value&gt;blue&lt;/value&gt;
               &lt;/property&gt;
            &lt;/properties&gt;
         &lt;/block&gt;
      &lt;/rule&gt;
   &lt;/rules&gt;
&lt;/css&gt;
</textual></programlisting><para class="po-block e71 e71"><textual class="po-textual">namely that there are certain elements in the tree
(</textual><code class="po-atom e72 e72"><textual class="po-textual">rules</textual></code><textual class="po-textual">, </textual><code class="po-atom e73 e73"><textual class="po-textual">properties</textual></code><textual class="po-textual">) that we
really aren't interested in. (You'll notice that some terminal
symbols such as the brackets, colons and semicolons don't appear in
the parse tree. This will be discussed later).</textual></para><para class="po-block e74 e74"><textual class="po-textual">The problem becomes even more apparent with a CSS snippet
like</textual></para><programlisting class="po-block e75 e75" xml:space="preserve"><textual class="po-textual">
body {color: blue; font-weight: bold}
</textual></programlisting><para class="po-block e76 e76"><textual class="po-textual">since the content of the </textual><code class="po-atom e77 e77"><textual class="po-textual">&lt;block&gt;</textual></code><textual class="po-textual">
element then becomes even more unwieldly:</textual></para><programlisting class="po-block e78 e78" xml:space="preserve"><textual class="po-textual">
&lt;properties&gt;
   &lt;property&gt;
      &lt;name&gt;color&lt;/name&gt;
      &lt;value&gt;blue&lt;/value&gt;
   &lt;/property&gt;
   &lt;properties&gt;
      &lt;property&gt;
         &lt;name&gt;font-weight&lt;/name&gt;
         &lt;value&gt;bold&lt;/value&gt;
      &lt;/property&gt;
   &lt;/properties&gt;
&lt;/properties&gt;
</textual></programlisting><para class="po-block e79 e79"><textual class="po-textual">where we would prefer to see the much more direct</textual></para><programlisting class="po-block e80 e80" xml:space="preserve"><textual class="po-textual">
&lt;property&gt;
   &lt;name&gt;color&lt;/name&gt;
   &lt;value&gt;blue&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
   &lt;name&gt;font-weight&lt;/name&gt;
   &lt;value&gt;bold&lt;/value&gt;
&lt;/property&gt;
</textual></programlisting><para class="po-block e81 e81"><textual class="po-textual">The problem arises in this case because the syntax
description method relies on recursion to deal with repetition. To
that end, we shall introduce a specific notation for repetition.
Zero or more repetitions:</textual></para><programlisting class="po-block e82 e82" xml:space="preserve"><textual class="po-textual">
(rule)*
</textual></programlisting><para class="po-block e83 e83"><textual class="po-textual">and one or more repetitions:</textual></para><programlisting class="po-block e84 e84" xml:space="preserve"><textual class="po-textual">
(rule)+
</textual></programlisting><para class="po-block e85 e85"><textual class="po-textual">In fact we shall extend these two postfix operators to also
act as infix operators, to handle a commonly occurring case:</textual></para><programlisting class="po-block e86 e86" xml:space="preserve"><textual class="po-textual">
(property)*";"
(property)+";"
</textual></programlisting><para class="po-block e87 e87"><textual class="po-textual">which respectively mean "zero or more, separated by
semicolon" and "one or more, separated by semicolon" (there is no
reason to restrict the separator to a terminal as here; it may also
be a nonterminal).</textual></para><para class="po-block e88 e88"><textual class="po-textual">Now we can specify our syntax as:</textual></para><programlisting class="po-block e89 e89" xml:space="preserve"><textual class="po-textual">
css: (rule)*.
rule: selector, block.
block: "{", (property)*";", "}".
property:  name, ":", value; .
name: ...
value: ...
</textual></programlisting><para class="po-block e90 e90"><textual class="po-textual">and the parsetree will now look like this:</textual></para><programlisting class="po-block e91 e91" xml:space="preserve"><textual class="po-textual">
&lt;css&gt;
   &lt;rule&gt;
      &lt;selector&gt;body&lt;/selector&gt;
      &lt;block&gt;
         &lt;property&gt;
            &lt;name&gt;color&lt;/name&gt;
            &lt;value&gt;blue&lt;/value&gt;
         &lt;/property&gt;
         &lt;property&gt;
            &lt;name&gt;font-weight&lt;/name&gt;
            &lt;value&gt;bold&lt;/value&gt;
         &lt;/property&gt;
      &lt;/block&gt;
   &lt;/rule&gt;
&lt;/css&gt;
</textual></programlisting><para class="po-block e92 e92"><textual class="po-textual">However, there is another reason why we might not want a
syntax rule name to appear in the parse tree, and that is when we
use a syntax rule as a </textual><emphasis class="po-inline e93 e93"><textual class="po-textual">refinement</textual></emphasis><textual class="po-textual">, that is to
say, when the syntax rule doesn't represent anything of semantic
importance, but has been defined so that we can use it in several
places without having to repeat it. For instance, suppose we wanted
to define a series of properties in a separate rule:</textual></para><programlisting class="po-block e94 e94" xml:space="preserve"><textual class="po-textual">
properties: (property)*";".
</textual></programlisting><para class="po-block e95 e95"><textual class="po-textual">and use it:</textual></para><programlisting class="po-block e96 e96" xml:space="preserve"><textual class="po-textual">
block: "{", properties, "}".
</textual></programlisting><para class="po-block e97 e97"><textual class="po-textual">but not want </textual><code class="po-atom e98 e98"><textual class="po-textual">&lt;properties&gt;</textual></code><textual class="po-textual"> to appear
in the final parse tree. What we define is that the use of any rule
name preceded by a minus sign is only being used for refinement. So
that would give us:</textual></para><programlisting class="po-block e99 e99" xml:space="preserve"><textual class="po-textual">
properties: (property)*";".
block: "{", -properties, "}".
</textual></programlisting><para class="po-block e100 e100"><textual class="po-textual">and this would result in the same parse-tree as above. Note
that this still allows a rule to be used in other places and appear
in the parse tree if needed.</textual></para><para class="po-block e101 e101"><textual class="po-textual">Also note that for simplicity we have ignored treating spaces
in the syntax description, but that is also an example of something
you would not want to have in the parse tree:</textual></para><programlisting class="po-block e102 e102" xml:space="preserve"><textual class="po-textual">
colon: -spaces, ":", -spaces.
spaces: " "*.
</textual></programlisting><para class="po-block e103 e103"><textual class="po-textual">Similarly, we can use it to make empty alternatives more
explicit:</textual></para><programlisting class="po-block e104 e104" xml:space="preserve"><textual class="po-textual">
property:  name, ":", value; -empty.
</textual></programlisting><programlisting class="po-block e105 e105" xml:space="preserve"><textual class="po-textual">
empty: .
</textual></programlisting></section><section class="po-hcontainer e106 e106" xml:id="Terminal"><title class="po-block e107 e107"><textual class="po-textual">Terminals</textual></title><para class="po-block e108 e108"><textual class="po-textual">As alluded to above, in general, terminal symbols do not
appear in the parse-tree, since most of them are only there to
delimit structural elements in the source file. If you want them to
show up, you can add an explicit rule for them:</textual></para><programlisting class="po-block e109 e109" xml:space="preserve"><textual class="po-textual">
colon: ":".
</textual></programlisting><para class="po-block e110 e110"><textual class="po-textual">which will cause them to show up in the tree like
this:</textual></para><programlisting class="po-block e111 e111" xml:space="preserve"><textual class="po-textual">
 &lt;property&gt;
     &lt;name&gt;color&lt;/name&gt;
     &lt;colon/&gt;
     &lt;value&gt;blue&lt;/value&gt;
 &lt;/property&gt;
</textual></programlisting><para class="po-block e112 e112"><textual class="po-textual">However, there are places where terminals have semantic
meaning, and you </textual><emphasis class="po-inline e113 e113"><textual class="po-textual">do</textual></emphasis><textual class="po-textual"> want them to appear in the
parse-tree, for instance in our example the names and values of the
properties. To achieve this we mark terminals that are to be copied
to the parse tree specially:</textual></para><programlisting class="po-block e114 e114" xml:space="preserve"><textual class="po-textual">
name: (+"a"; +"b"; ...etc...; +"9"; +"-")+.
</textual></programlisting><para class="po-block e115 e115"><textual class="po-textual">In other words, normally terminals are discarded, but if they
are preceded with a + they are copied to the parse-tree.</textual></para></section><section class="po-hcontainer e116 e116" xml:id="Extension"><title class="po-block e117 e117"><textual class="po-textual">Extensions</textual></title><para class="po-block e118 e118"><textual class="po-textual">Strictly speaking, this would be enough to allow you to parse
a document, and output it as an equivalent XML document. However,
there are possible extensions that give you a little more control
over the result. The most obvious is allowing the specification of
attributes. This is simply done by marking the use of rules with at
signs:</textual></para><programlisting class="po-block e119 e119" xml:space="preserve"><textual class="po-textual">
css: (rule)*.
rule: selector, block.
block: "{", (property)*";", "}".
property:  @name, ":", value.
</textual></programlisting><para class="po-block e120 e120"><textual class="po-textual">A rule used like this may clearly not contain any structural
elements (though it may contain terminals and refinements), since
attributes are not structured, but this is an easy condition to
check for. The parsetree will now look like this:</textual></para><programlisting class="po-block e121 e121" xml:space="preserve"><textual class="po-textual">
&lt;css&gt;
   &lt;rule&gt;
      &lt;selector&gt;body&lt;/selector&gt;
      &lt;block&gt;
         &lt;property name="color"&gt;
            &lt;value&gt;blue&lt;/value&gt;
         &lt;/property&gt;
         &lt;property name="font-weight"&gt;
            &lt;value&gt;bold&lt;/value&gt;
         &lt;/property&gt;
      &lt;/block&gt;
   &lt;/rule&gt;
&lt;/css&gt;
</textual></programlisting><para class="po-block e122 e122"><textual class="po-textual">If we changed the rule for </textual><code class="po-atom e123 e123"><textual class="po-textual">property</textual></code><textual class="po-textual"> to
look like this:</textual></para><programlisting class="po-block e124 e124" xml:space="preserve"><textual class="po-textual">
property:  @name, ":", @value.
</textual></programlisting><para class="po-block e125 e125"><textual class="po-textual">then the resultant parse-tree would look like</textual></para><programlisting class="po-block e126 e126" xml:space="preserve"><textual class="po-textual">
&lt;css&gt;
   &lt;rule&gt;
      &lt;selector&gt;body&lt;/selector&gt;
      &lt;block&gt;
         &lt;property name="color" value="blue"/&gt;
         &lt;property name="font-weight" value="bold"/&gt;
      &lt;/block&gt;
   &lt;/rule&gt;
&lt;/css&gt;
</textual></programlisting><para class="po-block e127 e127"><textual class="po-textual">Note that by marking the </textual><emphasis class="po-inline e128 e128"><textual class="po-textual">use</textual></emphasis><textual class="po-textual"> of a syntax
rule in this way, and not the definition, it allows the syntax rule
to be used for structural elements
(</textual><code class="po-atom e129 e129"><textual class="po-textual">&lt;name&gt;color&lt;/name&gt;</textual></code><textual class="po-textual">) as well as for
attributes (</textual><code class="po-atom e130 e130"><textual class="po-textual">name="color"</textual></code><textual class="po-textual">).</textual></para></section><section class="po-hcontainer e131 e131" xml:id="Parsing_Algorithm"><title class="po-block e132 e132"><textual class="po-textual">Parsing
Algorithms</textual></title><para class="po-block e133 e133"><textual class="po-textual">Although it would be possible to require the syntax to be
restricted to some class of language, such as LL(1) or LR(1) </textual><xref class="po-milestone e134 e134" linkend="LL1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
in order to make the parser faster, in practice it is easier for
the author of the syntax if we make no such restriction, since it
would require the author to understand the principles, and it would
require the system to check that the syntax adhered to the
requirement. In practise a parsing algorithm such as Earley's
</textual><xref class="po-milestone e135 e135" linkend="Earley"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is fast enough, and will treat all context-free languages.
The only remaining problem is if the syntax author describes an
ambiguous language. To that end we just define that the parser
outputs one of the parses, and leave it at that. For instance, if
expression were defined as:</textual></para><programlisting class="po-block e136 e136" xml:space="preserve"><textual class="po-textual">
expr: i; expr, plus, expr.
i: "i".
plus: "+".
</textual></programlisting><para class="po-block e137 e137"><textual class="po-textual">then a string such as</textual></para><programlisting class="po-block e138 e138" xml:space="preserve"><textual class="po-textual">
i+i+i
</textual></programlisting><para class="po-block e139 e139"><textual class="po-textual">could be parsed as both</textual></para><programlisting class="po-block e140 e140" xml:space="preserve"><textual class="po-textual">
&lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
&lt;plus/&gt;
&lt;expr&gt;
   &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
   &lt;plus/&gt;
   &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
&lt;/expr&gt;
</textual></programlisting><para class="po-block e141 e141"><textual class="po-textual">and as</textual></para><programlisting class="po-block e142 e142" xml:space="preserve"><textual class="po-textual">
&lt;expr&gt;
   &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
   &lt;plus/&gt;
   &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
&lt;/expr&gt;
&lt;plus/&gt;
&lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
</textual></programlisting></section><section class="po-hcontainer e143 e143" xml:id="Deliver"><title class="po-block e144 e144"><textual class="po-textual">Delivery</textual></title><para class="po-block e145 e145"><textual class="po-textual">To deliver a source document to be parsed by our system, we
can use a media type </textual><xref class="po-milestone e146 e146" linkend="MediaType"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> that supplies a reference to the
required syntax description. For instance:</textual></para><programlisting class="po-block e147 e147" xml:space="preserve"><textual class="po-textual">
application/xml-invisible; syntax=http://example.com/syntax/css
</textual></programlisting><para class="po-block e148 e148"><textual class="po-textual">Clearly a system can cache well-known syntax
descriptions.</textual></para></section><section class="po-hcontainer e149 e149" xml:id="Using_Invisible_XML_to_define_itsel"><title class="po-block e150 e150"><textual class="po-textual">Using
Invisible XML to define itself</textual></title><para class="po-block e151 e151"><textual class="po-textual">It should go without saying that the syntax descriptions
themselves are in Invisible XML (though in their case the syntax
description </textual><emphasis class="po-inline e152 e152"><textual class="po-textual">must</textual></emphasis><textual class="po-textual"> be cached to prevent an
infinite loop of processing.)</textual></para><para class="po-block e153 e153"><textual class="po-textual">The definition might look like this:</textual></para><programlisting class="po-block e154 e154" xml:space="preserve"><textual class="po-textual">
ixml: (rule)+.
rule: @name, -colon, -definition, -stop.
definition: (alternative)*-semicolon.
alternative: (-term)*-comma.
term: -symbol; -repetition.
repetition: one-or-more; zero-or-more.
one-or-more: -open, -definition, -close, -plus, separator.
zero-or-more: -open, -definition, -close, -star, separator.
separator: -symbol; -empty.
empty: .
symbol: -terminal; nonterminal; refinement.
terminal: explicit-terminal; implicit-terminal.
explicit-terminal: -plus, @string.
implicit-terminal: @string.
nonterminal: @name.
refinement: -minus, @name.
attribute: -at, @name.

string: -openquote, (-character)*, -closequote.
name: (-letter)+.
letter: +"a"; +"b"; ...
character: ...

colon: -S, ":", -S.
stop: -S, ".", -S.
semicolon: -S, ";", -S.
comma:  -S, ",", -S.
plus:  -S, "+", -S.
minus:  -S, "-", -S.
star:  -S, "*", -S.
open:  -S, "(", -S.
close:  -S, ")", -S.
at:  -S, "@", -S.
openquote: -S, """".
closequote: """", -S.
S: " "*.
</textual></programlisting><para class="po-block e155 e155"><textual class="po-textual">This would then parse to the XML form:</textual></para><programlisting class="po-block e156 e156" xml:space="preserve"><textual class="po-textual">
&lt;ixml&gt;
   &lt;rule name="ixml"&gt;
      &lt;alternative&gt;
         &lt;one-or-more&gt;
             &lt;alternative&gt;
                &lt;nonterminal name="rule"/&gt;
             &lt;/alternative&gt;&lt;separator/&gt;
         &lt;/one-or-more&gt;
      &lt;/alternative&gt;
   &lt;/rule&gt;
   &lt;rule name="rule"&gt;
      &lt;alternative&gt;
         &lt;attribute name="name"/&gt;
         &lt;refinement name="definition"/&gt;
      &lt;/alternative
   &lt;/rule&gt;
   &lt;rule name="definition"&gt;
      &lt;alternative&gt;
         &lt;zero-or-more&gt;
            &lt;alternative&gt;
               &lt;nonterminal name="alternative"/&gt;
            &lt;/alternative&gt;
            &lt;separator&gt;&lt;refinement name="semicolon"/&gt;&lt;/separator&gt;
         &lt;/zero-or-more&gt;
      &lt;/alternative
   &lt;/rule&gt;
   ... etc ...
   &lt;rule name="separator"&gt;
      &lt;alternative&gt;&lt;refinement name="symbol"/&gt;&lt;/alternative&gt;
      &lt;alternative&gt;&lt;refinement name="empty"/&gt;&lt;/alternative&gt;
   &lt;/rule&gt;
   ... etc ...
&lt;/ixml&gt;
</textual></programlisting><para class="po-block e157 e157"><textual class="po-textual">Thanks to Earley's parsing algorithm, we can remove the
</textual><code class="po-atom e158 e158"><textual class="po-textual">&lt;alternative&gt;</textual></code><textual class="po-textual"> elements when there is only
one </textual><code class="po-atom e159 e159"><textual class="po-textual">alternative</textual></code><textual class="po-textual"> in a </textual><code class="po-atom e160 e160"><textual class="po-textual">rule</textual></code><textual class="po-textual">, by
redefining </textual><code class="po-atom e161 e161"><textual class="po-textual">definition</textual></code><textual class="po-textual">:</textual></para><programlisting class="po-block e162 e162" xml:space="preserve"><textual class="po-textual">
definition: -alternative; alternative, -semicolon, (alternative)+-semicolon.
</textual></programlisting><para class="po-block e163 e163"><textual class="po-textual">Note how we have used the "-" character to prevent it being
copied in the first case (when there is only one). You wouldn't be
able to use such a rule as this if there were a requirement on the
syntax to be LL(1) or LR(1), since the two parts of the rule start
with the same symbols.</textual></para><para class="po-block e164 e164"><textual class="po-textual">Similarly, we can get rid of empty
</textual><code class="po-atom e165 e165"><textual class="po-textual">&lt;separators/&gt;</textual></code><textual class="po-textual"> thusly:</textual></para><programlisting class="po-block e166 e166" xml:space="preserve"><textual class="po-textual">
one-or-more: -open, -definition, -close, -plus; -open, -definition, -close, -plus, separator.
zero-or-more: -open, -definition, -close, -star; -open, -definition, -close, -star, separator.
separator: -symbol.
</textual></programlisting><para class="po-block e167 e167"><textual class="po-textual">We can move the value of the separator into an attribute
with:</textual></para><programlisting class="po-block e168 e168" xml:space="preserve"><textual class="po-textual">
separator: @explicit; @implicit; @nonterminal; @refinement.
explicit: -plus, -string.
implicit: -string.
</textual></programlisting><para class="po-block e169 e169"><textual class="po-textual">This would then generate:</textual></para><programlisting class="po-block e170 e170" xml:space="preserve"><textual class="po-textual">
&lt;ixml&gt;
   &lt;rule name="ixml"&gt;
      &lt;one-or-more&gt;
         &lt;nonterminal name="rule"/&gt;
      &lt;/one-or-more&gt;
   &lt;/rule&gt;
   &lt;rule name="rule"&gt;
      &lt;attribute name="name"/&gt;
      &lt;refinement name="definition"/&gt;
   &lt;/rule&gt;
   &lt;rule name="definition"&gt;
      &lt;alternative&gt;
         &lt;refinement name="alternative"/&gt;
      &lt;/alternative&gt;
      &lt;alternative&gt;
         &lt;nonterminal name="alternative"/&gt;
         &lt;one-or-more&gt;
            &lt;nonterminal name="alternative"/&gt;
            &lt;separator refinement="semicolon"/&gt;
         &lt;/one-or-more&gt;
      &lt;/alternative&gt;
   &lt;/rule&gt;
   ... etc ...
   &lt;rule name="separator"&gt;
      &lt;alternative&gt;&lt;refinement name="symbol"/&gt;&lt;/alternative&gt;
      &lt;alternative&gt;&lt;refinement name="empty"/&gt;&lt;/alternative&gt;
   &lt;/rule&gt;
   ... etc ...
&lt;/ixml&gt;
</textual></programlisting><para class="po-block e171 e171"><textual class="po-textual">(An observant reader will have spotted that we have allowed
attributes to be defined by attributes here -- for instance with
</textual><code class="po-atom e172 e172"><textual class="po-textual">@refinement</textual></code><textual class="po-textual"> -- that is we treat an attribute
within an attribute definition as if it were a refinement).</textual></para><para class="po-block e173 e173"><textual class="po-textual">As yet another possibility, we can move the separator into an
attribute of the </textual><code class="po-atom e174 e174"><textual class="po-textual">one-or-more</textual></code><textual class="po-textual"> or
</textual><code class="po-atom e175 e175"><textual class="po-textual">zero-or-more</textual></code><textual class="po-textual"> elements:</textual></para><programlisting class="po-block e176 e176" xml:space="preserve"><textual class="po-textual">
one-or-more: -open, -definition, -close, -plus; -open, -definition, -close, -plus, -separator.
zero-or-more: -open, -definition, -close, -star; -open, -definition, -close, -star, -separator.
separator: @explicit; @implicit; @nonterminal; @refinement.
explicit: -plus, -string.
implicit: -string.
</textual></programlisting></section><section class="po-hcontainer e177 e177" xml:id="Alternative_Representatio"><title class="po-block e178 e178"><textual class="po-textual">Alternative
Representation</textual></title><para class="po-block e179 e179"><textual class="po-textual">Although the syntax description so defined was developed
iteratively based on the needs of the user, and is sufficient for
its purpose, it is clear in the above example, that refinements
occur far more frequently than true semantic rules. An alternative
worth exploring would be to say that </textual><emphasis class="po-inline e180 e180"><textual class="po-textual">nothing</textual></emphasis><textual class="po-textual">
is copied to the syntax tree unless specifically marked. Let us use
the "^" character to mark items that are copied to the tree. The
result is clearly much more restful on the eyes:</textual></para><programlisting class="po-block e181 e181" xml:space="preserve"><textual class="po-textual">
ixml: (^rule)+.
rule: @name, colon, definition, stop.
definition: alternative; ^alternative, semicolon, (^alternative)+semicolon.
alternative: (term)*comma.
term: symbol; repetition.
repetition: ^one-or-more; ^zero-or-more.
one-or-more: open, definition, close, plus; open, definition, close, plus, ^separator.
zero-or-more: open, definition, close, star; open, definition, close, star, ^separator.
separator: terminal; @nonterminal; @refinement.
symbol: terminal; ^nonterminal; ^refinement.
terminal: ^explicit-terminal; ^implicit-terminal.
explicit-terminal: up, @string.
implicit-terminal: @string.
nonterminal: up, @name.
refinement: @name.
attribute: at, @name.

string: openquote, (character)*, closequote.
name: (letter)+.
letter: ^"a"; ^"b"; ...
character: ...

colon: S, ":", S.
stop: S, ".", S.
semicolon: S, ";", S.
comma:  S, ",", S.
plus:  S, "+", S.
up:  S, "^", S.
star:  S, "*", S.
open:  S, "(", S.
close:  S, ")", S.
at:  S, "@", S.
openquote: S, """".
closequote: """", S.
S: " "*.
</textual></programlisting></section><section class="po-hcontainer e182 e182" xml:id="Extra"><title class="po-block e183 e183"><textual class="po-textual">Extras</textual></title><para class="po-block e184 e184"><textual class="po-textual">There are obvious extra odds and ends that need adding, such
as sets of characters, to make terminal specification easier, for
instance:</textual></para><programlisting class="po-block e185 e185" xml:space="preserve"><textual class="po-textual">
letter: ^["a"-"z", "A"-"Z", "-"].
S: [" ", "\t", "\n", ...]*.
</textual></programlisting><para class="po-block e186 e186"><textual class="po-textual">but these are just details.</textual></para></section><section class="po-hcontainer e187 e187" xml:id="Restriction_on_the_XML_Produce"><title class="po-block e188 e188"><textual class="po-textual">Restriction
on the XML Produced</textual></title><para class="po-block e189 e189"><textual class="po-textual">It should be noted in passing that in the form presented
here, </textual><emphasis class="po-inline e190 e190"><textual class="po-textual">Invisible XML</textual></emphasis><textual class="po-textual"> only works in one
direction: you can turn any textual document into an equivalent XML
document. However, it is not in general possible to turn a textual
document into a </textual><emphasis class="po-inline e191 e191"><textual class="po-textual">particular</textual></emphasis><textual class="po-textual"> XML form without
more work. For instance, you could turn Wiki markup into an XML
document, but not into XHTML in particular.</textual></para></section><section class="po-hcontainer e192 e192" xml:id="Roundtrippin"><title class="po-block e193 e193"><textual class="po-textual">Roundtripping</textual></title><para class="po-block e194 e194"><textual class="po-textual">Returning the resultant XML document to its original format
is just a process of presentation, nothing that a suitable bit of
XSLT couldn't do, or even CSS in some simple cases. In fact it
should be apparent that from the </textual><emphasis class="po-inline e195 e195"><textual class="po-textual">Invisible XML</textual></emphasis><textual class="po-textual">
syntax, it would be straightforward to automatically generate the
required piece of XSLT directly.</textual></para></section><section class="po-hcontainer e196 e196" xml:id="Conclusio"><title class="po-block e197 e197"><textual class="po-textual">Conclusion</textual></title><para class="po-block e198 e198"><textual class="po-textual">There is really no reason why XML can't be more ubiquitous
than it is, and similarly there is no reason why XML documents have
to be written in an explicit XML format </textual><emphasis class="po-inline e199 e199"><textual class="po-textual">per
se</textual></emphasis><textual class="po-textual">. Anything that can be parsed can be perceived as XML,
since parsing is very easy, and parse-trees are really just XML
documents in different clothing. </textual><emphasis class="po-inline e200 e200"><textual class="po-textual">Invisible XML</textual></emphasis><textual class="po-textual">
allows a multitude of document formats to be authored in their
traditional form, but be processed as XML, with the concomitant
advantages of the XML toolchain.</textual></para></section><bibliography class="po-hcontainer e201 e201"><title class="po-block e202 e202"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e203 e203" xml:id="RelaxNG" xreflabel="RELAX NG"><textual class="po-textual">James Clark, Makoto MURATA (eds.), 2001, RELAX NG Specification,
</textual><link class="po-inline e204 e204" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://www.oasis-open.org/committees/relax-ng/spec.html</textual></link></bibliomixed><bibliomixed class="po-block e205 e205" xml:id="RelaxNGCOMPACT" xreflabel="RELAX NG COMPACT"><textual class="po-textual">James Clark (ed.). 2002, RELAX NG Compact Syntax,
</textual><link class="po-inline e206 e206" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://www.oasis-open.org/committees/relax-ng/compact-20021121.html</textual></link></bibliomixed><bibliomixed class="po-block e207 e207" xml:id="BNF" xreflabel="BNF"><textual class="po-textual">Backus-Naur Form,
</textual><link class="po-inline e208 e208" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/Backus-Naur_Form</textual></link></bibliomixed><bibliomixed class="po-block e209 e209" xml:id="VWG" xreflabel="VWG"><textual class="po-textual">S. Pemberton, 1982, "Executable Semantic Definition of
Programming Languages Using Two-level Grammars",
</textual><link class="po-inline e210 e210" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.cwi.nl/~steven/vw.html</textual></link></bibliomixed><bibliomixed class="po-block e211 e211" xml:id="LL1" xreflabel="LL1"><textual class="po-textual">Alfred Aho and Jeffrey D. Ullman, 1977, "Principles of
Compiler Design", Addison-Wesley, ISBN 0-201-00022-9.</textual></bibliomixed><bibliomixed class="po-block e212 e212" xml:id="Earley" xreflabel="Earley"><textual class="po-textual">Earley, Jay (1970), "An efficient context-free
parsing algorithm", Communications of the ACM 13 (2): 94-102,
doi:</textual><biblioid class="po-atom e213 doi e213"><textual class="po-textual">10.1145/362007.362035</textual></biblioid></bibliomixed><bibliomixed class="po-block e214 e214" xml:id="MediaType" xreflabel="Media type"><textual class="po-textual">N. Freed et al., 1996, "Multipurpose Internet
Mail Extensions, (MIME) Part Two: Media Types",
</textual><link class="po-inline e215 e215" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ietf.org/rfc/rfc2046.txt</textual></link></bibliomixed></bibliography></article></classedDocument>