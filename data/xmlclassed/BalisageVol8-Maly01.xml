<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Utilizing new capabilities of XML languages to verify integrity constraints</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">In this work, we show how integrity constraints expressed using Object Constraint
        Language (OCL) can be verified using XML technologies - Schematron, XPath/XQuery and XSLT -
        and using Model Driven Architecture (MDA) principles. Some constructs typical for OCL
        constraints are different from the methods used in XPath/XQuery expressions. That is why for
        translating some OCL expressions, the standard XML toolset must be extended. We introduce
        such extension for the 2.0 versions of the languages, but with the new features and
        constructs proposed in drafts for XSLT 3.0, XPath 3.0 and XQuery 3.0, the transition from
        OCL is much more seamless and transparent. Higher-order functions, maps, error-recovery
        instructions etc. provide us with necessary power to translate a general OCL expression and
        we discuss in detail their potential. </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Jakub</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Malý</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Jakub Malý is a Ph.D. student at Charles University in Prague, Czech Republic. 
          His research areas involve conceptual modeling of XML data, integrity constraints, evolution and adaptation 
          of XML applications.</textual></para></personblurb><affiliation class="po-record e14 e14"><orgname class="po-block e15 e15"><textual class="po-textual">XML and Web Engineering Research Group, Faculty of Mathematics and Physics, Charles
          University, Prague, Czech Republic</textual></orgname></affiliation><email class="po-field e16 e16"><textual class="po-textual">maly@ksi.mff.cuni.cz</textual></email></author><author class="po-record e17 e17"><personname class="po-record e18 e18"><firstname class="po-field e19 e19"><textual class="po-textual">Martin</textual></firstname><surname class="po-field e20 e20"><textual class="po-textual">Nečaský</textual></surname></personname><personblurb class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Martin Nečaský is an assistant professor at Charles University in Prague, Czech Republic. 
          His research areas involve XML data design, integration, evolution and linked open data. </textual></para></personblurb><affiliation class="po-record e23 e23"><orgname class="po-block e24 e24"><textual class="po-textual">XML and Web Engineering Research Group, Faculty of Mathematics and Physics, Charles
          University, Prague, Czech Republic</textual></orgname></affiliation><email class="po-field e25 e25"><textual class="po-textual">necasky@ksi.mff.cuni.cz</textual></email></author><legalnotice class="po-container e26 e26"><para class="po-block e27 e27"><textual class="po-textual">Copyright © 2012 by the authors. Used with permission.</textual></para></legalnotice><keywordset class="po-table e28 e28" role="author"><keyword class="po-field e29 e29"><textual class="po-textual">Schematron</textual></keyword><keyword class="po-field e30 e30"><textual class="po-textual">Integrity Constraint</textual></keyword><keyword class="po-field e31 e31"><textual class="po-textual">OCL</textual></keyword><keyword class="po-field e32 e32"><textual class="po-textual">UML</textual></keyword><keyword class="po-field e33 e33"><textual class="po-textual">Validation</textual></keyword></keywordset></info><section class="po-hcontainer e34 e34"><title class="po-block e35 e35"><textual class="po-textual">Introduction</textual></title><para class="po-block e36 e36"><textual class="po-textual">Unified Modeling Language (UML) has proved to be a powerful language for modeling software
      systems. Modeling is an important activity in the software development process. It is a good
      way of how to abstract from technical details of a software system and concentrate on
      structural, semantic and functional aspects of the system.
      In connection with UML, a methodology called Model-Driven Architecture (MDA) has been
      established. It proposes to start modeling a system at an abstract </textual><emphasis class="po-inline e37 e37" role="ital"><textual class="po-textual">platform-independent level</textual></emphasis><textual class="po-textual"> stripped from technical details and then specify the
      model with more technical details at a </textual><emphasis class="po-inline e38 e38" role="ital"><textual class="po-textual">platform-specific
        level</textual></emphasis><textual class="po-textual">. From this level, actual executable code can be then generated (ideally)
      automatically. In practice, the step from the platform-specific model (PSM) to executable code
      requires usually some level of the designer's interaction, but nonetheless, the presence of
      the layered model is a significant improvement both during initial formation of the
      implementation and it's management in the future. </textual></para><para class="po-block e39 e39"><textual class="po-textual">In our previous work (</textual><xref class="po-milestone e40 e40" linkend="necasky12a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e41 e41" linkend="necasky12b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), we have
      shown how beneficial it can be to interconnect the world of UML and MDA with the world of
      designing XML schemas. Our premise was the fact that complex software systems are often
      modeled with UML diagrams at the platform-independent level. In particular, a UML class
      diagram is suitable for modeling a conceptual schema of the application domain. Such schema is
      called </textual><emphasis class="po-inline e42 e42" role="ital"><textual class="po-textual">schema in a platform-independent model</textual></emphasis><textual class="po-textual"> or simply
        </textual><emphasis class="po-inline e43 e43" role="ital"><textual class="po-textual">PIM schema</textual></emphasis><textual class="po-textual"> in MDA terminology. The term model means a
      modeling language (the language of UML class diagrams in our case). Our method allows to
      exploit the existing PIM schema to design XML schemas in the system. Each XML schema is
      modeled as so called </textual><emphasis class="po-inline e44 e44" role="ital"><textual class="po-textual">schema in a platform-specific model</textual></emphasis><textual class="po-textual"> or
      simply </textual><emphasis class="po-inline e45 e45" role="ital"><textual class="po-textual">PSM schema</textual></emphasis><textual class="po-textual">. A PSM schema is, again, a UML class
      diagram. It represents a part of the PIM schema and shapes it to the form of the aimed XML
      schema. From the PSM schema, the XML schema expressed in a selected language (we currently
      support XML Schema) can be derived automatically. We have implemented the method in our CASE
      tool </textual><emphasis class="po-inline e46 e46" role="ital"><xref class="po-milestone e47 e47" linkend="exolutio"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></emphasis><textual class="po-textual">. </textual></para><para class="po-block e48 e48"><textual class="po-textual">One advantage of such approach is that an XML schema designer takes an existing PIM schema
      and derives from it a PSM schema of the aimed XML schema. This is much easier then writing the
      XML schema manually even when the designer uses an XML schema visualization tool. Another
      advantage of using a PIM schema is that it prevents from inconsitencies between the XML schema
      and the conceptual schema. </textual></para><para class="po-block e49 e49"><textual class="po-textual">Several UML/XML schema mapping approaches were proposed so far (</textual><xref class="po-milestone e50 e50" linkend="pagano09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e51 e51" linkend="bauman09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), the advantage of our approach is hidden in the fact that a
      software system usually does not presume only one XML schema, but a whole family of XML
      schemas each representing a selected part of the application domain (e.g. in the domain of
        </textual><emphasis class="po-inline e52 e52"><textual class="po-textual">of e-commerce</textual></emphasis><textual class="po-textual">, the system might contain following XML schemas:
        </textual><emphasis class="po-inline e53 e53" role="ital"><textual class="po-textual">purchase order</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e54 e54" role="ital"><textual class="po-textual">product
        catalogue</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e55 e55" role="ital"><textual class="po-textual">customer detail</textual></emphasis><textual class="po-textual">). Moreover, several
      different XML schemas may overlap and share some part of the reality but may represent it
      differently (e.g., the concept of </textual><emphasis class="po-inline e56 e56" role="ital"><textual class="po-textual">Customer</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e57 e57"><textual class="po-textual">of
        e-commerce</textual></emphasis><textual class="po-textual"> is shared by different XML schemas which represent it with different
      XML structures). Using our approach, the reality is modeled only once in the PIM schema and
      its different representations in different XML schemas are derived from the PIM schema as PSM
      schemas. When the designer examines a particular PSM schema, he can always track any used
      concept back to the common model and thanks to this fact never looses the "big picture". The
      management of a family of schemas is thus more efficient and error-proof. Moreover, our
      approach makes the XML schemas better readable - anyone can look up what real-world concepts
      modeled in the conceptual schema are represented with a selected part of a particular XML
      schema and, vice versa, how a selected real-world concept is represented in which XML schemas. </textual></para><para class="po-block e58 e58"><textual class="po-textual">In this work, we extend our previous work towards modeling complex integrity constraints
      (ICs). ICs are a substantial part of every software system, equally important as a conceptual
      schema. However, most of them cannot be expressed with UML class diagrams and, therefore,
      Object Constraint Language (OCL, see </textual><xref class="po-milestone e59 e59" linkend="ocl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) was introduced for this purpose.
      OCL is a formal language which can be used to declare ICs over a UML model. The ICs are in a
      form of logical expressions and can check constraints such as "employee, who is a division
      manager, must have a collage degree" or "the store manager can get a bonus only when the
      profits have grow at least 10% compared to last year" (the following section contains more
      examples of integrity constraints and how they are expressed fromally in OCL) . Usaing OCL has
      two main benefits in comparison to the natural language: </textual><orderedlist class="po-table e60 e60"><listitem class="po-container e61 e61"><para class="po-block e62 e62"><textual class="po-textual">unlike natural language, the formal expression is exact and unambiguous,</textual></para></listitem><listitem class="po-container e63 e63"><para class="po-block e64 e64"><textual class="po-textual">an expression in a formal modeling language can be used to generate code that
            verifies the validity of the IC in actual data or running program.</textual></para></listitem></orderedlist></para><para class="po-block e65 e65"><textual class="po-textual">The authors of Dresden OCL toolkit (see </textual><xref class="po-milestone e66 e66" linkend="dresden"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) have demonstrated how
      OCL ICs can be checked at runtime in Java (by translating OCL into Java code and adding
      triggers that verify the constraints when objects are changed) and also in relational
      databases (by translation of OCL expression into SQL statements, which allow to select records
      violating the IC). </textual></para><para class="po-block e67 e67"><textual class="po-textual">When a system uses XML (e.g. for message exchange in communication or storing data), the
      ICs should be checked in the XML data and using XML technologies. In this work, we show how
      OCL ICs can be checked at runtime in XML documents using Schematron. The result of our
      research can be again profitably used by XML schema designers in cases when a PIM schema
      complemented with OCL ICs. Together with modeling the XML schemas as PSM schemas derived from
      the PIM schema, the designers can also easily convert OCL ICs from the PIM schema to the PSM
      schemas.  </textual></para><para class="po-block e68 e68"><textual class="po-textual">Having OCL ICs expressed at the platform-independent level the question is how they can be
      translated to the platform-specific level and from here to the XML schema level. The
      conversion to the platform-specific level is not covered in this paper. Just let us note that
      we have already implemented several methods for this conversion in our tool eXolutio but we do
      not describe them in this paper. Instead, we focus on the actual conversion of OCL ICs
      expressed at the platform-specific level to their suitable XML conterpart, which are
      Schematron schemas. </textual><xref class="po-milestone e69 e69" linkend="fig-levels"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows an overall architecture of the system. </textual></para><figure class="po-container e70 e70" xml:id="fig-levels"><title class="po-block e71 e71"><textual class="po-textual">eXolutio - architecture overview</textual></title><mediaobject class="po-container e72 e72"><imageobject class="po-container e73 e73"><imagedata class="po-meta e74 e74" fileref="../../../vol8/graphics/Maly01/Maly01-001.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e75 e75"><textual class="po-textual">Schematron is a rule-based XML schema language based on XPath expressions. It is often
      used as a complement of grammar based schema languages (such as XML Schema, Relax NG or DTD),
      which define a proper vocabulary and validate the structure of the XML document, to check data
      and co-occurrence constraints - it serves a similar purpose, as does OCL in UML. Because the
      approach used in OCL to build expressions is rather different than the space of expression
      provided by XPath, it is necessary to extend XPath to provide comparable expressive power. We
      implemented the required extensions in our XSLT functions library called </textual><emphasis class="po-inline e76 e76" role="ital"><textual class="po-textual">OclX</textual></emphasis><textual class="po-textual">. Since Schematron validation is usually implemented as several steps of
      XSLT processing, our extension will not require modification of the existing Schematron
      validation tools, except referencing OclX library. We will examine different approaches, how
      the required functions can be implemented, and show how several of the new constructs (such as
        </textual><emphasis class="po-inline e77 e77" role="ital"><textual class="po-textual">higher-order functions</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e78 e78" role="ital"><textual class="po-textual">maps</textual></emphasis><textual class="po-textual">, or </textual><emphasis class="po-inline e79 e79" role="ital"><textual class="po-textual">error-recovery instructions</textual></emphasis><textual class="po-textual">) proposed
      in the 3.0 drafts of XPath, XQuery and XSLT can serve our goal. </textual></para><section class="po-hcontainer e80 e80"><title class="po-block e81 e81"><textual class="po-textual">Outline</textual></title><para class="po-block e82 e82"><textual class="po-textual">The rest of this work is organized as follows: </textual><xref class="po-milestone e83 e83" linkend="sec-constraints"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> gives
        brief introduction to OCL and shows examples demonstrating its expressive power. </textual><xref class="po-milestone e84 e84" linkend="sec-iterator"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> lists possibilities of translating iterator expressions, </textual><xref class="po-milestone e85 e85" linkend="sec-tuples"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> elaborates on tuples, </textual><xref class="po-milestone e86 e86" linkend="sec-collections"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> on other
        types of collections than sequences. In </textual><xref class="po-milestone e87 e87" linkend="sec-errors"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, we describe, how
        semantics of OCL error handling can be achieved. </textual><xref class="po-milestone e88 e88" linkend="sec-implementation"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
        describes the implementation of OclX in our tool and the use of XProc for validation. In
          </textual><xref class="po-milestone e89 e89" linkend="sec-sugar"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, we outline possibilities of rewriting certain classes of
        expressions. In </textual><xref class="po-milestone e90 e90" linkend="sec-conclusion"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, we conclude.</textual></para></section></section><section class="po-hcontainer e91 e91" xml:id="sec-constraints"><title class="po-block e92 e92"><textual class="po-textual">OCL Constraints</textual></title><para class="po-block e93 e93"><textual class="po-textual">In this section, we will show on several examples the usage of OCL constraints. </textual></para><para class="po-block e94 e94"><xref class="po-milestone e95 e95" linkend="fig-pim"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows a sample platform-independent schema of a chess leagues
      information system. </textual><footnote class="po-popup e96 e96"><para class="po-block e97 e97"><textual class="po-textual">Examples for this paper are based on </textual><link class="po-inline e98 e98" xlink:actuate="onRequest" xlink:href="http://www.stargroup.uwaterloo.ca/~ltahvild/courses/ECE493-T5/tutorials/Tutorial-Feb16-OCL.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">Mazeiar Salehie's OCL Tutorial.</textual></link><textual class="po-textual">
        </textual></para></footnote><textual class="po-textual">. </textual></para><figure class="po-container e99 e99" xml:id="fig-pim"><title class="po-block e100 e100"><textual class="po-textual">A sample platform-indpendent schema</textual></title><mediaobject class="po-container e101 e101"><imageobject class="po-container e102 e102"><imagedata class="po-meta e103 e103" fileref="../../../vol8/graphics/Maly01/Maly01-002.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e104 e104"><textual class="po-textual">
      </textual><xref class="po-milestone e105 e105" linkend="fig-pim-ocl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows some constraints defined for the PIM schema. We will not
      elaborate the syntax of OCL in detail in this paper. Briefly: OCL script consists of
      declaration of blocks of integrity constraints, each block starts with the selection of
      context class and contains one or more invariants for this class. The invariants are logical
      expression refereing to the concepts defined in the PIM schema. Standard OCL does not allow to
      specify an error message describing the violated constraint. However, this is a valued feature
      of Schematron which we did not want to lose. That is why we extended OCL to allow an optional
      message after each invariant definition. The message can contain subexpression, as is shown in
      IC PIM1. </textual></para><figure class="po-container e106 e106" xml:id="fig-pim-ocl"><title class="po-block e107 e107"><textual class="po-textual">PIM ICs for chess leagues</textual></title><programlisting class="po-block e108 e108" xml:space="preserve"><textual class="po-textual">context Tournament
/* PIM1 */
inv: </textual><emphasis class="po-inline e109 e109" role="bold"><textual class="po-textual">start &lt;= end</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e110 e110" role="ital"><textual class="po-textual">'Dates inconsistent {start} is grater than {end} in {name}'</textual></emphasis><textual class="po-textual">
/* which is an abbreviation for: */ 
inv: </textual><emphasis class="po-inline e111 e111" role="bold"><textual class="po-textual">self.start &lt;= self.end</textual></emphasis><textual class="po-textual">
/* PIM2 */
inv: </textual><emphasis class="po-inline e112 e112" role="bold"><textual class="po-textual">matches-&gt;forAll(m:Match | m.start &gt;= start and m.end &lt;= end)</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e113 e113" role="ital"><textual class="po-textual">'All matches in a tournament occur within the tournament’s time frame'</textual></emphasis><textual class="po-textual">
/* PIM2 in the previus is in fact an abbreviation for: */
inv: </textual><emphasis class="po-inline e114 e114" role="bold"><textual class="po-textual">self.matches-&gt;forAll(m:Match | m.start &gt;= self.start and m.end &lt;= self.end)</textual></emphasis><textual class="po-textual">
/* PIM3 */
inv: </textual><emphasis class="po-inline e115 e115" role="bold"><textual class="po-textual">matches-&gt;forAll(m | m.players-&gt;forAll(mp | mp.tournaments-&gt;includes(self)))</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e116 e116" role="ital"><textual class="po-textual">'A match can only involve players who are accepted in the tournament'</textual></emphasis><textual class="po-textual">
/* PIM4 */
inv: </textual><emphasis class="po-inline e117 e117" role="bold"><textual class="po-textual">matches-&gt;exists(m:Match | m.start.equals(start))</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e118 e118" role="ital"><textual class="po-textual">'Each tournament conducts at least one match on the first day'</textual></emphasis></programlisting></figure><para class="po-block e119 e119"><textual class="po-textual"> From this schema, two platform-specific schemas (</textual><xref class="po-milestone e120 e120" linkend="fig-psm1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e121 e121" linkend="fig-psm2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) were created, each using the classes from </textual><xref class="po-milestone e122 e122" linkend="fig-pim"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,
      but each for a different type of XML documents used in the system. XSDs obtained from the PSM
      schemas are shown alongside the figures. </textual></para><figure class="po-container e123 e123" xml:id="fig-psm1"><title class="po-block e124 e124"><textual class="po-textual">A sample platform-specific schema modeling a type of XML documents for Matches and Players involved in a Tournament</textual></title><informaltable class="po-container e125 e125" frame="void" rules="none"><tr class="po-table e126 e126"><td class="po-block e127 e127"><textual class="po-textual">
            </textual><mediaobject class="po-container e128 e128"><imageobject class="po-container e129 e129"><imagedata class="po-meta e130 e130" fileref="../../../vol8/graphics/Maly01/Maly01-003.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><textual class="po-textual">
          </textual></td><td class="po-block e131 e131"><textual class="po-textual">
            </textual><programlisting class="po-block e132 e132" xml:space="preserve"><textual class="po-textual">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:element name="tournament" type="Tournament" /&gt;
  &lt;xs:complexType name="Tournament"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="name" type="xs:string" /&gt;
      &lt;xs:element name="start" type="xs:dateTime" /&gt;
      &lt;xs:element name="end" type="xs:dateTime" /&gt;
      &lt;xs:element name="matches" type="Matches" /&gt;
      &lt;xs:element name="participatingPlayers" type="Players" /&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="Matches"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="day" type="Day" maxOccurs="unbounded" /&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="Players"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="player" type="Player" maxOccurs="unbounded" /&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="Player"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="name" type="xs:string" /&gt;
      &lt;xs:element name="email" type="xs:string" /&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  ...
&lt;/xs:schema&gt;</textual></programlisting><textual class="po-textual">
          </textual></td></tr></informaltable></figure><figure class="po-container e133 e133" xml:id="fig-psm2"><title class="po-block e134 e134"><textual class="po-textual">A sample platform-specific schema modeling a type of XML documents for Tournament Qualification</textual></title><informaltable class="po-container e135 e135" frame="void" rules="none"><tr class="po-table e136 e136"><td class="po-block e137 e137"><textual class="po-textual">
            </textual><mediaobject class="po-container e138 e138"><imageobject class="po-container e139 e139"><imagedata class="po-meta e140 e140" fileref="../../../vol8/graphics/Maly01/Maly01-004.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><textual class="po-textual">
          </textual></td><td class="po-block e141 e141"><textual class="po-textual">
            </textual><programlisting class="po-block e142 e142" xml:space="preserve"><textual class="po-textual">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:element name="tournaments" type="Tournaments" /&gt;
  &lt;xs:complexType name="Tournaments"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="tournament" type="Tournament" 
        minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="Tournament"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="name" type="xs:string" /&gt;
      ...
      &lt;xs:element name="qualification" type="Qualification" /&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="Qualification"&gt;    
    &lt;xs:attributeGroup ref="OpenTournament-att-opt" /&gt;
    &lt;xs:attributeGroup ref="League-att-opt" /&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:attributeGroup name="OpenTournament-att-opt"&gt;
    &lt;xs:attribute name="open" type="xs:boolean" use="optional" /&gt;
  &lt;/xs:attributeGroup&gt;
  &lt;xs:attributeGroup name="League-att-opt"&gt;
    &lt;xs:attribute name="leagueName" type="xs:string" use="optional" /&gt;
  &lt;/xs:attributeGroup&gt;
&lt;/xs:schema&gt;</textual></programlisting><textual class="po-textual">
          </textual></td></tr></informaltable></figure><para class="po-block e143 e143"><xref class="po-milestone e144 e144" linkend="fig-psm-ocl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows, how the constraints from </textual><xref class="po-milestone e145 e145" linkend="fig-pim-ocl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> can be applied in the PSM schemas, where they are relevant. For the purposes of using OCL
      at the PSM layer, we added additional ways of navigation (to those defined in the standard) -
        </textual><emphasis class="po-inline e146 e146" role="ital"><textual class="po-textual">parent</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e147 e147" role="ital"><textual class="po-textual">child_N</textual></emphasis><textual class="po-textual">,
        </textual><emphasis class="po-inline e148 e148" role="ital"><textual class="po-textual">choice_N</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e149 e149" role="ital"><textual class="po-textual">set_N</textual></emphasis><textual class="po-textual">,
        </textual><emphasis class="po-inline e150 e150" role="ital"><textual class="po-textual">seq_N</textual></emphasis><textual class="po-textual"> (navigate to the n-th child, choice set or sequence
      in the content model of a class). </textual></para><para class="po-block e151 e151"><textual class="po-textual">It is also possible to add additional constraints, which do not have a counterpart PIM
      constraint, for each PSM schema (e.g. constraint PSM5). In this paper, we will not show, how
      the relevant constraints are chosen for each PSM schema, but we will focus on how they can be
      verified in XML documents. (MARTIN: Tady ale zhruba rozved, jake jsou vyhody toho, ze to je na
      PIMu. Tj. odpovedi na otazku, proc si to nemuzu rovnou vyjadrit na PSM urovni?) </textual></para><figure class="po-container e152 e152" xml:id="fig-psm-ocl"><title class="po-block e153 e153"><textual class="po-textual">PSM ICs for chess leagues</textual></title><programlisting class="po-block e154 e154" xml:space="preserve"><textual class="po-textual">/*** Match schedule schema constraints ***/
context Tournament
/* PSM1 */
inv: </textual><emphasis class="po-inline e155 e155" role="bold"><textual class="po-textual">start &lt;= end</textual></emphasis><textual class="po-textual">
/* which is an abbreviation for: */ 
inv: </textual><emphasis class="po-inline e156 e156" role="bold"><textual class="po-textual">self.start &lt;= self.end</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e157 e157" role="ital"><textual class="po-textual">'Dates inconsistent, {start} is greater than {end} in {name}'</textual></emphasis><textual class="po-textual">
/* PSM2 */
inv: </textual><emphasis class="po-inline e158 e158" role="bold"><textual class="po-textual">matches.day.match-&gt;forAll(m:Match | m.start.after(start) and m.end.before(end))</textual></emphasis><textual class="po-textual">
/* abbreviation for: */
inv: </textual><emphasis class="po-inline e159 e159" role="bold"><textual class="po-textual">self.matches.day-&gt;collect(d:Day | d.match)-&gt;
        forAll(m:Match | m.start.after(self.start) and m.end.before(self.end))</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e160 e160" role="ital"><textual class="po-textual">'All matches in a tournament occur within the tournament\'s time frame'</textual></emphasis><textual class="po-textual">
context Match
/* PSM3: */
inv: </textual><emphasis class="po-inline e161 e161" role="bold"><textual class="po-textual">matchPlayers.player-&gt;forAll(p | p.parent.parent.parent.parent.parent.
        participatingPlayers.player-&gt;exists(px | px.name = p.name))</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e162 e162" role="ital"><textual class="po-textual">'A match can only involve players who are accepted in the tournament'</textual></emphasis><textual class="po-textual">
context Tournament
/* PSM4 */
inv: </textual><emphasis class="po-inline e163 e163" role="bold"><textual class="po-textual">matches.day.match-&gt;exists(m:Match | m.start.trunc() = start.trunc())</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e164 e164" role="ital"><textual class="po-textual">'Each tournament conducts at least one match on the first day of the tournament'</textual></emphasis><textual class="po-textual">
/*** Tournaments schedule schema constraints ***/
context Tournament
/* PSM5 */
inv: </textual><emphasis class="po-inline e165 e165" role="bold"><textual class="po-textual">qualification.choice_1.child_1.open = true or
        qualification.choice_1.child_2.leagueName &lt;&gt; null</textual></emphasis><textual class="po-textual">
message: </textual><emphasis class="po-inline e166 e166" role="ital"><textual class="po-textual">'Tournament must be either open tournament or belong to a league'</textual></emphasis></programlisting></figure><para class="po-block e167 e167"><textual class="po-textual">From the nature of the excerpt </textual><xref class="po-milestone e168 e168" linkend="fig-psm-ocl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, it can be seen that
        </textual><emphasis class="po-inline e169 e169" role="ital"><textual class="po-textual">contexts</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e170 e170" role="ital"><textual class="po-textual">invariants</textual></emphasis><textual class="po-textual"> in
      OCL play the same role as rules' </textual><emphasis class="po-inline e171 e171" role="ital"><textual class="po-textual">contexts</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e172 e172" role="ital"><textual class="po-textual">asserts</textual></emphasis><textual class="po-textual"> in Schematron. The core of the transition from OCL to
      Schematron thus lies in translating OCL expressions into XPath tests, preserving the
      semantics. Some expressions (e.g. literals, if-then-else, variables, arithmetic, string and
      boolean operations, some collection operations) may be mapped directly to a corresponding
      XPath expression or function. </textual></para><para class="po-block e173 e173"><textual class="po-textual">For some operations, a corresponding function does not exists or has a different semantics
      (e.g. OCL </textual><code class="po-atom e174 e174"><textual class="po-textual">indexOf</textual></code><textual class="po-textual"> behaves just like XPath </textual><code class="po-atom e175 e175"><textual class="po-textual">index-of</textual></code><textual class="po-textual"> when the searched
      item occurs at most once in the searched sequence, but XPath version returns indexes of all
      occurrences, when there are more). For these cases, we created a set of functions in OclX
      library preserving the semantics. </textual></para><para class="po-block e176 e176"><textual class="po-textual">Feature-call expressions are a fundamental part of OCL - starting at a variable, they
      allow traversing the UML model along associations and accessing attributes. These are mapped
      to path expressions of XPath, which traverse the XML document. E.g. expressions
        </textual><code class="po-atom e177 e177"><textual class="po-textual">self.start</textual></code><textual class="po-textual"> or </textual><code class="po-atom e178 e178"><textual class="po-textual">self.matches.day</textual></code><textual class="po-textual"> can be expressed as
        </textual><code class="po-atom e179 e179"><textual class="po-textual">$self/start</textual></code><textual class="po-textual"> and </textual><code class="po-atom e180 e180"><textual class="po-textual">$self/matches/day</textual></code><textual class="po-textual"> respectively. </textual></para><para class="po-block e181 e181"><textual class="po-textual">In the following sections, we will be dealing with those OCL constructs that cannot be
      expressed trivially - iterator expressions, tuples and nested sequences. We will also analyse
      the differences in error recovery in both languages. </textual></para></section><section class="po-hcontainer e182 e182" xml:id="sec-iterator"><title class="po-block e183 e183"><textual class="po-textual">Iterator expressions</textual></title><para class="po-block e184 e184"><textual class="po-textual">In the examples above, a construct distinctive for OCL is used several times. It is the
      so-called iterator expression. An iterator expression is a certain kind of a function. It is always
      called on a collection object. It does not have ordinary parameters, instead each usage
      declares the iterator variable(s) it will use and a </textual><emphasis class="po-inline e185 e185" role="ital"><textual class="po-textual">body
        expression</textual></emphasis><textual class="po-textual">. OCL standard library contains several predefined iterator
      expressions, the fundamental being </textual><code class="po-atom e186 e186"><textual class="po-textual">iterate</textual></code><textual class="po-textual">. Its most general form is: </textual></para><programlisting class="po-block e187 e187" xml:space="preserve"><textual class="po-textual"> iterate(i; acc = {acc-init} | {body}) </textual></programlisting><para class="po-block e188 e188"><textual class="po-textual"> The semantics of the expression is as follows: </textual><orderedlist class="po-table e189 e189"><listitem class="po-container e190 e190"><para class="po-block e191 e191"><textual class="po-textual">Expression </textual><code class="po-atom e192 e192"><textual class="po-textual">acc-init</textual></code><textual class="po-textual"> is evaluated (in the actual context, i.e. it may
            reference any variables valid in the calling expression). The result is assigned to
            variable </textual><code class="po-atom e193 e193"><textual class="po-textual">acc</textual></code><textual class="po-textual">, which, from now on, functions as an accumulator.</textual></para></listitem><listitem class="po-container e194 e194"><para class="po-block e195 e195"><textual class="po-textual">For each member of the source collection (for which iterate is called), the member
            is assigned to variable </textual><code class="po-atom e196 e196"><textual class="po-textual">i</textual></code><textual class="po-textual">. Variables </textual><code class="po-atom e197 e197"><textual class="po-textual">i</textual></code><textual class="po-textual"> and </textual><code class="po-atom e198 e198"><textual class="po-textual">acc</textual></code><textual class="po-textual">
            (containing the value of accumulator from the previous iteration) are added to the
            context. </textual></para></listitem><listitem class="po-container e199 e199"><para class="po-block e200 e200"><textual class="po-textual">Expression </textual><code class="po-atom e201 e201"><textual class="po-textual">body</textual></code><textual class="po-textual"> is evaluated (the context now contains the variables
              </textual><code class="po-atom e202 e202"><textual class="po-textual">i</textual></code><textual class="po-textual"> and </textual><code class="po-atom e203 e203"><textual class="po-textual">acc</textual></code><textual class="po-textual">. The result is assigned to variable
              </textual><code class="po-atom e204 e204"><textual class="po-textual">acc</textual></code><textual class="po-textual"> and will be used in the next iteration.</textual></para></listitem><listitem class="po-container e205 e205"><para class="po-block e206 e206"><textual class="po-textual">After the last iteration, the value in the accumulator is returned as a result.
          </textual></para></listitem></orderedlist></para><para class="po-block e207 e207"><textual class="po-textual">There are several facts regarding iterator expressions: </textual><orderedlist class="po-table e208 e208"><listitem class="po-container e209 e209"><para class="po-block e210 e210"><textual class="po-textual">There are two fundamental iterator operations - </textual><code class="po-atom e211 e211"><textual class="po-textual">closure</textual></code><textual class="po-textual"> and
              </textual><code class="po-atom e212 e212"><textual class="po-textual">iterate</textual></code><textual class="po-textual">. From these two, </textual><code class="po-atom e213 e213"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> is not very often used
            directly by the designers working with OCL. More often, another, more specific, iterator
            expression is used. The importance of iterate lies in the fact that all other iterator
            (with the exception of </textual><code class="po-atom e214 e214"><textual class="po-textual">closure</textual></code><textual class="po-textual">) expressions (and a majority of collection
            operations) can be defined in terms of the fundamental operation </textual><code class="po-atom e215 e215"><textual class="po-textual">iterate</textual></code><textual class="po-textual">.
            E.g. operation </textual><code class="po-atom e216 e216"><textual class="po-textual">exists(it|{body})</textual></code><textual class="po-textual"> is defined as </textual><code class="po-atom e217 e217"><textual class="po-textual">iterate(it; acc=false|
              {acc or {body}})</textual></code><textual class="po-textual">. </textual></para></listitem><listitem class="po-container e218 e218"><para class="po-block e219 e219"><textual class="po-textual">Iterator expressions </textual><code class="po-atom e220 e220"><textual class="po-textual">forAll</textual></code><textual class="po-textual"> and </textual><code class="po-atom e221 e221"><textual class="po-textual">exists</textual></code><textual class="po-textual"> (serving as
            quantifiers) together with </textual><code class="po-atom e222 e222"><textual class="po-textual">not</textual></code><textual class="po-textual"> and </textual><code class="po-atom e223 e223"><textual class="po-textual">implies</textual></code><textual class="po-textual"> make OCL
            expressions at least as powerful as first order logic . Operation </textual><code class="po-atom e224 e224"><textual class="po-textual">closure</textual></code><textual class="po-textual">
            increases the expressive power with the possibility to compute transitive closures.
            Operation </textual><code class="po-atom e225 e225"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> allows to compute primitively recursive functions (for
            more on the expressive power, see </textual><xref class="po-milestone e226 e226" linkend="Mandel99"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e227 e227"><para class="po-block e228 e228"><textual class="po-textual">Multiple iteration variables, such as in </textual><code class="po-atom e229 e229"><textual class="po-textual">c-&gt;forAll(v1,v2|v1 &lt;&gt; v2)</textual></code><textual class="po-textual">,
            are allowed for some expressions, but that is just a syntactic shortcut for nested calls
            (i.e. </textual><code class="po-atom e230 e230"><textual class="po-textual">c-&gt;forAll(v1|c-&gt;forall(v2|v1&lt;&gt;v2))</textual></code><textual class="po-textual">). </textual></para></listitem><listitem class="po-container e231 e231"><para class="po-block e232 e232"><textual class="po-textual">Collection operations define additional variables to </textual><code class="po-atom e233 e233"><textual class="po-textual">self</textual></code><textual class="po-textual">, which is
              </textual><emphasis class="po-inline e234 e234" role="ital"><textual class="po-textual">global</textual></emphasis><textual class="po-textual"> in the scope of the invariant, and these
            variables (iterators and accumulator) are </textual><emphasis class="po-inline e235 e235" role="ital"><textual class="po-textual">local</textual></emphasis><textual class="po-textual"> (they
            are valid in the subexpression only).</textual></para></listitem></orderedlist></para><para class="po-block e236 e236"><textual class="po-textual">When we want to translate OCL ICs for XML, property 1 guarantees that showing how to
      express </textual><code class="po-atom e237 e237"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> and </textual><code class="po-atom e238 e238"><textual class="po-textual">closure</textual></code><textual class="po-textual"> proves that other iterator expressions
      can be expressed as well, because they can be defined using these two (although the actual
      implementation would be often more efficient when implemented directly). Property 3 relieves
      us of the necessity of considering expressions with multiple iterators. Property 4 requires
      the translation to abide the rules for context and scope of variables. Every expression can
      refer to the global variable </textual><code class="po-atom e239 e239"><textual class="po-textual">self</textual></code><textual class="po-textual"> and possibly other global variables declared
      explicitly by the user. Iterator expressions define local variables. </textual></para><para class="po-block e240 e240"><textual class="po-textual">There is no construct similar to iterator expression in XPath, which is used by
      Schematron. In some special cases, </textual><code class="po-atom e241 e241"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> can be translated to XPath
        </textual><code class="po-atom e242 e242"><textual class="po-textual">for</textual></code><textual class="po-textual"> expression, but not in general - whereas </textual><code class="po-atom e243 e243"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> can in each
      iteration refer to the result of the previous iterations (through </textual><code class="po-atom e244 e244"><textual class="po-textual">acc</textual></code><textual class="po-textual"> variable),
      in XPath </textual><code class="po-atom e245 e245"><textual class="po-textual">for</textual></code><textual class="po-textual">, computations of every iteration are strictly separated. Thus, XPath
      must be extended to fully support iterator expressions and in this section, we will show
      several approaches, how it can be achieved. Since "iterate" is a name of a construct in OCL, a
      name of its implementation in our library OclX and also a name of an XSLT instruction, we will
      distinguish them by using </textual><code class="po-atom e246 e246"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> for the OCL construct,
        </textual><code class="po-atom e247 e247"><textual class="po-textual">oclX:iterate</textual></code><textual class="po-textual"> for its implementation in OclX and by refering to the XSLT
      instruction as to </textual><code class="po-atom e248 e248"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual">. </textual></para><section class="po-hcontainer e249 e249"><title class="po-block e250 e250"><textual class="po-textual">Iterators via generated functions</textual></title><para class="po-block e251 e251"><textual class="po-textual">The principle of using accumulators in recursive calls is a routine practice in XSLT.
        The expression from the integrity constraint PSM4 from </textual><xref class="po-milestone e252 e252" linkend="fig-psm-ocl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> can be
        rewritten into an XPath expression and an accompanying XSLT function as follows: </textual></para><figure class="po-container e253 e253" xml:id="xslt-exists-gen"><title class="po-block e254 e254"><textual class="po-textual">Usage of </textual><code class="po-atom e255 e255"><textual class="po-textual">exists</textual></code><textual class="po-textual"> translated to an XSLT function</textual></title><programlisting class="po-block e256 e256" xml:space="preserve"><textual class="po-textual">&lt;xsl:value-of select="oclX:iterate(matches/day/match, false(), 1, 
      count(matches/day/match), current())" /&gt;
      
&lt;xsl:function name="oclX:iterate"&gt;
  &lt;xsl:param name="collection" as="item()*" /&gt;
  &lt;xsl:param name="acc" as="xs:boolean" /&gt;	
  &lt;xsl:param name="iteration" as="xs:integer" /&gt;
  &lt;xsl:param name="total-iterations" as="xs:integer"/&gt;
  &lt;xsl:param name="self" as="item()" /&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="$iteration &amp;lt;= $total-iterations"&gt;
      &lt;xsl:variable name="m" select="$collection[$iteration]" /&gt;
      &lt;xsl:variable name="newAcc" as="xs:boolean"&gt;
        &lt;xsl:sequence select="$acc or ($m/start eq $self/start)" /&gt;
      &lt;/xsl:variable&gt;
      &lt;xsl:value-of select="oclX:iterate($collection, $newAcc, 
                            $iteration + 1, $total-iterations, $self)" /&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="$accumulator" /&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><para class="po-block e257 e257"><textual class="po-textual">The context of the expression (valid variables) is passed as parameters
          (</textual><code class="po-atom e258 e258"><textual class="po-textual">accumulator</textual></code><textual class="po-textual">, </textual><code class="po-atom e259 e259"><textual class="po-textual">self</textual></code><textual class="po-textual"> and </textual><code class="po-atom e260 e260"><textual class="po-textual">iteration</textual></code><textual class="po-textual">). The value of
        accumulator is computed using the combination of the two expressions: expression from the
        definition of </textual><code class="po-atom e261 e261"><textual class="po-textual">exists</textual></code><textual class="po-textual"> function (</textual><code class="po-atom e262 e262"><textual class="po-textual">acc or (body)</textual></code><textual class="po-textual">) and from the actual
        call of the function (</textual><code class="po-atom e263 e263"><textual class="po-textual">m.start = self.start</textual></code><textual class="po-textual">), which is substituted for
          </textual><code class="po-atom e264 e264"><textual class="po-textual">body</textual></code><textual class="po-textual">. </textual></para><para class="po-block e265 e265"><textual class="po-textual">In this way, it is possible to translate every iterator expression (</textual><code class="po-atom e266 e266"><textual class="po-textual">closure</textual></code><textual class="po-textual">
        function can be expressed similarly). The negative side is that for each usage (call) of an
        iterator expression, a separate function has to be generated and each Schematron schema must
        be equipped with a specific set of functions that handle iterator expressions. The generated
        functions for the same iterator expression (e.g. </textual><code class="po-atom e267 e267"><textual class="po-textual">exists</textual></code><textual class="po-textual">) would differ very
        little (in the case of exists, only in the second argument of </textual><code class="po-atom e268 e268"><textual class="po-textual">or</textual></code><textual class="po-textual"> computing the
        value of </textual><code class="po-atom e269 e269"><textual class="po-textual">newAcc</textual></code><textual class="po-textual">). Our aim is to create a set of universal functions directly
        corresponding to general iterator expresions, but for that, we will need some features
        beyond the 2.0 versions of XPath and XSLT. </textual></para></section><section class="po-hcontainer e270 e270"><title class="po-block e271 e271"><textual class="po-textual">Iterators via dynamic evaluation</textual></title><para class="po-block e272 e272"><textual class="po-textual">Function in </textual><xref class="po-milestone e273 e273" linkend="xslt-exists-gen"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> can be looked upon as a template. As we
        have pointed out in the previous paragraph, the generated functions for all iterator
        expressions (except </textual><code class="po-atom e274 e274"><textual class="po-textual">closure</textual></code><textual class="po-textual">) would differ very little - only in the line
        computing the next value of the accumulator. Moreover, the functions generated for different
        calls of the same predefined iterator (e.g. all calls of </textual><code class="po-atom e275 e275"><textual class="po-textual">exists</textual></code><textual class="po-textual">) would differ
        even less - only in the </textual><code class="po-atom e276 e276"><textual class="po-textual">body</textual></code><textual class="po-textual"> (</textual><code class="po-atom e277 e277"><textual class="po-textual">$m/start eq $self/start</textual></code><textual class="po-textual"> in the
        example). Thus, the whole generated function can be looked upon as a sort of template. If
        only it were possible to create such "templated function", we would be able to use the same
        template for all calls, parameterized by </textual><code class="po-atom e278 e278"><textual class="po-textual">body</textual></code><textual class="po-textual"> .</textual></para><para class="po-block e279 e279"><textual class="po-textual">One way to achieve this is by using dynamic evaluation. Each iterator expression can
        then be mapped to a call of the same function, for which </textual><code class="po-atom e280 e280"><textual class="po-textual">body</textual></code><textual class="po-textual"> is passed as a
        string. The value of </textual><code class="po-atom e281 e281"><textual class="po-textual">body</textual></code><textual class="po-textual"> is then computed dynamically. </textual><xref class="po-milestone e282 e282" linkend="xslt-iterate-dynamic"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows an implementation of </textual><code class="po-atom e283 e283"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> using
        dynamic evaluation.</textual></para><figure class="po-container e284 e284" xml:id="xslt-iterate-dynamic"><title class="po-block e285 e285"><textual class="po-textual">Generic </textual><code class="po-atom e286 e286"><textual class="po-textual">oclX:iterate</textual></code><textual class="po-textual"> function implemented using dynamic
          evaluation</textual></title><programlisting class="po-block e287 e287" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="oclX:iterate" as="item()*"&gt;
  &lt;xsl:param name="collection" as="item()*"/&gt;
  &lt;xsl:param name="iterationVar" as="xs:string"/&gt;
  &lt;xsl:param name="acc-init" as="xs:string"/&gt;
  &lt;xsl:param name="body" as="xs:string" /&gt;
  &lt;xsl:param name="self" as="xs:item()"/&gt;    

  &lt;xsl:variable name="accumulatorInitialValue" as="item()*"&gt;
    </textual><emphasis class="po-inline e288 e288" role="bold"><textual class="po-textual">&lt;xsl:sequence select="dyn:evaluate($acc-init)"/&gt;</textual></emphasis><textual class="po-textual">
  &lt;/xsl:variable&gt;

  &lt;xsl:sequence select="oclXin:iterate-rec($collection, $iterationVar, $accumulatorVar, 
     $accumulatorInitialValue, $body, 1, count($collection))"
  /&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="oclXin:iterate-rec" as="item()*"&gt;
  &lt;xsl:param name="collection" as="item()*"/&gt;
  &lt;xsl:param name="iterationVar" as="xs:string"/&gt;
  &lt;xsl:param name="accumulatorVar" as="xs:string"/&gt;
  &lt;xsl:param name="acc" as="item()*"/&gt;
  &lt;xsl:param name="body" as="xs:string"/&gt;
  &lt;xsl:param name="iteration" as="xs:integer"/&gt;
  &lt;xsl:param name="totalIterations" as="xs:integer"/&gt;
  &lt;xsl:param name="self" as="xs:item()"/&gt;     

  &lt;xsl:choose&gt;
    &lt;xsl:when test="$iteration = $totalIterations + 1"&gt;
      &lt;!-- return accumulated value --&gt;
      &lt;xsl:sequence select="$acc"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;-- iterator value for this iteration --&gt;
      &lt;xsl:variable name="m" as select="$collection[$iteration]" /&gt;
      &lt;xsl:variable name="newAcc" as="item()*"&gt;
        </textual><emphasis class="po-inline e289 e289" role="bold"><textual class="po-textual">&lt;xsl:sequence select="dyn:evaluate($body)"/&gt;</textual></emphasis><textual class="po-textual">
      &lt;/xsl:variable&gt;
      &lt;!-- call recursively --&gt;
      &lt;xsl:sequence
        select="oclXin:iterate-rec($collection, $iterationVar, $accumulatorVar, 
                  $newAcc, $body, $iteration + 1, $totalIterations, $self)" /&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><para class="po-block e290 e290"><textual class="po-textual">Dynamic evaluation is a feature not present in standardized XSLT 2.0, but exists both in
        the form of cross-processor portable external libraries (such as </textual><xref class="po-milestone e291 e291" linkend="exslt"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) or
        vendor-specific extensions (e.g. in </textual><xref class="po-milestone e292 e292" linkend="saxon"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Unfortunately, the semantics
        of dynamic evaluation is not consistent in these cases, e.g. EXSLT allows to use free
        variables in the evaluated expression (e.g. </textual><code class="po-atom e293 e293"><textual class="po-textual">self</textual></code><textual class="po-textual">, </textual><code class="po-atom e294 e294"><textual class="po-textual">m</textual></code><textual class="po-textual"> and
          </textual><code class="po-atom e295 e295"><textual class="po-textual">acc</textual></code><textual class="po-textual"> in the example) and they are bound to values defined in the context where
        the function is called. On the other hand, in Saxon, all free variables are bound to the
        parameters passed to the call of </textual><code class="po-atom e296 e296"><textual class="po-textual">evaluate</textual></code><textual class="po-textual"> (as a consequence to this design
        decision, the names of the free variables are coerced to be </textual><code class="po-atom e297 e297"><textual class="po-textual">p1</textual></code><textual class="po-textual">, </textual><code class="po-atom e298 e298"><textual class="po-textual">p2</textual></code><textual class="po-textual">
        etc. and there is a limit on the maximal amount of free variables allowed).</textual></para><para class="po-block e299 e299"><textual class="po-textual">W3C answered the call for dynamic evaluation in the draft of XSLT 3.0 and introduced a
        new instruction - </textual><code class="po-atom e300 e300"><textual class="po-textual">xsl:evaluate</textual></code><textual class="po-textual">. The semantics is closer to the one used by
        Saxon, values of free variables are assigned using </textual><code class="po-atom e301 e301"><textual class="po-textual">xsl:with-param</textual></code><textual class="po-textual"> instructions
        (the names of the parameters are in this case up to the user to decide). As it turns out,
        there is no perfect solution with dynamic evaluation, because there are these obstacles: </textual><orderedlist class="po-table e302 e302"><listitem class="po-container e303 e303"><para class="po-block e304 e304"><textual class="po-textual">There is no upper limit on the amount of both free and bound variables the user
              can use in an OCL expression. </textual></para></listitem><listitem class="po-container e305 e305"><para class="po-block e306 e306"><textual class="po-textual">The names of the variables are also selected by the user. </textual></para></listitem></orderedlist></para><para class="po-block e307 e307"><textual class="po-textual">The first one renders Saxon, with its limit on the number of free variables, not general
        enough. All three approaches also share the same problem - the names of free variables are
        either coerced (Saxon) or they are defined statically (EXSLT, </textual><code class="po-atom e308 e308"><textual class="po-textual">xsl:evaluate</textual></code><textual class="po-textual">). If
          </textual><code class="po-atom e309 e309"><textual class="po-textual">xsl:evaluate</textual></code><textual class="po-textual"> allowed dynamic naming of the parameters, the following call
        would be usable (the excerpt replaces the definition of </textual><code class="po-atom e310 e310"><textual class="po-textual">newAcc</textual></code><textual class="po-textual"> in the template
        from </textual><xref class="po-milestone e311 e311" linkend="xslt-iterate-dynamic"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">: </textual><programlisting class="po-block e312 e312" xml:space="preserve"><textual class="po-textual">&lt;xsl:evaluate xpath="$body"&gt;
  &lt;xsl:with-param name="</textual><emphasis class="po-inline e313 e313" role="bold"><textual class="po-textual">{accumulatorVar}</textual></emphasis><textual class="po-textual">" select="$acc" /&gt;
  &lt;xsl:with-param name="</textual><emphasis class="po-inline e314 e314" role="bold"><textual class="po-textual">{iterationVar}</textual></emphasis><textual class="po-textual">" select="$collection[$iteration]" /&gt;
  &lt;xsl:with-param name="self" select="$self" /&gt;
&lt;/xsl:evaluate&gt;</textual></programlisting></para><para class="po-block e315 e315"><textual class="po-textual">Yet, even this solution works only when there are only three allowed free variables in
          </textual><code class="po-atom e316 e316"><textual class="po-textual">body</textual></code><textual class="po-textual"> expression - accumulator, iterator, and self. </textual></para><para class="po-block e317 e317"><xref class="po-milestone e318 e318" linkend="xslt-exists-dynamic"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows, how </textual><code class="po-atom e319 e319"><textual class="po-textual">exists</textual></code><textual class="po-textual"> iterator expression
        can be implemented (as function </textual><code class="po-atom e320 e320"><textual class="po-textual">oclX:exists</textual></code><textual class="po-textual">) according to its specification in
        the terms of </textual><code class="po-atom e321 e321"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> (implemented as function </textual><code class="po-atom e322 e322"><textual class="po-textual">oclX:iterate</textual></code><textual class="po-textual">, </textual><xref class="po-milestone e323 e323" linkend="xslt-iterate-dynamic"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).  The </textual><code class="po-atom e324 e324"><textual class="po-textual">body</textual></code><textual class="po-textual"> expression is combined with the
        expression defining exists iterator expression (</textual><code class="po-atom e325 e325"><textual class="po-textual">acc or (body)</textual></code><textual class="po-textual">) using simple
        string manipulation. </textual></para><figure class="po-container e326 e326" xml:id="xslt-exists-dynamic"><title class="po-block e327 e327"><textual class="po-textual">Generic </textual><code class="po-atom e328 e328"><textual class="po-textual">exists</textual></code><textual class="po-textual"> function implemented via call of
          </textual><code class="po-atom e329 e329"><textual class="po-textual">iterate</textual></code></title><programlisting class="po-block e330 e330" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="oclX:exists" as="xs:boolean"&gt;
  &lt;xsl:param name="collection" as="item()*"/&gt;
  &lt;xsl:param name="iterationVar" as="xs:string"/&gt;
  &lt;xsl:param name="body" as="xs:string" /&gt;
  &lt;xsl:param name="self" /&gt; 
  
  &lt;xsl:sequence select="oclX:iterate($collection, $iterationVar, 'acc', 
    'false()', concat('$acc or (', $body ,')'), $self)"  &gt;&lt;/xsl:sequence&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><para class="po-block e331 e331"><textual class="po-textual">To conclude this discourse, we implemented a version of OclX library which uses dynamic
        evaluation. We used the extension function provided by Saxon. We solved the second problem
        by passing the values of all free variables in one value (a sequence of values) and
        replacing the references of free variables by expression indexing the sequence before the
        expression is evaluated. This solution works with XSLT 2.0 (+ Saxon extension). Passing more
        values in one sequence is a problem of itself, because empty values and values, which are
        sequences themselves, have to be encoded (more about this in section </textual><xref class="po-milestone e332 e332" linkend="sec-tuples"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the approach used there can also be applied for the encoding
        problem here). However, XSLT 3.0 offers another approach to tackle iterator expressions and
        free variables satisfactorily and elegantly, and those are higher-order functions.</textual></para></section><section class="po-hcontainer e333 e333"><title class="po-block e334 e334"><textual class="po-textual">Higher-order functions</textual></title><para class="po-block e335 e335"><textual class="po-textual">The drafts of XPath 3.0 and XQuery 3.0 define a new kind of item in the common data
        model - function item. Funciton item is an item, that can be </textual><emphasis class="po-inline e336 e336" role="ital"><textual class="po-textual">called</textual></emphasis><textual class="po-textual">. This makes functions in XPath and XQuery first-class citizens that can
        be results of expressions and passed as arguments to function calls, making XPath/XQuery
        full-fledged functional languages (technique for using higher-order functions also in XSLT
        2.0 was shown in </textual><xref class="po-milestone e337 e337" linkend="novatchev06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, but that is far from native). A prototype
        implementation of HOF is available in </textual><xref class="po-milestone e338 e338" linkend="saxon"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> since version 9.3.</textual></para><para class="po-block e339 e339"><textual class="po-textual">The OCL iterator expressions can be viewed as functions, which expect another function
        as their parameter - i.e. higher-order functions</textual><footnote class="po-popup e340 e340"><para class="po-block e341 e341"><textual class="po-textual">Yet OCL does not have the full power of functional languages, since it does not
            allow functions to be results of expressions.</textual></para></footnote><textual class="po-textual">. In </textual><code class="po-atom e342 e342"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> expression, </textual><code class="po-atom e343 e343"><textual class="po-textual">body</textual></code><textual class="po-textual"> can be looked upon as a
        parameter, which expects a function. </textual><xref class="po-milestone e344 e344" linkend="xslt-iterate-hof"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows how
          </textual><code class="po-atom e345 e345"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> is implemented in OclX. We also used the new instruction -
          </textual><code class="po-atom e346 e346"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual"> - which is also proposed in the XSLT 3.0 draft and has a very
        similar semantics to its OCL namesake. </textual></para><figure class="po-container e347 e347" xml:id="xslt-iterate-hof"><title class="po-block e348 e348"><textual class="po-textual">Implementation of </textual><code class="po-atom e349 e349"><textual class="po-textual">iterate</textual></code><textual class="po-textual"> as a higher-order function
            </textual><code class="po-atom e350 e350"><textual class="po-textual">oclX:iterate</textual></code></title><programlisting class="po-block e351 e351" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="oclX:iterate" as="item()*"&gt;        
  &lt;xsl:param name="collection" as="item()*"/&gt;
  &lt;xsl:param name="accInit" as="item()*"/&gt;
  &lt;xsl:param name="body" as="</textual><emphasis class="po-inline e352 e352" role="bold"><textual class="po-textual">function(item(), item()*) as item()*</textual></emphasis><textual class="po-textual">"/&gt;
         
  &lt;xsl:iterate select="1 to count($collection)"&gt;      
    &lt;xsl:param name="acc" select="$accInit" as="item()*" /&gt;
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="acc" select="</textual><emphasis class="po-inline e353 e353" role="bold"><textual class="po-textual">$body($collection[current()], $acc)</textual></emphasis><textual class="po-textual">" /&gt;
    &lt;/xsl:next-iteration&gt;      
    &lt;xsl:on-completion&gt;
      &lt;xsl:sequence select="$acc" /&gt;
    &lt;/xsl:on-completion&gt;
  &lt;/xsl:iterate&gt;    
&lt;/xsl:function&gt;</textual></programlisting></figure><para class="po-block e354 e354"><textual class="po-textual">The function's </textual><code class="po-atom e355 e355"><textual class="po-textual">body</textual></code><textual class="po-textual"> parameter expects a function with two bound variables,
        the first one representing the accumulator, the second one the member of the iterated
        collection for this iteration. Also, the definition of function </textual><code class="po-atom e356 e356"><textual class="po-textual">oclX:exists</textual></code><textual class="po-textual"> in
          </textual><xref class="po-milestone e357 e357" linkend="xslt-exists-hof"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows that this definition is general enough to be used
        to define other functions in its terms. The implementation of </textual><code class="po-atom e358 e358"><textual class="po-textual">closure</textual></code><textual class="po-textual"> is
        similar to that of </textual><code class="po-atom e359 e359"><textual class="po-textual">iterate</textual></code><textual class="po-textual">, only it uses recursion. </textual></para><figure class="po-container e360 e360" xml:id="xslt-exists-hof"><title class="po-block e361 e361"><textual class="po-textual">Implementation of </textual><code class="po-atom e362 e362"><textual class="po-textual">exists</textual></code><textual class="po-textual"> as a higher-order function
            </textual><code class="po-atom e363 e363"><textual class="po-textual">oclX:exists</textual></code><textual class="po-textual"> calling </textual><code class="po-atom e364 e364"><textual class="po-textual">oclX:iterate</textual></code></title><programlisting class="po-block e365 e365" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="oclX:exists" as="xs:boolean"&gt;    
  &lt;xsl:param name="collection" as="item()*"/&gt;
  &lt;xsl:param name="body" as="</textual><emphasis class="po-inline e366 e366" role="bold"><textual class="po-textual">function(item()) as xs:boolean</textual></emphasis><textual class="po-textual">"/&gt;    
  
  &lt;xsl:sequence select="</textual><emphasis class="po-inline e367 e367" role="bold"><textual class="po-textual">oclX:iterate($collection, false(), 
      function($it, $acc) { $acc or ($body($it)) })</textual></emphasis><textual class="po-textual">" /&gt;   
&lt;/xsl:function&gt;</textual></programlisting></figure><para class="po-block e368 e368"><textual class="po-textual">Now let us compare the higher-order function approach to the dynamic evaluation
        approach. As in OCL, there is no limit on the number of free variables in XPath function
        items, so the mapping is seamless in this respect. Furthermore, the semantics of free
        variables in a higher-order function is that their values are obtained from the context at the
        place of the call - the same semantics OCL uses for free variables. </textual></para><para class="po-block e369 e369"><textual class="po-textual">As an icing on the cake, we can utilize the reflection function
          </textual><code class="po-atom e370 e370"><textual class="po-textual">function-arity</textual></code><textual class="po-textual"> (supported for function items) to allow iterator expressions
        with more than one iterators directly (not via replacing them by nested calls). </textual><xref class="po-milestone e371 e371" linkend="xslt-existsN-hof"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows a multiple-iterator version of </textual><code class="po-atom e372 e372"><textual class="po-textual">exists</textual></code><textual class="po-textual">
        (which is one of the few iterator expressions, which allows multiple iterators by OCL
        specification). We use two helper functions: </textual><code class="po-atom e373 e373"><textual class="po-textual">getIndices</textual></code><textual class="po-textual"> (which returns the n-th
        number in a system with a given </textual><code class="po-atom e374 e374"><textual class="po-textual">base</textual></code><textual class="po-textual"> in the form of a zero-filled sequence) and
          </textual><code class="po-atom e375 e375"><textual class="po-textual">functionItemCall</textual></code><textual class="po-textual">, which assigns the values to the iterators and calls the
        higher-order function. However, we are forced to fix the maximum amount of iterators
        allowed, because a call of function item requires a fixed amount of parameters (of course,
        we could prolong the last </textual><code class="po-atom e376 e376"><textual class="po-textual">if</textual></code><textual class="po-textual"> as we like). </textual></para><figure class="po-container e377 e377" xml:id="xslt-existsN-hof"><title class="po-block e378 e378"><textual class="po-textual">Implementation of </textual><code class="po-atom e379 e379"><textual class="po-textual">existsN</textual></code><textual class="po-textual"> - multiple iterators</textual></title><programlisting class="po-block e380 e380" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="oclX:existsN" as="xs:boolean"&gt;    
  &lt;xsl:param name="collection" as="item()*"/&gt;
  &lt;xsl:param name="body" as="function(*)"/&gt;
  &lt;xsl:variable name="iteratorCount" select="function-arity($body)" as="xs:integer" /&gt;
  
  &lt;xsl:iterate select="1 to xs:integer(math:pow(count($collection), $iteratorCount))"&gt;  
    &lt;xsl:param name="satisfied" as="xs:boolean" select="true()" /&gt;  
    &lt;xsl:variable name="indices" select="
      oclXin:getIndices(. - 1, count($collection), $iteratorCount, ())"/&gt;
    &lt;xsl:variable name="forThis" select="oclXin:functionItemCall(
      $body, $iteratorCount, $indices, $collection)" as="xs:boolean" /&gt;  
    &lt;xsl:choose&gt;
      &lt;xsl:when test="$forThis eq true()"&gt;
        &lt;xsl:break&gt;
          &lt;xsl:sequence select="true()"/&gt;
        &lt;/xsl:break&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:next-iteration&gt;
          &lt;xsl:with-param name="satisfied" select="$satisfied or $forThis" /&gt;  
        &lt;/xsl:next-iteration&gt;    
      &lt;/xsl:otherwise&gt;  
    &lt;/xsl:choose&gt;  
    &lt;xsl:on-completion&gt;
      &lt;xsl:sequence select="$satisfied" /&gt;
    &lt;/xsl:on-completion&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:function&gt;  

&lt;xsl:function name="oclXin:getIndices" as="xs:integer*"&gt;
  &lt;xsl:param name="scalar" as="xs:integer" /&gt; 
  &lt;xsl:param name="base" as="xs:integer" /&gt;
  &lt;xsl:param name="length" as="xs:integer" /&gt;
  &lt;xsl:param name="result" as="xs:integer*" /&gt;
  &lt;xsl:choose&gt;      
    &lt;xsl:when test="$scalar eq 0"&gt;
      &lt;xsl:sequence select="
        (for $i in 1 to ($length - count($result)) return 0), $result" /&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:variable name="mod" select="$scalar mod $base"/&gt;
      &lt;xsl:sequence select="            
        oclXin:getIndices(xs:integer($scalar div $base), $base, $length, 
                          (($mod), $result))" /&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="oclXin:functionItemCall"&gt;
  &lt;xsl:param name="function" as="function(*)" /&gt;
  &lt;xsl:param name="arity" as="xs:integer" /&gt;
  &lt;xsl:param name="indices" as="xs:integer*" /&gt;
  &lt;xsl:param name="a" as="item()*" /&gt;
  
  &lt;xsl:sequence select="if ($arity eq 1) then $function($a[$indices[1] + 1])
    else if ($arity eq 2) then $function($a[$indices[1] + 1], $a[$indices[2] + 1])
    else if ($arity eq 3) then $function($a[$indices[1] + 1], $a[$indices[2] + 1], 
                                         $a[$indices[3] + 1])
    else error(QName('http://eXolutio.com/oclX/functional/error', 'oclXer:E001'), 
                     'A maximum of three different iterators are allowed. ')" /&gt;      
&lt;/xsl:function&gt;</textual></programlisting></figure></section><section class="po-hcontainer e381 e381"><title class="po-block e382 e382"><textual class="po-textual">Local variables</textual></title><para class="po-block e383 e383"><textual class="po-textual">The issue of local variables is closely related to iterator expressions, because they
        are one of the two ways how local variables can be defined. Apart from iterator expressions
        (which define local variables implicitly), OCL also contains </textual><code class="po-atom e384 e384"><textual class="po-textual">let</textual></code><textual class="po-textual"> expression,
        which defines a variable valid in the scope of the expression. The semantics of local
        variables is similar to that of XPath - the value is assigned in the moment of declaration
        and does not change from that place on. </textual></para><para class="po-block e385 e385"><textual class="po-textual">In XPath 2.0, the same effect can be achieved using </textual><code class="po-atom e386 e386"><textual class="po-textual">for</textual></code><textual class="po-textual">, but only when the
        value of the local variable is not a collection (</textual><code class="po-atom e387 e387"><textual class="po-textual">for</textual></code><textual class="po-textual"> would only perform one
        cycle). In other cases, we must descend to inlining the value (since it is immutable).
        Alternatively, when the variable is defined in the scope of the invariant (making it global
        variable for the whole invariant), it can be translated into XSLT variable definition. </textual></para><para class="po-block e388 e388"><textual class="po-textual">XPath 3.0 again makes the translation easier, because it allows </textual><code class="po-atom e389 e389"><textual class="po-textual">let/return</textual></code><textual class="po-textual">
        expressions, with semantics eqivalent to OCL </textual><code class="po-atom e390 e390"><textual class="po-textual">let</textual></code><textual class="po-textual">. </textual></para></section></section><section class="po-hcontainer e391 e391" xml:id="sec-tuples"><title class="po-block e392 e392"><textual class="po-textual">Tuples as maps</textual></title><para class="po-block e393 e393"><textual class="po-textual">In this section we propose how to deal with tuples (anonymous types) from OCL.</textual></para><para class="po-block e394 e394"><textual class="po-textual">OCL allows the designer to combine values in expressions into tuples. Tuples can be
      considered an anonymous type, which has a finite number of named parts. An example of a tuple
      may be </textual><code class="po-atom e395 e395"><textual class="po-textual">Tuple { firstName = 'Jakub', lastName = 'Malý', age = 26 }</textual></code><textual class="po-textual">. The values of
      the parts may be of arbitrary type, including collections and other tuples. The names of parts
        (</textual><code class="po-atom e396 e396"><textual class="po-textual">firstName</textual></code><textual class="po-textual">, </textual><code class="po-atom e397 e397"><textual class="po-textual">lastName</textual></code><textual class="po-textual">, </textual><code class="po-atom e398 e398"><textual class="po-textual">age</textual></code><textual class="po-textual"> in the example) must be
      unique and are used to access the parts of the tuple in the expressions, similarly to
      attributes of classes, i.e. it is possible to write </textual><code class="po-atom e399 e399"><textual class="po-textual">employees-&gt;collect( e | Tuple { name
        = e.name, salary = e.salary })-&gt;select( t | t.salary &gt; 2000)</textual></code><textual class="po-textual">, the result of this
      expression would be a collection of tuples. </textual></para><para class="po-block e400 e400"><textual class="po-textual">There is a noteworthy property coming with the possibility to create tuples: together with
      tuples, OCL was equipped with the operation </textual><code class="po-atom e401 e401"><textual class="po-textual">product</textual></code><textual class="po-textual">, defined as follows: </textual></para><programlisting class="po-block e402 e402" xml:space="preserve"><textual class="po-textual">
      product(c1:Collection(T1), c2:Collection(T2)) = 
        self-&gt;iterate(e1; acc = Set{} |
                c2-&gt;iterate (e2; acc2 = acc | acc2-&gt;including(
                      Tuple{first = e1, second = e2}) 
            ) 
        )</textual></programlisting><para class="po-block e403 e403"><textual class="po-textual">The result of </textual><code class="po-atom e404 e404"><textual class="po-textual">product</textual></code><textual class="po-textual"> is a collection of type </textual><code class="po-atom e405 e405"><textual class="po-textual">Collection(Tuple(first:
        T1, second: T2))</textual></code><textual class="po-textual">, which contains all possible pairs where the first compound comes
      from collection </textual><code class="po-atom e406 e406"><textual class="po-textual">c1</textual></code><textual class="po-textual"> and the second collection </textual><code class="po-atom e407 e407"><textual class="po-textual">c2</textual></code><textual class="po-textual">. This operation thus
      finalizes the suite of equivalents of the constructs required for a language to be
      relationally complete (see </textual><xref class="po-milestone e408 e408" linkend="Codd72"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">):</textual><itemizedlist class="po-table e409 e409"><listitem class="po-container e410 e410"><para class="po-block e411 e411"><emphasis class="po-inline e412 e412" role="ital"><textual class="po-textual">Select</textual></emphasis><textual class="po-textual"> - can be expressed using </textual><code class="po-atom e413 e413"><textual class="po-textual">select</textual></code><textual class="po-textual">
            iterator expression,</textual></para></listitem><listitem class="po-container e414 e414"><para class="po-block e415 e415"><emphasis class="po-inline e416 e416" role="ital"><textual class="po-textual">Project</textual></emphasis><textual class="po-textual"> - can be expressed using
              </textual><code class="po-atom e417 e417"><textual class="po-textual">collect</textual></code><textual class="po-textual"> iterator expression that creates a tuple with the projected
            attributes (see the </textual><code class="po-atom e418 e418"><textual class="po-textual">employees</textual></code><textual class="po-textual"> example above, which, in fact, performs
            projection to attributes </textual><code class="po-atom e419 e419"><textual class="po-textual">name</textual></code><textual class="po-textual"> and </textual><code class="po-atom e420 e420"><textual class="po-textual">salary</textual></code><textual class="po-textual">) ,</textual></para></listitem><listitem class="po-container e421 e421"><para class="po-block e422 e422"><emphasis class="po-inline e423 e423" role="ital"><textual class="po-textual">Union</textual></emphasis><textual class="po-textual"> - OCL has union operation as well,</textual></para></listitem><listitem class="po-container e424 e424"><para class="po-block e425 e425"><emphasis class="po-inline e426 e426" role="ital"><textual class="po-textual">Set difference</textual></emphasis><textual class="po-textual"> - OCL has operation '</textual><code class="po-atom e427 e427"><textual class="po-textual">-</textual></code><textual class="po-textual">'
            working on sets,</textual></para></listitem><listitem class="po-container e428 e428"><para class="po-block e429 e429"><emphasis class="po-inline e430 e430" role="ital"><textual class="po-textual">Cartesian product</textual></emphasis><textual class="po-textual"> - can be expressed using
              </textual><code class="po-atom e431 e431"><textual class="po-textual">product</textual></code><textual class="po-textual">,</textual></para></listitem><listitem class="po-container e432 e432"><para class="po-block e433 e433"><emphasis class="po-inline e434 e434" role="ital"><textual class="po-textual">(Rename)</textual></emphasis><textual class="po-textual"> - can be expressed using
              </textual><code class="po-atom e435 e435"><textual class="po-textual">collect</textual></code><textual class="po-textual"> in the same manner as </textual><emphasis class="po-inline e436 e436" role="ital"><textual class="po-textual">project</textual></emphasis><textual class="po-textual">
            operation. </textual></para></listitem></itemizedlist></para><para class="po-block e437 e437"><textual class="po-textual">Thus, not only tuples can be used to write more concise expressions, but, together with
      the operation product, they increase the expressive power of the language to relational
      completeness. </textual></para><para class="po-block e438 e438"><textual class="po-textual">As far as XPath 2.0 is concerned, there exists no construct that could be naturally used
      to represent tuples, they can only be partially simulated. One possibility is to use
      sequences, where each item in the sequence corresponds to one part of the tuple, i.e.
        </textual><code class="po-atom e439 e439"><textual class="po-textual">Tuple { firstName = 'Jakub', lastName = 'Malý', age = 26 }</textual></code><textual class="po-textual"> would be represented
      as a sequence </textual><code class="po-atom e440 e440"><textual class="po-textual">('Jakub', 'Malý', 26)</textual></code><textual class="po-textual">. </textual></para><para class="po-block e441 e441"><textual class="po-textual">But this solution is not completely satisfactory from the following reasons: </textual><orderedlist class="po-table e442 e442"><listitem class="po-container e443 e443"><para class="po-block e444 e444"><textual class="po-textual">We loose "safety" and clarity in the expression, because we have to write
              </textual><code class="po-atom e445 e445"><textual class="po-textual">$t[1]</textual></code><textual class="po-textual"> to represent the OCL expression </textual><code class="po-atom e446 e446"><textual class="po-textual">t.firstName</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e447 e447"><para class="po-block e448 e448"><textual class="po-textual">When some part is missing (which is in OCL indicated by </textual><code class="po-atom e449 e449"><textual class="po-textual">null</textual></code><textual class="po-textual"> value), we
            have to use some placeholder value to keep the length of the sequence constant (e.g.
              </textual><code class="po-atom e450 e450"><textual class="po-textual">('null', 'null', 26)</textual></code><textual class="po-textual">).</textual></para></listitem><listitem class="po-container e451 e451"><para class="po-block e452 e452"><textual class="po-textual">A part of a tuple in OCL can be of any type, including other tuples and collections.
            Here, this approach fails utterly, because all sequences are flattened in XPath. This
            also makes implementing </textual><code class="po-atom e453 e453"><textual class="po-textual">product</textual></code><textual class="po-textual"> operation impossible, because it should
            return a collection of tuples, i.e. a collection of sequences. </textual></para></listitem></orderedlist></para><para class="po-block e454 e454"><textual class="po-textual">Instead of representing tuples using sequences, an alternative would be to represent them
      using temporary documents, for example: </textual></para><programlisting class="po-block e455 e455" xml:space="preserve"><textual class="po-textual">      &lt;Tuple&gt;
        &lt;firstName&gt;Jakub&lt;/firstName&gt;
        &lt;lastName&gt;Malý&lt;/lastName&gt;
        &lt;age&gt;26&lt;/age&gt;
      &lt;/Tuple&gt;</textual></programlisting><para class="po-block e456 e456"><textual class="po-textual">This approach would overcome the first issue (</textual><code class="po-atom e457 e457"><textual class="po-textual">t.firstName</textual></code><textual class="po-textual"> would be
      represented as </textual><code class="po-atom e458 e458"><textual class="po-textual">$t/firstName</textual></code><textual class="po-textual">), the second issue (an empty element could represent
      a missing part) and also the third issue (nesting is no problem here and collections could be
      encoded into trees as well). However, it brings two problems of its own: </textual><orderedlist class="po-table e459 e459"><listitem class="po-container e460 e460"><para class="po-block e461 e461"><textual class="po-textual">The value which is about to become a part of a tuple, is copied to a temporary XML
            document. This would not hurt so much with atomic values, but would be a significant
            overhead, when the value was a node or a sequence of nodes in the input document (whole
            subtree would be copied in this case).</textual></para></listitem><listitem class="po-container e462 e462"><para class="po-block e463 e463"><textual class="po-textual">When a node is copied into the temporary document, its position in the document is
            lost, it would not be possible to navigate outside its subtree (e.g. using
              </textual><code class="po-atom e464 e464"><textual class="po-textual">parent</textual></code><textual class="po-textual"> axis) and operations relying on node identity (such as the
              </textual><code class="po-atom e465 e465"><textual class="po-textual">is</textual></code><textual class="po-textual"> operator) would give unexpected results when applied on nodes from the
            input tree and from the temporary tree. </textual></para></listitem></orderedlist></para><para class="po-block e466 e466"><textual class="po-textual">To conclude, restrictions inherent in XPath 2.0 data model prevent from satisfactory
      representation of tuples with semantics corresponding to OCL.</textual></para><para class="po-block e467 e467"><textual class="po-textual">However, the possibility of extending the XPath/XQuery model with another item type - map
      - is being discussed and a prototype implementation is now available in </textual><xref class="po-milestone e468 e468" linkend="saxon"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> (an alternative is to use XQuery implementation of maps using function items instead of map
      items, for details see </textual><xref class="po-milestone e469 e469" linkend="snelson11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). The map type requires atomic values for
      keys and allow items of any type as values. These properties of map type make it a great
      candidate for representing tuples, thus, we decided to create a version of OclX which supports
      tuples represented as maps. Strings containing the name of a tuple part can be used as keys
      (and the names of parts must be distinct in an OCL tuple as well). The tuple from the example
      would be represented as </textual><code class="po-atom e470 e470"><textual class="po-textual">map{'firstName' := 'Jakub', 'lastName' := 'Malý', 'age' :=
        26}</textual></code><textual class="po-textual">, expression </textual><code class="po-atom e471 e471"><textual class="po-textual">t.firstName</textual></code><textual class="po-textual"> would be represented as
        </textual><code class="po-atom e472 e472"><textual class="po-textual">$t('firstName')</textual></code><textual class="po-textual">. A value in a map can also be another map or sequence, which is
      consistent with semantics of OCL tuples. Operation </textual><code class="po-atom e473 e473"><textual class="po-textual">product</textual></code><textual class="po-textual"> can be defined either
      by translating the definition from specification (using two nested </textual><code class="po-atom e474 e474"><textual class="po-textual">iterates</textual></code><textual class="po-textual">) or
      via a much more succinct expression:</textual></para><programlisting class="po-block e475 e475" xml:space="preserve"><textual class="po-textual">   for $e1 in $collection1 return for $e2 in $collection2 
        return map{'first' := $e1, 'second' := $e2}</textual></programlisting></section><section class="po-hcontainer e476 e476" xml:id="sec-collections"><title class="po-block e477 e477"><textual class="po-textual">Different kinds of collections, nested collections</textual></title><para class="po-block e478 e478"><textual class="po-textual">OCL defines an abstract type Collection and 4 different types of collections - Set,
      OrderedSet, Bag (in other languages sometimes called multiset) and Sequence. A member of any
      collection can be an arbitrary value, including another collection. </textual></para><para class="po-block e479 e479"><textual class="po-textual">We treat all collections as sequences in OclX, yet it would be possible to represent the
      other kinds of collections using maps (or sequences as well). </textual></para><para class="po-block e480 e480"><textual class="po-textual">Nested collections are a foreign concept to XPath data model. The disadvantages of
      encoding collections into temporary documents were discussed in section </textual><xref class="po-milestone e481 e481" linkend="sec-tuples"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e482 e482"><textual class="po-textual">With the introduction of maps, there is a, rather ugly, way of encoding nested sequences -
      thanks to the possibility of using maps as values </textual><emphasis class="po-inline e483 e483" role="ital"><textual class="po-textual">and</textual></emphasis><textual class="po-textual"> members
      of sequences. A nested sequence ((1,2),(3),()) could be encoded to </textual><code class="po-atom e484 e484"><textual class="po-textual">map{'s' := (map{'s'
        := (1,2)}, map{'s' := (3)}, map{'s' := ()})}</textual></code><textual class="po-textual">, the expression returning number two
      would be written as </textual><code class="po-atom e485 e485"><textual class="po-textual">(map{'s' := (map{'s' := (1,2)}, map{'s' := (3)}, map{'s' :=
        ()})})('s')[1]('s')[2]</textual></code><textual class="po-textual">. Using this approach also requires the functions which
      concatenate sequences not to use XPath operator </textual><code class="po-atom e486 e486"><textual class="po-textual">,</textual></code><textual class="po-textual">, because it flattens the
      resulting sequence.</textual></para><para class="po-block e487 e487"><textual class="po-textual">The double indexing (first to get the value from the map, second for getting the desired
      member of the sequence) can seem confusing, but it can be in fact hidden behind a library
      function </textual><code class="po-atom e488 e488"><textual class="po-textual">at(i)</textual></code><textual class="po-textual"> (which OCL uses instead of the operator </textual><code class="po-atom e489 e489"><textual class="po-textual">[i]</textual></code><textual class="po-textual"> to get an
      i-th member of a sequence). The wordy and a bit unclear way of creating a nested sequence
      appears in those expression that create nested sequences using literals. This, however, could
      be eliminated by using preprocessing of the schemas before evaluating the expressions (adding
      another step to Schematron pipeline). </textual></para></section><section class="po-hcontainer e490 e490" xml:id="sec-errors"><title class="po-block e491 e491"><textual class="po-textual">Error recovery</textual></title><para class="po-block e492 e492"><textual class="po-textual">OCL as a language has a direct approach to "run-time" errors or exceptions. Errors in
      computation cause the result of the expression to be </textual><code class="po-atom e493 e493"><textual class="po-textual">invalid</textual></code><textual class="po-textual"> - a sole instance of
      type OclInvalid. It conforms to all other types and any further computation with
        </textual><code class="po-atom e494 e494"><textual class="po-textual">invalid</textual></code><textual class="po-textual"> results in </textual><code class="po-atom e495 e495"><textual class="po-textual">invalid</textual></code><textual class="po-textual"> - except for operation
        </textual><code class="po-atom e496 e496"><textual class="po-textual">oclIsInvalid</textual></code><footnote class="po-popup e497 e497"><para class="po-block e498 e498"><textual class="po-textual">To be accurate, another operation - </textual><code class="po-atom e499 e499"><textual class="po-textual">oclIsUndefined</textual></code><textual class="po-textual"> - behaves equally to
            </textual><code class="po-atom e500 e500"><textual class="po-textual">oclIsInvalid</textual></code><textual class="po-textual"> when the argument is </textual><code class="po-atom e501 e501"><textual class="po-textual">invalid</textual></code><textual class="po-textual">, but it also returns
          true, when the result of the computation is </textual><code class="po-atom e502 e502"><textual class="po-textual">null</textual></code><textual class="po-textual">. </textual></para></footnote><textual class="po-textual">, which returns </textual><code class="po-atom e503 e503"><textual class="po-textual">true</textual></code><textual class="po-textual">, when the computations results in
        </textual><code class="po-atom e504 e504"><textual class="po-textual">invalid</textual></code><textual class="po-textual"> and </textual><code class="po-atom e505 e505"><textual class="po-textual">false</textual></code><textual class="po-textual"> otherwise. This operation thus provides the
      only, very coarse-grained error checking (there are no error codes or exception types)
      available in OCL. Unlike OCL computation, XPath/XSLT 2.0 processor halts when it encounters a
      dynamic error and there is no equivalent of </textual><code class="po-atom e506 e506"><textual class="po-textual">oclIsInvalid</textual></code><textual class="po-textual">. It is also not possible
      to instruct it to jump to the validation of the next IC when a validation of an IC fails. </textual></para><para class="po-block e507 e507"><textual class="po-textual">XSLT 3.0, however, introduces new instructions - </textual><code class="po-atom e508 e508"><textual class="po-textual">xsl:try</textual></code><textual class="po-textual"> and
        </textual><code class="po-atom e509 e509"><textual class="po-textual">xsl:catch</textual></code><textual class="po-textual"> - which provide means of recovery from dynamic errors. With these
      instructions, it is possible to implement oclIsInvalid as listed in </textual><xref class="po-milestone e510 e510" linkend="xslt-invalid"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. We, again, utilize higher-order functions capabilities - the
      expression is evaluated in a function call wrapped in try/catch. OCL expression
        </textual><code class="po-atom e511 e511"><textual class="po-textual">oclIsInvalid(1 / 0)</textual></code><textual class="po-textual"> can be translated to </textual><code class="po-atom e512 e512"><textual class="po-textual">oclX:oclIsInvalid(function() { 1
        / 0 })</textual></code><textual class="po-textual">. Optionally, our validation pipeline (fully introduced in </textual><xref class="po-milestone e513 e513" linkend="sec-implementation"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) allows to safe-guard the evaluation of each expression using
      try/catch, so that the validation of another constraint may continue if a runtime error occurs
      and it is not contained by </textual><code class="po-atom e514 e514"><textual class="po-textual">oclIsInvalid</textual></code><textual class="po-textual">. </textual></para><figure class="po-container e515 e515" xml:id="xslt-invalid"><title class="po-block e516 e516"><textual class="po-textual">Implementation of </textual><code class="po-atom e517 e517"><textual class="po-textual">oclIsInvalid</textual></code><textual class="po-textual"> using
          </textual><code class="po-atom e518 e518"><textual class="po-textual">xsl:try</textual></code><textual class="po-textual">/</textual><code class="po-atom e519 e519"><textual class="po-textual">xsl:catch</textual></code></title><programlisting class="po-block e520 e520" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="oclX:oclIsInvalid" as="xs:boolean"&gt;
  &lt;xsl:param name="func" as="function() as item()*" /&gt;
  
  &lt;!-- evaluate func and forget the result, return false --&gt; 
  &lt;xsl:try select="let $result := $func() return false()"&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:if test="$debug"&gt;
        &lt;xsl:message select="'Runtime error making the result ''invalid''. '"/&gt;
        &lt;xsl:message select="'  - code: ' || $err:code"/&gt;
        &lt;xsl:message select="'  - description: ' || $err:description"/&gt;
        &lt;xsl:message select="'  - value: ' || $err:value"/&gt;
      &lt;/xsl:if&gt;
      &lt;!-- if function call fails, return true --&gt;
      &lt;xsl:sequence select="true()" /&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;    
&lt;/xsl:function&gt;</textual></programlisting></figure></section><section class="po-hcontainer e521 e521" xml:id="sec-implementation"><title class="po-block e522 e522"><textual class="po-textual">Implementation</textual></title><para class="po-block e523 e523"><textual class="po-textual">We implemented the work presented in this paper into our XML schema modeling tool
        </textual><xref class="po-milestone e524 e524" linkend="exolutio"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the workflow is depicted in </textual><xref class="po-milestone e525 e525" linkend="fig-pipeline"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. The
      tool incorporates a UML and OCL editor for both PIM and PSM schemas and implements algorithm
      for suggesting/translation of relevant constraints from PIM to PSM (steps 1-3, not covered in
      this paper) and translation from OCL (4) to Schematron schemas. The user may choose between
      schema-aware and non-schema-aware (which add data conversion for extracting typed values from
      the XML document) schema and between implementation of iterator expressions using dynamic
      evaluation or higher-order functions. The generated schema can be then used to validate an XML
      document. XProc pipeline is then used to perform the validation. It first executes the
      transformation steps from standard Schematron pipeline (5.), adds includes for OclX library
      (6.) and then validates the document (7.) with the resulting XSLT. The pipeline expects the
      schema (5.) and validated document (8.) on its input ports and writes validation result - a
      SVRL document - to its output port (9). </textual></para><figure class="po-container e526 e526" xml:id="fig-pipeline"><title class="po-block e527 e527"><textual class="po-textual">Schematron and OclX pipeline</textual></title><mediaobject class="po-container e528 e528"><imageobject class="po-container e529 e529"><imagedata class="po-meta e530 e530" fileref="../../../vol8/graphics/Maly01/Maly01-005.png" format="png" width="600"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e531 e531"><textual class="po-textual">The tool itself (incl. examples), OclX library and the XProc pipeline are all available
      for free download on the tools website. Finally, </textual><xref class="po-milestone e532 e532" linkend="fig-schematron"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> depicts the
      translation of integrity constraints from the examples in </textual><xref class="po-milestone e533 e533" linkend="fig-psm-ocl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
      (schema-aware, iterators via higher-order functions). The error messages defined in OCL
      translated into schematron error messages and their subexpressions into </textual><code class="po-atom e534 e534"><textual class="po-textual">value-of</textual></code><textual class="po-textual">
      instructions (see translation of PSM1). </textual></para><figure class="po-container e535 e535" xml:id="fig-schematron"><title class="po-block e536 e536"><textual class="po-textual">Generated Schematron schemas</textual></title><programlisting class="po-block e537 e537" xml:space="preserve"><textual class="po-textual">&lt;!-- Match schedule schema --&gt;
&lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
 &lt;sch:pattern&gt;
  &lt;sch:rule context="/tournament"&gt;
    &lt;!-- PSM1 --&gt;   
   &lt;sch:assert test="start le end"&gt;
     Dates inconsistent, &lt;sch:value-of select="$self/start" /&gt; 
     is greater than &lt;sch:value-of select="$self/end" /&gt; 
     in &lt;sch:value-of select="$self/name" /&gt;
   &lt;/sch:assert&gt;
   &lt;!-- PSM2 --&gt;   
   &lt;sch:assert test="oclX:forAll(oclX:collect($self/matches/day, function($d) { $d/match }), 
     function($m) { $m/start ge $self/start and $m/end le $self/end })"&gt;
     All matches in a tournament occur within the tournament's time frame
   &lt;/sch:assert&gt; 
   &lt;!-- PSM4 --&gt;
   &lt;sch:assert test="oclX:exists(
     oclX:collect(matches/day, function($d) { $d/match }), 
     function($m) { oclDate:trunc($m/start) eq oclDate:trunc($self/start) })"&gt;
     Each tournament conducts at least one match on the first day of the tournament
   &lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
  &lt;!-- PSM3 --&gt;
  &lt;sch:rule context="/tournament/matches/day/match"&gt;
   &lt;sch:assert test="oclX:forAll($self/matchPlayers/player, 
     function($p) { oclX:exists($p/../../../../../participatingPlayers/player, 
       function($px) { $px/name eq $p/name }) })"&gt;
     A match can only involve players who are accepted in the tournament
   &lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
 &lt;/sch:pattern&gt;
&lt;/sch:schema&gt;

&lt;!-- Tournaments schedule schema --&gt;
&lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
 &lt;sch:pattern&gt;
  &lt;!-- PSM5: either open tournament or belongs to some league --&gt;
  &lt;sch:assert test="qualification/@open eq true() or exists(qualification/@leagueName)"&gt;
    Tournament must be either open tournament or belong to a league
  &lt;/sch:assert&gt;
 &lt;/sch:pattern&gt;
&lt;/sch:schema&gt;</textual></programlisting></figure></section><section class="po-hcontainer e538 e538" xml:id="sec-sugar"><title class="po-block e539 e539"><textual class="po-textual">Expression rewriting and syntactic sugar</textual></title><para class="po-block e540 e540"><textual class="po-textual">In many cases, iterator expressions and functions, can be expressed using a native XPath
      construct, e.g. </textual><code class="po-atom e541 e541"><textual class="po-textual">forAll</textual></code><textual class="po-textual"> can be expressed as </textual><code class="po-atom e542 e542"><textual class="po-textual">every/satisfies</textual></code><textual class="po-textual">, select
      by application of a filter etc. The current version of the algorithm does not provide any of
      such rewritings, but in the following work, we plan to examine the possibilities of such
      rewritings and offer them to the user, where applicable. </textual></para><para class="po-block e543 e543"><textual class="po-textual">OCL expressions have a useful property that they can be read from left to right thanks
      to the arrow notation </textual><code class="po-atom e544 e544"><textual class="po-textual">'-&gt;'</textual></code><textual class="po-textual"> for collections and dot
        </textual><code class="po-atom e545 e545"><textual class="po-textual">'.'</textual></code><textual class="po-textual"> for calling operations . When translated to XPath, the
      readability decreases (the object before the arrow/dot corresponds to the first parameter of
      the function. Also, the notation of higher-order functions in XPath is not so transparent. If
      desirable, it would be possible to preserve OCL notation even for Schematron schemas (and
      change it to usual XPath notation in another preprocessing step). </textual></para><para class="po-block e546 e546"><textual class="po-textual">A valued feature of Schematron is the possibility to specify human-friendly error messages
      for violated integrity constraints. However, OCL does not provide such functionality in the
      current version of the standard (2.3.1). Since custom error messages were strongly advocated
      (e.g. in </textual><xref class="po-milestone e547 e547" linkend="malaika09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), we extended recognized OCL grammar to allow
      specification of error messages. </textual></para></section><section class="po-hcontainer e548 e548" xml:id="sec-conclusion"><title class="po-block e549 e549"><textual class="po-textual">Conclusion</textual></title><para class="po-block e550 e550"><textual class="po-textual">In this paper, we inquired into the possibility of using OCL for modeling integrity
      constraints over XML data. We have discussed several ways of how non-trivial OCL expressions
      can be expressed using XPath with our proposed extension in a form of a XSLT function library
      OclX. The library itself contains a useful set of functions, which can be used on their own
      and provide a handy toolset with considerable expressive power. However, the main contribution
      is the possibility to check OCL integrity constraints in XML data. Our approach allows using
      the integrity constraints defined in the UML model also for XML, which supports consistency of
      the system as a whole (the constraints do not have to be rewritten by hand and managed
      manually after each change). It helps to bridge the gap between the platform-independent
      conceptual model and its applicability at runtime.</textual></para><para class="po-block e551 e551"><textual class="po-textual">Since translated OclX constraints are, in structure, very simlar to OCL constraints, they
      will be easy to comprehend even for a modeller less familiar with XML technologies. </textual></para><para class="po-block e552 e552"><textual class="po-textual">In the future, we want to thoroughly examine the possibilities of rewriting the
      expressions in order to use native XPath constructs to express iterator expressions where
      possible and allow the user to choose from several ways of expressing a certain constraint. As
      another part the future work, we plan to extend our approach for schema evolution and document
      adaptation (see </textual><xref class="po-milestone e553 e553" linkend="maly11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) by utilizing OCL integrity constraints. </textual></para></section><section class="po-hcontainer e554 e554"><title class="po-block e555 e555"><textual class="po-textual">Acknowledgement</textual></title><para class="po-block e556 e556"><textual class="po-textual">This work was supported by GAČR grant no. P202/10/0573.</textual></para></section><bibliography class="po-hcontainer e557 e557"><title class="po-block e558 e558"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e559 e559" xml:id="ocl" xreflabel="OCL specification"><textual class="po-textual">OCL Specification, version 2.3.1.
      Object Management Group (OMG). January 2012. </textual><link class="po-inline e560 e560" xlink:actuate="onRequest" xlink:href="http://www.omg.org/spec/OCL/2.3.1/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.omg.org/spec/OCL/2.3.1/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e561 e561" xml:id="dresden" xreflabel="Dresden OCL"><textual class="po-textual">Software Technology Group at Technische Universität Dresden. 
      Dresden OCL - OCL support for your modeling language 
      </textual><link class="po-inline e562 e562" xlink:actuate="onRequest" xlink:href="http://www.dresden-ocl.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.dresden-ocl.org/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e563 e563" xml:id="pagano09" xreflabel="Pagano 2009"><textual class="po-textual">Pagano, Dennis, and Anne
      Brüggemann-Klein. Engineering Document Applications — From UML Models to XML Schemas.
      In </textual><emphasis class="po-inline e564 e564" role="ital"><textual class="po-textual">Proceedings of Balisage: The Markup Conference 2009</textual></emphasis><textual class="po-textual">. Balisage Series on
      Markup Technologies, vol. 3 (2009).  
      </textual><link class="po-inline e565 e565" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol3/html/Bruggemann-Klein01/BalisageVol3-Bruggemann-Klein01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual"> http://www.balisage.net/Proceedings/vol3/html/Bruggemann-Klein01/BalisageVol3-Bruggemann-Klein01.html</textual></link><textual class="po-textual"> doi:</textual><biblioid class="po-atom e566 doi e566"><textual class="po-textual">10.4242/BalisageVol3.Bruggemann-Klein01</textual></biblioid><textual class="po-textual">.
    </textual></bibliomixed><bibliomixed class="po-block e567 e567" xml:id="bauman09" xreflabel="Bauman 2009"><textual class="po-textual">Bauman, Bruce Todd. “Prying Apart
      Semantics and Implementation: Generating XML Schemata directly from ontologically sound
      conceptual models.” 
      In </textual><emphasis class="po-inline e568 e568" role="ital"><textual class="po-textual">In Proceedings of Balisage: The Markup Conference
        2009</textual></emphasis><textual class="po-textual">. Balisage Series on Markup Technologies, vol. 3 (2009).
      </textual><link class="po-inline e569 e569" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol3/html/Bauman01/BalisageVol3-Bauman01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol3/html/Bauman01/BalisageVol3-Bauman01.html</textual></link><textual class="po-textual">. doi:</textual><biblioid class="po-atom e570 doi e570"><textual class="po-textual">10.4242/BalisageVol3.Bauman01</textual></biblioid><textual class="po-textual">. 
    </textual></bibliomixed><bibliomixed class="po-block e571 e571" xml:id="necasky12a" xreflabel="Nečaský 2012A"><textual class="po-textual">Martin Nečaský, Jakub Klímek, Jakub
      Malý, Irena Mlýnková, Evolution and change management of XML-based systems, </textual><emphasis class="po-inline e572 e572" role="ital"><textual class="po-textual">Journal
        of Systems and Software</textual></emphasis><textual class="po-textual">, vol 85. 2012, ISSN 0164-1212,
      doi:</textual><biblioid class="po-atom e573 doi e573"><textual class="po-textual">10.1016/j.jss.2011.09.038</textual></biblioid><textual class="po-textual">. 
      </textual><link class="po-inline e574 e574" xlink:actuate="onRequest" xlink:href="http://www.sciencedirect.com/science/article/pii/S0164121211002524" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.sciencedirect.com/science/article/pii/S0164121211002524</textual></link><textual class="po-textual">      
    </textual></bibliomixed><bibliomixed class="po-block e575 e575" xml:id="necasky12b" xreflabel="Nečaský 2012B"><textual class="po-textual">Martin Nečaský, Irena Mlýnková, Jakub Klímek, Jakub
      Malý, When conceptual model meets grammar: A dual approach to XML data modeling, </textual><emphasis class="po-inline e576 e576" role="ital"><textual class="po-textual">Data 
        &amp; Knowledge Engineering</textual></emphasis><textual class="po-textual">, vol 72. 2012, ISSN 0169-023X,
      doi:</textual><biblioid class="po-atom e577 doi e577"><textual class="po-textual">10.1016/j.datak.2011.09.002</textual></biblioid><textual class="po-textual">. 
      </textual><link class="po-inline e578 e578" xlink:actuate="onRequest" xlink:href="http://www.sciencedirect.com/science/article/pii/S0169023X1100125X" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.sciencedirect.com/science/article/pii/S0169023X1100125X</textual></link><textual class="po-textual">      
    </textual></bibliomixed><bibliomixed class="po-block e579 e579" xml:id="Mandel99" xreflabel="Mandel 1999"><textual class="po-textual">L. Mandel, M. Cengarle. On the
      Expressive Power of OCL. In </textual><emphasis class="po-inline e580 e580" role="ital"><textual class="po-textual">FM'99 Formal Methods</textual></emphasis><textual class="po-textual">, volume 1708 of LNCS.
      Springer Berlin / Heidelberg, 1999.
      </textual><link class="po-inline e581 e581" xlink:actuate="onRequest" xlink:href="http://dl.acm.org/citation.cfm?id=730476" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dl.acm.org/citation.cfm?id=730476</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e582 e582" xml:id="saxon" xreflabel="Saxon"><textual class="po-textual">Saxonica. Saxon - the XSLT processor. 
      </textual><link class="po-inline e583 e583" xlink:actuate="onRequest" xlink:href="http://saxonica.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://saxonica.com/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e584 e584" xml:id="exslt" xreflabel="EXSLT"><textual class="po-textual">C. Stewart, C. Bayes, J. Fuller, U. Ogbuji, D. Pawson, J. Tennison.
      EXSLT - community initiative to provide extensions to XSLT.
      </textual><link class="po-inline e585 e585" xlink:actuate="onRequest" xlink:href="http://www.exslt.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.exslt.org/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e586 e586" xml:id="novatchev06" xreflabel="Novatchev 2006"><textual class="po-textual">Dimitre Novatchev. Higher-Order Functional Programming with XSLT 2.0 and FXSL. In 
      </textual><emphasis class="po-inline e587 e587" role="ital"><textual class="po-textual">Extreme Markup Languages 2006</textual></emphasis><textual class="po-textual">, Montréal, Québeck. 
      </textual><link class="po-inline e588 e588" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2006/Novatchev01/EML2006Novatchev01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">
        http://conferences.idealliance.org/extreme/html/2006/Novatchev01/EML2006Novatchev01.html
      </textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e589 e589" xml:id="snelson11" xreflabel="Snelson 2011"><textual class="po-textual">J. Snelson. An implementation of a red/black tree built using XQuery 3.0 
      higher order functions, and an associative map library built on top of it. 
      </textual><link class="po-inline e590 e590" xlink:actuate="onRequest" xlink:href="https://github.com/jpcs/rbtree.xq" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://github.com/jpcs/rbtree.xq</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e591 e591" xml:id="maly11" xreflabel="Maly 2011"><textual class="po-textual">J. Malý, I. Mlýnková, M. Nečaský. XML Data Transformations as Schema Evolves. 
      </textual><emphasis class="po-inline e592 e592" role="ital"><textual class="po-textual">Proceedings of ADBIS 2011: Advances in databases and infromation systems</textual></emphasis><textual class="po-textual">.
      September 2011. Lecture Notes in Computer Science. Springer. 
      </textual><link class="po-inline e593 e593" xlink:actuate="onRequest" xlink:href="http://dl.acm.org/citation.cfm?id=2041783" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dl.acm.org/citation.cfm?id=2041783</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e594 e594" xml:id="exolutio" xreflabel="eXolutio"><textual class="po-textual">eXolutio - a Tool for Conceptual Modeling of XML.
      </textual><link class="po-inline e595 e595" xlink:actuate="onRequest" xlink:href="http://exolutio.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://eXolutio.com</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e596 e596" xml:id="malaika09" xreflabel="Malaika 2009"><textual class="po-textual">S. Malaika, Ch. Pichler. Enforce basic document structure with XML
      constraint checking. IBM. 
      </textual><link class="po-inline e597 e597" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/library/x-consthealth/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ibm.com/developerworks/library/x-consthealth/index.html</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e598 e598" xml:id="Codd72" xreflabel="Codd 1972"><textual class="po-textual">E. F. Codd. Relational Completeness of Data Base Sublanguages. In: </textual><emphasis class="po-inline e599 e599" role="ital"><textual class="po-textual">Database Systems</textual></emphasis><textual class="po-textual">, Prentice Hall and IBM Research Report RJ 987, San
      Jose, California, 1972. </textual></bibliomixed></bibliography></article></classedDocument>