<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Transforming schemas</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Architectural Forms for the 21st Century</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">The traditional approach to transforming XML documents is a three-step pipeline: validate, transform, validate.  The SGML feature called architectural forms combined enhancements to DTDs with annotations in source documents to allow a valid SGML document to be automatically transformed into another SGML document valid against a different DTD.  This permitted document creators to conform to a general document architecture without having to constrain their own documents to every detail of a specific schema.  In the XML world, however, the emphasis has been on the creation of comprehensive schemas rather than easy transformation, and the ideas behind architectural forms have mostly been lost.  This paper attempts to explain how to restore those ideas to XML practice.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">John</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Cowan</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">John Cowan works for LexisNexis, which he likes to call "$EMPLOYER". On his 2011 tax returns, he listed his occupation as "ontologist" . He pushed both XML 1.1 and XML 1.0 Fifth Edition through the W3C XML Core Working Group, of which he somehow remains a member. He also hangs out on numerous mailing lists and blogs, masquerading on the A forum as the expert on B and and on the B forum as the expert on A. His friends say that he knows at least something about almost everything; his enemies, that he knows far too much about far too much.</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Senior Content Architect</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">LexisNexis</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">cowan@ccil.org</textual></email></author><legalnotice class="po-container e19 e19"><para class="po-block e20 e20"><textual class="po-textual">Copyright © 2013 by John Cowan</textual></para></legalnotice><keywordset class="po-table e21 e21" role="author"><keyword class="po-field e22 e22"><textual class="po-textual">Architectural forms</textual></keyword><keyword class="po-field e23 e23"><textual class="po-textual">Examplotron</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">Schema-driven transformation</textual></keyword></keywordset></info><section class="po-hcontainer e25 e25"><title class="po-block e26 e26"><textual class="po-textual">1. Introduction</textual></title><para class="po-block e27 e27"><textual class="po-textual">The traditional approach to transforming XML documents is a three-step pipeline: validate, transform, validate.  (Sometimes, of course, one or both of the validation steps is omitted.)  </textual><emphasis class="po-inline e28 e28" role="ital"><textual class="po-textual">Architectural forms</textual></emphasis><textual class="po-textual">, a feature first of the SGML-based hypermedia standard HyTime and then of SGML itself, made use of a combination of enhancements to DTDs and annotations in source documents to allow a two-step pipeline for certain simple transformations.  In this pipeline, a valid SGML document could be automatically transformed using a specialized SGML parser, called an </textual><emphasis class="po-inline e29 e29" role="ital"><textual class="po-textual">architectural engine</textual></emphasis><textual class="po-textual"> (AE), into another SGML document valid against a more general DTD known as the meta-DTD.  This permitted document creators to conform to a general document architecture without having to constrain their own documents to every detail of a specific schema.</textual></para><para class="po-block e30 e30"><textual class="po-textual">However, DTDs have not seen wide uptake in the XML world, and the few XML architectural engines that have been built have conformed more to the letter than to the spirit of architectural forms.  The emphasis has been on the creation of comprehensive and complex schemas which attempt simultaneously to serve local needs and the needs of interchange.  Such schemas are usually arrived at by difficult, lengthy, and highly political negotiations between interested parties, with victory often going to the participants with the greatest weight of </textual><emphasis class="po-inline e31 e31" role="ital"><textual class="po-textual">Sitzfleisch</textual></emphasis><textual class="po-textual"> rather than the best ideas.</textual></para><para class="po-block e32 e32"><textual class="po-textual">This paper describes an attempt to return to those thrilling days of yesteryear by providing a modern equivalent of SGML architectural engines. In principle any grammar-based schema language such as XML Schema or RELAX NG would be suitable for the methods outlined here.  However, the software development (still very much a work in progress as of this writing) is using the much simpler Examplotron schema language.  Examplotron is not well-known or much used in the XML environment, but I believe it to be extremely suitable to the stripped-down MicroXML environment in which I am now primarily interested.  Since most people don't know Examplotron, I have written the paper to be accessible to anyone who can read simple DTD declarations.</textual></para><para class="po-block e33 e33"><textual class="po-textual">In this paper, I will speak of the </textual><emphasis class="po-inline e34 e34" role="ital"><textual class="po-textual">source document</textual></emphasis><textual class="po-textual">, which is the input to a schema-based </textual><emphasis class="po-inline e35 e35" role="ital"><textual class="po-textual">transformation engine</textual></emphasis><textual class="po-textual"> (TE), and of the </textual><emphasis class="po-inline e36 e36" role="ital"><textual class="po-textual">target document</textual></emphasis><textual class="po-textual">, which is a TE's output.  Additional inputs are the </textual><emphasis class="po-inline e37 e37" role="ital"><textual class="po-textual">source schema</textual></emphasis><textual class="po-textual"> and the </textual><emphasis class="po-inline e38 e38" role="ital"><textual class="po-textual">target schema</textual></emphasis><textual class="po-textual">.  In this paper the schemas are expressed as DTD fragments, but in actual use they will be Examplotron 0.8 schemas.  In addition, we may supply the TE with the </textual><emphasis class="po-inline e39 e39" role="ital"><textual class="po-textual">transformation name</textual></emphasis><textual class="po-textual"> of the particular transformation to be performed on the source, possibly one of many such transformations.  For clarity's sake, I will speak as if the various transformations are made one by one, but except for attribute defaulting they are all made simultaneously.  For example, if all elements named </textual><code class="po-atom e40 e40"><textual class="po-textual">foo</textual></code><textual class="po-textual"> are to be renamed </textual><code class="po-atom e41 e41"><textual class="po-textual">bar</textual></code><textual class="po-textual">, and all elements named </textual><code class="po-atom e42 e42"><textual class="po-textual">bar</textual></code><textual class="po-textual"> are to be renamed </textual><code class="po-atom e43 e43"><textual class="po-textual">baz</textual></code><textual class="po-textual">, that does </textual><emphasis class="po-inline e44 e44" role="ital"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> mean that both </textual><code class="po-atom e45 e45"><textual class="po-textual">foo</textual></code><textual class="po-textual"> and </textual><code class="po-atom e46 e46"><textual class="po-textual">bar</textual></code><textual class="po-textual"> elements wind up being named </textual><code class="po-atom e47 e47"><textual class="po-textual">baz</textual></code><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e48 e48"><title class="po-block e49 e49"><textual class="po-textual">2. Element Renaming and the Renaming Attribute</textual></title><para class="po-block e50 e50"><textual class="po-textual">The first and simplest kind of transformation to be performed is </textual><emphasis class="po-inline e51 e51" role="ital"><textual class="po-textual">element renaming</textual></emphasis><textual class="po-textual">.  A TE does this by looking at each element of the source document for an attribute whose name is the same as the transformation name supplied to the TE.  This attribute is called the </textual><emphasis class="po-inline e52 e52" role="ital"><textual class="po-textual">renaming attribute</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e53 e53"><textual class="po-textual">For example, suppose we have the following source document:
    </textual><programlisting class="po-block e54 e54" xml:space="preserve"><textual class="po-textual">
      &lt;limerick&gt;
        &lt;title&gt;Relativity&lt;/title&gt;
        &lt;a&gt;There was a young lady named Bright&lt;/a&gt;
        &lt;a&gt;Who could travel much faster than light.&lt;/a&gt;
        &lt;b&gt;She set out one day&lt;/b&gt;
        &lt;b&gt;In a relative way&lt;/b&gt;
        &lt;a&gt;And returned the previous night.&lt;/a&gt;
      &lt;/limerick&gt;
    </textual></programlisting><textual class="po-textual">
    If we wish to transform it from its limerick-specific schema to a more general stanza schema, we might add a renaming attribute named </textual><code class="po-atom e55 e55"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> to every element, like this:
    </textual><programlisting class="po-block e56 e56" xml:space="preserve"><textual class="po-textual">
      &lt;limerick stanza="stanza"&gt;
        &lt;title stanza="title"&gt;Relativity&lt;/title&gt;
        &lt;a stanza="line"&gt;There was a young lady named Bright&lt;/a&gt;
        &lt;a stanza="line"&gt;Who could travel much faster than light.&lt;/a&gt;
        &lt;b stanza="line"&gt;She set out one day&lt;/b&gt;
        &lt;b stanza="line"&gt;In a relative way&lt;/b&gt;
        &lt;a stanza="line"&gt;And returned the previous night.&lt;/a&gt;
      &lt;/limerick&gt;
    </textual></programlisting><textual class="po-textual">
    Running a TE on the above document, specifying </textual><code class="po-atom e57 e57"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> as the transformation name, would produce the following target document:
    </textual><programlisting class="po-block e58 e58" xml:space="preserve"><textual class="po-textual">
      &lt;stanza&gt;
        &lt;title&gt;Relativity&lt;/title&gt;
        &lt;line&gt;There was a young lady named Bright&lt;/line&gt;
        &lt;line&gt;Who could travel much faster than light.&lt;/line&gt;
        &lt;line&gt;She set out one day&lt;/line&gt;
        &lt;line&gt;In a relative way&lt;/line&gt;
        &lt;line&gt;And returned the previous night.&lt;/line&gt;
      &lt;/stanza&gt;
    </textual></programlisting><textual class="po-textual">
    Note that all occurrences of the renaming attribute have been removed from the target document.
    </textual></para><para class="po-block e59 e59"><textual class="po-textual">What happens if an element doesn't have a renaming attribute?  The answer is that the element is dropped in its entirety.  For example, suppose we did not have a </textual><code class="po-atom e60 e60"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> attribute on the source document's </textual><code class="po-atom e61 e61"><textual class="po-textual">title</textual></code><textual class="po-textual"> element. In that case, the target document would contain only a </textual><code class="po-atom e62 e62"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> element with five </textual><code class="po-atom e63 e63"><textual class="po-textual">line</textual></code><textual class="po-textual"> child elements.</textual></para><para class="po-block e64 e64"><textual class="po-textual">If you don't provide a TE with a transformation name, there is no renaming attribute, and rather than dropping all the elements, none of them are renamed. However, the target document may still differ from the source document in other ways.</textual></para><note class="po-container e65 e65"><para class="po-block e66 e66"><textual class="po-textual">The concept of renaming attributes comes from AEs; however, AEs do not require the name of the renaming attribute to be the same as the transformation name, and have different and more flexible rules about processing elements without renaming attributes.</textual></para></note></section><section class="po-hcontainer e67 e67"><title class="po-block e68 e68"><textual class="po-textual">3. Attribute Defaulting</textual></title><para class="po-block e69 e69"><textual class="po-textual">This business of adding renaming attributes directly to the source document is irritating, and may be impossible if we aren't able to change the source document.  Instead, we can take advantage of </textual><emphasis class="po-inline e70 e70" role="ital"><textual class="po-textual">attribute defaulting</textual></emphasis><textual class="po-textual"> by specifying a source schema.  Consider the following DTD fragment: 
    </textual><programlisting class="po-block e71 e71" xml:space="preserve"><textual class="po-textual">
      &lt;!ATTLIST limerick stanza "stanza"&gt;
      &lt;!ATTLIST title stanza "title"&gt;
      &lt;!ATTLIST a stanza "line"&gt;
      &lt;!ATTLIST b stanza "line"&gt;
    </textual></programlisting><textual class="po-textual">
    This says that in the </textual><code class="po-atom e72 e72"><textual class="po-textual">limerick</textual></code><textual class="po-textual"> element, if no </textual><code class="po-atom e73 e73"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> attribute is supplied, its value is assumed to be </textual><code class="po-atom e74 e74"><textual class="po-textual">stanza</textual></code><textual class="po-textual">.  Likewise, for the </textual><code class="po-atom e75 e75"><textual class="po-textual">title</textual></code><textual class="po-textual"> element, the default value of the </textual><code class="po-atom e76 e76"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> attribute is </textual><code class="po-atom e77 e77"><textual class="po-textual">title</textual></code><textual class="po-textual">, and for the </textual><code class="po-atom e78 e78"><textual class="po-textual">a</textual></code><textual class="po-textual"> and </textual><code class="po-atom e79 e79"><textual class="po-textual">b</textual></code><textual class="po-textual"> elements, it is </textual><code class="po-atom e80 e80"><textual class="po-textual">line</textual></code><textual class="po-textual">.  Now we no longer have to alter our original limerick document when we want to transform it.  If we specify the transformation name as </textual><code class="po-atom e81 e81"><textual class="po-textual">stanza</textual></code><textual class="po-textual">, we will get the same target document that we saw in the previous section.</textual></para><para class="po-block e82 e82"><textual class="po-textual">What is more, we can provide more than one renaming attribute in the same source schema.  Suppose we add the following declarations to the above source schema:
    </textual><programlisting class="po-block e83 e83" xml:space="preserve"><textual class="po-textual">
      &lt;!ATTLIST limerick estrofa "estrofa"&gt;
      &lt;!ATTLIST title estrofa "título"
      &lt;!ATTLIST a estrofa "línea"&gt;
      &lt;!ATTLIST b estrofa "línea"&gt;
    </textual></programlisting><textual class="po-textual">
    If we specify the transformation name as </textual><code class="po-atom e84 e84"><textual class="po-textual">estrofa</textual></code><textual class="po-textual"> rather than </textual><code class="po-atom e85 e85"><textual class="po-textual">stanza</textual></code><textual class="po-textual">, we will generate a target document whose element names are in Spanish rather than English.  However, the TE cannot automatically remove the defaulted </textual><code class="po-atom e86 e86"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> attribute when doing an </textual><code class="po-atom e87 e87"><textual class="po-textual">estrofa</textual></code><textual class="po-textual"> transformation, nor vice versa, because it does not know which attributes might be used as renaming attributes in a different transformation run. In order to suppress them, we must provide the TE with a list of renaming attributes that are </textual><emphasis class="po-inline e88 e88" role="ital"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> being used for the current transformation, so that they can be suppressed from the target document.  In the rest of this paper we will assume that this list has been provided.</textual></para><para class="po-block e89 e89"><textual class="po-textual">Attribute defaulting is not restricted to renaming attributes. If any attribute is given a default value by the source schema but does not appear in the source document, it will be created, and by default will appear in the target document.  Attribute defaulting is done in advance of all other transformations; a default attribute may have its name or value changed by a later transformation.</textual></para><note class="po-container e90 e90"><para class="po-block e91 e91"><textual class="po-textual">Attribute defaulting is inherent to DTD processing.  The version of Examplotron used by TEs, Examplotron 0.8, allows the specification of default values for attributes, and in fact for elements too.</textual></para></note></section><section class="po-hcontainer e92 e92"><title class="po-block e93 e93"><textual class="po-textual">4. Element Reordering</textual></title><para class="po-block e94 e94"><textual class="po-textual">So far, we haven't had to deal with child elements appearing in a different order in the source and target documents.  However, this can often happen when the source document is data-oriented rather than content-oriented.  In order to know how to reorder child elements, we must provide the TE with  a target schema.  Here's a simple target schema specifying a document containing people's names:
    </textual><programlisting class="po-block e95 e95" xml:space="preserve"><textual class="po-textual">
      &lt;!ELEMENT people (person*)&gt;
      &lt;!ELEMENT person (last, first)&gt;
    </textual></programlisting><textual class="po-textual">
    In this schema, we see that a </textual><code class="po-atom e96 e96"><textual class="po-textual">people</textual></code><textual class="po-textual"> element contains zero or more </textual><code class="po-atom e97 e97"><textual class="po-textual">person</textual></code><textual class="po-textual"> elements and nothing else, and that each </textual><code class="po-atom e98 e98"><textual class="po-textual">person</textual></code><textual class="po-textual"> element contains </textual><code class="po-atom e99 e99"><textual class="po-textual">last</textual></code><textual class="po-textual"> and </textual><code class="po-atom e100 e100"><textual class="po-textual">first</textual></code><textual class="po-textual"> elements in that order. </textual></para><para class="po-block e101 e101"><textual class="po-textual">Now here's a source document:
    </textual><programlisting class="po-block e102 e102" xml:space="preserve"><textual class="po-textual">
      &lt;people&gt;
        &lt;person&gt;
          &lt;first&gt;John&lt;/first&gt;
          &lt;last&gt;Cowan&lt;/last&gt;
        &lt;/person&gt;
       &lt;person&gt;
          &lt;first&gt;Dorian&lt;/first&gt;
          &lt;last&gt;Cowan&lt;/last&gt;
       &lt;/person&gt;
      &lt;/people&gt;
    </textual></programlisting><textual class="po-textual">
    Suppose we pass this source document and the target schema to a TE without specifying a transformation name.  In that case, there is no renaming attribute, and so no element renaming is done.  However, since the order of child elements for the </textual><code class="po-atom e103 e103"><textual class="po-textual">person</textual></code><textual class="po-textual"> element in the source document is not valid according to the target schema, they will be reordered so as to be valid in the target document, producing this:
    </textual><programlisting class="po-block e104 e104" xml:space="preserve"><textual class="po-textual">
      &lt;people&gt;
        &lt;person&gt;
          &lt;last&gt;Cowan&lt;/last&gt;
          &lt;first&gt;John&lt;/first&gt;
        &lt;/person&gt;
       &lt;person&gt;
          &lt;last&gt;Cowan&lt;/last&gt;
          &lt;first&gt;Dorian&lt;/first&gt;
       &lt;/person&gt;
      &lt;/people&gt;
    </textual></programlisting><textual class="po-textual">
    </textual></para><note class="po-container e105 e105"><para class="po-block e106 e106"><textual class="po-textual">AEs do not perform element reordering.</textual></para></note></section><section class="po-hcontainer e107 e107"><title class="po-block e108 e108"><textual class="po-textual">5. Occurrences</textual></title><para class="po-block e109 e109"><textual class="po-textual">Both source and target schemas can specify how many occurrences a child
element can have within its parent element.  In DTDs, we can repeat the element name to specify a fixed number of occurrences, as in this source schema for our limerick document:
  </textual><programlisting class="po-block e110 e110" xml:space="preserve"><textual class="po-textual">
    &lt;!ELEMENT limerick (title, a, a, b, b, a)&gt;
    &lt;!ATTLIST limerick index "poem"&gt;
    &lt;!ATTLIST a index "firstline"&gt;
  </textual></programlisting></para><para class="po-block e111 e111"><textual class="po-textual">Now suppose we run a TE, passing it the transformation name </textual><code class="po-atom e112 e112"><textual class="po-textual">index</textual></code><textual class="po-textual">, our original limerick document, the above source schema, and the following target schema:
  </textual><programlisting class="po-block e113 e113" xml:space="preserve"><textual class="po-textual">
    &lt;!ELEMENT poem (firstline)&gt;
  </textual></programlisting><textual class="po-textual">
  The renaming attribute </textual><code class="po-atom e114 e114"><textual class="po-textual">index</textual></code><textual class="po-textual"> will rename the </textual><code class="po-atom e115 e115"><textual class="po-textual">limerick</textual></code><textual class="po-textual"> element to </textual><code class="po-atom e116 e116"><textual class="po-textual">poem</textual></code><textual class="po-textual"> and the three </textual><code class="po-atom e117 e117"><textual class="po-textual">a</textual></code><textual class="po-textual"> elements to </textual><code class="po-atom e118 e118"><textual class="po-textual">firstline</textual></code><textual class="po-textual">, dropping the </textual><code class="po-atom e119 e119"><textual class="po-textual">title</textual></code><textual class="po-textual"> and </textual><code class="po-atom e120 e120"><textual class="po-textual">b</textual></code><textual class="po-textual"> elements altogether.  But since the target schema permits only a single </textual><code class="po-atom e121 e121"><textual class="po-textual">firstline</textual></code><textual class="po-textual"> element in each </textual><code class="po-atom e122 e122"><textual class="po-textual">poem</textual></code><textual class="po-textual"> element, the second and third </textual><code class="po-atom e123 e123"><textual class="po-textual">firstline</textual></code><textual class="po-textual"> elements will also be dropped, producing the following target document:
  </textual><programlisting class="po-block e124 e124" xml:space="preserve"><textual class="po-textual">
    &lt;poem&gt;
      &lt;firstline&gt;There was a young lady named Bright&lt;/firstline&gt;
    &lt;/poem&gt;
  </textual></programlisting><textual class="po-textual"> This is suitable for inclusion in an index of first lines.
</textual></para><para class="po-block e125 e125"><textual class="po-textual"> On the other hand, if the target schema requires more occurrences
of an element than the source schema provides, sufficient elements are
created following the mapped elements. For an example of that process, consider this source document with explicit renaming attributes:
  </textual><programlisting class="po-block e126 e126" xml:space="preserve"><textual class="po-textual">
    &lt;couplet limerick="limerick"&gt;
      &lt;line limerick="a"&gt;Go and tell the Spartans, passerby,&lt;/line&gt;
      &lt;line limerick="b"&gt;That here, obedient to their laws, we lie.&lt;/line&gt;
    &lt;/couplet&gt;
  </textual></programlisting><textual class="po-textual">
    What happens if we transform this into a limerick using the limerick schema as the target schema?  (There is nothing inherent in a schema that says whether it is a source or a target, only in how it is provided to a TE.)  Limericks have to have a title and five lines, but we have only two lines here, one mapped (for some unknown reason) to an </textual><code class="po-atom e127 e127"><textual class="po-textual">a</textual></code><textual class="po-textual"> element and one to a </textual><code class="po-atom e128 e128"><textual class="po-textual">b</textual></code><textual class="po-textual"> element.  Consequently, we get this target document:
    </textual><programlisting class="po-block e129 e129" xml:space="preserve"><textual class="po-textual">
      &lt;limerick&gt;
        &lt;title/&gt;
        &lt;a&gt;Go and tell the Spartans, passerby,&lt;/a&gt;
        &lt;a/&gt;
        &lt;b&gt;That here, obedient to their laws, we lie.&lt;/b&gt;
        &lt;b/&gt;
        &lt;a/&gt;
      &lt;/limerick&gt;
  </textual></programlisting><textual class="po-textual">Not very useful or pretty, perhaps, but certainly valid.</textual></para><para class="po-block e130 e130"><textual class="po-textual">In this paper, newly created elements are shown as empty.  However, if the Examplotron schema provides a default value for them, it will be used.</textual></para><para class="po-block e131 e131"><textual class="po-textual">When specifying the content model of an element in a source or target schema, we can follow the name of a child element with </textual><code class="po-atom e132 e132"><textual class="po-textual">*</textual></code><textual class="po-textual"> to mean "zero or more occurrences", as shown in the declaration of the </textual><code class="po-atom e133 e133"><textual class="po-textual">people</textual></code><textual class="po-textual"> element.  In the same way, </textual><code class="po-atom e134 e134"><textual class="po-textual">?</textual></code><textual class="po-textual"> means "zero or one occurrences" and </textual><code class="po-atom e135 e135"><textual class="po-textual">+</textual></code><textual class="po-textual"> means "one or more occurrences".  All these indicators are respected by a TE.  So if two </textual><code class="po-atom e136 e136"><textual class="po-textual">foo</textual></code><textual class="po-textual"> child elements appear in the source document, but the target schema specifies </textual><code class="po-atom e137 e137"><textual class="po-textual">foo?</textual></code><textual class="po-textual">, then the second one will be dropped.  A TE cannot construct transformations based on more complex content models like </textual><code class="po-atom e138 e138"><textual class="po-textual">((a,b)+)</textual></code><textual class="po-textual">, in which the occurrence indicator follows a sequence of child element names, except as noted under the discussion of mixed content.</textual></para><para class="po-block e139 e139"><textual class="po-textual">However, technically ambiguous content models like </textual><code class="po-atom e140 e140"><textual class="po-textual">(line, line?, line?)</textual></code><textual class="po-textual">, meaning from one to three </textual><code class="po-atom e141 e141"><textual class="po-textual">line</textual></code><textual class="po-textual"> elements, which are illegal in DTDs, are supported in Examplotron schemas as well as by a TE.</textual></para><note class="po-container e142 e142"><para class="po-block e143 e143"><textual class="po-textual">AEs neither drop unwanted elements nor create new ones, but report validation errors instead.</textual></para></note></section><section class="po-hcontainer e144 e144"><title class="po-block e145 e145"><textual class="po-textual">6. Character Content</textual></title><para class="po-block e146 e146"><textual class="po-textual">So far, the source and target schemas we have seen have been incomplete, because not all the elements used in the documents have been mentioned in the schemas.  In particular, declarations for the elements whose only permitted content is characters, such as </textual><code class="po-atom e147 e147"><textual class="po-textual">a</textual></code><textual class="po-textual">, </textual><code class="po-atom e148 e148"><textual class="po-textual">firstline</textual></code><textual class="po-textual">, and </textual><code class="po-atom e149 e149"><textual class="po-textual">title</textual></code><textual class="po-textual"> have been left out.  Here's a complete version of the limerick source schema with all three renaming attributes provided:
    </textual><programlisting class="po-block e150 e150" xml:space="preserve"><textual class="po-textual">
      &lt;!ELEMENT limerick (title, a, a, b, b, a)&gt;
      &lt;!ATTLIST limerick stanza "stanza"&gt;
      &lt;!ATTLIST limerick estrofa "estrofa"&gt;
      &lt;!ATTLIST limerick index "poem"&gt;
      &lt;!ELEMENT title #PCDATA&gt;
      &lt;!ATTLIST title stanza "title"&gt;
      &lt;!ATTLIST title estrofa "título"
      &lt;!ELEMENT a #PCDATA&gt;
      &lt;!ATTLIST a stanza "line"&gt;
      &lt;!ATTLIST a estrofa "línea"&gt;
      &lt;!ATTLIST a index "firstline"&gt;
      &lt;!ELEMENT b #PCDATA&gt;
      &lt;!ATTLIST b stanza "line"&gt;
      &lt;!ATTLIST b estrofa "línea"&gt;
    </textual></programlisting><textual class="po-textual">
    And here is an erroneous target schema for stanza documents:
    </textual><programlisting class="po-block e151 e151" xml:space="preserve"><textual class="po-textual">
      &lt;!ELEMENT stanza (title, line*)&gt;
      &lt;!ELEMENT title #PCDATA&gt;
      &lt;!ELEMENT line EMPTY&gt;
    </textual></programlisting></para><para class="po-block e152 e152"><textual class="po-textual">Let's see what happens if we do a </textual><code class="po-atom e153 e153"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> transformation using that target schema.  We get this target document:
    </textual><programlisting class="po-block e154 e154" xml:space="preserve"><textual class="po-textual">
      &lt;stanza&gt;
        &lt;title&gt;Relativity&lt;/title&gt;
        &lt;line/&gt;
        &lt;line/&gt;
        &lt;line/&gt;
        &lt;line/&gt;
        &lt;line/&gt;
      &lt;/stanza&gt;
    </textual></programlisting><textual class="po-textual">
    Because the target schema specified the </textual><code class="po-atom e155 e155"><textual class="po-textual">line</textual></code><textual class="po-textual"> element as empty (no child elements or character content), the TE threw away the character content.  Again, probably not very useful, but again certainly valid.</textual></para><para class="po-block e156 e156"><textual class="po-textual">Reordering and occurrence control are really two aspects of the same thing, and they can both happen to the same children of an element at the same time.  Here is a not-very-realistic example.  Given the source document
  </textual><programlisting class="po-block e157 e157" xml:space="preserve"><textual class="po-textual">
    &lt;root&gt;
      &lt;a id="a1"/&gt;
      &lt;b id="b1"/&gt;
      &lt;a id="a2"/&gt;
      &lt;b id="b2"/&gt;
      &lt;a id="a3"/&gt;
    &lt;/root&gt;
  </textual></programlisting><textual class="po-textual">
  and the target schema
  </textual><programlisting class="po-block e158 e158" xml:space="preserve"><textual class="po-textual">
    &lt;!ELEMENT root (a, a, b, b, b&gt;)&gt;
  </textual></programlisting><textual class="po-textual">
  the target document will be
  </textual><programlisting class="po-block e159 e159" xml:space="preserve"><textual class="po-textual">
    &lt;root&gt;
      &lt;a id="a1"/&gt;
      &lt;a id="a2"/&gt;
      &lt;b id="b1"/&gt;
      &lt;b id="b2"/&gt;
      &lt;b/&gt;
    &lt;/root&gt;
  </textual></programlisting><textual class="po-textual">
  That is, the </textual><code class="po-atom e160 e160"><textual class="po-textual">a</textual></code><textual class="po-textual"> elements have been reordered before the </textual><code class="po-atom e161 e161"><textual class="po-textual">b</textual></code><textual class="po-textual"> elements, the third </textual><code class="po-atom e162 e162"><textual class="po-textual">a</textual></code><textual class="po-textual"> element has been dropped as unwanted, and a third </textual><code class="po-atom e163 e163"><textual class="po-textual">b</textual></code><textual class="po-textual"> element has been created.</textual></para><note class="po-container e164 e164"><para class="po-block e165 e165"><textual class="po-textual">AEs allow greater control of what happens to character content when an element containing it is dropped from the target document: it may be discarded or included as part of the parent element.  TEs always discard it unless the parent element's content model is specified as mixed content.</textual></para></note></section><section class="po-hcontainer e166 e166"><title class="po-block e167 e167"><textual class="po-textual">7. Mixed Content</textual></title><para class="po-block e168 e168"><textual class="po-textual">An element has mixed content when its content includes both child elements and characters.  Consider this limerick:
    </textual><programlisting class="po-block e169 e169" xml:space="preserve"><textual class="po-textual">
      &lt;limerick&gt;
        &lt;title&gt;Memory&lt;/title&gt;
        &lt;a&gt;There was an old man of Khartoum&lt;/a&gt;
        &lt;a&gt;Who kept two black sheep in his room.&lt;/a&gt;
        &lt;b&gt;&lt;quote&gt;"They remind me,"&lt;/quote&gt; he said,&lt;/b&gt;
        &lt;b&gt;&lt;quote&gt;"Of two friends who are dead,&lt;/quote&gt;&lt;/b&gt;
        &lt;a&gt;&lt;quote&gt;But I &lt;em&gt;cannot&lt;/em&gt; remember of whom."&lt;/quote&gt;&lt;/a&gt;
      &lt;/limerick&gt;
    </textual></programlisting><textual class="po-textual">  Because of the </textual><code class="po-atom e170 e170"><textual class="po-textual">quote</textual></code><textual class="po-textual"> and </textual><code class="po-atom e171 e171"><textual class="po-textual">em</textual></code><textual class="po-textual"> elements, this document isn't valid against our latest limerick schema.  Let's add the following declarations to our limerick schema, replacing the existing declarations for the </textual><code class="po-atom e172 e172"><textual class="po-textual">a</textual></code><textual class="po-textual"> and </textual><code class="po-atom e173 e173"><textual class="po-textual">b</textual></code><textual class="po-textual"> elements:
    </textual><programlisting class="po-block e174 e174" xml:space="preserve"><textual class="po-textual">
      &lt;!ELEMENT emphasis (#PCDATA|quote|em)*&gt;
      &lt;!ELEMENT quote (#PCDATA|quote|em)*&gt;
      &lt;!ELEMENT a (#PCDATA|quote|em)*&gt;
      &lt;!ELEMENT b (#PCDATA|quote|em)*&gt;
    </textual></programlisting><textual class="po-textual">
    The meaning of these element declarations is that the specified child elements (</textual><code class="po-atom e175 e175"><textual class="po-textual">quote</textual></code><textual class="po-textual"> and </textual><code class="po-atom e176 e176"><textual class="po-textual">em</textual></code><textual class="po-textual"> in this case) may appear in any order, any number of times, interleaved with the character content if any.  This is the only kind of mixed content that DTDs support.  Examplotron permits more restrictive sorts of mixed content, but a TE cannot handle them.  If we do a </textual><code class="po-atom e177 e177"><textual class="po-textual">stanza</textual></code><textual class="po-textual"> transformation, then because the </textual><code class="po-atom e178 e178"><textual class="po-textual">a</textual></code><textual class="po-textual"> and </textual><code class="po-atom e179 e179"><textual class="po-textual">b</textual></code><textual class="po-textual"> elements are declared to have mixed content, instead of simply dropping the </textual><code class="po-atom e180 e180"><textual class="po-textual">quote</textual></code><textual class="po-textual"> and </textual><code class="po-atom e181 e181"><textual class="po-textual">em</textual></code><textual class="po-textual"> elements along with their content as you might expect, their content is preserved.  The result, then, is the same as if no quotation or emphasis markup had appeared in the source document.</textual></para><para class="po-block e182 e182"><textual class="po-textual">What would happen if the target schema for stanzas allowed </textual><code class="po-atom e183 e183"><textual class="po-textual">em</textual></code><textual class="po-textual"> elements but not </textual><code class="po-atom e184 e184"><textual class="po-textual">quote</textual></code><textual class="po-textual"> elements?  Then the final line's content would become:
    </textual><programlisting class="po-block e185 e185" xml:space="preserve"><textual class="po-textual">
      &lt;line&gt;But I &lt;em&gt;cannot&lt;/em&gt; remember of whom.&lt;/line&gt;
    </textual></programlisting></para><para class="po-block e186 e186"><textual class="po-textual">By definition, reordering is never done on mixed content.  It is the presence of mixed content in the source schema, not in the target schema, that triggers this style of processing, although you usually want to specify mixed content in both schemas.</textual></para><para class="po-block e187 e187"><textual class="po-textual">In summary, the content models that a TE supports are mixed content, character-only content, empty content, and element content consisting of a simple sequence of child element names, possibly decorated with occurrence indicators.  All other content models are unsupported for transformation, though they are permitted for validation.</textual></para></section><section class="po-hcontainer e188 e188"><title class="po-block e189 e189"><textual class="po-textual">8. Attribute Mapping</textual></title><para class="po-block e190 e190"><textual class="po-textual">So far, the value of a renaming attribute has been a single token, an element name.  But if the renaming attribute contains multiple tokens separated by whitespace, the first token is the element name for element mapping, and the rest of the tokens are pairs of equivalent source and target attribute names.  For example, here's a </textual><code class="po-atom e191 e191"><textual class="po-textual">link</textual></code><textual class="po-textual"> element that contains a renaming attribute to map it to an HTML </textual><code class="po-atom e192 e192"><textual class="po-textual">a</textual></code><textual class="po-textual"> element:
  </textual><programlisting class="po-block e193 e193" xml:space="preserve"><textual class="po-textual">
    &lt;link target="http://examplotron.com"
     html="a target href"&gt;
      Examplotron
    &lt;/link&gt;
  </textual></programlisting><textual class="po-textual">
  
  Running a TE on this source document and providing </textual><code class="po-atom e194 e194"><textual class="po-textual">html</textual></code><textual class="po-textual"> as the transformation name produces this target document:
  </textual><programlisting class="po-block e195 e195" xml:space="preserve"><textual class="po-textual">
    &lt;a href="http://examplotron.com"&gt;
      Examplotron
    &lt;/a&gt;
  </textual></programlisting></para><para class="po-block e196 e196"><textual class="po-textual">TEs support three special cases of attribute mapping.  If the target attribute name is replaced by </textual><code class="po-atom e197 e197"><textual class="po-textual">#NONE</textual></code><textual class="po-textual">, then the source attribute will be omitted from the target document.  If the source attribute is </textual><code class="po-atom e198 e198"><textual class="po-textual">#CONTENT</textual></code><textual class="po-textual">, then the target attribute's value does not come from any source attribute, but from the character content of the element; likewise, if the target attribute is </textual><code class="po-atom e199 e199"><textual class="po-textual">#CONTENT</textual></code><textual class="po-textual">, then the source attribute is removed and its value is used as character content of the target element.  Here's an example of all three special cases.  The source element
  </textual><programlisting class="po-block e200 e200" xml:space="preserve"><textual class="po-textual">
    &lt;url purpose="linkage" label="Examplotron"
     html="a purpose #NONE label #CONTENT #CONTENT href"&gt;
       http://examplotron.org
    &lt;/url&gt;
  </textual></programlisting><textual class="po-textual"> is transformed by dropping the </textual><code class="po-atom e201 e201"><textual class="po-textual">purpose</textual></code><textual class="po-textual"> attribute, putting the character content </textual><code class="po-atom e202 e202"><textual class="po-textual">http://examplotron.org</textual></code><textual class="po-textual"> into the </textual><code class="po-atom e203 e203"><textual class="po-textual">href</textual></code><textual class="po-textual"> attribute, and putting the value of the </textual><code class="po-atom e204 e204"><textual class="po-textual">label</textual></code><textual class="po-textual"> attribute into the character content of the target element (an </textual><code class="po-atom e205 e205"><textual class="po-textual">a</textual></code><textual class="po-textual"> element), thus producing the same result (modulo whitespace) as the transformation of the </textual><code class="po-atom e206 e206"><textual class="po-textual">link</textual></code><textual class="po-textual"> element did.</textual></para><para class="po-block e207 e207"><textual class="po-textual">As a further extension to attribute mapping, if a source/target attribute name pair is followed by the token #</textual><code class="po-atom e208 e208"><textual class="po-textual">MAPTOKEN</textual></code><textual class="po-textual">, it is then followed by a source token and a target token.  The source attribute value is then divided into tokens by whitespace, and if the source token appears in it, it is replaced by the target token.  There may be any number of such triples of </textual><code class="po-atom e209 e209"><textual class="po-textual">#MAPTOKEN</textual></code><textual class="po-textual">, source token, target token following a source/target attribute pair.</textual></para><note class="po-container e210 e210"><para class="po-block e211 e211"><textual class="po-textual">This mechanism is usable but crude, and should eventually be replaced by something less hacky.  In AEs the source/target attribute pairs and mapping-token triples are in a separate attribute from the renaming attribute.</textual></para></note></section><bibliography class="po-hcontainer e212 e212"><title class="po-block e213 e213"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e214 e214"><textual class="po-textual">International Organization for Standards.   </textual><emphasis class="po-inline e215 e215" role="ital"><textual class="po-textual">SGML Extended Facilities</textual></emphasis><textual class="po-textual">, normative annex A to ISO/IEC 10744.  "A.3 Architectural Form Definition Requirements (AFDR)." [online]. © 1992, 1997 [cited 12 July 2013].  </textual><link class="po-inline e216 e216" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.pms.ifi.lmu.de/mitarbeiter/ohlbach/multimedia/HYTIME/ISO/clause-A.3.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e217 e217"><textual class="po-textual">van der Vlist, Eric. "Examplotron" [online]. © 2003 [cited 12 July 2013].
        </textual><link class="po-inline e218 e218" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.examplotron.org</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>