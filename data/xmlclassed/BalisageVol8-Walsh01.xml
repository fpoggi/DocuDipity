<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">On XML Languages…</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">Some XML languages have an XML syntax, some have a non-XML
syntax, and some have both. This paper explores the intersection of these
languages and syntaxes. What are the advantages of an XML syntax? What are
the advantages of a non-XML syntax? After discussing the general issues, the
paper presents two, alternative non-XML syntaxes for XProc as a case study
to further explore the issues.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Norman</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Walsh</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Norman Walsh is a Lead Engineer at MarkLogic Corporation where he
works with the Application Services team. Norm is also an active
participant in a number of standards efforts worldwide: he is chair of
the XML Processing Model Working Group at the W3C where he is also
co-chair of the XML Core Working Group. At OASIS, he is chair of the
DocBook Technical Committee.</textual></para><para class="po-block e14 e14"><textual class="po-textual">With more than a decade of industry experience, Norm is well known for
his work on DocBook and a wide range of open source projects. He is the
author of </textual><emphasis class="po-inline e15 e15"><textual class="po-textual">DocBook: The Definitive Guide</textual></emphasis><textual class="po-textual">.</textual></para></personblurb></author><legalnotice class="po-container e16 e16"><para class="po-block e17 e17"><textual class="po-textual">Copyright © 2012 Norman Walsh</textual></para></legalnotice></info><para class="po-block e18 e18"><textual class="po-textual">The Desperate Perl Hacker featured often in the early days of
XML. Designing a markup format that could be processed easily by
ordinary programmers using their chosen languages was an explicit
goal of XML: </textual><quote class="po-inline e19 e19"><textual class="po-textual">4. It
shall be easy to write programs which process XML documents.</textual></quote><textual class="po-textual">
</textual></para><para class="po-block e20 e20"><textual class="po-textual">This goal was achieved, at least for XML itself, if not all of the
subsequent specifications in the broader ecosystem, and as a consequence
there are no significant, mainstream languages which are incapable of processing
XML. There are probably none for which there aren't a choice of XML
parsers. Any language built on top of the Java VM includes such a choice.
Modern languages like Scala include features for the specific purpose of
writing </textual><quote class="po-inline e21 e21"><textual class="po-textual">domain specific language</textual></quote><textual class="po-textual"> parsers. These allow XML,
or subsets of XML, to be incorporated directly into the language itself.
</textual></para><para class="po-block e22 e22"><textual class="po-textual">It is straightforward to parse XML with more-or-less any programming
language you care to use. The way, and the extent to which, XML coexists with
those languages is largely a question of their design and the full range
of language design is outside the scope of this paper.</textual></para><para class="po-block e23 e23"><emphasis class="po-inline e24 e24"><textual class="po-textual">Within</textual></emphasis><textual class="po-textual"> the XML community, many XML
languages have been designed </textual><emphasis class="po-inline e25 e25"><textual class="po-textual">specifically</textual></emphasis><textual class="po-textual"> for the
purpose of processing XML. These include all of the usual suspects:
validation languages, transformation languages, query languages, etc.
These are languages designed by XML users for XML users to process XML.
These are the languages that are the focus of this paper.</textual></para><para class="po-block e26 e26"><textual class="po-textual">We are concerned mostly with the </textual><emphasis class="po-inline e27 e27"><textual class="po-textual">syntax</textual></emphasis><textual class="po-textual"> of these
languages, not their semantics. Of course, syntax and semantics are not
wholly separable. A language whose semantics are nothing more than the
expression of a single boolean value needs at most two tokens and so
can be vastly simpler syntactically than a language with Turing complete
semantics. Nevertheless, we'll focus mostly on the syntax for syntaxes
sake.</textual></para><para class="po-block e28 e28"><textual class="po-textual">The first, perhaps most obvious, question to ask about the syntax
of an XML language is: to what extent is it XML itself? A brief survey
of XML languages reveals that there is considerable variety on this point.
</textual></para><para class="po-block e29 e29"><textual class="po-textual">On one end of the spectrum,
</textual><emphasis class="po-inline e30 e30"><textual class="po-textual">RELAX NG Compact Syntax</textual></emphasis><textual class="po-textual"> has nothing that resembles XML to the untrained
eye. See </textual><xref class="po-milestone e31 e31" linkend="ex.rnc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e32 e32" xml:id="ex.rnc"><title class="po-block e33 e33"><textual class="po-textual">RELAX NG Compact Syntax</textual></title><programlisting class="po-block e34 e34" xml:space="preserve"><textual class="po-textual">namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace db = "http://docbook.org/ns/docbook"

start = purchaseOrder

purchaseOrder = element po { item+ }

item = element item { itemno, quantity, description, unitprice }

itemno =
  element itemno {
    xsd:string { pattern = "[A-Z]+[0-9]+" }
  }

quantity = element quantity { xsd:decimal }

description = element description { (text | emph)* }

emph = element emph { (text | emph)* }

unitprice =
    [
      db:para [
        "The unit price must have an associated currency.\x{a}" ~
        "If no currency is explicitly specified, the default\x{a}" ~
        "value of "
        db:literal [ "USD" ]
        "\x{a}"
        db:emphasis [ "must" ]
        " be assumed."
      ]
    ]
    element unitprice {
       [ a:defaultValue = "USD" ]
       attribute currency {
          ## US Dollars
          "USD"
        | ## Great British Pounds
          "GBP"
        | ## Euro
          "EUR"
       }?,
       xsd:decimal { fractionDigits = "2" }
    }
</textual></programlisting></figure><para class="po-block e35 e35"><textual class="po-textual">On the other end of the spectrum,
</textual><emphasis class="po-inline e36 e36"><textual class="po-textual">XQueryX</textual></emphasis><textual class="po-textual"> is nothing </textual><emphasis class="po-inline e37 e37"><textual class="po-textual">but</textual></emphasis><textual class="po-textual"> XML.
See </textual><xref class="po-milestone e38 e38" linkend="ex.xqx"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e39 e39" xml:id="ex.xqx"><title class="po-block e40 e40"><textual class="po-textual">XQueryX</textual></title><programlisting class="po-block e41 e41" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:versionDecl&gt;
    &lt;xqx:version&gt;1.0&lt;/xqx:version&gt;
    &lt;!-- encoding: null --&gt;
  &lt;/xqx:versionDecl&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:defaultNamespaceDecl&gt;
        &lt;xqx:defaultNamespaceCategory&gt;function&lt;/xqx:defaultNamespaceCategory&gt;
        &lt;xqx:uri&gt;http://www.w3.org/2005/xpath-functions&lt;/xqx:uri&gt;
      &lt;/xqx:defaultNamespaceDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:flworExpr&gt;
        &lt;xqx:letClause&gt;
          &lt;xqx:letClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;rows&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:letExpr&gt;
              &lt;xqx:flworExpr&gt;
                &lt;xqx:forClause&gt;
                  &lt;xqx:forClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;item&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:forExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:rootExpr/&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;po&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;item&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:forExpr&gt;
                  &lt;/xqx:forClauseItem&gt;
                &lt;/xqx:forClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;itemno&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqx:functionCallExpr&gt;
                        &lt;xqx:functionName&gt;string&lt;/xqx:functionName&gt;
                        &lt;xqx:arguments&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;item&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:nameTest&gt;itemno&lt;/xqx:nameTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                        &lt;/xqx:arguments&gt;
                      &lt;/xqx:functionCallExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;quant&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqx:functionCallExpr&gt;
                        &lt;xqx:functionName xqx:prefix="xs"&gt;integer&lt;/xqx:functionName&gt;
                        &lt;xqx:arguments&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;item&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:nameTest&gt;quantity&lt;/xqx:nameTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                        &lt;/xqx:arguments&gt;
                      &lt;/xqx:functionCallExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;desc&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;item&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;description&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:anyKindTest/&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;unitp&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqx:functionCallExpr&gt;
                        &lt;xqx:functionName xqx:prefix="xs"&gt;decimal&lt;/xqx:functionName&gt;
                        &lt;xqx:arguments&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;item&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:nameTest&gt;unitprice&lt;/xqx:nameTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                        &lt;/xqx:arguments&gt;
                      &lt;/xqx:functionCallExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:returnClause&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;tr&lt;/xqx:tagName&gt;
                    &lt;xqx:attributeList&gt;
                      &lt;xqx:namespaceDeclaration&gt;
                        &lt;xqx:uri&gt;http://www.w3.org/1999/xhtml&lt;/xqx:uri&gt;
                      &lt;/xqx:namespaceDeclaration&gt;
                    &lt;/xqx:attributeList&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;itemno&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;quant&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;desc&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;unitp&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:multiplyOp&gt;
                            &lt;xqx:firstOperand&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;quant&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:firstOperand&gt;
                            &lt;xqx:secondOperand&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;unitp&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:secondOperand&gt;
                          &lt;/xqx:multiplyOp&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                &lt;/xqx:returnClause&gt;
              &lt;/xqx:flworExpr&gt;
            &lt;/xqx:letExpr&gt;
          &lt;/xqx:letClauseItem&gt;
        &lt;/xqx:letClause&gt;
        &lt;xqx:returnClause&gt;
          &lt;xqx:elementConstructor&gt;
            &lt;xqx:tagName&gt;html&lt;/xqx:tagName&gt;
            &lt;xqx:attributeList&gt;
              &lt;xqx:namespaceDeclaration&gt;
                &lt;xqx:uri&gt;http://www.w3.org/1999/xhtml&lt;/xqx:uri&gt;
              &lt;/xqx:namespaceDeclaration&gt;
            &lt;/xqx:attributeList&gt;
            &lt;xqx:elementContent&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;head&lt;/xqx:tagName&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;title&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Purchase Order&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;body&lt;/xqx:tagName&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;h1&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Purchase Order&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;table&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;rows&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:elementContent&gt;
          &lt;/xqx:elementConstructor&gt;
        &lt;/xqx:returnClause&gt;
      &lt;/xqx:flworExpr&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</textual></programlisting></figure><para class="po-block e42 e42"><textual class="po-textual">Other XML languages fit between those two ends. </textual><emphasis class="po-inline e43 e43"><textual class="po-textual">XSLT</textual></emphasis><textual class="po-textual">
has a mostly XML syntax, see </textual><xref class="po-milestone e44 e44" linkend="ex.xslt"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e45 e45" xml:id="ex.xslt"><title class="po-block e46 e46"><textual class="po-textual">XSLT</textual></title><programlisting class="po-block e47 e47" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns="http://www.w3.org/1999/xhtml"
		exclude-result-prefixes="xs"
                version="2.0"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:variable name="rows"&gt;
    &lt;xsl:for-each select="/po/item"&gt;
      &lt;xsl:variable name="itemno" select="string(itemno)"/&gt;
      &lt;xsl:variable name="quant" select="xs:integer(quantity)"/&gt;
      &lt;xsl:variable name="desc" select="description/node()"/&gt;
      &lt;xsl:variable name="unitp" select="xs:decimal(unitprice)"/&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="$itemno"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="$quant"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:copy-of select="$desc"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="$unitp"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="$quant * $unitp"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:variable&gt;

  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Purchase Order&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Purchase Order&lt;/h1&gt;
      &lt;body&gt;
        &lt;table&gt;
          &lt;xsl:sequence select="$rows"/&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</textual></programlisting></figure><para class="po-block e48 e48"><textual class="po-textual">While
</textual><emphasis class="po-inline e49 e49"><textual class="po-textual">XQuery</textual></emphasis><textual class="po-textual"> has a mostly non-XML syntax, see
</textual><xref class="po-milestone e50 e50" linkend="ex.xqy"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e51 e51" xml:id="ex.xqy"><title class="po-block e52 e52"><textual class="po-textual">XQuery</textual></title><programlisting class="po-block e53 e53" xml:space="preserve"><textual class="po-textual">xquery version "1.0";

declare default function namespace "http://www.w3.org/2005/xpath-functions";

let $rows := for $item in /po/item
             let $itemno := string($item/itemno)
             let $quant  := xs:integer($item/quantity)
             let $desc   := $item/description/node()
             let $unitp  := xs:decimal($item/unitprice)
             return
               &lt;tr xmlns="http://www.w3.org/1999/xhtml"&gt;
                 &lt;td&gt;{ $itemno }&lt;/td&gt;
                 &lt;td&gt;{ $quant }&lt;/td&gt;
                 &lt;td&gt;{ $desc }&lt;/td&gt;
                 &lt;td&gt;{ $unitp } &lt;/td&gt;
                 &lt;td&gt;{ $quant * $unitp }&lt;/td&gt;
               &lt;/tr&gt;
return
  &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
      &lt;title&gt;Purchase Order&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Purchase Order&lt;/h1&gt;
      &lt;table&gt;
        { $rows }
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</textual></programlisting></figure><para class="po-block e54 e54"><textual class="po-textual">Let's look a little more closely at the distinction between
</textual><emphasis class="po-inline e55 e55"><textual class="po-textual">XQueryX</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e56 e56"><textual class="po-textual">XSLT</textual></emphasis><textual class="po-textual">. On the one hand,
</textual><emphasis class="po-inline e57 e57"><textual class="po-textual">XQueryX</textual></emphasis><textual class="po-textual"> provides improved machine readability: there are no
semantic elements not manifest in the XML. On the other hand, it gains this benefit
by sacrificing human readability. These are two possible axes on which we can
analyze a language syntax, we'll revisit them later.</textual></para><para class="po-block e58 e58"><textual class="po-textual">In the meantime, distinguish a “practical” XML
syntax as one that is concise enough for human comprehension
(even if it relies on some non-XML syntax to aid readability).</textual></para><para class="po-block e59 e59"><textual class="po-textual">How do XML languages stand up? See </textual><xref class="po-milestone e60 e60" linkend="xml.lang"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><table class="po-container e61 e61" xml:id="xml.lang"><caption class="po-container e62 e62"><para class="po-block e63 e63"><textual class="po-textual">XML Languages</textual></para></caption><tbody class="po-table e64 e64"><tr class="po-table e65 e65"><th class="po-field e66 e66"><textual class="po-textual">Language</textual></th><th class="po-field e67 e67"><textual class="po-textual">XML Syntax</textual></th><th class="po-field e68 e68"><textual class="po-textual">Practical XML Syntax</textual></th><th class="po-field e69 e69"><textual class="po-textual">Non-XML Syntax</textual></th></tr><tr class="po-table e70 e70"><td class="po-block e71 e71"><textual class="po-textual">Atom</textual></td><td class="po-block e72 e72"><textual class="po-textual">✓</textual></td><td class="po-block e73 e73"><textual class="po-textual">✓</textual></td><td class="po-block e74 e74"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr><tr class="po-table e75 e75"><td class="po-block e76 e76"><textual class="po-textual">DocBook, HTML, …</textual><footnote class="po-popup e77 e77"><para class="po-block e78 e78"><textual class="po-textual">…, DITA, TEI, etc. Markup languages
for prose.</textual></para></footnote></td><td class="po-block e79 e79"><textual class="po-textual">✓</textual></td><td class="po-block e80 e80"><textual class="po-textual">✓</textual></td><td class="po-block e81 e81"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr><tr class="po-table e82 e82"><td class="po-block e83 e83"><textual class="po-textual">MathML</textual></td><td class="po-block e84 e84"><textual class="po-textual">✓</textual></td><td class="po-block e85 e85"><textual class="po-textual">✓</textual></td><td class="po-block e86 e86"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr><tr class="po-table e87 e87"><td class="po-block e88 e88"><textual class="po-textual">RELAX NG</textual></td><td class="po-block e89 e89"><textual class="po-textual">✓</textual></td><td class="po-block e90 e90"><textual class="po-textual">✓</textual></td><td class="po-block e91 e91"><textual class="po-textual">✓</textual></td></tr><tr class="po-table e92 e92"><td class="po-block e93 e93"><textual class="po-textual">RDF</textual></td><td class="po-block e94 e94"><textual class="po-textual">✓</textual></td><td class="po-block e95 e95"><textual class="po-textual">✓</textual></td><td class="po-block e96 e96"><textual class="po-textual">✓</textual></td></tr><tr class="po-table e97 e97"><td class="po-block e98 e98"><textual class="po-textual">Schematron</textual></td><td class="po-block e99 e99"><textual class="po-textual">✓</textual></td><td class="po-block e100 e100"><textual class="po-textual">✓</textual></td><td class="po-block e101 e101"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr><tr class="po-table e102 e102"><td class="po-block e103 e103"><textual class="po-textual">SVG</textual></td><td class="po-block e104 e104"><textual class="po-textual">✓</textual></td><td class="po-block e105 e105"><textual class="po-textual">✓</textual></td><td class="po-block e106 e106"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr><tr class="po-table e107 e107"><td class="po-block e108 e108"><textual class="po-textual">XInclude</textual></td><td class="po-block e109 e109"><textual class="po-textual">✓</textual></td><td class="po-block e110 e110"><textual class="po-textual">✓</textual></td><td class="po-block e111 e111"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr><tr class="po-table e112 e112"><td class="po-block e113 e113"><textual class="po-textual">XLink</textual></td><td class="po-block e114 e114"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e115 e115"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e116 e116"><textual class="po-textual">✓</textual></td></tr><tr class="po-table e117 e117"><td class="po-block e118 e118"><textual class="po-textual">XML Schema</textual></td><td class="po-block e119 e119"><textual class="po-textual">✓</textual></td><td class="po-block e120 e120"><textual class="po-textual">✓</textual></td><td class="po-block e121 e121"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr><tr class="po-table e122 e122"><td class="po-block e123 e123"><textual class="po-textual">XPointer</textual></td><td class="po-block e124 e124"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e125 e125"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e126 e126"><textual class="po-textual">✓</textual></td></tr><tr class="po-table e127 e127"><td class="po-block e128 e128"><textual class="po-textual">XProc</textual></td><td class="po-block e129 e129"><textual class="po-textual">✓</textual></td><td class="po-block e130 e130"><textual class="po-textual">✓</textual></td><td class="po-block e131 e131"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr><tr class="po-table e132 e132"><td class="po-block e133 e133"><textual class="po-textual">XQuery</textual></td><td class="po-block e134 e134"><textual class="po-textual">✓</textual></td><td class="po-block e135 e135"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e136 e136"><textual class="po-textual">✓</textual></td></tr><tr class="po-table e137 e137"><td class="po-block e138 e138"><textual class="po-textual">XSLT</textual></td><td class="po-block e139 e139"><textual class="po-textual">✓</textual></td><td class="po-block e140 e140"><textual class="po-textual">✓</textual></td><td class="po-block e141 e141"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td></tr></tbody></table><para class="po-block e142 e142"><textual class="po-textual">There may be room for debate about some cells in that table.
Evan Lenz's work on </textual><xref class="po-milestone e143 e143" linkend="carrot"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, for example, is
moving in the direction of a more compact, non-XML syntax for XSLT.
One could argue that TeX is a non-XML syntax for MathML. We might debate
whether or not attribute-based languages like XLink are or are not XML.
And, in addition,
there may be other syntaxes for these languages of which the author is
unaware. However, at a coarse level of granularity, what we can see is
that there are languages all across the spectrum.</textual></para><section class="po-hcontainer e144 e144" xml:id="syntax-choice"><title class="po-block e145 e145"><textual class="po-textual">Syntactically: XML or not?</textual></title><para class="po-block e146 e146"><textual class="po-textual">Seeing languages spread across a spectrum like this invites the
question: why? What motivates a language designer to choose an XML
syntax, or not? When both are provided, what motivates a user to
choose an XML syntax, or not?</textual></para><section class="po-hcontainer e147 e147" xml:id="pro-xml"><title class="po-block e148 e148"><textual class="po-textual">The case for XML syntaxes</textual></title><para class="po-block e149 e149"><textual class="po-textual">Why choose XML?</textual></para><itemizedlist class="po-table e150 e150"><listitem class="po-container e151 e151"><para class="po-block e152 e152"><textual class="po-textual">“Eat your own dogfood”/”Fly your own airplanes.” One school of thought
says that XML languages should be expressed in XML simply because they are XML
languages. Some XML developers find XML to be a clear and precise format for
the expression of ideas.</textual></para></listitem><listitem class="po-container e153 e153"><para class="po-block e154 e154"><textual class="po-textual">Extensibility. The XML syntax has natural extension points,
attributes on start tags, for example, and namespaces. At a
</textual><emphasis class="po-inline e155 e155"><textual class="po-textual">syntactic</textual></emphasis><textual class="po-textual"> level, extending an XML language is an
easily solved problem. Conversely, non-XML languages sometimes suffer from
a dearth of extension points. Keeping a grammar for a complex language like
XQuery free from ambiguity while simultaneously adding language features
can be a real challenge.</textual></para><para class="po-block e156 e156"><textual class="po-textual">Whether the accretion of language features through this form of ad-hoc
extension, in either the XML or non-XML cases, produces a coherent and
regular language over time, is a separate question.</textual></para></listitem><listitem class="po-container e157 e157"><para class="po-block e158 e158"><textual class="po-textual">Accessibility to XML tools. The fact that an XSLT stylesheet can be used
to </textual><emphasis class="po-inline e159 e159"><textual class="po-textual">produce</textual></emphasis><textual class="po-textual"> an XSLT stylesheet is not a feature that every
XSLT user needs, but there are circumstances when it is a great boon.</textual></para></listitem><listitem class="po-container e160 e160"><para class="po-block e161 e161"><textual class="po-textual">Documentation. The ability to inline documentation in an XML language
is considered a great benefit in some environments. Expressing XML documentation
in a non-XML language can have a deleterious effect readability. Compare,
for example, the non-XML representation of the </textual><code class="po-atom e162 e162"><textual class="po-textual">unitprice</textual></code><textual class="po-textual"> pattern,
</textual><xref class="po-milestone e163 e163" linkend="rnc.doc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, with the equivalent XML representation,
</textual><xref class="po-milestone e164 e164" linkend="rng.doc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e165 e165" xml:id="rnc.doc"><title class="po-block e166 e166"><textual class="po-textual">XML Documentation in RELAX NG Compact Syntax</textual></title><programlisting class="po-block e167 e167" xml:space="preserve"><textual class="po-textual">unitprice =
    [
      db:para [
        "The unit price must have an associated currency.\x{a}" ~
        "If no currency is explicitly specified, the default\x{a}" ~
        "value of "
        db:literal [ "USD" ]
        "\x{a}"
        db:emphasis [ "must" ]
        " be assumed."
      ]
    ]
    element unitprice {
       [ a:defaultValue = "USD" ]
       attribute currency {
          ## US Dollars
          "USD"
        | ## Great British Pounds
          "GBP"
        | ## Euro
          "EUR"
       }?,
       xsd:decimal { fractionDigits = "2" }
    }
</textual></programlisting></figure><figure class="po-container e168 e168" xml:id="rng.doc"><title class="po-block e169 e169"><textual class="po-textual">XML Documentation in RELAX NG XML Syntax</textual></title><programlisting class="po-block e170 e170" xml:space="preserve"><textual class="po-textual">  &lt;define name="unitprice"&gt;
    &lt;element name="unitprice"&gt;
      &lt;db:para&gt;The unit price must have an associated currency.
      If no currency is explicitly specified, the default
      value of &lt;db:literal&gt;USD&lt;/db:literal&gt;
      &lt;db:emphasis&gt;must&lt;/db:emphasis&gt; be assumed.&lt;/db:para&gt;

      &lt;optional&gt;
        &lt;attribute name="currency" a:defaultValue="USD"&gt;
          &lt;choice&gt;
            &lt;value&gt;USD&lt;/value&gt;
            &lt;a:documentation&gt;US Dollars&lt;/a:documentation&gt;
            &lt;value&gt;GBP&lt;/value&gt;
            &lt;a:documentation&gt;Great British Pounds&lt;/a:documentation&gt;
            &lt;value&gt;EUR&lt;/value&gt;
            &lt;a:documentation&gt;Euro&lt;/a:documentation&gt;
          &lt;/choice&gt;
        &lt;/attribute&gt;
      &lt;/optional&gt;

      &lt;data type="decimal"&gt;
        &lt;param name="fractionDigits"&gt;2&lt;/param&gt;
      &lt;/data&gt;
    &lt;/element&gt;
</textual></programlisting></figure></listitem><listitem class="po-container e171 e171"><para class="po-block e172 e172"><textual class="po-textual">Syntactic conformance. Operating on XML with a language that has
an XML syntax provides certain minimum assurances about the outputs. An XSLT
stylesheet, which must itself be well formed, guarantees</textual><footnote class="po-popup e173 e173"><para class="po-block e174 e174"><textual class="po-textual">“Guarantees” in the
absence of features such as disable output escaping and character maps that
are designed to subvert the serialization, in any event.</textual></para></footnote><textual class="po-textual"> that
the resulting document will be well formed, by virtue of the nature of XSLT.
</textual></para></listitem><listitem class="po-container e175 e175"><para class="po-block e176 e176"><textual class="po-textual">Learnability? There's certainly anecdotal evidence that
non-programmers can be taught to be productive with XSLT in ways that
don't have parallels in non-XML languages. This may be because the
structure of the XSLT stylesheet has a strong surface resemblance to
the documents that are to be transformed. This is true both at the
level of the surface syntax (they're both XML) and at a deeper level
in that templates contain fragments of the documents in a very obvious
and direct way.</textual></para></listitem><listitem class="po-container e177 e177"><para class="po-block e178 e178"><textual class="po-textual">Declarativeness? There's a tendency for XML languages to have a more
declarative nature than their non-XML counterparts. This can be seen particularly
in the case of XSLT as compared to XQuery. The XSLT stylesheet in
</textual><xref class="po-milestone e179 e179" linkend="ex.xslt"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> was written in a very “pull” fashion in order to
have as much surface similarity to the XQuery example, </textual><xref class="po-milestone e180 e180" linkend="ex.xqy"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,
as possible</textual><footnote class="po-popup e181 e181"><para class="po-block e182 e182"><textual class="po-textual">Pulling the rows out of line and storing them in a
variable is an awkward consequence of XQuery's completely broken semantics with
respect to the default namespace.</textual></para></footnote><textual class="po-textual">.</textual></para><para class="po-block e183 e183"><textual class="po-textual">A more idiomatically natural XSLT solution for the problem is shown in
</textual><xref class="po-milestone e184 e184" linkend="ex.xslt2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e185 e185" xml:id="ex.xslt2"><title class="po-block e186 e186"><textual class="po-textual">Idiomatic XSLT</textual></title><programlisting class="po-block e187 e187" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns="http://www.w3.org/1999/xhtml"
		exclude-result-prefixes="xs"
                version="2.0"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Purchase Order&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Purchase Order&lt;/h1&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="po"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="item"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="itemno"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="quantity"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:apply-templates select="description"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="unitprice"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="xs:integer(quantity) * xs:decimal(unitprice)"/&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="description"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;em&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/em&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</textual></programlisting></figure><para class="po-block e188 e188"><textual class="po-textual">In the idiomatic, or “push”, style separate templates are declared
for each component. This greatly increases the flexibility and reusability of
XSLT.</textual></para></listitem><listitem class="po-container e189 e189"><para class="po-block e190 e190"><textual class="po-textual">Familiarity. For users whose principle tasks involve editing, validating,
transforming, or otherwise working with XML, a language that is itself expressed
in XML has a certain familiarity. Languages like XSLT or RELAX NG can be edited
in the same comfortable, understood environment used for other XML editing tasks.
</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e191 e191" xml:id="pro-non-xml"><title class="po-block e192 e192"><textual class="po-textual">The case for non-XML syntaxes</textual></title><para class="po-block e193 e193"><textual class="po-textual">Why choose a non-XML syntax?</textual></para><itemizedlist class="po-table e194 e194"><listitem class="po-container e195 e195"><para class="po-block e196 e196"><textual class="po-textual">Conciseness. One of the principle attractions of a non-XML syntax is that
it's more compact, more concise. A concise syntax allows more information to
fit on a screen or page and consequently provides the reader with a greater
perspective on the language.</textual></para><para class="po-block e197 e197"><textual class="po-textual">The compact schema in </textual><xref class="po-milestone e198 e198" linkend="ex.rnc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> fits easily on a
single page or screen and is completely straightforward to understand,
assuming you're familiar with RELAX NG and its compact syntax.</textual></para><para class="po-block e199 e199"><textual class="po-textual">The same schema expressed in the XML syntax, </textual><xref class="po-milestone e200 e200" linkend="ex.rng"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, is </textual><emphasis class="po-inline e201 e201"><textual class="po-textual">twice</textual></emphasis><textual class="po-textual"> as long as it's
compact counterpart. It's not manifestly more difficult to understand,
assuming you're familiar with RELAX NG and its XML syntax, but it
doesn't fit on a single page and contains a lot of syntactic “clutter” that
one must learn to “look through”.
</textual></para><figure class="po-container e202 e202" xml:id="ex.rng"><title class="po-block e203 e203"><textual class="po-textual">RELAX NG</textual></title><programlisting class="po-block e204 e204" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;grammar xmlns:db="http://docbook.org/ns/docbook"
         xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
         xmlns="http://relaxng.org/ns/structure/1.0"
         datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
  &lt;start&gt;
    &lt;ref name="purchaseOrder"/&gt;
  &lt;/start&gt;

  &lt;define name="purchaseOrder"&gt;
    &lt;element name="po"&gt;
      &lt;oneOrMore&gt;
        &lt;ref name="item"/&gt;
      &lt;/oneOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="item"&gt;
    &lt;element name="item"&gt;
      &lt;ref name="itemno"/&gt;
      &lt;ref name="quantity"/&gt;
      &lt;ref name="description"/&gt;
      &lt;ref name="unitprice"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="itemno"&gt;
    &lt;element name="itemno"&gt;
      &lt;data type="string"&gt;
        &lt;param name="pattern"&gt;[A-Z]+[0-9]+&lt;/param&gt;
      &lt;/data&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="quantity"&gt;
    &lt;element name="quantity"&gt;
      &lt;data type="decimal"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="description"&gt;
    &lt;element name="description"&gt;
      &lt;zeroOrMore&gt;
        &lt;choice&gt;
          &lt;text/&gt;
          &lt;ref name="emph"/&gt;
        &lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="emph"&gt;
    &lt;element name="emph"&gt;
      &lt;zeroOrMore&gt;
        &lt;choice&gt;
          &lt;text/&gt;
          &lt;ref name="emph"/&gt;
        &lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="unitprice"&gt;
    &lt;element name="unitprice"&gt;
      &lt;db:para&gt;The unit price must have an associated currency.
      If no currency is explicitly specified, the default
      value of &lt;db:literal&gt;USD&lt;/db:literal&gt;
      &lt;db:emphasis&gt;must&lt;/db:emphasis&gt; be assumed.&lt;/db:para&gt;

      &lt;optional&gt;
        &lt;attribute name="currency" a:defaultValue="USD"&gt;
          &lt;choice&gt;
            &lt;value&gt;USD&lt;/value&gt;
            &lt;a:documentation&gt;US Dollars&lt;/a:documentation&gt;
            &lt;value&gt;GBP&lt;/value&gt;
            &lt;a:documentation&gt;Great British Pounds&lt;/a:documentation&gt;
            &lt;value&gt;EUR&lt;/value&gt;
            &lt;a:documentation&gt;Euro&lt;/a:documentation&gt;
          &lt;/choice&gt;
        &lt;/attribute&gt;
      &lt;/optional&gt;

      &lt;data type="decimal"&gt;
        &lt;param name="fractionDigits"&gt;2&lt;/param&gt;
      &lt;/data&gt;
    &lt;/element&gt;
  &lt;/define&gt;
&lt;/grammar&gt;
</textual></programlisting></figure></listitem><listitem class="po-container e205 e205"><para class="po-block e206 e206"><textual class="po-textual">Familiarity. For tasks, such as programming, that are most
typically performed with non-XML languages, using a non-XML syntax for
an XML language makes it more familiar and approachable for users that come
from other backgrounds.</textual></para><para class="po-block e207 e207"><textual class="po-textual">XQuery is arguably far more familiar, and consequently less threatening
and more approachable, and easier to learn for a programmer with a background
in SQL or any of a host of common scripting languages.</textual></para></listitem><listitem class="po-container e208 e208"><para class="po-block e209 e209"><textual class="po-textual">Accessibility to </textual><emphasis class="po-inline e210 e210"><textual class="po-textual">non-XML</textual></emphasis><textual class="po-textual"> tools.
Both familiarity and conciseness play into another strength for non-XML languages:
support in tools and environments that programmers are used to. An XQuery or
RELAX NG Compact Syntax plugin for the programmer's favorite IDE makes editing those
files part of a comfortable, understood environment. Using an XML syntax may require
a new editing tool.</textual></para></listitem><listitem class="po-container e211 e211"><para class="po-block e212 e212"><textual class="po-textual">Syntactic expressiveness. An XML syntax imposes constraints on what characters
may appear unescaped. Some of the characters that must escaped are common in
other contexts. For example, it's easy to argue that “</textual><code class="po-atom e213 e213"><textual class="po-textual">$a &lt;= 5</textual></code><textual class="po-textual">”
is easier to read and understand than “</textual><code class="po-atom e214 e214"><textual class="po-textual">$a &amp;lt;= 5</textual></code><textual class="po-textual">”.
</textual></para></listitem></itemizedlist></section></section><section class="po-hcontainer e215 e215" xml:id="syntax-both"><title class="po-block e216 e216"><textual class="po-textual">Syntactically: Both?</textual></title><para class="po-block e217 e217"><textual class="po-textual">Why choose if you can have both? RELAX NG is widely praised for having both
an XML syntax and a compact syntax. Why not always take that approach?</textual></para><para class="po-block e218 e218"><textual class="po-textual">One critical metric by which the success or failure of a
dual-syntax approach will be judged is semantic compatibility.
Arguably, the RELAX NG Compact Syntax has not been successful simply
because it has the advantages of a non-XML syntax, but also because it
describes </textual><emphasis class="po-inline e219 e219"><textual class="po-textual">exactly</textual></emphasis><textual class="po-textual"> the same language as the XML
syntax. There are no constructs that can be represented in the compact
syntax that cannot be represented in the XML syntax, and vice-versa.
It is possible to translate </textual><emphasis class="po-inline e220 e220"><textual class="po-textual">every</textual></emphasis><textual class="po-textual"> valid schema
losslessly from one format to the other and back again.</textual></para><para class="po-block e221 e221"><textual class="po-textual">In practice, this is a </textual><emphasis class="po-inline e222 e222"><textual class="po-textual">remarkably</textual></emphasis><textual class="po-textual"> high bar.
RELAX NG is a purely declarative language with no semantics for
iteration or transformation. As such, it is burdened with far fewer
semantics to express than a programming language like XSLT or XQuery.
It is difficult to imagine finding a useful alternative syntax for either
of those languages that expressed </textual><emphasis class="po-inline e223 e223"><textual class="po-textual">precisely</textual></emphasis><textual class="po-textual"> the same
underlying semantics.</textual></para><para class="po-block e224 e224"><textual class="po-textual">Yet, the absolute syntactic isomorphism of the two syntaxes is
considered in this paper to be an absolute requirement. Devising alternate
syntaxes for subsets of a language is both much easier and much less
useful. Every instance of the language that uses a construct not available
in the alternate syntax is unavailable to the users who prefer the alternative,
and to tools that are designed to work best with it.</textual></para><para class="po-block e225 e225"><textual class="po-textual">It's also worth noting that even in the RELAX NG case, there are
unusual artifacts in the non-XML syntax: square bracketed notations
placed in front of the constructs that they modify and a somewhat
torturous representation of XML markup in such annotations. Luckily,
and by design, these annotations are uncommon, the simplest of these
annotations are the most common and the most complicated are quite
rare. Also, because of the syntactic isomorphism, it is possible to
switch back-and-forth between the syntaxes, editing XML annotations in
the XML syntax, and content models in the compact syntax, for
example.</textual></para></section><section class="po-hcontainer e226 e226" xml:id="case-studies"><title class="po-block e227 e227"><textual class="po-textual">Case studies: compact syntaxes for XProc</textual></title><para class="po-block e228 e228"><textual class="po-textual">To explore these ideas further, for the balance of this paper,
we will consider two alternative, compact syntaxes for
</textual><emphasis class="po-inline e229 e229"><textual class="po-textual">XProc: An XML Pipeline Language</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e230 e230"><textual class="po-textual">XProc, for those unfamiliar with it, is a language “for
describing operations to be performed on XML documents.”A pipeline
accepts XML documents as input, performs an arbitrary series of
operations on them, and produces XML documents as output. In the
context of an XProc pipeline, an “operation” is one of a set of
discrete steps. These steps perform tasks such as adding an attribute,
counting nodes, deleting nodes, inserting nodes, performing XInclude,
XSLT, or XQuery, various forms of validation. XProc has about 40 such
operations built in and may be extended with additional operations.
</textual></para><para class="po-block e231 e231"><textual class="po-textual">A simple XProc pipeline is shown in </textual><xref class="po-milestone e232 e232" linkend="simple.xpl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e233 e233" xml:id="simple.xpl"><title class="po-block e234 e234"><textual class="po-textual">Simple XProc Pipeline</textual></title><programlisting class="po-block e235 e235" xml:space="preserve"><textual class="po-textual">&lt;p:pipeline xmlns:p="http://www.w3.org/ns/xproc"
            version='1.0'&gt;
&lt;p:serialization port="result" method="xhtml" indent="true"/&gt;

&lt;p:xinclude/&gt;

&lt;p:xslt&gt;
  &lt;p:input port="stylesheet"&gt;
    &lt;p:document href="dbslides.xsl"/&gt;
  &lt;/p:input&gt;
&lt;/p:xslt&gt;

&lt;/p:pipeline&gt;
</textual></programlisting></figure><para class="po-block e236 e236"><textual class="po-textual">This pipeline takes a single input document, performs XInclude processing,
styles it using the “</textual><emphasis class="po-inline e237 e237"><textual class="po-textual">dbslides.xsl</textual></emphasis><textual class="po-textual">” stylesheet, and then
produces as its output the result of that transformation. If the XProc processor
serializes the result, it does so as indented XHTML.</textual></para><section class="po-hcontainer e238 e238" xml:id="case-study1"><title class="po-block e239 e239"><textual class="po-textual">Case study 1: A compact syntax for XProc</textual></title><para class="po-block e240 e240"><textual class="po-textual">How might the pipeline in </textual><xref class="po-milestone e241 e241" linkend="simple.xpl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> be
represented in a compact, non-XML syntax? Where might we look for
inspiration?</textual></para><itemizedlist class="po-table e242 e242"><listitem class="po-container e243 e243"><para class="po-block e244 e244"><textual class="po-textual">Python? With significant whitespace?</textual></para></listitem><listitem class="po-container e245 e245"><para class="po-block e246 e246"><textual class="po-textual">Pascal? With </textual><code class="po-atom e247 e247"><textual class="po-textual">BEGIN</textual></code><textual class="po-textual">/</textual><code class="po-atom e248 e248"><textual class="po-textual">END</textual></code><textual class="po-textual"> and </textual><code class="po-atom e249 e249"><textual class="po-textual">:=</textual></code><textual class="po-textual">?</textual></para></listitem><listitem class="po-container e250 e250"><para class="po-block e251 e251"><textual class="po-textual">Scheme? Because everything looks better with parentheses?</textual></para></listitem><listitem class="po-container e252 e252"><para class="po-block e253 e253"><textual class="po-textual">Something from the C/Java/JavaScript family?</textual></para></listitem></itemizedlist><para class="po-block e254 e254"><textual class="po-textual">For our first attempt, we'll take the last option. Translating
</textual><xref class="po-milestone e255 e255" linkend="simple.xpl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> into a compact syntax along these lines produces
</textual><xref class="po-milestone e256 e256" linkend="simple.xpc1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e257 e257" xml:id="simple.xpc1"><title class="po-block e258 e258"><textual class="po-textual">Simple XProc Pipeline, Compact Syntax #1</textual></title><programlisting class="po-block e259 e259" xml:space="preserve"><textual class="po-textual">xproc 1.0

pipeline {
  serialization "result" with method="xhtml",
       indent="true"
  xinclude
  xslt {
    input "stylesheet" {
      document "dbslides.xsl"
    }
  }
}
</textual></programlisting></figure><para class="po-block e260 e260"><textual class="po-textual">This is in many ways a very direct translation. Like RELAX NG's
compact syntax and XQuery, we use curly braces to delimit the bodies
of our semantic constructs. Each new construct is introduced by a new
token. There are two syntactic extension points in the XML syntax that
we must accommodate: the presence of arbitrary extension attributes on what are
elements in the XML syntax, and the presence of arbitrary XML
fragments.</textual></para><para class="po-block e261 e261"><textual class="po-textual">The “</textual><code class="po-atom e262 e262"><textual class="po-textual">with</textual></code><textual class="po-textual">” keyword is used at the end of each
construct in the compact syntax to introduce an unbounded list of
name/value pairs. These map back to extension attributes in the XML
syntax.</textual></para><figure class="po-container e263 e263" xml:id="lib.xpl"><title class="po-block e264 e264"><textual class="po-textual">XProc Library</textual></title><programlisting class="po-block e265 e265" xml:space="preserve"><textual class="po-textual">&lt;p:library xmlns:p="http://www.w3.org/ns/xproc"
	   xmlns:cx="http://xmlcalabash.com/ns/extensions"
           version="1.0"&gt;

&lt;p:declare-step type="cx:unzip"&gt;
  &lt;p:output port="result"/&gt;
  &lt;p:option name="href" required="true"
            cx:type="xsd:anyURI"/&gt;
  &lt;p:option name="file"/&gt;
  &lt;p:option name="content-type"/&gt;
&lt;/p:declare-step&gt;

&lt;/p:library&gt;
</textual></programlisting></figure><para class="po-block e266 e266"><textual class="po-textual">Where additional namespaces are required, as in the pipeline library
in </textual><xref class="po-milestone e267 e267" linkend="lib.xpl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, they're introduced in the compact syntax and
</textual><code class="po-atom e268 e268"><textual class="po-textual">CName</textual></code><textual class="po-textual">s are allowed as tokens. The equivalent library in
this compact syntax is shown in </textual><xref class="po-milestone e269 e269" linkend="lib.xpc1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e270 e270" xml:id="lib.xpc1"><title class="po-block e271 e271"><textual class="po-textual">XProc Library, Compact Syntax #1</textual></title><programlisting class="po-block e272 e272" xml:space="preserve"><textual class="po-textual">xproc 1.0

namespace p = "http://www.w3.org/ns/xproc"
namespace cx = "http://xmlcalabash.com/ns/extensions"

library with version="1.0" {
  declare-step with type="cx:unzip" {
    output "result"
    required option href with cx:type="xsd:anyURI"
    option file
    option content-type
  }
}
</textual></programlisting></figure><para class="po-block e273 e273"><textual class="po-textual">This example shows the use of an extension attribute, </textual><code class="po-atom e274 e274"><textual class="po-textual">cx:type</textual></code><textual class="po-textual">,
represented in the compact syntax.</textual></para><para class="po-block e275 e275"><textual class="po-textual">The other challenge is representing arbitrary XML. In RELAX NG,
arbitrary XML fragments are always annotations of one sort or another;
they're both relatively uncommon and, to some extent, unimportant to
the core grammar. Not so in XProc where they appear both in annotations,
like </textual><code class="po-atom e276 e276"><textual class="po-textual">p:documentation</textual></code><textual class="po-textual">, </textual><xref class="po-milestone e277 e277" linkend="lib2.xpl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,
but also as </textual><emphasis class="po-inline e278 e278"><textual class="po-textual">inline</textual></emphasis><textual class="po-textual"> document
content in the pipeline. Using a syntax as awkward as the approach in
RNC seems like a bad choice.</textual></para><figure class="po-container e279 e279" xml:id="lib2.xpl"><title class="po-block e280 e280"><textual class="po-textual">XProc Library with Documentation</textual></title><programlisting class="po-block e281 e281" xml:space="preserve"><textual class="po-textual">&lt;p:library xmlns:p="http://www.w3.org/ns/xproc"
           xmlns:cx="http://xmlcalabash.com/ns/extensions"
           version="1.0"&gt;

&lt;p:documentation&gt;
&lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;h1&gt;XML Calabash Extension Library&lt;/h1&gt;
&lt;h2&gt;Version 1.0&lt;/h2&gt;
&lt;p&gt;The steps defined in this library are implemented in
&lt;a href="http://xmlcalabash.com/"&gt;XML Calabash&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/p:documentation&gt;
…
</textual></programlisting></figure><para class="po-block e282 e282"><textual class="po-textual">However, in the context of parsing a non-XML syntax, it must be
possible to recognize both where the XML begins and where it
</textual><emphasis class="po-inline e283 e283"><textual class="po-textual">ends</textual></emphasis><textual class="po-textual">. The presence of, for example, a fragment of
XProc compact syntax in a program listing in some XML must not be
accidentally parsed as XProc. One approach would be to build a
complete XML parser into the grammar of the compact syntax. But even
this is tricky because a </textual><code class="po-atom e284 e284"><textual class="po-textual">p:inline</textual></code><textual class="po-textual"> might include
several consecutive sibling elements that each have to be recognized.
</textual></para><para class="po-block e285 e285"><textual class="po-textual">If only there were some string of tokens that can't appear in
XML…</textual></para><para class="po-block e286 e286"><textual class="po-textual">In fact, such a sequence exists. Almost. The sequence “</textual><code class="po-atom e287 e287"><textual class="po-textual">]]&gt;</textual></code><textual class="po-textual">”
is forbidden in XML </textual><emphasis class="po-inline e288 e288"><textual class="po-textual">except</textual></emphasis><textual class="po-textual"> when it ends a CDATA section.
We can leverage this fact in our compact syntax to form delimiters for
arbitrary XML: “</textual><code class="po-atom e289 e289"><textual class="po-textual">&lt;![xml[</textual></code><textual class="po-textual">” and “</textual><code class="po-atom e290 e290"><textual class="po-textual">]]&gt;</textual></code><textual class="po-textual">”.
See </textual><xref class="po-milestone e291 e291" linkend="lib2.xpc1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e292 e292" xml:id="lib2.xpc1"><title class="po-block e293 e293"><textual class="po-textual">XProc Library with Documentation, Compact Syntax #1</textual></title><programlisting class="po-block e294 e294" xml:space="preserve"><textual class="po-textual">xproc 1.0

library with version="1.0" {

documentation {
&lt;![xml[&lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;h1&gt;XML Calabash Extension Library&lt;/h1&gt;
&lt;h2&gt;Version 1.0&lt;/h2&gt;
&lt;p&gt;The steps defined in this library are implemented in
&lt;a href="http://xmlcalabash.com/"&gt;XML Calabash&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;]]&gt;
…
</textual></programlisting></figure><para class="po-block e295 e295"><textual class="po-textual">It's arguably a hack, but it allows us to satisfy the
requirement that each syntax represent exactly the same underlying
constructs.</textual></para><para class="po-block e296 e296"><textual class="po-textual">This syntax has been implemented. The implementation strategy is
to transform the compact syntax into the XML syntax as a
pre-processing step and then process the resulting XML as usual.</textual></para><para class="po-block e297 e297"><textual class="po-textual">How does this syntax stand up to the suggested benefits of
non-XML syntaxes?</textual></para><itemizedlist class="po-table e298 e298"><listitem class="po-container e299 e299"><para class="po-block e300 e300"><textual class="po-textual">Conciseness? A wash. It's not clearly shorter in terms of absolute number of lines.
</textual></para></listitem><listitem class="po-container e301 e301"><para class="po-block e302 e302"><textual class="po-textual">Familiarity? Not clear. It has the advantage of
less visual clutter, but doesn't draw from the C/Java/JavaScript family in
any significant regard beyond curly braces.
</textual></para></listitem><listitem class="po-container e303 e303"><para class="po-block e304 e304"><textual class="po-textual">Accessibility to non-XML tools? Probably an improvement. It's likely that a modern
IDE could be customized with the EBNF (see </textual><xref class="po-milestone e305 e305" linkend="xpc1-grammar"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
</textual></para></listitem><listitem class="po-container e306 e306"><para class="po-block e307 e307"><textual class="po-textual">Syntactic expressiveness? An improvement; outside of XML blocks, there are
no characters that need to be explicitly escaped.
</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e308 e308" xml:id="case-study2"><title class="po-block e309 e309"><textual class="po-textual">Case study 2: An alternate compact syntax for XProc</textual></title><para class="po-block e310 e310"><textual class="po-textual">When I presented the first compact syntax in a lightning talk last year,
Jeni Tennison
observed that it could be made more compact, and perhaps more useful
if it was more idiomatically like other programming languages. She
subsequently produced most of the “second compact syntax” language
design.</textual></para><para class="po-block e311 e311"><textual class="po-textual">Translating
</textual><xref class="po-milestone e312 e312" linkend="simple.xpl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> into this second compact syntax produces
</textual><xref class="po-milestone e313 e313" linkend="simple.xpc2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e314 e314" xml:id="simple.xpc2"><title class="po-block e315 e315"><textual class="po-textual">Simple XProc Pipeline, Compact Syntax #2</textual></title><programlisting class="po-block e316 e316" xml:space="preserve"><textual class="po-textual">pipeline {
  xinclude
  xslt ( stylesheet = document 'dbslides.xsl' )
} =&gt; ( result serialized with [ method = 'xhtml', indent = 'true' ] )
</textual></programlisting></figure><para class="po-block e317 e317"><textual class="po-textual">Adopting a more “method call”-like syntax does make the pipelines
shorter. The outputs of a step are treated in a similar way, but shown at
the end of the body.</textual></para><para class="po-block e318 e318"><textual class="po-textual">The most obvious example of an attempt to make the language more
idiomatically like other programming languages can be seen in the handling
of </textual><code class="po-atom e319 e319"><textual class="po-textual">p:choose</textual></code><textual class="po-textual">. Consider </textual><xref class="po-milestone e320 e320" linkend="choose.xpl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e321 e321" xml:id="choose.xpl"><title class="po-block e322 e322"><textual class="po-textual">XProc “Choose” Pipeline</textual></title><programlisting class="po-block e323 e323" xml:space="preserve"><textual class="po-textual">&lt;p:pipeline xmlns:p="http://www.w3.org/ns/xproc"
            xmlns:a="http://example.com/a"
            xmlns:b="http://example.com/b"
            version='1.0'&gt;

&lt;p:choose&gt;
  &lt;p:when test="/a:*"&gt;
    &lt;p:xslt&gt;
      &lt;p:input port="stylesheet"&gt;
        &lt;p:document href="a2html.xsl"/&gt;
      &lt;/p:input&gt;
    &lt;/p:xslt&gt;
  &lt;/p:when&gt;
  &lt;p:when test="/b:*"&gt;
    &lt;p:xslt&gt;
      &lt;p:input port="stylesheet"&gt;
        &lt;p:document href="b2html.xsl"/&gt;
      &lt;/p:input&gt;
    &lt;/p:xslt&gt;
  &lt;/p:when&gt;
  &lt;p:otherwise&gt;
    &lt;p:identity/&gt;
  &lt;/p:otherwise&gt;
&lt;/p:choose&gt;

&lt;/p:pipeline&gt;
</textual></programlisting></figure><para class="po-block e324 e324"><textual class="po-textual">Translating it into our initial compact syntax produces
</textual><xref class="po-milestone e325 e325" linkend="choose.xpc1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e326 e326" xml:id="choose.xpc1"><title class="po-block e327 e327"><textual class="po-textual">XProc “Choose” Pipeline, Compact Syntax #1</textual></title><programlisting class="po-block e328 e328" xml:space="preserve"><textual class="po-textual">xproc 1.0

namespace a='http://example.com/a'
namespace b='http://example.com/b'

pipeline {
  choose {
    when "/a:*" {
      xslt {
        input "stylesheet" {
          document "a2html.xsl"
        }
      }
    }
    when "/b:*" {
      xslt {
        input "stylesheet" {
          document "b2html.xsl"
        }
      }
    }
    otherwise {
      identity
    }
  }
}
</textual></programlisting></figure><para class="po-block e329 e329"><textual class="po-textual">This is clearly a non-XML syntax, but it retains all of the semantic
flavor of the original. In the second XProc compact syntax, a choose statement
is represented using an if/then/else construct that's likely to be more familiar
to programmers, see </textual><xref class="po-milestone e330 e330" linkend="choose.xpc2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e331 e331" xml:id="choose.xpc2"><title class="po-block e332 e332"><textual class="po-textual">XProc “Choose” Pipeline, Compact Syntax #2</textual></title><programlisting class="po-block e333 e333" xml:space="preserve"><textual class="po-textual">namespace a: 'http://example.com/a'
namespace b: 'http://example.com/b'

pipeline {
  if (/a:*) {
    xslt ( stylesheet = document 'a2html.xsl' )
  } else if (/b:*) {
    xslt ( stylesheet = document 'b2html.xsl' )
  } else {
    identity
  }
}
</textual></programlisting></figure><para class="po-block e334 e334"><textual class="po-textual">Again, this manages to be both shorter and possibly more familiar.</textual></para><para class="po-block e335 e335"><textual class="po-textual">Whether or not either of these syntaxes would be markedly easier to use
or would spur greater adoption of XProc is an open question.</textual></para></section></section><appendix class="po-hcontainer e336 e336" xml:id="xpc1-grammar"><title class="po-block e337 e337"><textual class="po-textual">Grammar for XProc Compact Syntax #1</textual></title><programlisting class="po-block e338 e338" xml:space="preserve"><textual class="po-textual">document    ::= xpcMarker namespace* ( declareStep | pipeline | library ) EOF

xpcMarker   ::= 'xproc' version

version     ::= '1.0'

namespace   ::= ('namespace' prefix '=' quotedstr)
              | ('default' 'namespace' '=' quotedstr)

prefix      ::= NCName

declareStep ::= 'declare-step' stepName? withExtra? pipelineBody

stepName    ::= 'named' quotedstr

withExtra   ::= 'with' attr (',' attr)*

attr        ::= QName '=' (QName | quotedstr)

pipelineBody ::= '{'
     ( input | output | option | log | serialization )*
     ( declareStep | pipeline | imports )*
     subpipeline?
     '}'

input       ::= 'input' quotedstr withExtra? ( '{' binding* '}' )?

output      ::= 'output' quotedstr withExtra? ( '{' binding* '}' )?

option      ::= 'required' 'option' QName withExtra?
              | 'option' QName withExtra?

log         ::= 'log' quotedstr 'to' quotedstr

serialization ::= 'serialization' quotedstr withExtra?

imports     ::= 'import' quotedstr

variable    ::= 'variable' QName '=' quotedstr variableBody?

variableBody ::= '{' ( binding | namespaces )* '}'

namespaces  ::= 'namespaces' withExtra? nsBody?

nsBody      ::= '{' namespace '}'

binding     ::= ( comment | pi )*
                ( emptyBinding | documentBinding | dataBinding | pipeBinding | inlineBinding )

emptyBinding    ::= 'empty' withExtra?
documentBinding ::= 'document' quotedstr withExtra?
dataBinding     ::= 'data' quotedstr withExtra?
pipeBinding     ::= quotedstr 'on' quotedstr withExtra?
inlineBinding   ::= 'inline' withExtra? inlineXML

inlineXML       ::= '&lt;![XML[' Char* ']]&gt;'

subpipeline     ::= ( variable | documentation | pipeinfo | forEachStep | viewportStep
                     | chooseStep | tryStep | groupStep | atomicStep | comment | pi )+

documentation   ::= 'documentation' withExtra? '{' inlineXML '}'

pipeinfo        ::= 'pipeinfo' withExtra? '{' inlineXML '}'

named           ::= 'named' quotedstr

forEachStep     ::= 'for-each' named? withExtra? forEachBody

forEachBody     ::= '{' ( iterationSource | output | log )* subpipeline '}'

iterationSource ::= 'iteration-source' withExtra? ( '{' binding* '}' )?

viewportStep    ::= 'viewport' named? withExtra? viewportBody

viewportBody    ::= '{' ( viewportSource | output | log )* subpipeline '}'

viewportSource  ::= 'viewport-source' withExtra? ( '{' binding* '}' )?

chooseStep      ::= 'choose' named? withExtra? chooseBody

chooseBody      ::= '{' xpathContext? variable* whenStep* otherwiseStep? '}'

xpathContext    ::= 'xpath-context' withExtra? ( '{' binding* '}' )?

whenStep        ::= 'when' quotedstr withExtra? whenBody

whenBody        ::= ( xpathContext | output | log )* subpipeline

otherwiseStep   ::= 'otherwise' withExtra? otherwiseBody

otherwiseBody   ::= ( output | log )* subpipeline

tryStep         ::= 'try' named? withExtra? tryBody

tryBody         ::= '{' variable* groupStep catchStep '}'

groupStep       ::= 'group' named? withExtra? groupBody

groupBody       ::= '{' ( output | log )* subpipeline '}'

catchStep       ::= 'catch' named? withExtra? catchBody

catchBody       ::= '{' ( output | log )* subpipeline '}'

atomicStep      ::= ( 'add-xml-base' | 'add-attribute' | 'compare' | 'count' | 'delete'
                      | 'directory-list' | 'error' | 'escape-markup' | 'exec' | 'filter'
                      | 'hash' | 'http-request' | 'identity' | 'insert' | 'label-elements'
                      | 'load' | 'make-absolute-uris' | 'namespace-rename' | 'pack'
                      | 'parameters' | 'rename' | 'replace' | 'set-attributes' | 'sink'
                      | 'split-sequence' | 'store' | 'string-replace' | 'unescape-markup'
                      | 'unwrap' | 'uuid' | 'validate-with-relax-ng'
                      | 'validate-with-schematron' | 'validate-with-xml-schema'
                      | 'wrap' | 'wrap-sequence' | 'www-form-urldecode' | 'www-form-urlencode'
                      | 'xinclude' | 'xquery' | 'xslt' | 'xsl-formatter' )
                    named? withExtra? atomicStepBody?
                  | CName named? withExtra? atomicStepBody?

atomicStepBody  ::= '{' ( input | withOption | withParam | log )* '}'

withOption      ::= 'with-option' QName '=' quotedstr withExtra? withOptionBody?

withOptionBody  ::= '{' ( binding | namespaces )* '}'

withParam       ::= 'with-param' QName '=' quotedstr withExtra? withParamBody?

withParamBody   ::= '{' ( binding | namespaces )* '}'

pipeline        ::= 'pipeline' named? withExtra? pipelineBody

library         ::= 'library' withExtra? libraryBody

libraryBody     ::= '{' ( imports | declareStep | pipeline )* '}'

</textual><textual class="po-textual">

EOF ::= $

comment  ::= '&lt;!--' ( ( Char - '-' ) | '-' ( Char - '-' ) )* '--&gt;'
pi       ::= '&lt;?' pitarget ( S ( [^?] | '?'+ [^?&gt;] )* '?'* )? '?&gt;' /* ws: explicit */
pitarget ::= NCName
S        ::= ( #x0020 | #x0009 | #x000D | #x000A )+ /* ws: definition */

quotedstr ::= '"' ( [^"] )* '"'
            | "'" ( [^'] )* "'"

NameStartChar
         ::= [A-Z]
           | '_'
           | [a-z]
           | [#x00C0-#x00D6]
           | [#x00D8-#x00F6]
           | [#x00F8-#x02FF]
           | [#x0370-#x037D]
           | [#x037F-#x1FFF]
           | [#x200C-#x200D]
           | [#x2070-#x218F]
           | [#x2C00-#x2FEF]
           | [#x3001-#xD7FF]
           | [#xF900-#xFDCF]
           | [#xFDF0-#xFFFD]
NameChar ::= NameStartChar
           | '-'
           | '.'
           | [0-9]
           | #x00B7
           | [#x0300-#x036F]
           | [#x203F-#x2040]
NCName   ::= NameStartChar NameChar*
CName    ::= (NCName ':' NCName)
QName    ::= NCName | CName

Char     ::= [#x0021-#xD7FF]
           | [#xE000-#xFFFD]
           | [#x10000-#x10FFFF]

</textual></programlisting></appendix><appendix class="po-hcontainer e339 e339" xml:id="implementation"><title class="po-block e340 e340"><textual class="po-textual">Implementation</textual></title><para class="po-block e341 e341"><emphasis class="po-inline e342 e342"><textual class="po-textual">XML Calabash</textual></emphasis><textual class="po-textual"> implements both compact syntaxes
in the same way.</textual></para><orderedlist class="po-table e343 e343"><listitem class="po-container e344 e344"><para class="po-block e345 e345"><textual class="po-textual">The EBNF for the compact syntax is compiled into an XQuery module
using the </textual><emphasis class="po-inline e346 e346"><textual class="po-textual">REx Parser Generator</textual></emphasis><textual class="po-textual">. The XQuery module
produces an XML parse tree for the input pipeline.
</textual></para></listitem><listitem class="po-container e347 e347"><para class="po-block e348 e348"><textual class="po-textual">An XSLT stylesheet is written which transforms the XML parse tree
into standard XProc.</textual></para></listitem><listitem class="po-container e349 e349"><para class="po-block e350 e350"><textual class="po-textual">These two steps are combined into a pipeline,
</textual><xref class="po-milestone e351 e351" linkend="xpc1toxpl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, which is used to transform the input document
into XProc which is then executed normally.</textual></para><para class="po-block e352 e352"><textual class="po-textual">This mechanism may not be particularly efficient, but it is quite
easy to write as a proof-of-concept.</textual></para></listitem></orderedlist><figure class="po-container e353 e353" xml:id="xpc1toxpl"><title class="po-block e354 e354"><textual class="po-textual">XProc Pipeline for Converting XPC to XPL</textual></title><programlisting class="po-block e355 e355" xml:space="preserve"><textual class="po-textual">&lt;p:pipeline xmlns:p="http://www.w3.org/ns/xproc" version="1.0"&gt;

&lt;p:xquery&gt;
  &lt;p:input port="query"&gt;
    &lt;p:data href="xpc1.xqy"/&gt;
  &lt;/p:input&gt;
&lt;/p:xquery&gt;

&lt;p:xslt version="2.0"&gt;
  &lt;p:input port="stylesheet"&gt;
    &lt;p:document href="xpc1.xsl"/&gt;
  &lt;/p:input&gt;
&lt;/p:xslt&gt;

&lt;/p:pipeline&gt;
</textual></programlisting></figure></appendix><bibliography class="po-hcontainer e356 e356"><title class="po-block e357 e357"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e358 e358" xml:id="carrot"><textual class="po-textual">
Lenz, Evan. “Carrot: An appetizing hybrid of XQuery and XSLT.” Presented at
Balisage: The Markup Conference 2011, Montréal, Canada, August 2 - 5, 2011. In
</textual><emphasis class="po-inline e359 e359"><textual class="po-textual">Proceedings of Balisage: The Markup Conference 2011</textual></emphasis><textual class="po-textual">.
Balisage Series on Markup Technologies, vol. 7 (2011).
doi:</textual><biblioid class="po-atom e360 doi e360"><textual class="po-textual">10.4242/BalisageVol7.Lenz01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e361 e361" xml:id="rex"><textual class="po-textual">
Rademacher, Gunther. “REx Parser Generator”,
http://www.bottlecaps.de/rex/</textual></bibliomixed><bibliomixed class="po-block e362 e362" xml:id="xmlcalabash"><textual class="po-textual">
Walsh, Norman. “XML Calabash”,
http://xmlcalabash.com/</textual></bibliomixed></bibliography></article></classedDocument>