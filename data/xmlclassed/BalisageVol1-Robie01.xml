<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">The Apache Qpid XML Exchange</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">High speed, reliable enterprise messaging using open standards and open source</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2008</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 12 - 15, 2008</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">XML is widely used for messaging applications.  Message-oriented
Middleware (MOM) is a natural fit for XML messaging, but it has been
plagued by a lack of standards. Each vendor's system uses its own
proprietary protocols, so clients from one system generally can not
communicate with servers from another system.  Developers who are
drawn to XML because it is simple, open, interoperable, language
independent, and platform independent often use REST for messaging
because it shares the same virtues. When XML developers need
high-performance, guaranteed delivery, transactions, security,
management, asynchronous notification, or direct support for common
messaging paradigms like point-to-point, broadcast, request/response, and publish/subscribe,
they have been forced to sacrifice some of the virtues that drew them
to XML in the first place.  Java JMS is an API, defined only for Java,
and it does not define a wire protocol that would allow applications
running on different platforms or written in different languages to
interoperate. SOAP and Web Services offer interoperability if the same
underlying protocols are used and if the same WSI-protocol is used by
all parties, but at the cost of more complexity than a MOM system. And
as the basic components of enterprise messaging have been added piece
by piece to the original specifications, Web Services have become
complex, defined in a large number of overlapping specifications,
without a coherent and simple architecture.
</textual></para><para class="po-block e9 e9"><textual class="po-textual">The new Advanced Message Queueing Protocol (AMQP) is an open, language
independent, platform  independent standard for  enterprise messaging.
It provides  precisely the coherent  and simple architecture  that has
been missing for sophisticated  messaging applications.
Red Hat Enterprise MRG includes a multi-language, multi-platform, open
source implementation of AMQP. We develop the messaging component as
part of the upstream Apache Qpid project. In order to meet the needs
of XML messaging systems, we contributed the Apache Qpid XML Exchange,
which provides XQuery-based routing for XML content and message
properties.  Together, AMQP, Apache Qpid, and the Qpid XML Exchange
provide a solid foundation for mission critical XML messaging
applications.
</textual></para></abstract><author class="po-record e10 e10"><personname class="po-record e11 e11"><firstname class="po-field e12 e12"><textual class="po-textual">Jonathan</textual></firstname><surname class="po-field e13 e13"><textual class="po-textual">Robie</textual></surname></personname><personblurb class="po-container e14 e14"><para class="po-block e15 e15"><textual class="po-textual">Jonathan Robie designed and implemented the Apache Qpid XML
Exchange. He is a member of the Emerging Technologies team at Red Hat.
Jonathan is one of the inventors of XQuery, and is an editor of XQuery
1.1 and several other XQuery specifications. He received an Infoworld
Innovator 2005 award for his work on XQuery.</textual></para><para class="po-block e16 e16"><textual class="po-textual">Before joining Red Hat, Jonathan was the Program Manager for
DataDirect XQuery, and he has also worked on the architectural team
for three XML databases: Software AG's Tamino, Texcel, and POET's CMS.
He has also been an editor for specifications on the W3C XML Schema
and Document Object Model Working Groups.</textual></para></personblurb><email class="po-field e17 e17"><textual class="po-textual">jonathan.robie@redhat.com</textual></email><affiliation class="po-record e18 e18"><jobtitle class="po-field e19 e19"><textual class="po-textual">Emerging Technologies</textual></jobtitle><orgname class="po-block e20 e20"><textual class="po-textual">Red Hat</textual></orgname></affiliation></author><legalnotice class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Copyright © 2008 by the author.  Used with
permission.</textual></para></legalnotice></info><para class="po-block e23 e23"><textual class="po-textual">Modern software systems are often composed of many separate
programs working together. In simple cases, there may be a few
programs running on one computer; in more ambitious systems, many
programs may be running on various hardware and operating systems on
machines scattered across the world.

These programs may be developed in a variety of languages, including
both traditional programming languages and scripting languages, and
they may include legacy programs written long before there was a need
to communicate with other programs.

Programs may be distributed across an organization, or span the
boundaries of an organization to include key trading partners,
suppliers, and consumers. These programs need to share data, and many
of these programs represent that data as XML. From the very beginning,
XML was designed to make it easier for programs to exchange data,
independent of the languages, platforms, and underlying systems </textual><xref class="po-milestone e24 e24" linkend="Bosak"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, and it has been widely used as a way to exchange
data with existing proprietary systems.  But XML defines only the data
format, not the mechanism for exchanging documents among
programs.</textual></para><para class="po-block e25 e25"><textual class="po-textual">In many systems, the requirement is to support message transfer,
allowing one program to send a message that can be received by one or
more other programs. These messages may be simple notifications, or
part of a request/response, publish/subscribe, or similar
pattern. Message-oriented middleware (MOM) provides direct support for
sending and receiving messages, hiding the details of network
communication, and providing guaranteed delivery, high performance,
transactions, and a variety of other features.
Most MOM systems support asynchronous messaging between programs,
typically sending messages to message queues that store a message
until it is retrieved, even if the receiving program is busy or not
connected. These systems are often described using an email analogy -
a program can address a message and send it, or receive the messages
addressed to it.
Other MOM systems use multicast or broadcast messaging instead of or
in addition to asynchronous messaging.
</textual></para><para class="po-block e26 e26"><textual class="po-textual">Unfortunately, message-oriented Middleware has been plagued by a
lack of standards. Each vendor's system uses its own proprietary
protocols, so clients from one system generally can not communicate
with servers from another system. For Java programs, most systems
support the Java JMS API, but this is only an API, and does not define
a standard protocol that would allow communication across systems.

The Advanced Message Queuing Protocol (AMQP) </textual><xref class="po-milestone e27 e27" linkend="AMQP"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
was developed by a consortium of companies </textual><footnote class="po-popup e28 e28"><para class="po-block e29 e29"><textual class="po-textual">Cisco
Systems, Credit Suisse, Deutsche Börse Systems, Envoy Technologies,
Inc., Goldman Sachs, IONA Technologies PLC, iMatix Corporation sprl.,
JPMorgan Chase Bank Inc. N.A, Novell, Rabbit Technologies Ltd., Red
Hat, Inc., TWIST Process Innovations ltd, and 29West
Inc.</textual></para></footnote><textual class="po-textual"> to be an open standard for enterprise level
messaging. It is licensed to allow implementation on a perpetual,
worldwide, royalty-free basis, and will be submitted to a recognized
standards body.</textual><footnote class="po-popup e30 e30"><para class="po-block e31 e31"><textual class="po-textual">At the time of writing, it is not
possible to be more specific about the standards
submission.</textual></para></footnote><textual class="po-textual">

AMQP supports most common messaging idioms, including
request/response, point-to-point, publish/subscribe, and broadcast. It
has security, reliability, transactions, and other basic enterprise
messaging features built in.

AMQP defines a network protocol, which specifies what client
applications and message servers must send over the wire to
interoperate with each other. It also defines a protocol model, which
specifies the semantics an AMQP implementation must obey to be
interoperable with other implementations.  AMQP is already being used
in production systems, where it is serving very high message volumes;
for example, one bank has a worldwide deployment that delivers over
100 million messages per day in a 7 hour trading window in its Tokyo
hub.</textual></para><para class="po-block e32 e32"><textual class="po-textual">Red Hat Enterprise MRG </textual><xref class="po-milestone e33 e33" linkend="MRG"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> includes a multi-language,
multi-platform implementation of AMQP that provides enterprise level
messaging with guaranteed delivery, transaction management, queuing,
distribution, security, management and heterogeneous multi-platform
support. Client APIs include C++, Java, Python and C# for .NET. A JMS
API is also provided for JMS environments.  We develop the AMQP
implementation as part of the upstream Apache Qpid project </textual><xref class="po-milestone e34 e34" linkend="Qpid"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
</textual></para><para class="po-block e35 e35"><textual class="po-textual">The Apache Qpid XML Exchange is a messaging exchange
specifically designed for reliable, high performance XML messaging. In
the XML Exchange, message routing is specified in the broker (not in
the application), using XQuery, based on the content of XML messages,
message properties, or both. Queries can be as simple or as complex as
needed.

Clients can determine which documents they are interested in without
changing the applications that publish XML documents.

The Qpid XML Exchange was developed by Red Hat and contributed to the
Apache Qpid project.
</textual></para><para class="po-block e36 e36"><textual class="po-textual">
This article discusses the AMQP protocol, shows how to write a basic
messaging application in Apache Qpid, then shows how to write
messaging applications using the Qpid XML Exchange, using XQuery to
specify which messages should be routed to a queue. Finally, we make a
brief comparison between the technologies presented in this paper and
alternative technologies like REST, SOAP and Web Services, Java JMS,
ESB, and ebXML.
</textual></para><section class="po-hcontainer e37 e37"><title class="po-block e38 e38"><textual class="po-textual">Advanced Message Queueing Protocol</textual></title><subtitle class="po-block e39 e39"><textual class="po-textual">The AMQP Model</textual></subtitle><para class="po-block e40 e40"><textual class="po-textual">In the AMQP model, message producers write to exchanges, exchanges
route messages to queues, and message consumers read from queues. AMQP
allows modular architectures that cleanly separate the concerns of
each module; for instance, a message producer can write to an exchange
without knowing which queues its messages will be routed to, and a
message consumer can read from its queues without knowing anything
about the message producer or the exchange to which the message was
written.
</textual></para><para class="po-block e41 e41"><textual class="po-textual">Here are the basic components of the AMQP model:</textual></para><itemizedlist class="po-table e42 e42"><listitem class="po-container e43 e43"><para class="po-block e44 e44"><textual class="po-textual">A </textual><emphasis class="po-inline e45 e45" role="ital"><textual class="po-textual">message producer</textual></emphasis><textual class="po-textual"> is a program that
writes messages to an exchange. To do this, it creates a
</textual><emphasis class="po-inline e46 e46" role="ital"><textual class="po-textual">message</textual></emphasis><textual class="po-textual">, fills it with content, gives the
message a </textual><emphasis class="po-inline e47 e47" role="ital"><textual class="po-textual">routing key</textual></emphasis><footnote class="po-popup e48 e48"><para class="po-block e49 e49"><textual class="po-textual">For one
kind of exchange, the fanout exchange, a routing key is
optional</textual></para></footnote><textual class="po-textual">, and sends it to an exchange. The routing
key is simply a string that the exchange can use to determine to which
queues the message should be delivered</textual><footnote class="po-popup e50 e50"><para class="po-block e51 e51"><textual class="po-textual">The way the
routing key is used depends on the exchange type, and is discussed
later in this chapter</textual></para></footnote><textual class="po-textual">. </textual></para></listitem><listitem class="po-container e52 e52"><para class="po-block e53 e53"><textual class="po-textual">An </textual><emphasis class="po-inline e54 e54" role="ital"><textual class="po-textual">exchange</textual></emphasis><textual class="po-textual"> accepts messages from message producers and routes them to
message queues if the message meets the criteria expressed in a
binding.</textual></para></listitem><listitem class="po-container e55 e55"><para class="po-block e56 e56"><textual class="po-textual">A </textual><emphasis class="po-inline e57 e57" role="ital"><textual class="po-textual">binding</textual></emphasis><textual class="po-textual"> defines the relationship between an exchange and a
message queue, specifying which messages should be routed to a given
queue. For instance, a binding might state that all messages with a
given routing key should be sent to a particular queue. If a queue is
not bound to an exchange, it does not receive any messages from that
exchange.</textual></para></listitem><listitem class="po-container e58 e58"><para class="po-block e59 e59"><textual class="po-textual">A </textual><emphasis class="po-inline e60 e60" role="ital"><textual class="po-textual">message queue</textual></emphasis><textual class="po-textual"> holds messages and delivers them to the message
consumers that subscribe to the queue. A message queue may be durable,
which means that the queue is never lost; even if the messaging broker
were to suffer a hardware failure, the queue would be restored when
the broker is restarted. A message queue may be exclusive, which means
only one client can use it. A message queue may also be auto-delete,
which means that the queue will disappear from the server when the
last client unsubscribes from the queue.</textual></para></listitem><listitem class="po-container e61 e61"><para class="po-block e62 e62"><textual class="po-textual">A </textual><emphasis class="po-inline e63 e63" role="ital"><textual class="po-textual">message consumer</textual></emphasis><textual class="po-textual"> is a program
that reads messages from a message queue. A message consumer can
create, subscribe to, share, use, or destroy message queues and their
bindings (as long as it has have permission to do so).
</textual></para></listitem></itemizedlist><para class="po-block e64 e64"><textual class="po-textual">Before delivering a message, the message producer can influence
message handling characteristics by setting various message properties
in the message; for instance, one property determines whether the
message is durable. If a broker supports persistence, it guarantees
durable messages are never lost; even if the messaging broker were to
suffer a hardware failure, all durable messages would be delivered
when the broker is restarted. Another property can be used to specify
message priority; the broker gives higher priority messages precedence
over lower priority messages.  A message producer can use transactions
to ensure that a group of messages are all received. In a transaction,
messages and acknowledgements acknowledgements are batched together,
and all messages in the transaction succeed or fail as a unit.</textual></para><para class="po-block e65 e65"><textual class="po-textual">The exact way that a message is routed depends on the exchange
type. Here are the main exchange types in AMQP:</textual></para><itemizedlist class="po-table e66 e66"><listitem class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">A </textual><emphasis class="po-inline e69 e69" role="ital"><textual class="po-textual">fanout exchange</textual></emphasis><textual class="po-textual"> routes messages to every queue
bound to the exchange, ignoring the routing key.</textual></para></listitem><listitem class="po-container e70 e70"><para class="po-block e71 e71"><textual class="po-textual">A </textual><emphasis class="po-inline e72 e72" role="ital"><textual class="po-textual">direct exchange</textual></emphasis><textual class="po-textual"> routes a message only if
a queue's binding key is the same as the message's routing key.</textual></para></listitem><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">A </textual><emphasis class="po-inline e75 e75" role="ital"><textual class="po-textual">topic exchange</textual></emphasis><textual class="po-textual"> is similar to a Direct exchange, but it supports
multipart keys that contain multiple words separated by the “.”
delimiter; for instance, a message producer can create messages with
routing keys like usa.news, usa.weather, europe.news, and
europe.weather. Binding keys can include wildcard characters: a “#”
matches one or more words, a “*” matches a single word. Typical
bindings use binding keys like #.news (all news items), usa.# (all
items in the USA), or usa.weather (all usa weather items).</textual></para></listitem></itemizedlist><para class="po-block e76 e76"><textual class="po-textual">Any of the standard exchange types we have discussed in this
paragraph can be used for exchanging any kind of data, including
XML. Routing decisions are based on the exchange type and the routing
key only; none of these exhange types allow routing based on the
content of a message, and none has any direct support for XML.

The XML Exchange, which is the subject of this paper, is a custom
exchange type that lets programs use XQuery to specify routing for XML
messages. Before we discuss the XML Exchange, we will look at the code
needed for a simple and conventional AMQP program written in Python.
</textual></para></section><section class="po-hcontainer e77 e77"><title class="po-block e78 e78"><textual class="po-textual">Programming AMQP Applications with Apache Qpid</textual></title><para class="po-block e79 e79"><textual class="po-textual">
This section shows how to write a basic AMQP application using Apache
Qpid.  The examples in this section are written in Python and use the
direct exchange.  Like the other native AMQP exchanges, the direct
exchange works well for sending XML messages as long as routing
decisions are not made based on the content of the messages.
Applications that need to do routing based on the XML content of a
message use the XML exchange, which is presented in the following
section.
</textual></para><para class="po-block e80 e80"><textual class="po-textual">This application is composed of two programs:</textual></para><itemizedlist class="po-table e81 e81"><listitem class="po-container e82 e82"><para class="po-block e83 e83"><textual class="po-textual">A </textual><emphasis class="po-inline e84 e84" role="ital"><textual class="po-textual">message producer</textual></emphasis><textual class="po-textual"> that sends
messages to an exchange (which routes messages to the appropriate
message queue).</textual></para></listitem><listitem class="po-container e85 e85"><para class="po-block e86 e86"><textual class="po-textual">A </textual><emphasis class="po-inline e87 e87" role="ital"><textual class="po-textual">message consumer</textual></emphasis><textual class="po-textual"> that creates
a message queue, binds the queue to the exchange, then reads messages
that are sent to its queue.</textual></para></listitem></itemizedlist><para class="po-block e88 e88"><textual class="po-textual">
In this application, messages are published to the direct exchange using the key
"routing_key". The first step is to establish a binding on the server to route
these messages to a queue called "message_queue":
</textual></para><programlisting class="po-block e89 e89" xml:space="preserve"><textual class="po-textual">
session.queue_declare(queue="message_queue")
session.exchange_bind(exchange="amq.direct", queue="message_queue", 
routing_key="routing_key")
</textual></programlisting><para class="po-block e90 e90"><textual class="po-textual">Before these lines can be invoked, the client must log in to the
server and create a session. Here is a complete program that uses the
above two lines to declare a queue:</textual></para><programlisting class="po-block e91 e91" xml:space="preserve"><textual class="po-textual">import qpid
from qpid.client import Client
from qpid.content import Content
from qpid.queue import Empty

#----- Initialization ----------------------------

#  Set parameters for login

host="127.0.0.1"
port=5672
amqp_spec="/usr/share/amqp/amqp.0-10-preview.xml"
user="guest"
password="guest"

#  Create a client and log in to the server.

client = Client(host, port, qpid.spec.load(amqp_spec))
client.start({"LOGIN": user, "PASSWORD": password})

session = client.session()
session.session_open()

#----- Main Body of Program-----------------------

session.queue_declare(queue="message_queue")
session.exchange_bind(exchange="amq.direct", queue="message_queue", 
routing_key="routing_key")

#----- Cleanup -----------------------------------

# Close the session before exiting so there are no open threads.

session.session_close()
</textual></programlisting><para class="po-block e92 e92"><textual class="po-textual">The following code publishes 10 messages to the direct exchange
using "routing_key" as the routing key. To create a full program,
simply replace the two lines in the main body of the previous example
with the following lines:</textual></para><programlisting class="po-block e93 e93" xml:space="preserve"><textual class="po-textual">
for i in range(10):
  message = Content("message " + str(i))
  message["routing_key"] = "routing_key"
  session.message_transfer(destination="amq.direct", content=message)
</textual></programlisting><para class="po-block e94 e94"><textual class="po-textual">Now let's write a program that reads messages from the message queue.
First, the client creates a local queue into which messages will
be read from the server, subscribes to the message queue on the
server, and activates the local queue to start receiving messages. It then reads messages off the queue and prints them::</textual></para><programlisting class="po-block e95 e95" xml:space="preserve"><textual class="po-textual">
local_queue_name = "local_queue"
local_queue = session.incoming(local_queue_name)

session.message_subscribe(queue="message_queue", destination=local_queue_name)
local_queue.start()

final = "That's all, folks!"   # In a message body, signals the last message
content = ""           # Content of the last message read

message = None
while content != final:
  message = local_queue.get(timeout=10)
  content = message.body
        session.message_accept(RangedSet(message.id)) # acknowledge message receipt
  print content
</textual></programlisting><para class="po-block e96 e96"><textual class="po-textual">This section introduced basic Apache Qpid messaging using a
direct exchange in python. For a more complete tutorial on Apache
Qpid, including point-to-point, broadcast, request-response, and
publish-subscribe applications, with persistence and transactions, in
Java JMS, C++, and Python, see the MRG Messaging Tutorial </textual><xref class="po-milestone e97 e97" linkend="MRGTutorial"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
</textual></para></section><section class="po-hcontainer e98 e98"><title class="po-block e99 e99"><textual class="po-textual">The Apache Qpid XML Exchange</textual></title><para class="po-block e100 e100"><textual class="po-textual">
The Qpid XML Exchange adds two basic capabilities to Apache Qpid: it
can route XML messages based on message content, and it can do more
sophisticated queries based on message properties. In both cases,
queries are expressed in XQuery.</textual></para><para class="po-block e101 e101"><textual class="po-textual">For a Qpid programmer, the main difference between an XML
Exchange and any other exchange is the message binding. In the XML
Exchange, an XQuery is provided to indicate which documents should be
routed for a given binding.</textual></para><section class="po-hcontainer e102 e102"><title class="po-block e103 e103"><textual class="po-textual">A Simple Example</textual></title><para class="po-block e104 e104"><textual class="po-textual">The following code declares an XML
exchange and uses an XQuery to specify that all messages with
odd-numbered ids should be routed to a queue named "message_queue":</textual></para><programlisting class="po-block e105 e105" xml:space="preserve"><textual class="po-textual">
session.exchange_declare(exchange="xml", type="xml")
session.queue_declare(queue="message_queue")

binding = {}
binding["xquery"] = "./message/id mod 2 = 1"

session.exchange_bind(exchange="xml", queue="message_queue", 
routing_key="routing_key", args=binding)
</textual></programlisting><para class="po-block e106 e106"><textual class="po-textual">A publisher can write XML messages to this message queue with no
knowledge of the query, it needs only the name of the XML exchange so
it can specify the destination:</textual></para><programlisting class="po-block e107 e107" xml:space="preserve"><textual class="po-textual">
for i in range(10):
  message = Content("&lt;message&gt;&lt;id&gt;" + i + "&lt;/id&gt;&lt;/message&gt;"))
  message["routing_key"] = "routing_key"
  session.message_transfer(destination="xml", content=message)
</textual></programlisting><para class="po-block e108 e108"><textual class="po-textual">A consumer needs no knowledge of the publisher or the XML
Exchange, it simply reads messages from its queue, as shown in the
previous section.</textual></para></section><section class="po-hcontainer e109 e109"><title class="po-block e110 e110"><textual class="po-textual">A Weather Alert</textual></title><subtitle class="po-block e111 e111"><textual class="po-textual">Time to go Sailing!</textual></subtitle><para class="po-block e112 e112"><textual class="po-textual">Now let's explore an application that uses the XML Exchange in a
publish/subscribe application using weather observations from the
National Oceanic and Atmospheric Administration's National Weather
Service </textual><xref class="po-milestone e113 e113" linkend="NWS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.  In this application, each
individual can set up a persistent queue, to which alerts are sent,
and identify weather conditions that should trigger an alert. For
instance, I like to sail small sailboats, and I live in Durham, NC, so
I might ask for a weather alert whenever it is really good weather for
sailing.</textual></para><para class="po-block e114 e114"><textual class="po-textual">This example is composed of two programs:</textual></para><itemizedlist class="po-table e115 e115"><listitem class="po-container e116 e116"><para class="po-block e117 e117"><textual class="po-textual">A </textual><emphasis class="po-inline e118 e118" role="ital"><textual class="po-textual">message producer</textual></emphasis><textual class="po-textual"> that sends
weather notifications in XML to an exchange (which routes messages to
the appropriate message queues).</textual></para></listitem><listitem class="po-container e119 e119"><para class="po-block e120 e120"><textual class="po-textual">A </textual><emphasis class="po-inline e121 e121" role="ital"><textual class="po-textual">message consumer</textual></emphasis><textual class="po-textual"> that creates
a message queue, binds the queue to the XML exchange using an XQuery
to indicate messages it wants to receive, then reads messages that are
sent to its queue.</textual></para></listitem></itemizedlist><para class="po-block e122 e122"><textual class="po-textual">In this application, a producer posts messages to an XML
exchange named "weather" in the National Weather Service's standard
XML format. Here is one message in that format:</textual></para><programlisting class="po-block e123 e123" xml:space="preserve"><textual class="po-textual">
&lt;current_observation version="1.0"
xsi:noNamespaceSchemaLocation="http://www.weather.gov/data/current_obscurrent_observation.xsd"&gt;
&lt;credit&gt;NOAA's National Weather Service&lt;/credit&gt;
&lt;credit_URL&gt;http://weather.gov/&lt;/credit_URL&gt;
&lt;image&gt;
&lt;url&gt;http://weather.gov/images/xml_logo.gif&lt;/url&gt;
&lt;title&gt;NOAA's National Weather Service&lt;/title&gt;
&lt;link&gt;http://weather.gov&lt;/link&gt;
&lt;/image&gt;
&lt;suggested_pickup&gt;15 minutes after the hour&lt;/suggested_pickup&gt;
&lt;suggested_pickup_period&gt;60&lt;/suggested_pickup_period&gt;
&lt;location&gt;Raleigh-Durham International Airport, NC&lt;/location&gt;
&lt;station_id&gt;KRDU&lt;/station_id&gt;
&lt;latitude&gt;35.88&lt;/latitude&gt;
&lt;longitude&gt;-78.78&lt;/longitude&gt;
&lt;observation_time&gt;Last Updated on Apr 21, 2:51 pm EDT&lt;/observation_time&gt;
&lt;observation_time_rfc822&gt;Mon, 21 Apr 2008 14:51:00 -0400 EDT&lt;/observation_time_rfc822&gt;
&lt;weather&gt;Mostly Cloudy&lt;/weather&gt;
&lt;temperature_string&gt;67 F (19 C)&lt;/temperature_string&gt;
&lt;temp_f&gt;67&lt;/temp_f&gt;
&lt;temp_c&gt;19&lt;/temp_c&gt;
&lt;relative_humidity&gt;57&lt;/relative_humidity&gt;
&lt;wind_string&gt;Variable at 7 MPH&lt;/wind_string&gt;
&lt;wind_dir&gt;Variable&lt;/wind_dir&gt;
&lt;wind_degrees&gt;999&lt;/wind_degrees&gt;
&lt;wind_mph&gt;6.9&lt;/wind_mph&gt;
&lt;wind_gust_mph&gt;NA&lt;/wind_gust_mph&gt;
&lt;pressure_string&gt;29.95" (1014.0 mb)&lt;/pressure_string&gt;
&lt;pressure_mb&gt;1014.0&lt;/pressure_mb&gt;
&lt;pressure_in&gt;29.95&lt;/pressure_in&gt;
&lt;dewpoint_string&gt;51 F (11 C)&lt;/dewpoint_string&gt;
&lt;dewpoint_f&gt;51&lt;/dewpoint_f&gt;
&lt;dewpoint_c&gt;11&lt;/dewpoint_c&gt;
&lt;heat_index_string&gt;NA&lt;/heat_index_string&gt;
&lt;heat_index_f&gt;NA&lt;/heat_index_f&gt;
&lt;heat_index_c&gt;NA&lt;/heat_index_c&gt;
&lt;windchill_string&gt;NA&lt;/windchill_string&gt;
&lt;windchill_f&gt;NA&lt;/windchill_f&gt;
&lt;windchill_c&gt;NA&lt;/windchill_c&gt;
&lt;visibility_mi&gt;10.00&lt;/visibility_mi&gt;
&lt;icon_url_base&gt;http://weather.gov/weather/images/fcicons/&lt;/icon_url_base&gt;
&lt;icon_url_name&gt;bkn.jpg&lt;/icon_url_name&gt;
&lt;two_day_history_url&gt;http://www.weather.gov/data/obhistory/KRDU.html&lt;/two_day_history_url&gt;
&lt;ob_url&gt;http://www.nws.noaa.gov/data/METAR/KRDU.1.txt&lt;/ob_url&gt;
&lt;disclaimer_url&gt;http://weather.gov/disclaimer.html&lt;/disclaimer_url&gt;
&lt;copyright_url&gt;http://weather.gov/disclaimer.html&lt;/copyright_url&gt;
&lt;privacy_policy_url&gt;http://weather.gov/notice.html&lt;/privacy_policy_url&gt;
&lt;/current_observation&gt;
</textual></programlisting><para class="po-block e124 e124"><textual class="po-textual">The message consumer is an application that allows me to
subscribe to this weather feed, specifying conditions for my alerts
based on the data available in such a message. On my little sailboats,
I especially like to sail when the local weather is at least 60
degrees Fahrenheit, the wind is between 7 and 15 miles per hour, and
the temperature is at least 10 degrees above the dewpoint (so it is
unlikely to rain). The application would have a GUI to allow me to
specify these kinds of conditions, and would generate an XQuery for
the XML binding. Here is a query that expresses these
conditions:</textual></para><programlisting class="po-block e125 e125" xml:space="preserve"><textual class="po-textual">
let $obs := ./current_observation
return $obs/station_id = 'KRDU'
   and $obs/wind_mph &gt;= 7
   and $obs/wind_mph &lt;= 20
   and $obs/temp_f &gt; 60
   and $obs/temp_f - $obs/dewpoint_f &gt;= 10
</textual></programlisting><para class="po-block e126 e126"><textual class="po-textual">Of course, this is very individual. My friend Jim has a 40 foot
sailboat in Clearwater, and his sailboat just starts to get moving at
speeds that would be very challenging in my little sailboat. So he
might specify very different values for wind speeds. And I have other
friends whose weather-related interests have nothing to do with
sailing - perhaps someone would simply like an alert when it looks
like it will rain. Each of us can declare an exclusive queue with a
binding that expresses which messages we are interested in, as
illustrated in the following code:</textual></para><programlisting class="po-block e127 e127" xml:space="preserve"><textual class="po-textual">
# Use a UUID as the name of the queue
# to guarantee a unique queue name
uuid = uuid()
session.queue_declare(queue=uuid, exclusive=True)

binding = {}
binding["xquery"] = """
  let $obs := ./current_observation
    return $obs/station_id = 'KRDU'
      and $obs/wind_mph &gt;= 7
      and $obs/wind_mph &lt;= 20
      and $obs/temp_f &gt; 60
      and $obs/temp_f - $obs/dewpoint_f &gt;= 10"""

session.exchange_bind(exchange="xml", queue="message_queue", 
routing_key="routing_key", args=binding)
</textual></programlisting></section><section class="po-hcontainer e128 e128"><title class="po-block e129 e129"><textual class="po-textual">Querying Message Properties</textual></title><para class="po-block e130 e130"><textual class="po-textual">When the data used by clients is flat, and clients are
interested in the same properties, a message producer can bind these
properties to a message so they can be accessed without parsing the
message content, which may be faster, since the message content need
not be parsed. When used in this way, the XML Exchange operates much
like Java JMS selectors.</textual></para><para class="po-block e131 e131"><textual class="po-textual">In the XQuery used for binding, message properties are bound as
external variables of type string. The query must declare these
external variables before using them.  The XML Exchange binds the
message properties to the corresponding variables before the query is
invoked. Here is the query from the previous example expressed using
message properties instead of XML message content:</textual></para><programlisting class="po-block e132 e132" xml:space="preserve"><textual class="po-textual">
declare variable $station_id as xs:string external;
declare variable $wind_mph as xs:string external;
declare variable $temp_mph as xs:string external;
$station_id = 'KRDU'
and xs:decimal($wind_mph) &gt;= 7
and xs:decimal($wind_mph) &lt;= 20
and xs:decimal($temp_f) &gt; 60
and xs:decimal($temp_f) - xs:decimal($dewpoint_f) &gt;= 10
</textual></programlisting><para class="po-block e133 e133"><textual class="po-textual">Properties and XML content can both be used in the same
query. In the following query, the station identifier is read from the
message content, but the wind speed and temperature are read from
message properties:</textual></para><programlisting class="po-block e134 e134" xml:space="preserve"><textual class="po-textual">
declare variable $wind_mph as xs:string external;
declare variable $temp_mph as xs:string external;
./current_observation/station_id = 'KRDU'
and xs:decimal($wind_mph) &gt;= 7
and xs:decimal($wind_mph) &lt;= 20
and xs:decimal($temp_f) &gt; 60
and xs:decimal($temp_f) - xs:decimal($dewpoint_f) &gt;= 10
</textual></programlisting></section><section class="po-hcontainer e135 e135"><title class="po-block e136 e136"><textual class="po-textual">XML Messaging in the REST/SOAP/ESB Landscape</textual></title><para class="po-block e137 e137"><textual class="po-textual">XML applications already have a bewildering number of choices
for exchanging data. Many applications already use REST </textual><xref class="po-milestone e138 e138" linkend="Fielding"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, SOAP </textual><xref class="po-milestone e139 e139" linkend="Soap1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> </textual><xref class="po-milestone e140 e140" linkend="Soap2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, ebXML </textual><xref class="po-milestone e141 e141" linkend="ebXML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Enterprise Service
Buses </textual><xref class="po-milestone e142 e142" linkend="ESBWiki"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Java JMS Messaging </textual><xref class="po-milestone e143 e143" linkend="JMS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, or any one of the dozens of other available choices
now available. Each of these sytems has advantages and disadvantages,
and a thorough comparison to these systems is beyond the scope of this
paper. This section attempts to point out some of the fundamental
design characteristics of AMQP and the XML Exchange to make it easier
for readers to make their own comparisons.</textual></para><para class="po-block e144 e144"><textual class="po-textual">Like REST, AMQP is simple</textual><footnote class="po-popup e145 e145"><para class="po-block e146 e146"><textual class="po-textual">Though not as simple as
REST!</textual></para></footnote><textual class="po-textual">, open, platform independent, and programming
language independent. However, REST is designed only for client/server
request/response interaction, and because it relies on HTTP, it is a
synchronous protocol. AMQP supports request/response together with
other common patterns such as point-to-point, broadcast, and
publish-subscribe, which allows it to define communication among
messaging clients, not just communication to a server. AMQP is an
asynchronous protocol, which is much more suitable for
high-performance systems, though synchronous patterns are also
supported in the Qpid APis.</textual></para><para class="po-block e147 e147"><textual class="po-textual">Java JMS provides broad support for these kinds of messaging
patterns, but it is a Java API, with no support for other languages,
and it does not define an interoperable protocol, allowing each
implementation choose how to exchange data. As a result, Java JMS does
not provide interoperability across languages or across messaging
systems.</textual></para><para class="po-block e148 e148"><textual class="po-textual">SOAP and Web Services support many of the same messaging
patterns as AMQP, are language and platform independent, and can also
be used to achieve interoperable messaging if all parties agree on the
communication protocol and on a given WS-I profile. AMQP is smaller in
scope and more narrowly focused on messaging per se; it is designed to
be as simple as possible while still providing robust and complete
support for messaging. An AMQP server would probably be an excellent
basis for implementing a SOAP server. Unlike SOAP, AMQP message
headers and basic routing information are not contained in XML. This
allows more efficient processing, since XML parsing is slow compared
to the speed with which routing decisions are made in high-performance
messaging systems, and it also cleanly separates message content from
envelope information.</textual><footnote class="po-popup e149 e149"><para class="po-block e150 e150"><textual class="po-textual">Message properties can be read
from messages in applications that want this information. An
application could easily model them as XML.</textual></para></footnote><textual class="po-textual"> Another
difference is that XML is just one of the formats supported by AMQP,
and messages can be in any desired format (but the XML Exchange was
designed for XML messages). Another advantage of AMQP is that there is
just one specification, and only one way to claim conformance, so
interoperability does not require agreeing on specific protocols. This
is simpler and more interoperable than the SOAP family of
specifications </textual><xref class="po-milestone e151 e151" linkend="WSActivity"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> </textual><xref class="po-milestone e152 e152" linkend="Oasis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
</textual><xref class="po-milestone e153 e153" linkend="WS-I"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, which specify basic messaging functionality in
a variety of unrelated and overlapping specifications, from different
organizations, while other organizations specify profiles that can be
used for interoperability.</textual></para><para class="po-block e154 e154"><textual class="po-textual">Much of what was said in the previous paragraph also applies to
ebXML. AMQP would be an excellent technology for implementing ebXML
messaging, and can be used as a bridging technology between ebXML
systems and other systems. But AMQP does not attempt to address
anything beyond messaging.</textual></para><para class="po-block e155 e155"><textual class="po-textual">Similarly, an Enterprise Service Bus generally refers to a more
complex system build on top of an enterprise messaging system. AMQP is
such an enterprise messaging system. But XML-based routing is a
prominent feature in some ESB systems, and the XML Exchange provides
this feature, inegrated into an AMQP server.</textual></para></section><section class="po-hcontainer e156 e156"><title class="po-block e157 e157"><textual class="po-textual">Summary</textual></title><para class="po-block e158 e158"><textual class="po-textual">AMQP provides a coherent, simple architecture for high
performance, reliable messaging that is interoperable across
implementations and supports most common messaging paradigms. Apache
Qpid is a multi-platform, multi-language implementation of AMQP.

The Qpid XML Exchange provides XML-based routing in an AMQP server,
using XQuery to express routing criteria based on message content and
message properties.

Together, they provide the simplicity of REST
together with the broad support for enterprise messaging that SOAP
aspires to achieve. They provide a solid foundation for mission
critical XML messaging applications, and vastly simplify the task of
writing XML messaging software.</textual></para></section></section><bibliography class="po-hcontainer e159 e159"><title class="po-block e160 e160"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e161 e161" xml:id="Bosak"><textual class="po-textual">
</textual><quote class="po-inline e162 e162"><textual class="po-textual">XML, Java, and the future of the Web</textual></quote><textual class="po-textual"> Jon Bosak, Sun Microsystems. Last revised 1997.03.10.
</textual><link class="po-inline e163 e163" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ibiblio.org/pub/sun-info/standards/xml/why/xmlapps.htm</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e164 e164" xml:id="Fielding"><textual class="po-textual">
</textual><quote class="po-inline e165 e165"><textual class="po-textual">Architectural Styles and the Design of Network-based Software
Architectures</textual></quote><textual class="po-textual">. Roy Thomas Fielding, 2000. DISSERTATION submitted in partial satisfaction of the requirements for the degree of DOCTOR OF PHILOSOPHY
in Information and Computer Science. University of California, Irvine.
</textual><link class="po-inline e166 e166" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e167 e167" xml:id="Vinoski"><textual class="po-textual">
"Advanced Message Queuing Protocol", Steve Vinoski. IEEE Internet Computing, vol. 10, no. 6, 2006, pp. 87-89.
</textual><link class="po-inline e168 e168" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://steve.vinoski.net/pdf/IEEE-Advanced_Message_Queuing_Protocol.pdf</textual></link><textual class="po-textual">. doi: </textual><biblioid class="po-atom e169 doi e169"><textual class="po-textual">10.1109/MIC.2006.116</textual></biblioid><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e170 e170" xml:id="AMQP"><textual class="po-textual">
AMQP: A General-Purpose Middleware Standard.  Copyright Cisco Systems,
Credit Suisse, Deutsche Börse Systems, Envoy Technologies,
Inc.,Goldman Sachs, IONA Technologies PLC, iMatix Corporation
sprl., JPMorgan Chase Bank Inc. N.A, Novell, Rabbit Technologies Ltd.,
Red Hat, Inc., TWIST Process Innovations ltd, and 29West Inc. 2006.
</textual><link class="po-inline e171 e171" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://jira.amqp.org/confluence/download/attachments/720900/amqp.0-10.pdf?version=1</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e172 e172" xml:id="Qpid"><textual class="po-textual">
Apache Qpid Project.
</textual><link class="po-inline e173 e173" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://cwiki.apache.org/qpid/</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e174 e174" xml:id="MRG"><textual class="po-textual">
Red Hat Enterprise MRG. </textual><link class="po-inline e175 e175" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.redhat.com/mrg/</textual></link><textual class="po-textual">.
</textual></bibliomixed><bibliomixed class="po-block e176 e176" xml:id="MRGTutorial"><textual class="po-textual">
Red Hat Enterprise MRG: MRG Messaging Tutorial. Available from </textual><link class="po-inline e177 e177" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.redhat.com/mrg/resources/</textual></link><textual class="po-textual">.
</textual></bibliomixed><bibliomixed class="po-block e178 e178" xml:id="XQueryREST"><textual class="po-textual">
</textual><quote class="po-inline e179 e179"><textual class="po-textual">An XQuery Servlet for RESTful Data Services</textual></quote><textual class="po-textual">,
Jonathan Robie.
</textual><link class="po-inline e180 e180" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://2006.xmlconference.org/proceedings/87/presentation.html</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e181 e181" xml:id="Soap1"><textual class="po-textual">
SOAP Version 1.2 Part 1: Messaging Framework (Second Edition).
W3C Recommendation 27 April 2007.
</textual><link class="po-inline e182 e182" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2007/REC-soap12-part1-20070427/</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e183 e183" xml:id="Soap2"><textual class="po-textual">
SOAP Version 1.2 Part 2: Adjuncts (Second Edition).
W3C Recommendation 27 April 2007.
</textual><link class="po-inline e184 e184" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2007/REC-soap12-part2-20070427/</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e185 e185" xml:id="WSActivity"><textual class="po-textual">
W3C Web Services Activity.
</textual><link class="po-inline e186 e186" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/2002/ws/</textual></link><textual class="po-textual">
Currently lists 15 W3C Recommendations for Web Services.
</textual></bibliomixed><bibliomixed class="po-block e187 e187" xml:id="Oasis"><textual class="po-textual">
OASIS. A full list of committees can be found at
</textual><link class="po-inline e188 e188" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.oasis-open.org/committees/</textual></link><textual class="po-textual">.
</textual></bibliomixed><bibliomixed class="po-block e189 e189" xml:id="WS-I"><textual class="po-textual">
Web Services Interoperability
Organization. </textual><link class="po-inline e190 e190" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://wsi-org</textual></link><textual class="po-textual">. Currently lists the
following profiles for interoperability: Basic Profile, Simple Soap
Binding Profile, Basic Security Profile, Reliable Secure Profile,
Kerberos Token Profile, REL Token Profile 1.0, SAML Token Profile.
</textual></bibliomixed><bibliomixed class="po-block e191 e191" xml:id="NWS"><textual class="po-textual">
National Weather Service, current observations in XML.
</textual><link class="po-inline e192 e192" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.nws.noaa.gov/data/current_obs/</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e193 e193" xml:id="JMS"><textual class="po-textual">
Java JMS. </textual><link class="po-inline e194 e194" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://java.sun.com/products/jms/</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e195 e195" xml:id="ebXML"><textual class="po-textual">
ebXML: Enabling a Global Electronic Market.
</textual><link class="po-inline e196 e196" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ebxml.org/</textual></link><textual class="po-textual">
</textual></bibliomixed><bibliomixed class="po-block e197 e197" xml:id="ESBWiki"><textual class="po-textual">
Enterprise service bus.
From Wikipedia, the free encyclopedia.
</textual><link class="po-inline e198 e198" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/Enterprise_service_bus</textual></link><textual class="po-textual">
</textual></bibliomixed></bibliography></article></classedDocument>