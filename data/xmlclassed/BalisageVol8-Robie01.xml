<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">XQuery, XSLT and JSON</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Adapting the XML stack for a world of XML, HTML, JSON and JavaScript</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">XML and JSON have become the dominant formats for
      exchanging data on the Internet, and applications frequently
      need to send and receive data in many different JSON-based or
      XML-based formats, consuming or producing data in JSON, XML, or
      HTML. JSON has not yet developed an application stack as mature
      as the XML application stack; for instance, there is still no
      standard query language, transformation language, or schema
      language. 

      And the XML application stack has not yet evolved to
      easily process JSON.</textual></para><para class="po-block e9 e9"><textual class="po-textual">There are several areas where the XML stack should evolve
      to better support developers who work with JSON together with
      XML, and the features needed to support JSON in XQuery and XSLT
      also provide data structures that simplify writing queries and
      transformations, and allow more efficient processing of
      intermediate results when processing XML. As JSON becomes
      increasingly common in databases, and is exchanged among
      servers, these same kinds of tools may even become important in
      environments that use only JSON.</textual></para><para class="po-block e10 e10"><textual class="po-textual">This paper focuses on queries and transformations, looking
      at JSON support in several NoSQL databases, the JSONiq proposal
      (which adds JSON objects and arrays to XQuery), and the XSLT
      maps proposal (which adds maps that can represent JSON objects
      and arrays).

      At the time of writing, the W3C XML Query Working Group and the
      W3C XSL Working Group are considering several proposals for
      supporting JSON.  

      The Working Groups expect to agree on a common solution that can
      be used in both XSLT and XQuery.</textual></para></abstract><author class="po-record e11 e11"><personname class="po-record e12 e12"><firstname class="po-field e13 e13"><textual class="po-textual">Jonathan</textual></firstname><surname class="po-field e14 e14"><textual class="po-textual">Robie</textual></surname></personname><personblurb class="po-container e15 e15"><para class="po-block e16 e16"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><email class="po-field e17 e17"><textual class="po-textual">jonathan.robie@emc.com</textual></email></author><legalnotice class="po-container e18 e18"><para class="po-block e19 e19"><textual class="po-textual">Creative Commons attribution 3.0 unported (</textual><link class="po-inline e20 e20" xlink:actuate="onRequest" xlink:href="http://www.creativecommons.org/licenses/by/3.0/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://creativecommons.org/licenses/by/3.0/</textual></link><textual class="po-textual">)</textual></para></legalnotice></info><section class="po-hcontainer e21 e21"><title class="po-block e22 e22"><textual class="po-textual">Introduction</textual></title><para class="po-block e23 e23"><textual class="po-textual">In the early days of XML, many in the XML community saw it
    as a universal format that would be used to represent most kinds
    of data exchanged among programs, allowing many different kinds of
    information to be processed in the same way.</textual></para><blockquote class="po-container e24 e24"><para class="po-block e25 e25"><textual class="po-textual">XML provides a way to label information from diverse
      data sources including structured and semi-structured
      documents, relational databases, and object
      repositories.</textual></para><para class="po-block e26 e26"><textual class="po-textual">The Extensible Markup Language, XML, is having a
      profoundly unifying effect on diverse forms of
      information. For the first time, XML provides an information
      interchange format that is editable, easily parsed, and
      capable of representing nearly any kind of structured or
      semi-structured information.</textual></para><attribution class="po-block e27 e27"><citation class="po-atom e28 e28"><textual class="po-textual">"Quilt: An XML Query Language for Heterogeneous Data Sources", 2000.</textual></citation><textual class="po-textual">
      </textual></attribution></blockquote><para class="po-block e29 e29"><textual class="po-textual">But less than a decade after XML 1.0 became a W3C
    Recommendation, some people were concluding that XML was not the
    best way to exchange traditional program data on the
    Internet.</textual></para><blockquote class="po-container e30 e30"><para class="po-block e31 e31"><textual class="po-textual">Unfortunately, XML is not well suited to
      data-interchange, much as a wrench is not well-suited to
      driving nails. It carries a lot of baggage, and it doesn't
      match the data model of most programming languages. When
      most programmers saw XML for the first time, they were
      shocked at how ugly and inefficient it was. It turns out
      that that first reaction was the correct one. There is
      another text notation that has all of the advantages of XML,
      but is much better suited to data-interchange. That notation
      is JavaScript Object Notation (JSON).</textual></para><para class="po-block e32 e32"><textual class="po-textual">JSON is a better data exchange format. XML is a better
      document exchange format. Use the right tool for the right
      job.</textual></para><attribution class="po-block e33 e33"><citation class="po-atom e34 e34"><textual class="po-textual">"JSON: The Fat-Free Alternative to XML", 2006.</textual></citation></attribution></blockquote><para class="po-block e35 e35"><textual class="po-textual">In many environments, XML and HTML are used to represent
    documents, and JSON is used for traditional data exchange. As more
    and more data is exchanged, stored, and queried as JSON, XML tools
    need to evolve to allow JSON and XML to be processed together.

    And adding support for JSON is useful even for XML data, because
    JSON's data structures are sorely missing in both XSLT and XQuery,
    and can simplify many transformations and queries.</textual></para><para class="po-block e36 e36"><textual class="po-textual">This paper explores how an XML stack can be adapted to support
    a world of HTML5, JavaScript, and JSON, then explores two existing
    proposals that provide support for JSON: (1) the XSLT 3.0 maps
    proposal, which adds maps to XSLT and provides functions to convert
    JSON to and from these maps, and (2) JSONiq, which extends XQuery to
    add JSON objects and arrays. After that, a comparison of the two
    proposals is given, along with some thoughts about the issues that
    should be resolved as the W3C XSL Working Group and the W3C XML
    Query Working Group seek to develop a common proposal.</textual></para><para class="po-block e37 e37"><textual class="po-textual">This talk represents the views of the author, not those of
    EMC Corporation, the W3C, or the XML Working Group. Most of these
    views were formed in conversation with Dana Florescu, Michael Kay,
    Ghislain Fourney, John Snelson, Mary Holstege, Matthias Brantner,
    Till Westmann, Andrew Eisenberg, and others whose views continue
    to inform me.</textual></para></section><section class="po-hcontainer e38 e38"><title class="po-block e39 e39"><textual class="po-textual">The Web in 2012: HTML5, JavaScript, and JSON</textual></title><para class="po-block e40 e40"><textual class="po-textual">The XML community has long argued that programs should
    exchange both documents and program data using text-based data
    formats that are readable, platform-neutral, based on open
    standards, separate presentation from content, and are
    optimized for data reuse and long-term storage of data. This
    argument has largely been won. However, XML is only one of
    several formats that are being used for this purpose.</textual></para><para class="po-block e41 e41"><textual class="po-textual">In the early days of XML, many spoke of it as a
    </textual><quote class="po-inline e42 e42"><textual class="po-textual">universal data format</textual></quote><textual class="po-textual">, or a </textual><quote class="po-inline e43 e43"><textual class="po-textual">universal
    hub format</textual></quote><textual class="po-textual">, and some hoped that XHTML would finally
    unify the Web, with XML as the foundation. But XHTML was not
    well supported by some browsers, and was never widely accepted
    as a replacement for HTML 4. Instead, the HTML community has
    moved strongly in the direction of HTML5.

    Even for data exchange, many JavaScript programmers decided
    that XML was too difficult to use in JavaScript programs,
    opting for JSON instead. While XML won the argument that data
    should be exchanged using text-based formats with the
    characteristics listed above, we now have three dominant
    formats: HTML, XML, and JSON. They are frequently used
    together. Few tools are designed to work equally well with all
    three formats, but many developers are expected to.</textual></para><para class="po-block e44 e44"><textual class="po-textual">In recent years, the Web has been moving strongly in the
    direction of HTML5, JavaScript, and JSON
    and a new generation of databases, designed for distributed
    processing of massive amounts of data, uses JSON as the native
    data model. Ironically, JSON is now widely used for the
    very use cases highlighted in Jon Bosak's 1997 paper,
    </textual><quote class="po-inline e45 e45"><textual class="po-textual">XML, Java, and the future of the Web</textual></quote><textual class="po-textual">, which was
    written to promote XML. JSON was designed as a programming
    language-independent representation of typical programming
    language data structures, and in many languages, a simple
    library call can convert JSON to programming language
    structures, or programming language structures to JSON.  For
    this kind of data, JSON programming is dramatically simpler
    than XML programming, except when you need queries,
    transformations, or schema validation.</textual></para><para class="po-block e46 e46"><textual class="po-textual">But JSON does not exist in a vacuum, and it frequently
    needs to be used together with mixed content, typically
    represented as HTML or XML. A single application may often use
    several Web interfaces, some XML-based, others JSON-based, and
    combine data from the two, creating results in various
    formats. And even as XML becomes less common in Web
    interfaces, it continues to be important for documents and for
    managing and generating content on the server, to be combined
    with other data and exchanged in other formats. XML tools are
    particularly powerful for complex data integration tasks
    involving heterogeneous data, and they can handle HTML well,
    but they need to be extended to better support JSON. This will
    benefit both the JSON and XML communities.</textual></para><para class="po-block e47 e47"><textual class="po-textual">XML has a mature tool stack that does not yet exist for
    JSON, including schema languages, XSLT, and XQuery. Many XML
    developers find these tools sorely missing when they work with
    JSON, but it's not clear that the JSON community feels a strong
    need for most of these tools. Many query languages have been
    developed for JSON, a few schema languages and transformation
    languages have also been developed, but have not been widely
    used.</textual></para><para class="po-block e48 e48"><textual class="po-textual">Using schemas to enforce contracts is just as relevant for JSON as
    it is for XML, but there is little enthusiasm in the JSON
    community for schema languages, especially complex schema
    languages. JSON Schema, perhaps the most widely used JSON schema
    language, provided validation, and also added "formats", which
    allow for validation of simple types such as
    </textual><code class="po-atom e49 e49"><textual class="po-textual">date-time</textual></code><textual class="po-textual">, </textual><code class="po-atom e50 e50"><textual class="po-textual">date</textual></code><textual class="po-textual">, </textual><code class="po-atom e51 e51"><textual class="po-textual">time</textual></code><textual class="po-textual">,
    etc. JSON Schema is supported by several tools, and was written up
    as an IETF draft, but the draft expired in 2011.

    As a result, there is no standard way to support schema validation
    or validation of these data types in JSON. That makes it difficult
    for JSON interfaces to support declarative contracts via schemas.</textual></para><para class="po-block e52 e52"><textual class="po-textual">The JSON community generally believes that JSON frequently
    needs to be transformed to and from other formats, especially HTML
    and XML, but JSONT, a lightweight XSLT-like transformation
    language designed in 2006, does not seem to have gained much
    traction, nor have any of the alternatives that have emerged. This
    may be partly because JavaScript and many scripting languages are
    fairly powerful for many common simple transformations. A number
    of libraries and other approaches have emerged for using XSLT to
    transform JSON, and are popular in the XML community among those
    who also work with JSON; it is too early to tell how widely they
    will be adopted in the JSON community.</textual></para><para class="po-block e53 e53"><textual class="po-textual">Because NoSQL databases that use JSON as their native data
    model have gained significant traction in recent years, JSON query
    languages have gained much more traction, but no standard JSON
    query language has emerged. Standards are not as deeply embedded
    in JSON culture as they are in XML culture, and it is more
    difficult to gain agreement on a standard across the industry.

    A variety of approaches to querying JSON are used, including
    template-based queries (e.g. Mongo Query Language), SQL-like query
    languages (e.g. UnQL, HiveQL, YQL), procedural data flow languages
    (e.g. Pig Latin), functional data flow languages (e.g. Jaql), and
    simply using MapReduce libraries from conventional programming
    languages (e.g. Google BigTable).
    </textual></para><para class="po-block e54 e54"><textual class="po-textual">To support queries, these languages often extend JSON with
    additional data types, such as date, object id, binary data,
    regular expression, or more specific numeric types such as int32,
    int64, or double.
    </textual></para><para class="po-block e55 e55"><textual class="po-textual">The following queries illustrate the range of query
    languages that are used for querying JSON.</textual><footnote class="po-popup e56 e56"><para class="po-block e57 e57"><textual class="po-textual">A
    detailed comparison of these languages is beyond the scope of
    this paper.</textual></para></footnote></para><itemizedlist class="po-table e58 e58"><title class="po-block e59 e59"><textual class="po-textual">Queries in JSON Query Languages</textual></title><listitem class="po-container e60 e60"><para class="po-block e61 e61"><textual class="po-textual">Mongo Query Language: a template-based language for search/retrieval</textual><footnote class="po-popup e62 e62"><para class="po-block e63 e63"><textual class="po-textual">Example taken from </textual><xref class="po-milestone e64 e64" linkend="MQL"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote></para><programlisting class="po-block e65 e65" xml:space="preserve"><textual class="po-textual">
// select * from things where x=3 and y="foo"
db.things.find( { x : 3, y : "foo" } );

// select * where j&lt;&gt; 3 and k&gt;10
db.things.find({j: {$ne: 3}, k: {$gt: 10} });

// select * where a=1 or b=2 
db.foo.find( { $or : [ { a : 1 } , { b : 2 } ] } )
      </textual></programlisting></listitem><listitem class="po-container e66 e66"><para class="po-block e67 e67"><textual class="po-textual">UNQL: a SQL-based language</textual><footnote class="po-popup e68 e68"><para class="po-block e69 e69"><textual class="po-textual">Example taken from </textual><xref class="po-milestone e70 e70" linkend="UnQL"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote></para><programlisting class="po-block e71 e71" xml:space="preserve"><textual class="po-textual">
// An UPSERT:  Incrementing a counter on a webpage.
UPDATE abc SET abc.n=abc.n+1 WHERE abc.page=="/page/one"
  ELSE INSERT {page:"/page/one", n: 1, create_time: 1234567};
SELECT FROM abc;
      </textual></programlisting></listitem><listitem class="po-container e72 e72"><para class="po-block e73 e73"><textual class="po-textual">Pig Latin: a data flow language</textual><footnote class="po-popup e74 e74"><para class="po-block e75 e75"><textual class="po-textual">Example taken from </textual><xref class="po-milestone e76 e76" linkend="Pig"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote></para><programlisting class="po-block e77 e77" xml:space="preserve"><textual class="po-textual">
     VISITS = load '/visits' as (user, url, time);
USER_VISITS = group VISITS by user;
USER_COUNTS = foreach USER_VISITS generate group as user, COUNT(VISITS) as numvisits;
 ALL_COUNTS = group USER_COUNTS all;
  AVG_COUNT = foreach ALL_COUNTS generate AVG(USER_COUNTS.numvisits);

dump AVG_COUNT;
      </textual></programlisting></listitem><listitem class="po-container e78 e78"><para class="po-block e79 e79"><textual class="po-textual">HiveQL: a SQL-based data flow language</textual><footnote class="po-popup e80 e80"><para class="po-block e81 e81"><textual class="po-textual">Example taken from </textual><xref class="po-milestone e82 e82" linkend="Hive"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote></para><programlisting class="po-block e83 e83" xml:space="preserve"><textual class="po-textual">
INSERT OVERWRITE TABLE pv_gender_sum
SELECT pv_users.gender, count (DISTINCT pv_users.userid)
FROM pv_users
GROUP BY pv_users.gender;
      </textual></programlisting></listitem><listitem class="po-container e84 e84"><para class="po-block e85 e85"><textual class="po-textual">Jaql: a functional data flow language</textual><footnote class="po-popup e86 e86"><para class="po-block e87 e87"><textual class="po-textual">Example taken from </textual><xref class="po-milestone e88 e88" linkend="Jaql"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">.</textual></para><programlisting class="po-block e89 e89" xml:space="preserve"><textual class="po-textual">
import myrecord;
countFields = fn(records) (
  records
  -&gt; transform myrecord::names($)
  -&gt; expand
  -&gt; group by fName = $ as occurrences
  into { name: fName, num: count(occurrences) }
);
read(hdfs("docs.dat"))
  -&gt; countFields()
  -&gt; write(hdfs("fields.dat"));
      </textual></programlisting></listitem></itemizedlist></section><section class="po-hcontainer e90 e90"><title class="po-block e91 e91"><textual class="po-textual">Maps and Arrays, a missing piece in XQuery and XSLT</textual></title><para class="po-block e92 e92"><textual class="po-textual">Maps and arrays, under various names, are available in most
    modern programming languages, but until recently, they were
    absent from both XQuery and XSLT. This came from a basic design
    decision: XML is the complex data structure in these languages,
    and we felt that no other complex data structure was
    needed. While this worked well for most things, it made some
    kinds of queries and transformations needlessly complex for users
    to write, and complicated the design of the languages.</textual></para><para class="po-block e93 e93"><textual class="po-textual">Maps and arrays are simple data structures, much simpler
    than XML, and adding them to XQuery and XSLT does not greatly
    change the complexity of the two languages. And maps and arrays
    add significant new features to both languages:</textual></para><itemizedlist class="po-table e94 e94"><listitem class="po-container e95 e95"><para class="po-block e96 e96"><textual class="po-textual">Lightweight data structures that do not have
      the overhead associated with namespace processing, element
      construction, order preservation, or whitespace processing
      rules.</textual></para></listitem><listitem class="po-container e97 e97"><para class="po-block e98 e98"><textual class="po-textual">Data structures that can associate additional
      data with an node, without losing the original identity of the
      node. This is particularly helpful in function parameters and
      returns. (Element construction in XQuery and XSLT loses the
      original identity of the items used to construct the
      element.)</textual></para></listitem><listitem class="po-container e99 e99"><para class="po-block e100 e100"><textual class="po-textual">Nested arrays that can represent multiple
      sequences returned from a function, mathematical matrices,
      sparse matrices, etc.</textual></para></listitem><listitem class="po-container e101 e101"><para class="po-block e102 e102"><textual class="po-textual">Data structures that can be used to describe
      intermediate results of XQuery expressions, such as the tuple
      stream in FLWOR expressions. (The notation used to describe the
      tuple stream in the current XQuery specification could easily
      be changed to maps.)</textual></para></listitem></itemizedlist><para class="po-block e103 e103"><textual class="po-textual">All of these things can be simulated with XML, but doing so
    introduces conceptual overhead for those who write queries or
    transformations, and system overhead that can affect the
    efficiency of queries.</textual></para><para class="po-block e104 e104"><textual class="po-textual">If producing modified copies of a map is easy and
    efficient, maps add another useful feature: complex data
    structures that can track information encountered during a query
    or transformation. For instance, a reporting application can keep
    running totals and summaries by creating new map instances to
    reflect changing information.</textual></para></section><section class="po-hcontainer e105 e105"><title class="po-block e106 e106"><textual class="po-textual">The XSLT 3.0 Maps Proposal</textual></title><para class="po-block e107 e107"><textual class="po-textual">The XSLT 3.0 maps proposal, which is new in the July 2012
    Working Draft of XSLT, was motivated by streaming use cases,
    which require complex data structures that can be used to
    remember what has been seen in the document, and also provides
    support for JSON.  It extends the type system, data model, and
    syntax of XPath 3.0 to support maps, which are represented as
    function items in the data model.</textual><footnote class="po-popup e108 e108"><para class="po-block e109 e109"><textual class="po-textual">Because XPath 3.0 is jointly owned with the XML Query
    Working Group, the two Working Groups have committed to work
    together to create a joint proposal, but this is not yet
    reflected in any public document.</textual></para></footnote><textual class="po-textual">

    It does not provide explicit support for arrays, but supports
    similar functionality using maps with integer-valued keys.</textual></para><para class="po-block e110 e110"><textual class="po-textual">The XSLT proposal extends the syntax of XPath's
    </textual><code class="po-atom e111 e111"><textual class="po-textual">ItemType</textual></code><textual class="po-textual"> to allow support map types.</textual></para><programlisting class="po-block e112 e112" xml:space="preserve"><textual class="po-textual">MapType ::= 'map' '(' ( '*' | (AtomicOrUnionType ',' SequenceType) ')'</textual></programlisting><para class="po-block e113 e113"><textual class="po-textual">For instance, </textual><code class="po-atom e114 e114"><textual class="po-textual">MapType</textual></code><textual class="po-textual"> can be used to specify the type of a function parameter. Here is the signature of a function that uses a map to specify parsing options.</textual></para><programlisting class="po-block e115 e115" xml:space="preserve"><textual class="po-textual">parse-json($json-text  as xs:string, 
           $options as map(*)) as item()?</textual></programlisting><para class="po-block e116 e116"><textual class="po-textual">There is no way to declare the type of a map, and the type
    of a map depends on its current contents. For instance,
    </textual><code class="po-atom e117 e117"><textual class="po-textual">map(xs:integer, element(employee))</textual></code><textual class="po-textual"> matches a map if
    all the keys in the map are integers and all the values are
    employee elements. If a new entry with a different key type or
    value type is added, the type of the map changes.</textual></para><para class="po-block e118 e118"><textual class="po-textual">The maps proposal adds a new kind of primary expression to
    XPath in order to construct a map.</textual></para><programlisting class="po-block e119 e119" xml:space="preserve"><textual class="po-textual">MapExpr := "map" "{" (KeyExpr ":=" ValueExpr ("," KeyExpr ":=" ValueExpr )*)? "}"
KeyExpr := ExprSingle
ValueExpr := ExprSingle</textual></programlisting><para class="po-block e120 e120"><textual class="po-textual">Here is an example of a map expression: </textual><footnote class="po-popup e121 e121"><para class="po-block e122 e122"><textual class="po-textual">Most
    examples in this section are taken from </textual><xref class="po-milestone e123 e123" linkend="xslt30"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote></para><programlisting class="po-block e124 e124" xml:space="preserve"><textual class="po-textual">
map {
  "Su" := "Sunday",
  "Mo" := "Monday",
  "Tu" := "Tuesday",
  "We" := "Wednesday",
  "Th" := "Thursday",
  "Fr" := "Friday",
  "Sa" := "Saturday
}   </textual></programlisting><para class="po-block e125 e125"><textual class="po-textual">The following map uses integer-valued keys, and is analogous to an array.</textual></para><programlisting class="po-block e126 e126" xml:space="preserve"><textual class="po-textual">
map {
  0 := "Sonntag", 
  1 := "Montag", 
  2 := "Dienstag", 
  3 := "Mittwoch", 
  4 := "Donnerstag", 
  5 := "Freitag", 
  6 := "Samstag"
}
     </textual></programlisting><para class="po-block e127 e127"><textual class="po-textual">In the XSLT 3.0 maps proposal, a map is a function from
     keys to associated values, and is represented as a function
     item. The function </textual><code class="po-atom e128 e128"><textual class="po-textual">map:get($map, $key)</textual></code><textual class="po-textual"> returns the
     value associated with a given key.

     The function signature for a map is </textual><code class="po-atom e129 e129"><textual class="po-textual">function($key as
     xs:anyAtomicValue) as item()*</textual></code><textual class="po-textual">, and calling a map function
     returns the value for that key (thus, </textual><code class="po-atom e130 e130"><textual class="po-textual">$map($key)</textual></code><textual class="po-textual"> is
     a synonym for </textual><code class="po-atom e131 e131"><textual class="po-textual">map:get($map, $key)</textual></code><textual class="po-textual">. If
     </textual><code class="po-atom e132 e132"><textual class="po-textual">$map</textual></code><textual class="po-textual"> is bound to the map shown above, the following
     expressions are equivalent, they each evaluate to "Tuesday".</textual></para><programlisting class="po-block e133 e133" xml:space="preserve"><textual class="po-textual">map:get($map,"Tu")</textual></programlisting><programlisting class="po-block e134 e134" xml:space="preserve"><textual class="po-textual">$map("Tu")</textual></programlisting><para class="po-block e135 e135"><textual class="po-textual">Maps have no identity; the contents of two maps can be
     compared, but there is no way to distinguish two maps with the
     same content.</textual></para><para class="po-block e136 e136"><textual class="po-textual">All values in XSLT are immutable, but functions are
     provided to create new maps that differ from an existing map by
     removing an entry, adding an entry, or changing the value of an
     entry.</textual></para><para class="po-block e137 e137"><textual class="po-textual">The following table provides a brief synopsis of the
     functions provided for maps.
     </textual></para><table class="po-container e138 e138"><caption class="po-container e139 e139"><para class="po-block e140 e140"><textual class="po-textual">Map functions in the XSLT 3.0 maps
       proposal</textual></para></caption><tbody class="po-table e141 e141"><tr class="po-table e142 e142"><td class="po-block e143 e143"><textual class="po-textual">map:new</textual></td><td class="po-block e144 e144"><textual class="po-textual">Creates a new map: either an empty
	 map, or a map that combines entries from a number of existing
	 maps. Allows a collation to be specified.</textual></td></tr><tr class="po-table e145 e145"><td class="po-block e146 e146"><textual class="po-textual">map:entry</textual></td><td class="po-block e147 e147"><textual class="po-textual">Creates a map that contains a
	 single key/value pair. Useful for creating maps with
	 </textual><code class="po-atom e148 e148"><textual class="po-textual">map:new</textual></code></td></tr><tr class="po-table e149 e149"><td class="po-block e150 e150"><textual class="po-textual">map:get</textual></td><td class="po-block e151 e151"><textual class="po-textual">Returns the value associated with a key.</textual></td></tr><tr class="po-table e152 e152"><td class="po-block e153 e153"><textual class="po-textual">map:keys</textual></td><td class="po-block e154 e154"><textual class="po-textual">Returns the keys found in a map.</textual></td></tr><tr class="po-table e155 e155"><td class="po-block e156 e156"><textual class="po-textual">map:contains</textual></td><td class="po-block e157 e157"><textual class="po-textual">Tests whether a supplied map contains an entry for a given key.</textual></td></tr><tr class="po-table e158 e158"><td class="po-block e159 e159"><textual class="po-textual">map:remove</textual></td><td class="po-block e160 e160"><textual class="po-textual">Constructs a new map by removing an entry from an existing map.</textual></td></tr><tr class="po-table e161 e161"><td class="po-block e162 e162"><textual class="po-textual">map:collation</textual></td><td class="po-block e163 e163"><textual class="po-textual">Returns the URI of a given map's collation.</textual></td></tr><tr class="po-table e164 e164"><td class="po-block e165 e165"><textual class="po-textual">fn:deep-equal2</textual></td><td class="po-block e166 e166"><textual class="po-textual">Determines whether two
	 sequences are deep-equal to each other; this function extends
	 </textual><code class="po-atom e167 e167"><textual class="po-textual">fn:deep-equal</textual></code><textual class="po-textual"> to support sequences that contain
	 maps.</textual></td></tr></tbody></table><para class="po-block e168 e168"><textual class="po-textual">The </textual><code class="po-atom e169 e169"><textual class="po-textual">map:new</textual></code><textual class="po-textual"> function is used to create new
     maps from existing ones by specifying a sequence of maps. The
     newly created map contains every key/value pair that occurs in
     one of these maps; if a given key occurs in more than one map,
     its value in the newly created map is taken from the last map
     that contains a value for this key. The following examples show how </textual><code class="po-atom e170 e170"><textual class="po-textual">map:new</textual></code><textual class="po-textual"> and </textual><code class="po-atom e171 e171"><textual class="po-textual">map:remove</textual></code><textual class="po-textual"> are used to create modified versions of maps.</textual></para><itemizedlist class="po-table e172 e172"><listitem class="po-container e173 e173"><para class="po-block e174 e174"><code class="po-atom e175 e175"><textual class="po-textual">map:new()</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e176 e176"><textual class="po-textual">map{ }</textual></code></para></listitem><listitem class="po-container e177 e177"><para class="po-block e178 e178"><code class="po-atom e179 e179"><textual class="po-textual">map:new((map:entry(0, "Sunntig"), map:entry(1, "Määntig")))</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e180 e180"><textual class="po-textual">map{0:="Sunntig",1:="Määntig"}</textual></code></para></listitem><listitem class="po-container e181 e181"><para class="po-block e182 e182"><code class="po-atom e183 e183"><textual class="po-textual">map:new((map{0:="Sunntig"},map{1:="Määntig",2:="Ziischtig"}))</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e184 e184"><textual class="po-textual">map{0:="Sunntig",1:="Määntig",2:="Ziischtig"}</textual></code></para></listitem><listitem class="po-container e185 e185"><para class="po-block e186 e186"><code class="po-atom e187 e187"><textual class="po-textual">map:new(map{0:="Sunntig",1:="Määntig",2:="Ziischtig"},map{0:="Sunday",2:="Dienstag"))</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e188 e188"><textual class="po-textual">map{0:="Sunday",1:="Määntig",2:="Dienstag"</textual></code></para></listitem><listitem class="po-container e189 e189"><para class="po-block e190 e190"><code class="po-atom e191 e191"><textual class="po-textual">let $m:=map{"count":=1} return map:new("count":$m("count")+1)</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e192 e192"><textual class="po-textual">map{"count":2}</textual></code></para></listitem><listitem class="po-container e193 e193"><para class="po-block e194 e194"><code class="po-atom e195 e195"><textual class="po-textual">map:remove(map{0:="Sunntig",1:="Määntig",2:="Ziischtig"}, 1)</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e196 e196"><textual class="po-textual">map{0:="Sunntig",2:="Ziischtig"}</textual></code></para></listitem></itemizedlist><para class="po-block e197 e197"><textual class="po-textual">The following example, taken from the XSLT 3.0 Working Draft, uses maps and </textual><code class="po-atom e198 e198"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual"> to find the highest earning employee in each department, in a single streaming pass of a document containing employee records.</textual></para><programlisting class="po-block e199 e199" xml:space="preserve"><textual class="po-textual">
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners" 
               as="map(xs:string, element(employee))" 
               select="map:new()"/&gt;
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
          select="let $existing := $highest-earners($this/department)
                  return if ($existing/salary gt $this/salary)
                         then $highest-earners
                         else map:new($highest-earners, 
                                      map:entry($this/department, $this))"/&gt;
    &lt;/xsl:next-iteration&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:stream&gt;</textual></programlisting><para class="po-block e200 e200"><textual class="po-textual">The XSLT maps proposal also adds two functions,
     </textual><code class="po-atom e201 e201"><textual class="po-textual">parse-JSON</textual></code><textual class="po-textual"> and </textual><code class="po-atom e202 e202"><textual class="po-textual">serialize-JSON</textual></code><textual class="po-textual">, that
     convert between serialized JSON and XSLT
     maps. </textual><code class="po-atom e203 e203"><textual class="po-textual">parse-JSON</textual></code><textual class="po-textual"> converts JSON arrays are converted
     to maps with integer-valued keys.
     </textual></para><itemizedlist class="po-table e204 e204"><listitem class="po-container e205 e205"><para class="po-block e206 e206"><code class="po-atom e207 e207"><textual class="po-textual">parse-json('{"x":1, "y":[3,4,5]}')</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e208 e208"><textual class="po-textual">map{"x":=1e0,"y":=map{1:=3e0,2:=4e0,3:=5e0}}</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e209 e209"><para class="po-block e210 e210"><code class="po-atom e211 e211"><textual class="po-textual">let $m := parse-json('{"x":1, "y":[3,4,5]}') return $m("y")(2)</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e212 e212"><textual class="po-textual">4e0</textual></code><textual class="po-textual">.</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e213 e213"><title class="po-block e214 e214"><textual class="po-textual">JSONiq: Extending XQuery with Maps and Arrays</textual></title><para class="po-block e215 e215"><textual class="po-textual">The JSONiq proposal extends XQuery to add support for
     JSON. It was primarily motivated by the need for a JSON query
     language, and the need for a single language that can query JSON,
     XML, and HTML. JSONiq extends the type system, data model, and
     syntax of XQuery to support JSON objects</textual><footnote class="po-popup e216 e216"><para class="po-block e217 e217"><textual class="po-textual">JSON
     calls maps objects, as does JavaScript. In this paper, the term
     object always refers to a map, rather than the objects used in
     the object oriented paradigm.</textual></para></footnote><textual class="po-textual"> and
     arrays. JSONiq defines two profiles: one is a strict superset of
     XQuery that adds support for JSON, the other is a pure JSON query
     language with no XML constructs.</textual></para><para class="po-block e218 e218"><textual class="po-textual">The following diagram shows JSONiq extensions to the data
     model in green.</textual></para><figure class="po-container e219 e219" xml:id="jdm"><title class="po-block e220 e220"><textual class="po-textual">JSONiq Data Model</textual></title><mediaobject class="po-container e221 e221"><imageobject class="po-container e222 e222"><imagedata class="po-meta e223 e223" fileref="../../../vol8/graphics/Robie01/Robie01-001.png" format="png" width="60%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e224 e224"><para class="po-block e225 e225"><code class="po-atom e226 e226"><textual class="po-textual">object</textual></code><textual class="po-textual"> represents a JSON object, </textual><code class="po-atom e227 e227"><textual class="po-textual">array</textual></code><textual class="po-textual"> represents a JSON array.  Both are derived from </textual><code class="po-atom e228 e228"><textual class="po-textual">json-item</textual></code><textual class="po-textual">. </textual><code class="po-atom e229 e229"><textual class="po-textual">structured-item</textual></code><textual class="po-textual"> is an abstract base class for both </textual><code class="po-atom e230 e230"><textual class="po-textual">node</textual></code><textual class="po-textual"> and </textual><code class="po-atom e231 e231"><textual class="po-textual">json-item</textual></code><textual class="po-textual">.</textual></para><para class="po-block e232 e232"><code class="po-atom e233 e233"><textual class="po-textual">json:null</textual></code><textual class="po-textual"> is an atomic data type that represents JSON nulls.</textual></para></caption></figure><para class="po-block e234 e234"><textual class="po-textual">Like XDM 3.0 nodes, a JSON item has identity, and it can
     be serialized. However, the identity of a JSON item is used only
     to support updates. Like XSLT maps, the contents of JSON items
     can be compared, but there is no way to distinguish two items
     with the same content.</textual></para><para class="po-block e235 e235"><textual class="po-textual">JSONiq extends the syntax of XPath's </textual><code class="po-atom e236 e236"><textual class="po-textual">ItemType</textual></code><textual class="po-textual">
     to support the types of JSON items.</textual></para><programlisting class="po-block e237 e237" xml:space="preserve"><textual class="po-textual">
StructuredItemTest ::= "structured-item" "(" ")"
JSONItemTest ::= "json-item" "(" ")"
JSONObjectTest ::= "object" "(" ")"
JSONArrayTest ::= "array" "(" ")"
     </textual></programlisting><para class="po-block e238 e238"><textual class="po-textual">For instance, a </textual><code class="po-atom e239 e239"><textual class="po-textual">JSONItemTest</textual></code><textual class="po-textual"> can be used to declare the type of a function parameter or return.</textual></para><programlisting class="po-block e240 e240" xml:space="preserve"><textual class="po-textual">declare function local:summary($o as object()) as array()
{
};</textual></programlisting><para class="po-block e241 e241"><textual class="po-textual">JSONiq adds primary expressions to construct objects and arrays.</textual></para><programlisting class="po-block e242 e242" xml:space="preserve"><textual class="po-textual">
ObjectConstructor ::=  "{" PairConstructor ("," PairConstructor)* "}"      
PairConstructor ::=  ExprSingle ":" ExprSingle
ArrayConstructor ::=  "[" Expr? "]"
     </textual></programlisting><para class="po-block e243 e243"><textual class="po-textual">Here is an example of a JSON object that contains an array.</textual></para><programlisting class="po-block e244 e244" xml:space="preserve"><textual class="po-textual">{
  "name" : "Sarah",
  "age" : 13,
  "gender" : "female",
  "friends" : [ "Jim", "Mary", "Jennifer"]
}    </textual></programlisting><para class="po-block e245 e245"><textual class="po-textual">Arrays can nest.</textual></para><programlisting class="po-block e246 e246" xml:space="preserve"><textual class="po-textual">
[
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
     </textual></programlisting><para class="po-block e247 e247"><textual class="po-textual">Both objects and arrays compose with existing XQuery expressions; for instance, the following example uses an XQuery range expression to construct an array containing five integers:</textual></para><programlisting class="po-block e248 e248" xml:space="preserve"><textual class="po-textual">[ 1 to 5 ]</textual></programlisting><para class="po-block e249 e249"><textual class="po-textual">Here is the result of the above query:</textual></para><programlisting class="po-block e250 e250" xml:space="preserve"><textual class="po-textual">[ 1, 2, 3, 4, 5 ]</textual></programlisting><para class="po-block e251 e251"><textual class="po-textual">The following example constructs an object from the values in a sequence:</textual></para><programlisting class="po-block e252 e252" xml:space="preserve"><textual class="po-textual">
{
  for $d at $i in ("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday" )
  return $d : $i
}
     </textual></programlisting><para class="po-block e253 e253"><textual class="po-textual">Here is the result of the above query:</textual></para><programlisting class="po-block e254 e254" xml:space="preserve"><textual class="po-textual">
{
   "Sunday"    : 1,
   "Monday"    : 2,
   "Tuesday"   : 3, 
   "Wednesday" : 4,
   "Thursday"  : 5,
   "Friday"    : 6,
   "Saturday"  : 7
}
     </textual></programlisting><para class="po-block e255 e255"><textual class="po-textual">In JSONiq, an array contains a sequence of items, and an
     array is itself an item. JSONiq also supports JSON nulls. In the
     following array constructor, </textual><code class="po-atom e256 e256"><textual class="po-textual">jn:null()</textual></code><textual class="po-textual"> creates a
     null value.</textual></para><programlisting class="po-block e257 e257" xml:space="preserve"><textual class="po-textual">[1, "string", jn:null(), &lt;four/&gt;, ["nested", "array"]</textual></programlisting><para class="po-block e258 e258"><textual class="po-textual">Navigation in objects and arrays is done using "selectors",
     which use function call syntax as in the XSLT 3.0 maps proposal.
     An object selector has the function type </textual><code class="po-atom e259 e259"><textual class="po-textual">function($key as
     xs:string) as item()?</textual></code><textual class="po-textual">. An object selector returns the
     value associated with a given key, as in the following
     example.</textual></para><programlisting class="po-block e260 e260" xml:space="preserve"><textual class="po-textual">
let $map := { "eyes" : "blue", "hair" : "fuchsia" }
return $map("eyes")
     </textual></programlisting><para class="po-block e261 e261"><textual class="po-textual">The result of the above query is "blue".</textual></para><para class="po-block e262 e262"><textual class="po-textual">An array selector matches the function type
     </textual><code class="po-atom e263 e263"><textual class="po-textual">function(xs:integer) as item()?</textual></code><textual class="po-textual">. An array selector
     returns the value found at a given position, as in the following
     example:</textual></para><programlisting class="po-block e264 e264" xml:space="preserve"><textual class="po-textual">
let $wd := ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
return $wd(1)
     </textual></programlisting><para class="po-block e265 e265"><textual class="po-textual">The result of the above query is "Sunday".</textual></para><para class="po-block e266 e266"><textual class="po-textual">JSONiq also supports member selectors on sequences. If </textual><code class="po-atom e267 e267"><textual class="po-textual">$s</textual></code><textual class="po-textual"> is a sequence, then </textual><code class="po-atom e268 e268"><textual class="po-textual">$s($param)</textual></code><textual class="po-textual"> is translated to:</textual></para><programlisting class="po-block e269 e269" xml:space="preserve"><textual class="po-textual">for $item in $s return $item($param)</textual></programlisting><para class="po-block e270 e270"><textual class="po-textual">The following example, taken from the </textual><xref class="po-milestone e271 e271" linkend="jsoniq-uc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,
     queries sales data, then groups it to show sales by category
     within each state.</textual></para><para class="po-block e272 e272"><code class="po-atom e273 e273"><textual class="po-textual">collection("sales")</textual></code><textual class="po-textual"> contains the following data:</textual></para><programlisting class="po-block e274 e274" xml:space="preserve"><textual class="po-textual">
{ "product" : "broiler", "store number" : 1, "quantity" : 20  },
{ "product" : "toaster", "store number" : 2, "quantity" : 100 },
{ "product" : "toaster", "store number" : 2, "quantity" : 50 },
{ "product" : "toaster", "store number" : 3, "quantity" : 50 },
{ "product" : "blender", "store number" : 3, "quantity" : 100 },
{ "product" : "blender", "store number" : 3, "quantity" : 150 },
{ "product" : "socks", "store number" : 1, "quantity" : 500 },
{ "product" : "socks", "store number" : 2, "quantity" : 10 },
{ "product" : "shirt", "store number" : 3, "quantity" : 10 }
     </textual></programlisting><para class="po-block e275 e275"><code class="po-atom e276 e276"><textual class="po-textual">collection("products")</textual></code><textual class="po-textual"> contains the following data:</textual></para><programlisting class="po-block e277 e277" xml:space="preserve"><textual class="po-textual">
{ "name" : "broiler", "category" : "kitchen", "price" : 100, "cost" : 70 },
{ "name" : "toaster", "category" : "kitchen", "price" : 30, "cost" : 10 },
{ "name" : "blender", "category" : "kitchen", "price" : 50, "cost" : 25 },
{ "name" : "socks", "category" : "clothes", "price" : 5, "cost" : 2 },
{ "name" : "shirt", "category" : "clothes", "price" : 10, "cost" : 3 }
     </textual></programlisting><para class="po-block e278 e278"><code class="po-atom e279 e279"><textual class="po-textual">collection("stores")</textual></code><textual class="po-textual"> contains the following data:</textual></para><programlisting class="po-block e280 e280" xml:space="preserve"><textual class="po-textual">
{ "store number" : 1, "state" : CA },
{ "store number" : 2, "state" : CA },
{ "store number" : 3, "state" : MA },
{ "store number" : 4, "state" : MA }
     </textual></programlisting><para class="po-block e281 e281"><textual class="po-textual">The following query groups by state, then by category, then lists individual products and the sales associated with each.</textual></para><programlisting class="po-block e282 e282" xml:space="preserve"><textual class="po-textual">
{
  for $store in collection("stores")
  let $state := $store("state")
  group by $state
  return {
    $state : {
      for $product in collection("products")
      let $category := $product("category")
      group by $category
      return {
        $category : {
          for $sales in collection("sales")
          where $sales("store number") = $store("store number")
            and $sales("product") = $product("name")
          let $pname := $sales("product")
          group by $pname
          return $pname : sum( $sales("quantity") )
        }
      }
    }
  }
}
     </textual></programlisting><para class="po-block e283 e283"><textual class="po-textual">Here is the result of the above query.</textual></para><programlisting class="po-block e284 e284" xml:space="preserve"><textual class="po-textual">
{
  "CA" : {
      "clothes" : {
         "socks" :  510
      },
      "kitchen" : {
         "broiler" : 20,
         "toaster" : 150
      }
  },
  "MA" : {
      "clothes" : {
         "shirt" : 10
       },
      "kitchen" : {
         "blender" : 250,
         "toaster" : 50
      }
  }
}
     </textual></programlisting><para class="po-block e285 e285"><textual class="po-textual">Beyond what has been discussed in this section, JSONiq adds functions for parsing and serializing JSON, a syntax for JSON updates, a function library for managing objects and arrays, and rules for combining XML and JSON. See </textual><xref class="po-milestone e286 e286" linkend="jsoniq"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for further information.</textual></para></section><section class="po-hcontainer e287 e287"><title class="po-block e288 e288"><textual class="po-textual">Comparing the XSLT 3.0 Maps Proposal to JSONiq</textual></title><para class="po-block e289 e289"><textual class="po-textual">The XSLT 3.0 Maps proposal and JSONiq have similar
     functionality. They each extend the XPath 3.0 type system, data
     model, and syntax, but they do it in incompatible ways. The XSL
     Working Group and XML Query Working Group expect to agree on a
     common solution that can be used in both XSLT and XQuery. This
     section explores some of the similarities and differences between
     the two proposals.</textual></para><para class="po-block e290 e290"><textual class="po-textual">XSLT maps are extremely similar to JSONiq objects, but they
     do differ in a variety of ways. The following list summarizes
     these differences.</textual></para><orderedlist class="po-table e291 e291"><title class="po-block e292 e292"><textual class="po-textual">Maps</textual></title><listitem class="po-container e293 e293"><para class="po-block e294 e294"><textual class="po-textual">In the XSLT 3.0 maps proposal, maps are
       functions. In JSONiq, they are structured items, similar to XML
       nodes, with accessors defined in the data model. Both proposals
       use function notation to find the value associated with a key;
       in JSONiq this is done by overloading the function call syntax
       for objects and arrays.</textual></para><para class="po-block e295 e295"><textual class="po-textual">If maps are modeled as functions, the properties of maps
       still need to be clearly described in the data model, much as
       they are for elements and attributes, for the sake of
       implementations. If maps are modeled as data, the language
       description needs to explain the use of function call syntax,
       or a different approach must be used to find the value
       associated with a key.</textual></para></listitem><listitem class="po-container e296 e296"><para class="po-block e297 e297"><textual class="po-textual">In the XSLT 3.0 maps proposal, a map can be
       passed as a parameter where a function is expected. In JSONiq,
       a map must first be wrapped in an inline function, which can be
       passed as a parameter where a function is
       expected.</textual></para></listitem><listitem class="po-container e298 e298"><para class="po-block e299 e299"><textual class="po-textual">The XSLT 3.0 maps proposal makes it easy to
       create a new copy of a map that is modified by adding an entry,
       changing the value of an entry, or removing an entry. This is
       not as easy in JSONiq. JSONiq provides operations to update the
       contents of a map in place. This is not possible in XSLT (which
       does not have updates).</textual></para><para class="po-block e300 e300"><textual class="po-textual">Maps should support both models. Updates are needed for
       conventional database operations, modified copies are needed
       for XSLT and for XQuery implementatinos that do not provide
       updates.</textual></para></listitem><listitem class="po-container e301 e301"><para class="po-block e302 e302"><textual class="po-textual">In the XSLT 3.0 maps proposal, maps have no
       identity. In JSONiq, maps have identity, but it is used only to
       support updates. (XSLT does not have updates, and does not need
       this functionality). To reduce complexity and simplify query
       optimization, neither proposal allows XPath operations that
       expose the identity of maps, such as </textual><code class="po-atom e303 e303"><textual class="po-textual">is</textual></code><textual class="po-textual">,
       </textual><code class="po-atom e304 e304"><textual class="po-textual">&lt;&lt;=</textual></code><textual class="po-textual">, </textual><code class="po-atom e305 e305"><textual class="po-textual">&gt;&gt;</textual></code><textual class="po-textual">,
       </textual><code class="po-atom e306 e306"><textual class="po-textual">union</textual></code><textual class="po-textual">, </textual><code class="po-atom e307 e307"><textual class="po-textual">intersect</textual></code><textual class="po-textual">, and
       </textual><code class="po-atom e308 e308"><textual class="po-textual">except</textual></code><textual class="po-textual"> operators.</textual></para></listitem><listitem class="po-container e309 e309"><para class="po-block e310 e310"><textual class="po-textual">In the XSLT 3.0 maps proposal, the value of a
       map entry is an arbitrary sequence. In JSONiq, the value of a
       map entry is a single item; if the value is a sequence, it is
       placed in an array, as it would be in JSON.</textual></para></listitem><listitem class="po-container e311 e311"><para class="po-block e312 e312"><textual class="po-textual">In the XSLT 3.0 maps proposal, a key can have
       any atomic type, and the keys in a given map may have different
       types, which need not be mutually comparable (e.g. one map may
       have keys of type </textual><code class="po-atom e313 e313"><textual class="po-textual">integer</textual></code><textual class="po-textual">, </textual><code class="po-atom e314 e314"><textual class="po-textual">string</textual></code><textual class="po-textual">,
       and </textual><code class="po-atom e315 e315"><textual class="po-textual">boolean</textual></code><textual class="po-textual">). The type of a map depends on the
       types of its keys and values at any given time. In JSONiq, a
       key is always a string, as it is in JSON.</textual></para></listitem><listitem class="po-container e316 e316"><para class="po-block e317 e317"><textual class="po-textual">In the XSLT 3.0 maps proposal, keys are
       compared using the default collation, and a map can be given a
       collation, so that keys considered equivalent in a given
       language can be made equivalent. In JSONiq, all maps use the
       Unicode codepoint collation to ensure that they are compared
       the same way in all environments.</textual></para></listitem><listitem class="po-container e318 e318"><para class="po-block e319 e319"><textual class="po-textual">JSONiq maps use a constructor syntax that
       closely resembles the syntax of JSON maps in the same way that
       XQuery direct element constructors resemble XML elements. The
       XSLT 3.0 maps proposal uses a syntax more like computed element
       constructors, introducing a constructor with a keyword, and
       uses </textual><code class="po-atom e320 e320"><textual class="po-textual">:=</textual></code><textual class="po-textual"> as a delimiter between name/value pairs,
       instead of the </textual><code class="po-atom e321 e321"><textual class="po-textual">:</textual></code><textual class="po-textual"> delimiter used by
       JSON.</textual></para></listitem></orderedlist><para class="po-block e322 e322"><textual class="po-textual">JSONiq has arrays, the XSLT 3.0 proposal does not. This is
     perhaps the most significant difference between the two
     proposals. The XSLT 3.0 proposal uses maps to represent JSON
     arrays; for instance, the </textual><code class="po-atom e323 e323"><textual class="po-textual">parse-json()</textual></code><textual class="po-textual"> function
     converts the JSON text </textual><code class="po-atom e324 e324"><textual class="po-textual">["a", "b", null]</textual></code><textual class="po-textual"> to the map
     </textual><code class="po-atom e325 e325"><textual class="po-textual">map{1:="a", 2:="b", 3:=()}</textual></code><textual class="po-textual">, and does not support
     arrays in XPath per se. If a transformation creates a new copy of
     the map, removing one of the entries, the positions of the other
     entries are not adjusted; for example, consider the following
     expression:</textual></para><programlisting class="po-block e326 e326" xml:space="preserve"><textual class="po-textual">
let $j := parse-json('["a", "b", null]')
return map:remove($j, 2)
     </textual></programlisting><para class="po-block e327 e327"><textual class="po-textual">This expression evaluates to a map with entries in position
     1 and 3, but not in 2:</textual></para><programlisting class="po-block e328 e328" xml:space="preserve"><textual class="po-textual">map{1:="a", 3:=()}</textual></programlisting><para class="po-block e329 e329"><textual class="po-textual">JSONiq does not have this problem; deleting an item from an
     array moves all subsequent items one position to the left.</textual></para><para class="po-block e330 e330"><textual class="po-textual">Beyond the differences mentioned above, the main
     differences involve the functions associated with maps and arrays
     in the two proposals.</textual></para></section><section class="po-hcontainer e331 e331"><title class="po-block e332 e332"><textual class="po-textual">Arrays and Sequences</textual></title><para class="po-block e333 e333"><textual class="po-textual">In JSONiq, an array is a single item, which allows an array
    to be a member of an array. In the XSLT 3.0 maps proposal, a map
    is used to simulate an array. In either case, an array is an item
    that can occur in a sequence, and items are retrieved using
    function call syntax (e.g. </textual><code class="po-atom e334 e334"><textual class="po-textual">$a(1)</textual></code><textual class="po-textual">), not the subscript
    operator (e.g. </textual><code class="po-atom e335 e335"><textual class="po-textual">$a[1]</textual></code><textual class="po-textual">). Functions, operators, and
    expressions that operate on sequences all treat an array as a
    single item. For instance, the following expression returns a
    single item:</textual></para><programlisting class="po-block e336 e336" xml:space="preserve"><textual class="po-textual">for $i in [1, 2, 3]
return $i</textual></programlisting><para class="po-block e337 e337"><textual class="po-textual">The result of the above query is the array </textual><code class="po-atom e338 e338"><textual class="po-textual">[1, 2,
    3]</textual></code><textual class="po-textual">, not the sequence </textual><code class="po-atom e339 e339"><textual class="po-textual">1, 2, 3</textual></code><textual class="po-textual">. JSONiq provides
    the </textual><code class="po-atom e340 e340"><textual class="po-textual">members()</textual></code><textual class="po-textual"> function to convert an array to a
    sequence:</textual></para><programlisting class="po-block e341 e341" xml:space="preserve"><textual class="po-textual">for $i in members([1, 2, 3])
return $i</textual></programlisting><para class="po-block e342 e342"><textual class="po-textual">The result of the above expression is </textual><code class="po-atom e343 e343"><textual class="po-textual">1, 2,
    3</textual></code><textual class="po-textual">.</textual></para><para class="po-block e344 e344"><textual class="po-textual">In the same way, the expression </textual><code class="po-atom e345 e345"><textual class="po-textual">[1, 2][1]</textual></code><textual class="po-textual"> is
    not equivalent to the expression </textual><code class="po-atom e346 e346"><textual class="po-textual">[1, 2](1)</textual></code><textual class="po-textual">. The array
    selector </textual><code class="po-atom e347 e347"><textual class="po-textual">(1)</textual></code><textual class="po-textual"> returns the first member of the
    sequence, which is </textual><code class="po-atom e348 e348"><textual class="po-textual">1</textual></code><textual class="po-textual">. The positional predicate
    </textual><code class="po-atom e349 e349"><textual class="po-textual">[1]</textual></code><textual class="po-textual"> returns the first item of the sequence. In XPath,
    an item is identical to a singleton sequence containing that item,
    so </textual><code class="po-atom e350 e350"><textual class="po-textual">[1, 2][1]</textual></code><textual class="po-textual"> is equivalent to </textual><code class="po-atom e351 e351"><textual class="po-textual">([1,
    2])[1]</textual></code><textual class="po-textual">, which returns the first item in the sequence:
    </textual><code class="po-atom e352 e352"><textual class="po-textual">[1, 2]</textual></code><textual class="po-textual">.</textual></para><para class="po-block e353 e353"><textual class="po-textual">Some people would like most functions, operators, and
    expressions to treat arrays and sequences in the same
    way. However, the semantics of sequences is fundamental to the
    design of XQuery, XPath, and XSLT, and sequences have semantics
    that are quite different from arrays. For instance, in these
    languages a single item is indistinguishable from a sequence
    containing a single item, most languages clearly distinguish an
    array containing a single item from an item. Similarly, sequences
    do not nest, and are automatically flattened. Arrays nest, and are
    not flattened. Because sequences and arrays have significantly
    different semantics, it is not clear whether it is possible to
    make functions, operators, and expressions treat them the same way
    without introducing inconsistencies. The two Working Groups should
    explore this question.</textual></para></section><section class="po-hcontainer e354 e354"><title class="po-block e355 e355"><textual class="po-textual">Moving Forward</textual></title><para class="po-block e356 e356"><textual class="po-textual">If support for JSON is added to both XSLT and XQuery,
    developers can query or transform XML, HTML, and JSON to produce
    XML, HTML, or JSON. The XSLT 3.0 Maps proposal and JSONiq are more
    similar than different, and should be combined, retaining the best
    features of each. The XSL and XML Query Working Groups have
    started this effort. This paper has attempted to sketch the
    differences between the two proposals, and suggest some ways that
    they can be combined. This will be helpful to XML developers who
    also need to process JSON, but also to XML developers who need
    simple, lightweight data structures that preserve identity, and to
    the Working Groups as we design extensions to our
    languages.</textual></para><para class="po-block e357 e357"><textual class="po-textual">It is too early to say how interesting this work will become
    to the JSON community. As JSON moves beyond the browser into
    databases and enterprise data exchange, the lack of a mature
    application stack like the XML application stack becomes more
    painful, but the JSON community is extremely reluctant to embrace
    the complexity of XML Schema and other aspects of the XML
    application stack. At this point, the strongest interest seems to
    be in query languages. For the JSON-only community, JSONiq has a
    profile that removes support for XML, resulting in a much smaller,
    simpler language that supports only JSON. Standard support for a
    broader set of datatypes would also be extremely helpful for JSON
    developers, who routinely work with dates, URLs, and other
    datatypes that are not directly supported in JSON, as would a
    simple schema language.  Because of the strong desire for
    simplicity in the JSON community, it is unlikely that they will
    simply adopt the XML application stack without modification, but
    the JSON community may benefit by learning from the work that has
    already been done by their XML cousins.</textual></para></section><bibliography class="po-hcontainer e358 e358"><title class="po-block e359 e359"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e360 e360" xml:id="json-ff1" xreflabel="JSON: The Fat-Free Alternative to XML"><textual class="po-textual">
      Douglas Crockford
      </textual><emphasis class="po-inline e361 e361" role="ital"><textual class="po-textual">JSON: The Fat-Free Alternative to XML.</textual></emphasis><textual class="po-textual"> 
    [online]. </textual><link class="po-inline e362 e362" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.json.org/xml.html</textual></link><textual class="po-textual">, </textual><link class="po-inline e363 e363" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.json.org/fatfree.html</textual></link></bibliomixed><bibliomixed class="po-block e364 e364" xml:id="jsont" xreflabel="JSONT"><textual class="po-textual">
      Stefan Goessner.
      </textual><emphasis class="po-inline e365 e365" role="ital"><textual class="po-textual">JSONT: Transforming JSON.</textual></emphasis><textual class="po-textual"> 
    [online]. </textual><link class="po-inline e366 e366" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://goessner.net/articles/jsont/</textual></link></bibliomixed><bibliomixed class="po-block e367 e367" xml:id="jsoniq" xreflabel="JSONiq"><textual class="po-textual">
      Jonathan Robie, Matthias Brantner, Daniela Florescu, Ghislain Fourny, Till Westman.
      </textual><emphasis class="po-inline e368 e368" role="ital"><textual class="po-textual">JSONiq: XQuery for JSON, JSON for XQuery. (Language Specification).</textual></emphasis><textual class="po-textual"> 
    [online]. </textual><link class="po-inline e369 e369" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jsoniq.org/docs/spec/</textual></link></bibliomixed><bibliomixed class="po-block e370 e370" xml:id="jsoniq-uc" xreflabel="JSONiq Use Cases"><textual class="po-textual">Jonathan Robie, Matthias Brantner, Daniela Florescu, Ghislain Fourny, Till Westman. 
    </textual><emphasis class="po-inline e371 e371" role="ital"><textual class="po-textual">JSONiq: Use Cases.</textual></emphasis><textual class="po-textual"> [online]. 
    </textual><link class="po-inline e372 e372" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jsoniq.org/docs/use-cases/</textual></link></bibliomixed><bibliomixed class="po-block e373 e373" xml:id="xslt30" xreflabel="XSLT 3.0 July 2012 Working Draft"><textual class="po-textual">Michael Kay.
      </textual><emphasis class="po-inline e374 e374" role="ital"><textual class="po-textual">XSL Transformations (XSLT) Version 3.0.</textual></emphasis><textual class="po-textual"> 
      W3C Working Draft 10 July 2012 [online].
    </textual><link class="po-inline e375 e375" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2012/WD-xslt-30-20120710/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e376 e376" xml:id="xquery30" xreflabel="XQuery 3.0"><textual class="po-textual">Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson.
      </textual><emphasis class="po-inline e377 e377" role="ital"><textual class="po-textual">XQuery 3.0: An XML Query Language.</textual></emphasis><textual class="po-textual"> 
      W3C Working Draft 13 December 2011. [online].
    </textual><link class="po-inline e378 e378" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery-30/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e379 e379" xml:id="xpath30" xreflabel="XPath 3.0"><textual class="po-textual">Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson.
      </textual><emphasis class="po-inline e380 e380" role="ital"><textual class="po-textual">XML Path Language (XPath) 3.0.</textual></emphasis><textual class="po-textual"> 
      W3C Working Draft 13 December 2011. [online].
    </textual><link class="po-inline e381 e381" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-30/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e382 e382" xml:id="xdm30" xreflabel="XDM 3.0"><textual class="po-textual">Norman Walsh, Anders Berglund, John Snelson.
      </textual><emphasis class="po-inline e383 e383" role="ital"><textual class="po-textual">XQuery and XPath Data Model 3.0</textual></emphasis><textual class="po-textual"> 
      W3C Working Draft 13 December 2011. [online].
    </textual><link class="po-inline e384 e384" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel-30/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e385 e385" xml:id="quilt" xreflabel="Quilt"><textual class="po-textual">Don Chamberlin, Jonathan Robie, Daniela Florescu
      </textual><emphasis class="po-inline e386 e386" role="ital"><textual class="po-textual">Quilt: An XML Query Language for Heterogeneous Data Sources</textual></emphasis><textual class="po-textual"> 
    </textual><link class="po-inline e387 e387" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e388 e388" xml:id="xml.why" xreflabel="Bosak 1997"><textual class="po-textual">Jon Bosak. "XML, Java, and the future of the Web". [online].
      </textual><link class="po-inline e389 e389" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">ftp://sunsite.unc.edu/pub/sun-info/standards/xml/why/xmlapps.html</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e390 e390" xml:id="jclark" xreflabel="XML vs the Web"><quote class="po-inline e391 e391"><textual class="po-textual">XML vs the Web</textual></quote><textual class="po-textual">, James Clark. [online] </textual><link class="po-inline e392 e392" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://blog.jclark.com/2010/11/xml-vs-web_24.html</textual></link></bibliomixed><bibliomixed class="po-block e393 e393" xml:id="normwalsh" xreflabel="Deprecating XML"><quote class="po-inline e394 e394"><textual class="po-textual">Deprecating XML</textual></quote><textual class="po-textual">, Norman Walsh. [online] </textual><link class="po-inline e395 e395" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://norman.walsh.name/2010/11/17/deprecatingXML</textual></link></bibliomixed><bibliomixed class="po-block e396 e396" xml:id="timbray" xreflabel="JSON and XML"><quote class="po-inline e397 e397"><textual class="po-textual">JSON and XML</textual></quote><textual class="po-textual">, Tim Bray. [online] </textual><link class="po-inline e398 e398" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.tbray.org/ongoing/When/200x/2006/12/21/JSON</textual></link></bibliomixed><bibliomixed class="po-block e399 e399" xml:id="MQL" xreflabel="Mongo Query Language"><quote class="po-inline e400 e400"><textual class="po-textual">Mongo Query Language: Advanced Queries.</textual></quote><textual class="po-textual">
    [online] </textual><link class="po-inline e401 e401" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mongodb.org/display/DOCS/Advanced+Queries</textual></link><textual class="po-textual">. </textual><quote class="po-inline e402 e402"><textual class="po-textual">Data Types and Conventions</textual></quote><textual class="po-textual">, </textual><link class="po-inline e403 e403" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mongodb.org/display/DOCS/Data+Types+and+Conventions</textual></link><textual class="po-textual">. </textual><quote class="po-inline e404 e404"><textual class="po-textual">BSON</textual></quote><textual class="po-textual">, </textual><link class="po-inline e405 e405" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mongodb.org/display/DOCS/BSON</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e406 e406" xml:id="UnQL" xreflabel="UnQL"><quote class="po-inline e407 e407"><textual class="po-textual">UnQL: Unstructured Query Language.</textual></quote><textual class="po-textual">
    [online] </textual><link class="po-inline e408 e408" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.unqlspec.org/display/UnQL/Home</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e409 e409" xml:id="HQL" xreflabel="HQL Tutorial"><quote class="po-inline e410 e410"><textual class="po-textual">HQL Tutorial</textual></quote><textual class="po-textual">,
    [online] </textual><link class="po-inline e411 e411" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dev.wavemaker.com/wiki/bin/Dev/HqlTutorial</textual></link></bibliomixed><bibliomixed class="po-block e412 e412" xml:id="YQL" xreflabel="Yahoo Query Language"><quote class="po-inline e413 e413"><textual class="po-textual">Yahoo Query Language</textual></quote><textual class="po-textual">,
    [online] </textual><link class="po-inline e414 e414" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://developer.yahoo.com/yql/</textual></link></bibliomixed><bibliomixed class="po-block e415 e415" xml:id="Hive" xreflabel="Hive"><quote class="po-inline e416 e416"><textual class="po-textual">Hive Language Manual.</textual></quote><textual class="po-textual">
    [online] </textual><link class="po-inline e417 e417" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://cwiki.apache.org/confluence/display/Hive/LanguageManual</textual></link></bibliomixed><bibliomixed class="po-block e418 e418" xml:id="Pig" xreflabel="Pig"><quote class="po-inline e419 e419"><textual class="po-textual">Apache Hadoop: Pig Documentation.</textual></quote><textual class="po-textual">
    [online] </textual><link class="po-inline e420 e420" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://pig.apache.org/docs/r0.7.0/index.html</textual></link></bibliomixed><bibliomixed class="po-block e421 e421" xml:id="Jaql" xreflabel="Jaql"><textual class="po-textual">Kevin S. Beyer, Mohamed Eltabakh, Vuk Ercegovac, Rainer Gemulla, Carl-Christian Kanne, Fatma Ozcan, Andrey Balmin, Eugene J. Shekita.</textual><quote class="po-inline e422 e422"><textual class="po-textual">Jaql: A Scripting Language for Large Scale Semistructured Data
    Analysis.</textual></quote><textual class="po-textual"> 
    [online]
    </textual><link class="po-inline e423 e423" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mpi-inf.mpg.de/~rgemulla/publications/beyer11jaql.pdf</textual></link></bibliomixed><bibliomixed class="po-block e424 e424" xml:id="json-schema" xreflabel="JSON Schema"><textual class="po-textual">K. Zyp, G. Court.</textual><quote class="po-inline e425 e425"><textual class="po-textual">A JSON Media Type for Describing the Structure and Meaning of JSON Documents.</textual></quote><textual class="po-textual">
    IETF Internet-Draft [online]
    </textual><link class="po-inline e426 e426" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/draft-zyp-json-schema-03</textual></link></bibliomixed><bibliomixed class="po-block e427 e427" xml:id="jsonpath" xreflabel="JSON Path"><textual class="po-textual">JSON Path. Part of MarkLogic Corona. [online] </textual><link class="po-inline e428 e428" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://github.com/marklogic/Corona/wiki/JSON-Path</textual></link></bibliomixed><bibliomixed class="po-block e429 e429" xml:id="rbtree" xreflabel="rbtree"><textual class="po-textual">John Snelson. rbtree.  [online] </textual><link class="po-inline e430 e430" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://github.com/jpcs/rbtree.xq/</textual></link></bibliomixed><bibliomixed class="po-block e431 e431" xml:id="cosql" xreflabel="cosql"><textual class="po-textual">Erik Meijer, Gavin Bierman. </textual><quote class="po-inline e432 e432"><textual class="po-textual">A co-Relational Model of Data for Large Shared Data Banks.</textual></quote><textual class="po-textual"> ACM Queue, March 2011, volume 9, number 3. </textual><link class="po-inline e433 e433" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://queue.acm.org/detail.cfm?id=1961297</textual></link></bibliomixed></bibliography></article></classedDocument>