<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Where did all the document kids go?</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Open-source, markup, and the casual developer</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">When I began developing with XML technologies, there were a multitude of toolkits and implementations of XML parsers, multiple DOM (and DOM-like) implementations outside web browsers, and XSLT implementations everywhere. My current development environments seems impoverished in comparison. What happened? The population of web development tools, by contrast, has grown by leaps and bounds. Why is the one ecosystem contracting and the other growing? One should never underestimate the power of making things more accessible to the casual user.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Matt</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Patterson</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Matt Patterson is a web developer who has worked with HTML and XML for over 10 years. He lives
in Berlin, Germany</textual></para></personblurb><email class="po-field e15 e15"><textual class="po-textual">matt@werkstatt.io</textual></email></author><legalnotice class="po-container e16 e16"><para class="po-block e17 e17"><textual class="po-textual">Copyright © 2013 Matt Patterson, some rights reserved:  This work is licensed under a </textual><link class="po-inline e18 e18" xlink:actuate="onRequest" xlink:href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US" xlink:show="new" xlink:title="license" xlink:type="simple"><textual class="po-textual">Creative Commons Attribution-ShareAlike 3.0 Unported License</textual></link><textual class="po-textual">.</textual></para></legalnotice></info><section class="po-hcontainer e19 e19"><title class="po-block e20 e20"><textual class="po-textual">Introduction</textual></title><para class="po-block e21 e21"><textual class="po-textual">It’s a truism that things were different when I was a lad, but with open-source implementations of markup technologies there seems to be truth to it.</textual></para><para class="po-block e22 e22"><textual class="po-textual">When I began to develop with XML technologies in the very early 2000s there was a slew of toolkits and implementations for XML parsers, multiple DOM-like implementations outside web browsers, XSLT implementations, etc (almost ad nauseam).</textual></para><para class="po-block e23 e23"><textual class="po-textual">Now, GNOME’s LibXML seems to be the de facto standard implementation, used with many (non-Java) language bindings, there’s only one open-source XSLT2 implementation, and technologies like XQuery seem to be restricted to specialist use and implementations on top of XML databases.</textual></para><para class="po-block e24 e24"><textual class="po-textual">What happened? Open-source technologies in related areas including document-like data stores, document-manipulation (albeit in Javascript running in a browser), have come on in leaps and bounds. The XML technology space seems to have contracted and stagnated, at least to a casual observer.</textual></para><para class="po-block e25 e25"><textual class="po-textual">Why should you care about this? Will it affect you? And if you do care, what can you do?</textual></para></section><section class="po-hcontainer e26 e26"><title class="po-block e27 e27"><textual class="po-textual">The greener grass</textual></title><para class="po-block e28 e28"><textual class="po-textual">For comparison, let’s take a look at open-source web development, and what’s happened to that in the last 10 years. Web development is a good comparison point because it is, in essence, in the business of markup production.</textual></para><para class="po-block e29 e29"><textual class="po-textual">If we go back to 2003 we’re in a world where Perl and variants of the CGI model are dominant, and PHP (a variant of the CGI model itself) is fast rising. Python is heavily used by self-respecting developers (Google being the poster child for Python at this time). MySQL has already won and taken its place as the default database backing the web. The common thread is that there are very few frameworks, as we would understand them now. The frameworks that are there seem to largely be restricted to proprietary toolkits like WebObjects and J2EE. The open-source web development world is making do with CGI, templating libraries, and SQL. A uniform API to connect to different SQL databases and issue queries is pretty much the height of sophistication.</textual></para><para class="po-block e30 e30"><textual class="po-textual">In the XML world, we have LibXML 2 fast emerging, but still not installed by default on pretty much every computer system (as it is now). Saxon and Xerces/Xalan are the heavyweights here.</textual></para><section class="po-hcontainer e31 e31"><title class="po-block e32 e32"><textual class="po-textual">July 2004: Ruby on Rails</textual></title><para class="po-block e33 e33"><textual class="po-textual">Rails was the first proper full-stack web framework to get significant traction and adoption. Django, the Python framework which most closely matches it in terms of scope, was first released in July 2005.</textual></para><para class="po-block e34 e34"><textual class="po-textual">The release of Rails and Django are not unique, but they are significant enough to stand in for the changes in backend web development as a whole.</textual></para><para class="po-block e35 e35"><textual class="po-textual">What we see as they pick up speed is an explosion of libraries and plugins and the emergence of ecosystems surrounding them. Ruby makes for a nice subject here. Rails was largely responsible for it becoming a language with widespread adoption, especially outside Japan. If we look at statistics from Github (launched 2008) about the growth in number of public repositories for projects written in Ruby, then we see growth that looks exponential.</textual></para><para class="po-block e36 e36"><textual class="po-textual">Rubygems is Ruby’s package management system, with all public gems hosted by rubygems.org. There are currently 55,075 public gems. Looking at Rails itself, the current version (released 18 March 2013) has (as of 17 April 2013) been installed 380,730 times.</textual></para><para class="po-block e37 e37"><textual class="po-textual">What does this tell us? Apart from the obvious – there’s a lot happening – it’s fairly clear that the buzz about web development technologies 10 years ago translated into sustained and impressive development of an open-source ecosystem. Contrast that with the buzz around XML technologies, say, 15 years ago, and there’s no real comparison. The real question is why.</textual></para></section></section><section class="po-hcontainer e38 e38"><title class="po-block e39 e39"><textual class="po-textual">A parallel story</textual></title><para class="po-block e40 e40"><textual class="po-textual">Back in the early 2000’s there were several competing open-source relational databases, in addition to Oracle and DB2, where ‘real’ work was done. Of those available open-source DB’s, MySQL was the one which became the default choice, quickly almost entirely displacing its open-source competitors (and Oracle) from general web development. You’d be hard pressed to find anyone who actually understands relational database implementation who’ll say that MySQL was the best technology, and many who’ll say it was pretty bad in the early days. Yet, in the battle of MySQL vs. everything else, MySQL destroyed the competition. Why?</textual></para><para class="po-block e41 e41"><textual class="po-textual">There are two critical factors in getting a developer to adopt a technology like a relational DB.</textual></para><orderedlist class="po-table e42 e42"><listitem class="po-container e43 e43"><para class="po-block e44 e44"><textual class="po-textual">Is it straightforward to install?</textual></para></listitem><listitem class="po-container e45 e45"><para class="po-block e46 e46"><textual class="po-textual">Is it easy to use?</textual></para></listitem></orderedlist><para class="po-block e47 e47"><textual class="po-textual">MySQL’s great weapon was that it was trivial to install on almost any system with a C compiler, and it soon had client bindings for almost all languages.</textual></para><para class="po-block e48 e48"><textual class="po-textual">If you wanted to use a relational DB, you could either spend an age figuring out how to satisfy the dependencies and configuration requirements for a competing RDBMS or you could spend 5 minutes installing MySQL.</textual></para><para class="po-block e49 e49"><textual class="po-textual">It was a SQL database, so writing queries for it was easy. It had native bindings for your language, so it was easy to integrate. It was quick and worked well enough for the 80% case that you didn’t immediately notice its flaws.</textual></para><para class="po-block e50 e50"><textual class="po-textual">In short, it was a database for casual users.</textual></para></section><section class="po-hcontainer e51 e51"><title class="po-block e52 e52"><textual class="po-textual">A true story of pain and bewilderment: Validating XML</textual></title><para class="po-block e53 e53"><textual class="po-textual">Recently, I have been experimenting with a web service which has a ReST API with an XML serialisation format, and which provides XML Schema grammars for the various endpoints. Writing a client in Ruby, and wanting to validate XML I generated as part of my automated tests, how could I go about that?</textual></para><para class="po-block e54 e54"><textual class="po-textual">My first thought was to shell out to a command line utility and pass or fail tests based on the return value, in classic Unix style.</textual></para><para class="po-block e55 e55"><textual class="po-textual">So. LibXML’s support is incomplete, a polite way of saying dangerous and broken.</textual></para><para class="po-block e56 e56"><textual class="po-textual">Saxon HE doesn’t include it (which is fine, but meant I couldn’t use it)</textual></para><para class="po-block e57 e57"><textual class="po-textual">Xerces’ command-line utilities (C++ or Java) are really hard to figure out (and the JVM startup tax is really hefty when shelling out dozens of times in an automated test suite). (Norm Walsh released a wrapper that does schema validation, but I didn’t find it until researching for this paper, and I know Norm.)</textual></para><para class="po-block e58 e58"><textual class="po-textual">Having tried to do this a few times in the past, it’s at this point that I usually give up, because nothing has changed since the last time I went looking.</textual></para><para class="po-block e59 e59"><textual class="po-textual">This time, I realised that a Ruby XML/HTML library (Nokogiri, more on this later) wrapped Xerces-J under JRuby, and Xerces-J’s XML Schema implementation works. So, now I have XML Schema validation integrated into my test suite, but only when it runs under JRuby. Under MRI (the standard Ruby implementation) LibXML 2’s broken Schema implementation explodes.</textual></para><para class="po-block e60 e60"><textual class="po-textual">XML Schema is a technology that’s been a TR since 2001. It seems absurd that, in 2013, it’s simplest task – validation – requires so many hoops to be jumped in order to integrate it into a sensible, modern, web development workflow.</textual></para></section><section class="po-hcontainer e61 e61"><title class="po-block e62 e62"><textual class="po-textual">hpricot, Nokogiri, and getting things done</textual></title><para class="po-block e63 e63"><textual class="po-textual">One of the side-effects of the HTML/XHTML kerfuffle was that, by and large, tools for dealing with HTML (without resorting to regexes) were tools for dealing with XML, at least in Python and Ruby. Partly as a legacy of its SGML roots, but mostly because humans are incredibly good at being incredibly bad at things, vast swathes of HTML content wasn’t (still isn’t) even well-formed HTML, let alone XML. Even more content isn’t valid HTML.</textual></para><para class="po-block e64 e64"><textual class="po-textual">XML’s default error handling (terror, immediate exit) makes it extremely problematic to use with HTML, and HTML constitutes the largest body of markup on the internet.</textual></para><para class="po-block e65 e65"><textual class="po-textual">Python’s Beautiful Soup &amp; lxml, and Ruby’s Hpricot provided tools for coping with HTML. They ignored the DOM for search interfaces based on idiomatic constructs and even CSS.</textual></para><para class="po-block e66 e66"><textual class="po-textual">Hpricot was effectively superseded by Nokogiri, which wraps LibXML 2 in an API based on Hpricot’s. Before it was installed by default on Mac OS X, Nokogiri was the sole reason that a lot of people installed LibXML 2.</textual></para><para class="po-block e67 e67"><textual class="po-textual">These libraries are widely used, and successful precisely because of their pragmatic and idiomatic approach.</textual></para></section><section class="po-hcontainer e68 e68"><title class="po-block e69 e69"><textual class="po-textual">Language bindings matter, and why LibXML won</textual></title><para class="po-block e70 e70"><textual class="po-textual">If MySQL won because any fool with a C compiler and Make could get it running, LibXML 2 won because it was actually fast enough to use, and had language bindings for almost everything. That was enough for it to creep onto almost every developer’s system as part of the base OS install (a side-effect of the XML-as-data-storage fad which meant that core OS systems needed to read and write XML). (Mac OS X did this in 2007, the last holdout.) Even before then, the pain of installing LibXML 2 + language bindings (not inconsiderable if you were installing from source) was far outweighed by the orders-of-magnitude better performance than most other libraries outside the Java world.</textual></para><para class="po-block e71 e71"><textual class="po-textual">LibXML 2 / LibXSLT 1 have what amounts to a frozen feature set though: no XSLT 2, no XPath 2, no XQuery, incomplete XML Schema support. Its ubiquity and competence far outweigh its restrictions for most people, but that means that very few will ever explore beyond XSLT 1 in the way that its introduction allowed many people to explore beyond simple document parsing.</textual></para><para class="po-block e72 e72"><textual class="po-textual">The standard HTML &amp; XML processing libraries for almost all dynamic languages are wrappers around LibXML 2.</textual></para></section><section class="po-hcontainer e73 e73"><title class="po-block e74 e74"><textual class="po-textual">Next steps</textual></title><para class="po-block e75 e75"><textual class="po-textual">What can we do about this state of affairs? Is there a way continue to advance the state-of-the-art whilst also making it easy for new developers to jump in?</textual></para><para class="po-block e76 e76"><textual class="po-textual">The short answer is that there needs to be. The longer answer, I think, draws on what we’ve learnt from MySQL and LibXML.</textual></para><section class="po-hcontainer e77 e77"><title class="po-block e78 e78"><textual class="po-textual">There’s no excuse for being inaccessible</textual></title><para class="po-block e79 e79"><textual class="po-textual">Java seems to be where current open-source markup technology development is taking place. If you’re not a Java developer it’s often a pain to get started. If you are a Java developer it’s often tedious to do common, trivial, tasks.</textual></para><para class="po-block e80 e80"><textual class="po-textual">There’s no excuse for being inaccessible to non-Java developers, and there’s no excuse for tedium. Let’s take Jenkins as an example. Jenkins is a continuous integration server written in Java. There are many CI servers written in many languages. Jenkins is beating them all because it’s trivial to get started with it. It bundles a simple Java app server in its .war, meaning that, if you want, you can get started with nothing more complex than downloading the .war, and running it with </textual><code class="po-atom e81 e81"><textual class="po-textual">java -jar jenkins.war</textual></code><textual class="po-textual">. There’s nothing else to it, and that built-in server is enough for almost everyone.</textual></para><para class="po-block e82 e82"><textual class="po-textual">Saxon can be used from the command line, but it doesn’t have a dedicated utility, which means there’s no man page, and no simple tab-completion for a half-remembered command name. xmllint and xsltproc, the utilities shipped with Libxml2 are so useful because they are standard command line utilities: they are invoked with a single-word command, they have man pages, they aren’t dependent on CLASSPATH or on remembering where you put saxon9he.jar.</textual></para><para class="po-block e83 e83"><textual class="po-textual">(If Saxon is PostgreSQL, technically superior in almost every way, then LibXML 2 is MySQL. LibXML2 is utterly ubiquitous: it’s on your phone.)</textual></para></section><section class="po-hcontainer e84 e84"><title class="po-block e85 e85"><textual class="po-textual">Language bindings are important</textual></title><para class="po-block e86 e86"><textual class="po-textual">The popularity of the JVM as a host for implementations of popular dynamic languages (JRuby, Jython) and new languages (Scala, Clojure) mean that even Java-native libraries like Saxon can be made obvious and easy to use for non-Java developers. Nokogiri uses Xerces as its parser and XSLT engine under JRuby, which means that I use JRuby + Nokogiri to validate documents against XML Schema (although, obviously, I’m limited to XML Schema 1.0). Why not have idiomatic Saxon bindings for other JVM host languages?</textual></para></section><section class="po-hcontainer e87 e87"><title class="po-block e88 e88"><textual class="po-textual">There’s more to life than DOM.</textual></title><para class="po-block e89 e89"><textual class="po-textual">hpricot and Nokogiri made it fun and easy to work with complex HTML and XML. Their shelving of the DOM API in favour of idiomatic Ruby made many common tasks vastly easier than with DOM. That led in turn to Nokogiri’s near-total dominance of XML handling in Ruby.</textual></para><para class="po-block e90 e90"><textual class="po-textual">Imagine if XQuery were opened up in that way. Imagine if the DSDL validation pipeline were made trivial to use. There are lots of XML-clad web APIs out there. Imagine how much better documented they’d be with, say, RelaxNG + Schematron that anyone could trivially easily use.</textual></para></section></section></article></classedDocument>