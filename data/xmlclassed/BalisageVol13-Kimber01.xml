<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">RELAX NG and DITA: An Almost Perfect Match</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2014</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 5 - 8, 2014</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">The DITA vocabulary architecture defines a formal and controlled mechanism for configuring and extending the base DITA vocabulary. The architecture is independent of any XML document grammar facility in that DITA only requires that document instances exhibit specific attributes that serve to declare the document's effective document type (set of vocabulary and constraint modules) and each element's relationship to its base element types (specialization hierarchy). However, practical authoring and management of DITA documents requires the use of some form of document grammar, e.g. a DTD, XML schema, etc. While the DITA standard defines specific coding patterns for implementing DITA vocabulary and constraint modules and for integrating those modules into document type shells, DITA users find both the DTD and XSD implementation details difficult and challenging due to the syntax and semantics of both grammar facilities. Through DITA version 1.2, the DITA standard recognized only DTDs and XSDs as conforming DITA grammar languages and the DITA Technical Committee provided both DTD and XSD versions of the DITA modules and document type shells. One the authors (George Bina) discovered that RELAX NG provided significant advantages over both DTD and XSD grammars, significantly simplifying both the task of integrating modules into working document types and defining vocabulary and constraint modules. Specific features of RELAX NG make it the best match to DITA's vocabulary architecture of any current XML document grammar facility. This paper discusses the general requirements defined by the DITA vocabulary architecture, the challenges presented by the DTD and XSD grammar facilities, and how RELAX NG addresses all those requirements. We also present some suggestions for improvements in RELAX NG that would remove the few places where RELAX NG is not optimal for DITA's requirements.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><surname class="po-field e10 e10"><textual class="po-textual">Kimber</textual></surname><firstname class="po-field e11 e11"><textual class="po-textual">Eliot</textual></firstname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Eliot has been doing generalized markup longer than most humans have been
        alive. Eliot's most recent professional focus is on the application of the DITA
        standard to the requirements of professional publishers. Eliot is a founding member
        of the OASIS DITA Technical Committee and active contributor to the DITA standard.
        Eliot maintains the DITA For Publishers open source project. When not wrangling
        tags to his will, Eliot trains in Aikido and skateboards when he can. Eliot lives
        in Austin, Texas.</textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Owner</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">Contrext, LLC</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">ekimber@contrext.com</textual></email></author><author class="po-record e18 e18"><personname class="po-record e19 e19"><surname class="po-field e20 e20"><textual class="po-textual">Bina</textual></surname><firstname class="po-field e21 e21"><textual class="po-textual">George</textual></firstname></personname><personblurb class="po-container e22 e22"><para class="po-block e23 e23"><textual class="po-textual">George is founder of SyncroSoft, makers of the oXygenXML product.
        George is a mathematician by training. George lives and works in Criova,
        Romania. When not contributing to open-source projects, George enjoys
        travel with his family and taking selfies of himself working in 
        exotic locations.</textual></para></personblurb><affiliation class="po-record e24 e24"><orgname class="po-block e25 e25"><textual class="po-textual">SyncroSoft</textual></orgname></affiliation><email class="po-field e26 e26"><textual class="po-textual">george@oxygenxml.com</textual></email></author><legalnotice class="po-container e27 e27"><para class="po-block e28 e28"><textual class="po-textual">Copyright Â© 2014 George Bina and Eliot Kimber</textual></para></legalnotice><keywordset class="po-table e29 e29" role="author"><keyword class="po-field e30 e30"><textual class="po-textual">DITA</textual></keyword><keyword class="po-field e31 e31"><textual class="po-textual">document grammar</textual></keyword><keyword class="po-field e32 e32"><textual class="po-textual">DTD</textual></keyword><keyword class="po-field e33 e33"><textual class="po-textual">XSD</textual></keyword><keyword class="po-field e34 e34"><textual class="po-textual">RELAX NG</textual></keyword><keyword class="po-field e35 e35"><textual class="po-textual">XML schema document</textual></keyword><keyword class="po-field e36 e36"><textual class="po-textual">vocabulary architecture</textual></keyword><keyword class="po-field e37 e37"><textual class="po-textual">Darwin Information Typing Architecture (DITA)</textual></keyword></keywordset></info><section class="po-hcontainer e38 e38"><title class="po-block e39 e39"><textual class="po-textual">Introduction</textual></title><para class="po-block e40 e40"><textual class="po-textual">The </textual><citation class="po-atom e41 e41" linkend="dita-std"><textual class="po-textual">OASIS Darwin Information Typing Architecture standard</textual></citation><textual class="po-textual"> (DITA) defines a unique approach to the definition and management of XML document vocabularies. Rather than defining a monolithic set of element types and attributes that can then be modified or added to without constraint, DITA defines a formal architecture consisting of a set of invariant base vocabulary "modules" comprising the base standard DITA vocabulary. These modules are invariant in the sense that they are not intended to be modified directly but only through specific configuration and extension facilities as defined by the DITA standard. In particular, modules may not be modified in a way that makes them less constrained than the base definition. All copies of a given module version in time should be identical.</textual></para><para class="po-block e42 e42"><textual class="po-textual">A given set of modules represents a unique "DITA document type". Two DITA documents that use the same modules have the same DITA document type. Note that this notion of "DITA document type" is independent of the use of any particular document grammar associated with the document: it is only necessary for a document to declare the set of modules it uses, which is done with the DITA-defined @domains attribute on the document root element. The value of the @domains attribute is simply a list of modules: </textual><code class="po-atom e43 e43"><textual class="po-textual">&lt;topic domains="(topic topic) (topic hi-d) (topic pr-d)"&gt;</textual></code><textual class="po-textual">.</textual></para><para class="po-block e44 e44"><textual class="po-textual">Likewise, each DITA element declares it's relationship to the base DITA vocabulary through the the DITA-defined @class attribute, which enumerates the element's ancestry as a sequence of module/tagname pairs: </textual><code class="po-atom e45 e45"><textual class="po-textual">&lt;steps class="- topic/ol task/steps "&gt;</textual></code><textual class="po-textual">. For the &lt;steps&gt; element, the @class value can be read as "the &lt;steps&gt; element, defined within the "task" topic type module, is a specialization of the &lt;ol&gt; element defined in the "topic" topic type module. That is, it reflects the type hierarchy "steps is-a ol".</textual></para><para class="po-block e46 e46"><textual class="po-textual">Given a DITA document with the @domains and@class attributes present the document is fully processable by any DITA-aware processor. In practice, however, the @domains and @class values are defined as attribute default values in some governing grammar and omitted from document instances. Thus, while the DITA standard does not require the use of grammars with conforming DITA documents, practical considerations effectively require grammars to enable population of the @domains and @class values, general document validation, authoring support, and so on.</textual></para><para class="po-block e47 e47"><textual class="po-textual">The DITA standard defines specific coding requirements for the grammar types recognized by the DITA standard. These coding requirements ensure consistency across all conforming DITA vocabularies and thus facilitate interchange of vocabulary modules.</textual></para><para class="po-block e48 e48"><textual class="po-textual">DITA vocabulary implementation involves three component types:</textual><itemizedlist class="po-table e49 e49"><listitem class="po-container e50 e50"><para class="po-block e51 e51"><textual class="po-textual">Vocabulary modules, which define element and attribute types. Vocabulary modules are either "structural", defining new map or topic types, or "domain", defining element types that may be used in any map or topic type as appropriate ("mix-in" elements). Every DITA document is either a map or a topic and therefore uses at least a single structural module. Vocabulary modules must be coded in such a way as to enable appropriate extension and constraint through separate modules. That is, it must be possible to modify the base content model and attribute list declarations as allowed by the DITA architecture without directly modifying the vocabulary module files themselves.</textual></para></listitem><listitem class="po-container e52 e52"><para class="po-block e53 e53"><textual class="po-textual">Constraint modules, which constrain content modules or attributes for elements. Constraints are implemented by redefining or overriding base content model and attribute list declarations.</textual></para></listitem><listitem class="po-container e54 e54"><para class="po-block e55 e55"><textual class="po-textual">Document type shells, which "integrate" vocabulary and constraint modules to implement specific DITA document types. Document type shells are logically just inclusion lists of the vocabulary and constraint modules used by the document type. In particular, the list of included modules should match the set of modules named by the document's @domains attribute.</textual></para></listitem></itemizedlist></para><para class="po-block e56 e56"><textual class="po-textual">The implementation challenge for DITA vocabulary, constraint, and document type shell authors is that neither DTD nor XSD are a particularly good match syntactically or semantically to DITA's requirements. DTDs require the use of parameter entities, which leads to convoluted and difficult-to-debug document type shells. XSD 1.0's limited and highly-constrained facilities for content model and group redefinition require various forms of indirection not inherent in the semantics of the DITA element types nor required in the DTD implementation of the equivalent vocabulary. The DITA user community, even highly-experienced practitioners, find implementing and maintaining both DTD and XSD vocabulary modules tedious and challenging. </textual></para><para class="po-block e57 e57"><textual class="po-textual">While the issues with DTD mostly stem from the difficulty in debugging parameter entities and the large opportunity for error in constructing parameter entity declarations and references, the issues with XSD go deeper, relating to XSD's class model and restrictions on how groups may be redefined through the XSD redefine facility. In addition, the XSD 1.0 redefine facility is ambiguously specified such that conforming XSD processors may use either of two incompatible interpretations of how redefine should work. However DITA's use of XSD depends on the interpretation as implemented by the Xerces Java and C XSD parsers, making the use of XSD for DITA problematic in the general case. While the XSD 1.1 override facility appears to address the issues with redefine, until XSD 1.1 is implemented widely it cannot be mandated by the DITA standard.</textual></para><para class="po-block e58 e58"><textual class="po-textual">Finally, the DITA Technical Committee, along with any other provider of DITA vocabularies, constraints, and document type shells faces the practical problem of maintaining both DTD and XSD versions of their vocabulary, which is challenging at best. An ideal solution would allow generation of either or both of the DTD and XSD versions from a single source. Through DITA version 1.2 the Technical Committee considered this too difficult to attempt from either the DTD or XSD as the authoritative source.</textual></para><para class="po-block e59 e59"><textual class="po-textual">RELAX NG offers solutions to all these challenges by providing an XML-based syntax for document grammars that is a close equivalent to DTD syntax (avoiding the verbosity and conceptual overhead of XSD) while making the creation of document type shells much simpler, reducing them to essentially a simple inclusion list of modules. Because RELAX NG patterns may unilaterally augment other patterns, RELAX NG vocabulary and constraint modules become "self integrating", such that in most cases no additional work is required beyond simply creating a reference to the module from the document type shell.</textual></para><para class="po-block e60 e60"><textual class="po-textual">Likewise, the relative simplicity of RELAX NG syntax coupled with an XML format make it practical to generate both DTD and XSD versions of the vocabulary from the RELAX NG.</textual></para></section><section class="po-hcontainer e61 e61"><title class="po-block e62 e62"><textual class="po-textual">DITA Modular Vocabulary Requirements</textual></title><para class="po-block e63 e63"><textual class="po-textual">A DITA vocabulary module defines either a set of element types or a single global attribute. The grammar definition for a module must satisfy the following requirements:</textual><orderedlist class="po-table e64 e64"><listitem class="po-container e65 e65"><para class="po-block e66 e66"><textual class="po-textual">Provide the @domains attribute contribution for the module.</textual></para></listitem><listitem class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">Define content models with appropriate parameterization so that the following types of modifications may be made through the redefinition, extension, or override of those parameters:</textual><itemizedlist class="po-table e69 e69"><listitem class="po-container e70 e70"><para class="po-block e71 e71"><textual class="po-textual">Redefine the content model in its entirety</textual></para></listitem><listitem class="po-container e72 e72"><para class="po-block e73 e73"><textual class="po-textual">Allow additional element types where any given element type is allowed (integration of domain-provided specializations of base element types).</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e74 e74"><para class="po-block e75 e75"><textual class="po-textual">Define attribute lists with appropriate parameterization so that the following types of modifications may be made through the redefinition, extension, or override of those parameters:</textual><itemizedlist class="po-table e76 e76"><listitem class="po-container e77 e77"><para class="po-block e78 e78"><textual class="po-textual">Redefine the attribute list in its entirety, for example, to omit specific attributes or set specific default values for specific attributes.</textual></para></listitem><listitem class="po-container e79 e79"><para class="po-block e80 e80"><textual class="po-textual">Extend the attribute list with global attributes defined in separate attribute domain modules.</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e81 e81"><para class="po-block e82 e82"><textual class="po-textual">Provide common reusable content model fragments used to construct element-type-specific content models</textual></para></listitem></orderedlist></para><para class="po-block e83 e83"><textual class="po-textual">Constraint modules use the parameterization facilities defined in modules to constrain element types. Thus any grammar facility must provide a way to include separate modules that can redefine or override parameters provided by modules.</textual></para><para class="po-block e84 e84"><textual class="po-textual">Document type shells include ("integrate") the vocabulary and constraint modules in order to define a working document type. The document type shell must set the value of the @domains attribute as specified on the root element of the DITA document the document type shell governs.</textual></para></section><section class="po-hcontainer e85 e85"><title class="po-block e86 e86"><textual class="po-textual">Challenges Posed by DTD Syntax</textual></title><para class="po-block e87 e87"><textual class="po-textual">As in all standard XML vocabularies intended for general use, the DITA DTDs make heavy use of parameter entities in order to enable configuration and constraint of vocabulary. The DITA DTD coding requirements specify the structure and naming rules for the parameter entities used to construct DITA element type and attribute list declarations.</textual></para><para class="po-block e88 e88"><textual class="po-textual">The most important parameters are:</textual><itemizedlist class="po-table e89 e89"><listitem class="po-container e90 e90"><para class="po-block e91 e91"><textual class="po-textual">Element type name parameter entities for use in content models. For each element type defined in a vocabulary module there is a correponding parameter entity that expands to the element type name. These parameter entities are used in content models, e.g.:</textual><programlisting class="po-block e92 e92" xml:space="preserve"><textual class="po-textual">&lt;!ENTITY % ph         "ph"            &gt;


...

&lt;!ENTITY % basic.ph 
  "%boolean; | 
   %cite; | 
   %keyword; | 
   </textual><emphasis class="po-inline e93 e93" role="bold"><textual class="po-textual">%ph;</textual></emphasis><textual class="po-textual"> | 
   %q; |
   %term; | 
   %tm; | 
   %xref; | 
   %state;
  "
&gt;</textual></programlisting></para></listitem><listitem class="po-container e94 e94"><para class="po-block e95 e95"><textual class="po-textual">"Domain integration" parameter entities, which are defined in domain modules and are used to override and extend the base values of element type name parameter entities in order to allow any specialization of the base type wherever the base type is allowed:</textual><programlisting class="po-block e96 e96" xml:space="preserve"><textual class="po-textual">&lt;!ENTITY % hi-d-ph      
  "b | 
   i | 
   sup | 
   sub |
   tt | 
   u 
  "
&gt;</textual></programlisting></para><para class="po-block e97 e97"><textual class="po-textual">Each element domain module is represented by a pair of files, one named *.ent, the other named *.mod. The domain integration parameter entity is defined in the .ent file while the element-type-name parameter entities are defined in the .mod files. This use of two files for each module leads to one common error in constructing DTD document type shells: inclusion of the wrong file, leading to confusing and difficult-to-detect or understand errors.</textual></para></listitem><listitem class="po-container e98 e98"><para class="po-block e99 e99"><textual class="po-textual">Content model parameter entities, which define the content models for each element type. These parameter entities are always named "</textual><emphasis class="po-inline e100 e100"><textual class="po-textual">tagname</textual></emphasis><textual class="po-textual">.content". These parameter entities allow any element type to be constrained through separate constraint modules that override the base definition of the element's content model parameter entity, e.g.:</textual><programlisting class="po-block e101 e101" xml:space="preserve"><textual class="po-textual">&lt;!ENTITY % body.content
                       "(%body.cnt; |
                         %bodydiv; | 
                         %example; | 
                         %section;)*"
&gt;</textual></programlisting></para></listitem></itemizedlist></para><para class="po-block e102 e102"><textual class="po-textual">As for all XML DTDs that make heavy use of parameter entities, one practical challenge is working out what the effective value of any given parameter entity is, as few, if any, DTD editing tools provide convenient ways to visualize expanded content models or follow references back to declarations.</textual></para><para class="po-block e103 e103"><textual class="po-textual">Another practical problem is determining which declaration of a given parameter entity is the effective one when there are multiple declarations in multiple files. Error messages resulting from incorrect declarations are usually not very helpful in finding the actual cause of the error as the errors tend to be about incorrect content models resulting from the failure to resolve a particular entity or an error in the declaration of a redefinition of an existing entity. All complex, heavily-parameterized document types suffer from this problem and DITA's are as complicated as any. If DITA has an advantage in this area it is only that its coding patterns are both consistent and mandated by the standard, making it slightly easier to detect typing errors.</textual></para><para class="po-block e104 e104"><textual class="po-textual">DTD-syntax document type shells in DITA require multiple external parameter entity references, in specific orders, for each structural and domain module as well as declaration of the domain integration parameter entities, again in the right order, as well as inclusion of any constraint modules used in the shell.</textual></para><para class="po-block e105 e105"><textual class="po-textual">The need for multiple external parameter entities for each module adds complexity and opportunities for error. For example, it is easy to accidentally include the wrong file, for example, including a .mod file instead of the required .ent file. This type of error can be hard to find because it doesn't necessarily make the resulting DTD invalid but may make it incorrect because the order of parameter entity declarations is not correct, causing subsequent redefinitions to have no effect.</textual></para><para class="po-block e106 e106"><textual class="po-textual">Likewise, it is easy to make typos in the domain entity integration parameter entity declarations, for example, omitting a "|" separator or simply misspelling the name of a domain-defined parameter entity. Or simply forgetting to include a reference to domain's integration parameter entity. None of these errors is easy to check programmatically and none are reported in a way that makes the real error obvious. Even experienced DITA DTD authors can find it difficult to diagnose and resolve these types of errors.</textual></para><para class="po-block e107 e107"><textual class="po-textual">While the DITA standard defines and documents the coding pattern for document type shells such that anyone should be able to simply follow the pattern in order to successfully create their own custom shell, in practice few people even attempt it and fewer succeed because of the inherent challenges of DTD syntax.</textual></para></section><section class="po-hcontainer e108 e108"><title class="po-block e109 e109"><textual class="po-textual">Challenges Posed by XML Schema</textual></title><para class="po-block e110 e110"><textual class="po-textual">The XML Schema Document (XSD) facility presents several challenges for use with DITA vocabularies:</textual></para><itemizedlist class="po-table e111 e111"><listitem class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">The requirement to use the XSD redefine facility</textual></para></listitem><listitem class="po-container e114 e114"><para class="po-block e115 e115"><textual class="po-textual">Limits on redefine and the resulting need for intermediate groups and, in some cases, intermediate files</textual></para></listitem><listitem class="po-container e116 e116"><para class="po-block e117 e117"><textual class="po-textual">Declarations for integrating domain-provided element types into base content models</textual></para></listitem><listitem class="po-container e118 e118"><para class="po-block e119 e119"><textual class="po-textual">The verbosity of the markup generally stemming from the XSD class and element type distinction, which does not correspond to DITA's class concept. </textual></para></listitem></itemizedlist><section class="po-hcontainer e120 e120"><title class="po-block e121 e121"><textual class="po-textual">XSD Redefine Facility</textual></title><para class="po-block e122 e122"><textual class="po-textual">The XSD redefine facility is defined ambiguously in the XSD recommendation such that conforming XSD processors may use either of two incompatible interpretations of redefinition, only one of which works for DITA. This means only some XSD processors can be used to validate XSD-based DITA documents. Fortunately, two of those processors are the Xerces Java and C-language XSD processors, making the required XSD processing available in all Java environments and many non-Java environments. In XSD 1.1 the Redefine facility is deprecated:</textual><blockquote class="po-container e123 e123"><para class="po-block e124 e124"><textual class="po-textual">4.2.4 Including modified component definitions (&lt;redefine&gt;)</textual></para><para class="po-block e125 e125"><textual class="po-textual">Note: The redefinition feature described in the remainder of this section is Â·deprecatedÂ· and may be removed from future versions of this specification. Schema authors are encouraged to avoid its use in cases where interoperability or compatibility with later versions of this specification are important.</textual></para></blockquote></para><para class="po-block e126 e126"><textual class="po-textual">The primary issue appears to be with systems that cache schemas. If two documents use two different top-level schemas, each of which redefines the same base model from a third schema, it is possible that a system may cache the redefine as defined by the first top-level schema and use it when processing against the second top-level schema. Any system that does this will reliably fail with typical DITA documents where there is a mix of topic types, each of which necessarily provides different redefines for the same base models. It is not clear if any XSD processors actually have this caching behavior.</textual></para><para class="po-block e127 e127"><textual class="po-textual">The XSD 1.1 override facility, which was driven in part by DITA requirements, appears to provide the override semantics DITA requires, but as XSD 1.1 is not universally implemented it is difficult to justify requiring the use of XSD 1.1. However, because the DITA XSDs are generated starting with DITA 1.3, it would be possible to generate XSDs that use override in place of redefine if the DITA community requires them. As of May 2014 it appears that the only XSD 1.1 implementations are Xerces-J and Saxon EE, which is not sufficient to support the full DITA community.</textual></para><para class="po-block e128 e128"><textual class="po-textual">The challenge presented by the XSD Redefine facility is its "particle preservation" requirement, defined as follows:</textual><blockquote class="po-container e129 e129"><para class="po-block e130 e130"><textual class="po-textual">The definitions within the &lt;redefine&gt; element itself are restricted to be redefinitions of components from the &lt;redefine&gt;d schema document, in terms of themselves. That is, </textual><itemizedlist class="po-table e131 e131"><listitem class="po-container e132 e132"><para class="po-block e133 e133"><textual class="po-textual">Type definitions must use themselves as their base type definition; </textual></para></listitem><listitem class="po-container e134 e134"><para class="po-block e135 e135"><textual class="po-textual">Attribute group definitions and model group definitions must be supersets or subsets of their original definitions, either by including exactly one reference to themselves or by containing only (possibly restricted) components which appear in a corresponding way in their &lt;redefine&gt;d selves.</textual><footnote class="po-popup e136 e136"><para class="po-block e137 e137"><textual class="po-textual">XML Schema Part 1: Structures Second Edition, clause 4.2.2 Including modified component definitions</textual></para></footnote></para></listitem></itemizedlist></para></blockquote></para><para class="po-block e138 e138"><textual class="po-textual">This means that any redefinition of a model must reflect each of the particles in the original model. For choice groups this is not a problem: any choice group is a valid restriction, including an empty group. But for sequence groups it is a serious problem, in that you cannot simply omit items from the sequence as part of the redefinition.</textual></para><para class="po-block e139 e139"><textual class="po-textual">For example, given this base schema:</textual><programlisting class="po-block e140 e140" xml:space="preserve"><textual class="po-textual">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
  xmlns:s1="urn:example.com:schema-01"
  targetNamespace="urn:example.com:schema-01"
  &gt;
  
  &lt;xs:complexType name="root.type"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="s1:A"/&gt;
      &lt;xs:element ref="s1:B"/&gt;
      &lt;xs:element ref="s1:C"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:element name="root" type="s1:root.type"&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="A" &gt;    
  &lt;/xs:element&gt;
  &lt;xs:element name="B" &gt;    
  &lt;/xs:element&gt;
  &lt;xs:element name="C" &gt;    
  &lt;/xs:element&gt;
  
&lt;/xs:schema&gt;</textual></programlisting></para><para class="po-block e141 e141"><textual class="po-textual">This redefinition is invalid:</textual><programlisting class="po-block e142 e142" xml:space="preserve"><textual class="po-textual">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
   xmlns:s1="urn:example.com:schema-01"
  targetNamespace="urn:example.com:schema-01"
  &gt;
  
  &lt;!-- Redefine of redefined schema 01 --&gt;
  &lt;xs:redefine schemaLocation="redefined-schema-01.xsd"&gt;
    &lt;xs:complexType name="root.type"&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:restriction base="s1:root.type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="s1:A"/&gt;
            &lt;xs:element ref="s1:C"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:redefine&gt;
&lt;/xs:schema&gt;</textual></programlisting></para><para class="po-block e143 e143"><textual class="po-textual">Because the "B" particle from the origin sequence is not accounted for in the redefined sequence.</textual></para><para class="po-block e144 e144"><textual class="po-textual">Likewise, this attempt to make "B" disallowed is also invalid:</textual><programlisting class="po-block e145 e145" xml:space="preserve"><textual class="po-textual">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
   xmlns:s1="urn:example.com:schema-01"
  targetNamespace="urn:example.com:schema-01"
  &gt;
  
  &lt;!-- Redefine of redefined schema 01 --&gt;
  &lt;xs:redefine schemaLocation="redefined-schema-01.xsd"&gt;
    &lt;xs:complexType name="root.type"&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:restriction base="s1:root.type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="s1:A"/&gt;
            </textual><emphasis class="po-inline e146 e146"><textual class="po-textual">&lt;xs:element ref="s1:B" maxOccurs="0" minOccurs="0"/&gt;</textual></emphasis><textual class="po-textual">
            &lt;xs:element ref="s1:C"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:redefine&gt;
&lt;/xs:schema&gt;</textual></programlisting></para><para class="po-block e147 e147"><textual class="po-textual">In both cases, the Xerces J parser reports that there is not a complete functional mapping between the particles in the original model and the redefined model.</textual></para><para class="po-block e148 e148"><textual class="po-textual">The solution is to refactor the sequence into a sequence of named groups. This allows the groups to be referenced from a redefinition, satisfying the requirement that a redefinition must include the thing being redefined:</textual><programlisting class="po-block e149 e149" xml:space="preserve"><textual class="po-textual">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" 
   xmlns:s1="urn:example.com:schema-01" targetNamespace="urn:example.com:schema-01"&gt;

  &lt;xs:group name="A.grp"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="s1:A"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
  &lt;xs:group name="B.grp"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="s1:B"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
  &lt;xs:group name="C.grp"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="s1:C"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;

  &lt;xs:complexType name="root.type"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="s1:A.grp"/&gt;
      &lt;xs:group ref="s1:B.grp"/&gt;
      &lt;xs:group ref="s1:C.grp"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="root" type="s1:root.type"&gt; &lt;/xs:element&gt;

  &lt;xs:element name="A"&gt; &lt;/xs:element&gt;
  &lt;xs:element name="B"&gt; &lt;/xs:element&gt;
  &lt;xs:element name="C"&gt; &lt;/xs:element&gt;

&lt;/xs:schema&gt;</textual></programlisting></para><para class="po-block e150 e150"><textual class="po-textual">Note that the pattern of xs:sequence/xs:choice is required in order to control occurrence of the choice (e.g., to make the choice optional or repeatable).</textual></para><para class="po-block e151 e151"><textual class="po-textual">The redefinition can then look like this:</textual><programlisting class="po-block e152 e152" xml:space="preserve"><textual class="po-textual">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
   xmlns:s1="urn:example.com:schema-01"
  targetNamespace="urn:example.com:schema-01"
  &gt;
  
  &lt;!-- Redefine of redefined schema 01 --&gt;
  &lt;xs:redefine schemaLocation="redefined-schema-02.xsd"&gt;
     &lt;xs:group name="B.grp"&gt;
       &lt;xs:sequence&gt;         
         &lt;xs:choice minOccurs="0" maxOccurs="0"&gt;
           &lt;xs:group ref="s1:B.grp"/&gt;
         &lt;/xs:choice&gt;
       &lt;/xs:sequence&gt;
     &lt;/xs:group&gt;
  &lt;/xs:redefine&gt;
&lt;/xs:schema&gt;</textual></programlisting></para><para class="po-block e153 e153"><textual class="po-textual">In this case, making the "B" element effectively disallowed while maintaining the required particle-to-particle association.</textual></para><para class="po-block e154 e154"><textual class="po-textual">This need for additional named groups for sequences within content models makes translating content models as normally formulated in DTD or RELAX NG grammars into XSD tedious at best and challenging at worst. It is not clear if there is a general algorithm for translating arbitrary content models with sequences into the necessary XSD groups in order to then enable arbitrary constraint via redefinition. In the case of the DITA XSDs, at least through DITA 1.2, this type of group refactoring has been done only as needed to support constraints defined by the DITA Technical Committee. This means that there are many element types that cannot be constrained using the XSD modules as provided by the DITA Technical Committee. This issue is explored in more detail below.</textual></para></section><section class="po-hcontainer e155 e155"><title class="po-block e156 e156"><textual class="po-textual">DITA 1.2 Group Design and XSD</textual></title><para class="po-block e157 e157"><textual class="po-textual">In DITA every base element type may be extended through the creation of "domain" element specializations such that anywhere the base element type is allowed the domain-defined specializations are also allowed.</textual></para><para class="po-block e158 e158"><textual class="po-textual">This is implemented in all grammar languages by defining the base content models using references to some type of parameter that initially resolves to just the base element type but that may be redefined to expand to the base type and its domain-provided specializations. Document type shells may also omit the base type or any specialized type, effectively imposing a constraint on the base element type as part of the domain integration. For example, given a domain that specializes the general inline element type &lt;ph&gt;, you might allow only the specialized types and omit &lt;ph&gt;. The naming pattern used in all grammar languages  gives the parameter the same name as the element type, e.g., "%ph" in DTDs, &lt;define name="ph"&gt; in RELAX NG, and &lt;xs:group name="ph"&gt; in XSD. </textual></para><para class="po-block e159 e159"><textual class="po-textual">For XSD this pattern means that there is one element-type-specific group for each element type defined in each vocabulary module. The base definition of each group simply allows the corresponding element:</textual><programlisting class="po-block e160 e160" xml:space="preserve"><textual class="po-textual">&lt;xs:group name="author"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="author"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:group&gt;</textual></programlisting></para><para class="po-block e161 e161"><textual class="po-textual">For example, a domain could extend the &lt;author&gt; element by defining two specializations of &lt;author&gt;, say &lt;editor&gt; and &lt;primary-author&gt;. Within document type shell XSD documents that integrate this domain the "author" group is redefined like so:</textual><programlisting class="po-block e162 e162" xml:space="preserve"><textual class="po-textual">  &lt;xs:redefine schemaLocation="urn:oasis:names:tc:dita:xsd:metaDeclGrp.xsd"&gt;
    &lt;xs:group name="author"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="author"/&gt;
        &lt;xs:group ref="jrnlmeta-d-author" /&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group&gt;
  &lt;/xs:redefine&gt;</textual></programlisting></para><para class="po-block e163 e163"><textual class="po-textual">The group "jrnlmeta-d-author" is defined like so:</textual><programlisting class="po-block e164 e164" xml:space="preserve"><textual class="po-textual">  &lt;xs:group name="jrnlmeta-d-author"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="editor" /&gt;
      &lt;xs:element ref="primary-author" /&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;</textual></programlisting></para><para class="po-block e165 e165"><textual class="po-textual">This redefinition satisfies the particle preservation requirement of the redefine feature because the original particle "author" is maintained with additional new particles added within a choice group. </textual></para><para class="po-block e166 e166"><textual class="po-textual">Note that each element-type-specific group must itself require its contained choice group. If this were not the case it would be impossible to define content models that required elements. Thus the element-type-specific groups themselves cannot be used to work around the redefinition particle preservation requirement.</textual></para></section><section class="po-hcontainer e167 e167"><title class="po-block e168 e168"><textual class="po-textual">Working Around Redefine Limitations: Indirection in Sequence Groups</textual></title><para class="po-block e169 e169"><textual class="po-textual">XSD redefinition is applied at the group level such that every particle in the original group must be represented in the redefined group. When the group defines a sequence it is not possible to redefine the sequence in order to omit tokens.</textual></para><para class="po-block e170 e170"><textual class="po-textual">For example, the DITA &lt;prolog&gt; element uses this sequence group as its abstract content model:</textual></para><programlisting class="po-block e171 e171" xml:space="preserve"><textual class="po-textual"> (author*, 
  source?, 
  publisher?,
  copyright*, 
  critdates?,
  permissions?, 
  metadata*, 
  resourceid*,
  (data.elements.incl | 
   foreign.unknown.incl)*)</textual></programlisting><para class="po-block e172 e172"><textual class="po-textual">Each element is optional. Per the rule for DITA constraints you can omit any optional element. This means that any restriction of the content model that omits one or more particles is a conforming constraint. </textual></para><para class="po-block e173 e173"><textual class="po-textual">If the XSD implementation of the content model is defined as a single group the resulting group is will not allow constraints that omit optional types:</textual><programlisting class="po-block e174 e174" xml:space="preserve"><textual class="po-textual">&lt;xs:sequence&gt;
  &lt;xs:group ref="author" minOccurs="0" maxOccurs="unbounded"/&gt;
  &lt;xs:group ref="source" minOccurs="0"/&gt;
  &lt;xs:group ref="publisher" minOccurs="0"/&gt;
  &lt;xs:group ref="copyright" minOccurs="0" maxOccurs="unbounded"/&gt;
  &lt;xs:group ref="critdates" minOccurs="0"/&gt;
  &lt;xs:group ref="permissions" minOccurs="0"/&gt;
  &lt;xs:group ref="metadata" minOccurs="0" maxOccurs="unbounded"/&gt;
  &lt;xs:group ref="resourceid" minOccurs="0" maxOccurs="unbounded"/&gt;
  &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
    &lt;xs:group ref="data.elements.incl"/&gt;
    &lt;xs:group ref="foreign.unknown.incl"/&gt;
  &lt;/xs:choice&gt;
&lt;/xs:sequence&gt;</textual></programlisting></para><para class="po-block e175 e175"><textual class="po-textual">The general solution is to add another layer of grouping such that for each contiguous sequence of omittable elements there is a group whose content is an emptiable choice or sequence.</textual></para><para class="po-block e176 e176"><textual class="po-textual">For example, the base content model for the DITA &lt;taskbody&gt; element is:</textual><programlisting class="po-block e177 e177" xml:space="preserve"><textual class="po-textual">((prereq | 
  context |
  section)*,
 (steps | 
  steps-unordered |
  steps-informal)?, 
 result?, 
 example*, 
 postreq*)      </textual></programlisting></para><para class="po-block e178 e178"><textual class="po-textual">The DITA standard defines a constraint on this content model, the "strict task" constraint, which omits the &lt;section&gt; and &lt;steps-informal&gt; elements. </textual></para><para class="po-block e179 e179"><textual class="po-textual">If the XSD implementation of this content model were simply the equivalent sequence group, it would not be constrainable because the particle preservation rule does not allow omission of the &lt;section&gt; or &lt;steps-informal&gt; groups.</textual></para><para class="po-block e180 e180"><textual class="po-textual">One solution is to insert three groups: one for the elements before &lt;steps&gt;, one for the &lt;steps&gt; optional choice group, and one for the elements after &lt;steps&gt;:</textual><programlisting class="po-block e181 e181" xml:space="preserve"><textual class="po-textual">  &lt;xs:group name="taskbody.content"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="taskPreStep"/&gt;
      &lt;xs:group ref="taskStep"/&gt;
      &lt;xs:group ref="taskPostStep"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;

  &lt;xs:group name="taskPreStep"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:group ref="context" minOccurs="0"/&gt;
        &lt;xs:group ref="prereq"  minOccurs="0"/&gt;
        &lt;xs:group ref="section" minOccurs="0"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;

  &lt;xs:group name="taskPostStep"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="result"  minOccurs="0"/&gt;
      &lt;xs:group ref="example"  minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:group ref="postreq"  minOccurs="0" maxOccurs="unbounded"/&gt;  
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:group name="taskStep"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="1"&gt;
        &lt;xs:group ref="steps" /&gt;
        &lt;xs:group ref="steps-unordered" /&gt;
        &lt;xs:group ref="steps-informal" /&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;</textual></programlisting></para><para class="po-block e182 e182"><textual class="po-textual">This extra level of grouping enables the constraint for &lt;taskbody&gt;. However, no other sequence group content model in the DITA 1.2 XSD schemas provides a comparable set of emptiable groups, meaning that more than 150 element types in the DITA 1.2 base vocabulary are not constrainable without first modifying the OASIS-provided XSDs, which violates the basic DITA principle that all copies of a given vocabulary module are identical.</textual></para><para class="po-block e183 e183"><textual class="po-textual">This presents an implementation challenge for the XSD generation process: is there a general algorithm that will generate constrainable model groups that allow any valid constraint (in particular, allowing removal of optional elements?</textual></para></section><section class="po-hcontainer e184 e184"><title class="po-block e185 e185"><textual class="po-textual">Declarations for Integrating Domain Element Types in XSD Document Type Shells</textual></title><para class="po-block e186 e186"><textual class="po-textual">Domain-provided specialized element types are integrated through redefinitions specified in document type shells. The markup itself is not particularly complicated, but it must be specified in every document type shell that integrates a given domain.  Domain-provided elements types are "mix-in" elements, meaning that the domain-provided elements must be allowed wherever the element they specialize is allowed. Conceptually this is equivalent to an XSD substitution group. However, it appears that XSD substitution groups do not work reliably for this and thus are not used by the DITA XSDs.</textual></para><para class="po-block e187 e187"><textual class="po-textual">Because the integration of each domain requires explicit redefinition in the XSD document type shell, XSD domains are not self integrating.</textual></para><para class="po-block e188 e188"><textual class="po-textual">The names of the groups to be referenced in the redefined groups are determined by the short name of each integrated domain. The DITA XSD coding requirements specify that the domain integration groups must be named such that, given the domain short name, you can reliably construct the domain integration group name.</textual></para><para class="po-block e189 e189"><textual class="po-textual">A typical document type shell is the OASIS-provided concept topic type shell:</textual><programlisting class="po-block e190 e190" xml:space="preserve"><textual class="po-textual">  &lt;xs:redefine schemaLocation="urn:oasis:names:tc:dita:xsd:commonElementGrp.xsd:1.2"&gt;
    &lt;xs:group name="keyword"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="keyword"/&gt;
        &lt;xs:group ref="pr-d-keyword" /&gt;
        &lt;xs:group ref="ui-d-keyword" /&gt;
        &lt;xs:group ref="sw-d-keyword" /&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group&gt;

    &lt;xs:group name="ph"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="ph"/&gt;
        &lt;xs:group ref="pr-d-ph" /&gt;
        &lt;xs:group ref="ui-d-ph" /&gt;
        &lt;xs:group ref="hi-d-ph" /&gt;
        &lt;xs:group ref="sw-d-ph" /&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group&gt;

    &lt;xs:group name="pre"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="pre"/&gt;
        &lt;xs:group ref="pr-d-pre" /&gt;
        &lt;xs:group ref="ui-d-pre" /&gt;
        &lt;xs:group ref="sw-d-pre" /&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group&gt;

    &lt;xs:group name="dl"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="dl"/&gt;
        &lt;xs:group ref="pr-d-dl"/&gt;
      &lt;/xs:choice &gt;
    &lt;/xs:group &gt;

    &lt;xs:group name="fig"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="fig"/&gt;
        &lt;xs:group ref="pr-d-fig"/&gt;
        &lt;xs:group ref="ut-d-fig" /&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group &gt;
    
    &lt;xs:group name="index-base"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="index-base"/&gt;
        &lt;xs:group ref="indexing-d-index-base"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group &gt;
      
    &lt;xs:group name="note"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="note"/&gt;
        &lt;xs:group ref="hazard-d-note"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group &gt;
    
    &lt;xs:group name="term"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="term"/&gt;
        &lt;xs:group ref="abbrev-d-term"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group &gt;

  &lt;/xs:redefine&gt;</textual></programlisting></para></section></section><section class="po-hcontainer e191 e191"><title class="po-block e192 e192"><textual class="po-textual">How RELAX NG Addresses DITA Requirements</textual></title><para class="po-block e193 e193"><textual class="po-textual">RELAX NG provides an almost ideal match of syntax and semantics to DITA vocabulary architecture requirements:</textual></para><itemizedlist class="po-table e194 e194"><listitem class="po-container e195 e195"><para class="po-block e196 e196"><textual class="po-textual">The RELAX NG pattern approach is a good match to DTD semantics and thus to DITA semantics.</textual></para></listitem><listitem class="po-container e197 e197"><para class="po-block e198 e198"><textual class="po-textual">The ability to extend patterns unilaterally makes modules self-integrating, reducing the complexity of document type shells.</textual></para></listitem><listitem class="po-container e199 e199"><para class="po-block e200 e200"><textual class="po-textual">RELAX NG's XML syntax plus semantic match to DTDs makes generating conforming DITA DTDs practical.</textual></para></listitem><listitem class="po-container e201 e201"><para class="po-block e202 e202"><textual class="po-textual">RELAX NG's XML syntax makes generating XSDs practical, if challenging due to requirements for XSDs.</textual></para></listitem></itemizedlist><para class="po-block e203 e203"><textual class="po-textual">The use of RELAX NG for DITA does require two things not in the base RELAX NG standard:</textual><itemizedlist class="po-table e204 e204"><listitem class="po-container e205 e205"><para class="po-block e206 e206"><textual class="po-textual">Attribute default values. These are provided for by the companion RELAX NG DTD Compatibility standard. One of us (Bina) implemented support for attribute defaults as an enhancement to the open-source JING library, making RELAX NGs directly usable for DITA document processing in any Java processing environment. </textual></para></listitem><listitem class="po-container e207 e207"><para class="po-block e208 e208"><textual class="po-textual">DITA-specific metadata for vocabulary and constraint modules and document type shells. DITA-specific metadata is required in order to enable generation of DTD and XSD versions of the RELAX NG document type shells and modules, such as the public IDs to use for specific generated modules, the module types, and module short names, as well as DITA-specific properties for individual element types, such as a long name and the initial DITA versions for patterns and pattern components.</textual></para></listitem></itemizedlist></para><para class="po-block e209 e209"><textual class="po-textual">The one tedious aspect of RELAX NG that adds complexity to the DITA document type shells is the need to have special declarations in the shell for elements that define @id attributes of type "ID". </textual></para><para class="po-block e210 e210"><textual class="po-textual">In DITA most elements define the @id attribute as NMTOKEN rather than as an XML ID. However, some element types, in particular, &lt;topic&gt; and all specializations of &lt;topic&gt;, use XML IDs. RELAX NG's rules for "any" patterns do not allow two different element types to have different datatypes for the same attribute. DITA document type shells must work around this by redefining the "any" patterns to explicitly exclude those element types or foreign namespaces that define @id attributes as type ID. However, for most shells this redefinition is the same except for the tagnames of the topic types defined or included in the shell. </textual></para><para class="po-block e211 e211"><textual class="po-textual">The only other component of document type shells that must be set manually is the value of the @domains attribute for the root topic or map element defined by the shell as RELAX NG provides no way to dynamically construct the pattern for attribute defaults. However, each vocabulary and constraint module declares its @domains contribution in DITA-specific metadata. The DITA Technical Committee provides a simple XQuery script that updates the value of the @domains attribute to reflect the modules actually included, removing the need to manually set and maintain the @domains value.</textual></para><section class="po-hcontainer e212 e212"><title class="po-block e213 e213"><textual class="po-textual">RELAX NG is a Good Match to DTDs</textual></title><para class="po-block e214 e214"><textual class="po-textual">The RELAX NG pattern approach, as opposed to the XSD type/element approach, provides a close semantic and syntactic match to XML DTDs, making it relatively easy for DTD authors to transition to RELAX NG as their grammar language. There is an almost one-to-one correspondence between DTD syntactic constructs and RELAX NG grammar components. This makes it relatively easy to translate existing DTD-syntax vocabulary modules into the equivalent RELAX NG grammars. It also allows the DITA-defined RELAX NG coding requirements to be as close to the DTD coding requirements as possible, maximizing the applicability of existing DTD coding knowledge to DITA RELAX NG grammars.</textual></para><para class="po-block e215 e215"><textual class="po-textual">The RELAX NG compact syntax is also syntactically similar to DTD syntax. The compact syntax is less convenient for DITA vocabularies because DITA grammars do require use of non-RELAX NG elements and attributes but it is still usable as RELAX NG provides ways of encoding foreign elements and attributes in the compact syntax. The DITA Technical Committee generates RELAX NG compact syntax versions of all the TC-defined DITA vocabulary.</textual></para></section><section class="po-hcontainer e216 e216"><title class="po-block e217 e217"><textual class="po-textual">Modules are Self Integrating</textual></title><para class="po-block e218 e218"><textual class="po-textual">The most dramatic advantage of RELAX NG over both DTD and XSD is the ability for one pattern to unilaterally extend another pattern. This allows DITA domain modules to automatically extend the patterns for the base elements those domains specialize. </textual></para><para class="po-block e219 e219"><textual class="po-textual">As for DTDs and XSDs, each element type is represented by a pattern whose name is the same as the element type:</textual><programlisting class="po-block e220 e220" xml:space="preserve"><textual class="po-textual">  &lt;define name="ph"&gt;
    &lt;ref name="ph.element"/&gt;
  &lt;/define&gt;</textual></programlisting></para><para class="po-block e221 e221"><textual class="po-textual">The domain specialization of a given element simply extends the element-type pattern to add the specializations provided by the domain:</textual><programlisting class="po-block e222 e222" xml:space="preserve"><textual class="po-textual">    &lt;define name="hi-d-ph"&gt;
      &lt;choice&gt;
        &lt;ref name="b.element"/&gt;
        &lt;ref name="i.element"/&gt;
        &lt;ref name="line-through.element" dita:since="1.3"/&gt;
        &lt;ref name="overline.element" dita:since="1.3"/&gt;
        &lt;ref name="sup.element"/&gt;
        &lt;ref name="sub.element"/&gt;
        &lt;ref name="tt.element"/&gt;
        &lt;ref name="u.element"/&gt;
      &lt;/choice&gt;
    &lt;/define&gt;

    &lt;define name="ph" combine="choice"&gt;
      &lt;ref name="hi-d-ph"/&gt;
    &lt;/define&gt;</textual></programlisting></para><para class="po-block e223 e223"><textual class="po-textual">The </textual><code class="po-atom e224 e224"><textual class="po-textual">combine="choice"</textual></code><textual class="po-textual"> on the domain-specific definition of the "ph" pattern in this example makes the effective value of the "ph" pattern the base tokens plus all the tokens defined in the "hi-d-ph" pattern. This corresponds directly to the domain integration parameter entities in DTDs and domain integration redefines in XSDs, but requires no additional work in document type shells.</textual></para><para class="po-block e225 e225"><textual class="po-textual">The document type shell can then be a simple set of module inclusions. This eliminates almost all of the complexity and opportunity for error of DTD and XSD document type shells. In short, it makes creating DITA document type shells about as easy as it could possibly be.</textual></para></section><section class="po-hcontainer e226 e226"><title class="po-block e227 e227"><textual class="po-textual">DTD and XSD Generation</textual></title><para class="po-block e228 e228"><textual class="po-textual">While RELAX NG has many advantages for DITA vocabulary authors the DITA community still requires DTDs and, to a lesser extent, XSDs. Almost all DITA-aware tools are DTD-aware and a few are XSD-only. Few support use of RELAX NG today. Thus the DITA Technical Committee must continue to provide DTD and XSD versions of all TC-defined vocabulary. In addition, these DTDs and XSDs must themselves conform to the DITA coding requirements for DTDs.</textual></para><para class="po-block e229 e229"><textual class="po-textual">One of us (Kimber) has implemented XSLT-based transforms to generate conforming DTD, XSD, and RELAX NG compact syntax modules and shells from the RELAX NG XML syntax modules. These transforms allow the DITA Technical Committee to make the RELAX NG vocabulary the authoritative master from which all other forms are generated, significantly reducing the cost of maintaining multiple grammar formats for the DITA vocabulary.</textual></para></section></section><section class="po-hcontainer e230 e230"><title class="po-block e231 e231"><textual class="po-textual">Conclusions and Future Work</textual></title><para class="po-block e232 e232"><textual class="po-textual">As an alternative to DTDs, RELAX NG has proven to be superior to XSD in almost every way. It is provides a good semantic and syntactic match to DTDs. It's rules for extending and overriding patterns work well for DITA's specialization and constraint features. It's XML syntax makes implementing generation of other formats practical using normal XML tools (XSLT, XQuery). The ability to unilaterally extend patterns makes RELAX NG document type shells about as easy as it can be. Even if used only as a source for then generating the DTDs and XSDs used with DITA processing tools, RELAX NG offers significant benefits to DITA document type shell and module authors.</textual></para><para class="po-block e233 e233"><textual class="po-textual">Through this experience we have identified potential improvements to RELAX NG that would make its use even simpler:</textual><itemizedlist class="po-table e234 e234"><listitem class="po-container e235 e235"><para class="po-block e236 e236"><textual class="po-textual">Relax the constraints on attribute types within "any" patterns.</textual></para></listitem><listitem class="po-container e237 e237"><para class="po-block e238 e238"><textual class="po-textual">Provide a mechanism for dynamically constructing attribute value defaults</textual></para></listitem></itemizedlist></para><para class="po-block e239 e239"><textual class="po-textual">With these two refinements, DITA modules would be complete self-integrating, making DITA document type shells truly just inclusion lists of modules.</textual></para><para class="po-block e240 e240"><textual class="po-textual">The question of generation of constrainable XSD content models remain open. More thought and experimentation is required but at the time of writing it is not clear that a general algorithm for translating sequence groups to the necessary XSD groups is either possible or desirable. In addition, it is not clear that there is sufficient use of XSDs within the DITA community with non-TC-provided constraints to justify the effort of trying to generate constrainable XSDs. One piece of evidence that this is the case is the fact that the issue with the general lack of constrainability was not discovered until we started implementing the XSD generation process, meaning that no DITA user reported any issue with XSD constraints between the time DITA 1.1 was released and now. Either nobody tried to implement constraints of sequence groups using XSDs in that time or anyone who did simply modified their TC-provided XSD files locally and never reported the issue to the DITA Technical Committee or to the DITA community at large.</textual></para><para class="po-block e241 e241"><textual class="po-textual">At the time of writing the decision of the DITA Technical Committee is to generate the DITA 1.3 XSDs using the same content model patterns as for DITA 1.2, treating those content models that require constraint (e.g., taskbody) as special cases within the XSD generation transform. Because the XSDs are generated the Technical Committee can add additional special cases as required, replace the use of Redefine with Override, or improve the general model generation algorithm.</textual></para></section><bibliography class="po-hcontainer e242 e242"><title class="po-block e243 e243"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e244 e244" xml:id="dita-std"><emphasis class="po-inline e245 e245"><textual class="po-textual">Darwin Information Typing Architecture</textual></emphasis><textual class="po-textual">, OASIS Open. </textual><link class="po-inline e246 e246" xlink:actuate="onRequest" xlink:href="http://docs.oasis-open.org/dita/v1.2/os/spec" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.oasis-open.org/dita/v1.2/os/spechttp://docs.oasis-open.org/dita/v1.2/os/spec</textual></link></bibliomixed><bibliomixed class="po-block e247 e247" xml:id="xml-std"><emphasis class="po-inline e248 e248"><textual class="po-textual">Extensible Markup Language</textual></emphasis><textual class="po-textual">, W3C. </textual><link class="po-inline e249 e249" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml11/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml11/</textual></link></bibliomixed><bibliomixed class="po-block e250 e250" xml:id="relaxng-std"><emphasis class="po-inline e251 e251"><textual class="po-textual">RELAX NG</textual></emphasis><textual class="po-textual">, OASIS Open. </textual><link class="po-inline e252 e252" xlink:actuate="onRequest" xlink:href="http://relaxng.org/spec-20011203.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://relaxng.org/spec-20011203.html</textual></link></bibliomixed><bibliomixed class="po-block e253 e253" xml:id="rng-dtd-compat-std"><emphasis class="po-inline e254 e254"><textual class="po-textual">RELAX NG DTD Compatibility</textual></emphasis><textual class="po-textual">, OASIS Open. </textual><link class="po-inline e255 e255" xlink:actuate="onRequest" xlink:href="http://relaxng.org/compatibility-20011203.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></link></bibliomixed><bibliomixed class="po-block e256 e256" xml:id="xsd-std1.1"><emphasis class="po-inline e257 e257"><textual class="po-textual">XML Schema Part 1: Structures Second Edition</textual></emphasis><textual class="po-textual">, W3C. </textual><link class="po-inline e258 e258" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</textual></link></bibliomixed><bibliomixed class="po-block e259 e259"><emphasis class="po-inline e260 e260"><textual class="po-textual">W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures</textual></emphasis><textual class="po-textual">, W3C. </textual><link class="po-inline e261 e261" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema11-1" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema11-1</textual></link></bibliomixed></bibliography></article></classedDocument>