<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Beyond Well-Formed and Valid</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">QA for XML Configuration Files</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">International Symposium on Quality Assurance and Quality Control in XML</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 6, 2012</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">One of the consequences of the rapid development and dissemination of the ecosystem of XML technologies was the widespread adoption of XML as a meta-format for the specification of application configuration information.  The validation of these rich configuration files with standard XML validation tools, however, is often not sufficient for error-free deployment of applications.  This paper considers how to categorize some of the constraints that cannot be enforced by such tools, and discusses some XML-based approaches to enforcing such constraints before, or as part of, deployment.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Sheila</textual></firstname><othername class="po-field e12 e12"><textual class="po-textual">M.</textual></othername><surname class="po-field e13 e13"><textual class="po-textual">Morrissey</textual></surname></personname><personblurb class="po-container e14 e14"><para class="po-block e15 e15"><textual class="po-textual">Sheila Morrissey is Senior Research Developer at ITHAKA.</textual></para></personblurb><affiliation class="po-record e16 e16"><jobtitle class="po-field e17 e17"><textual class="po-textual">Senior Research Developer</textual></jobtitle><orgname class="po-block e18 e18"><textual class="po-textual">ITHAKA</textual></orgname></affiliation><email class="po-field e19 e19"><textual class="po-textual">sheila.morrissey@ithaka.org</textual></email></author><author class="po-record e20 e20"><personname class="po-record e21 e21"><firstname class="po-field e22 e22"><textual class="po-textual">John</textual></firstname><surname class="po-field e23 e23"><textual class="po-textual">Meyer</textual></surname></personname><personblurb class="po-container e24 e24"><para class="po-block e25 e25"><textual class="po-textual">John Meyer is Director of Data Technology at ITHAKA.</textual></para></personblurb><affiliation class="po-record e26 e26"><jobtitle class="po-field e27 e27"><textual class="po-textual">Director of Data Technology</textual></jobtitle><orgname class="po-block e28 e28"><textual class="po-textual">ITHAKA</textual></orgname></affiliation><email class="po-field e29 e29"><textual class="po-textual">john.meyer@ithaka.org</textual></email></author><author class="po-record e30 e30"><personname class="po-record e31 e31"><firstname class="po-field e32 e32"><textual class="po-textual">Sushil</textual></firstname><surname class="po-field e33 e33"><textual class="po-textual">Bhattarai</textual></surname></personname><personblurb class="po-container e34 e34"><para class="po-block e35 e35"><textual class="po-textual">Sushil Bhattarai is a Data Software Developer at ITHAKA.</textual></para></personblurb><affiliation class="po-record e36 e36"><jobtitle class="po-field e37 e37"><textual class="po-textual">Data Software Developer</textual></jobtitle><orgname class="po-block e38 e38"><textual class="po-textual">ITHAKA</textual></orgname></affiliation><email class="po-field e39 e39"><textual class="po-textual">sushil.bhattarai@ithaka.org</textual></email></author><author class="po-record e40 e40"><personname class="po-record e41 e41"><firstname class="po-field e42 e42"><textual class="po-textual">Gautham</textual></firstname><surname class="po-field e43 e43"><textual class="po-textual">Kalwala</textual></surname></personname><personblurb class="po-container e44 e44"><para class="po-block e45 e45"><textual class="po-textual">Gautham Kalwala is a member of the ITHAKA data team.</textual></para></personblurb><email class="po-field e46 e46"><textual class="po-textual">gautham.kalwala@ithaka.org</textual></email></author><author class="po-record e47 e47"><personname class="po-record e48 e48"><firstname class="po-field e49 e49"><textual class="po-textual">Sachin</textual></firstname><surname class="po-field e50 e50"><textual class="po-textual">Kurdikar</textual></surname></personname><personblurb class="po-container e51 e51"><para class="po-block e52 e52"><textual class="po-textual">Sachin Kurdikar  is a Data Software Developer at ITHAKA.</textual></para></personblurb><affiliation class="po-record e53 e53"><jobtitle class="po-field e54 e54"><textual class="po-textual">Data Software Developer</textual></jobtitle><orgname class="po-block e55 e55"><textual class="po-textual">ITHAKA</textual></orgname></affiliation><email class="po-field e56 e56"><textual class="po-textual">sachin.kurdikar@ithaka.org</textual></email></author><author class="po-record e57 e57"><personname class="po-record e58 e58"><firstname class="po-field e59 e59"><textual class="po-textual">Jie</textual></firstname><surname class="po-field e60 e60"><textual class="po-textual">Ling</textual></surname></personname><personblurb class="po-container e61 e61"><para class="po-block e62 e62"><textual class="po-textual">Jie Ling is a Data Software Developer at ITHAKA.</textual></para></personblurb><affiliation class="po-record e63 e63"><jobtitle class="po-field e64 e64"><textual class="po-textual">Data Software Developer</textual></jobtitle><orgname class="po-block e65 e65"><textual class="po-textual">ITHAKA</textual></orgname></affiliation><email class="po-field e66 e66"><textual class="po-textual">jie.ling@ithaka.org</textual></email></author><author class="po-record e67 e67"><personname class="po-record e68 e68"><firstname class="po-field e69 e69"><textual class="po-textual">Matt</textual></firstname><surname class="po-field e70 e70"><textual class="po-textual">Stoeffler </textual></surname></personname><personblurb class="po-container e71 e71"><para class="po-block e72 e72"><textual class="po-textual">Matt Stoeffler is a Data Software Developer at ITHAKA.</textual></para></personblurb><affiliation class="po-record e73 e73"><jobtitle class="po-field e74 e74"><textual class="po-textual">Data Software Developer</textual></jobtitle><orgname class="po-block e75 e75"><textual class="po-textual">ITHAKA</textual></orgname></affiliation><email class="po-field e76 e76"><textual class="po-textual">matt.stoeffler@ithaka.org</textual></email></author><author class="po-record e77 e77"><personname class="po-record e78 e78"><firstname class="po-field e79 e79"><textual class="po-textual">Umadevi</textual></firstname><surname class="po-field e80 e80"><textual class="po-textual">Thanneeru</textual></surname></personname><personblurb class="po-container e81 e81"><para class="po-block e82 e82"><textual class="po-textual">Umadevi Thanneeru is a Data Software Developer at ITHAKA.</textual></para></personblurb><affiliation class="po-record e83 e83"><jobtitle class="po-field e84 e84"><textual class="po-textual">Data Software Developer</textual></jobtitle><orgname class="po-block e85 e85"><textual class="po-textual">ITHAKA</textual></orgname></affiliation><email class="po-field e86 e86"><textual class="po-textual">umadevi.thanneeru@ithaka.org</textual></email></author><legalnotice class="po-container e87 e87"><para class="po-block e88 e88"><textual class="po-textual">Copyright © 2012 ITHAKA</textual></para></legalnotice></info><section class="po-hcontainer e89 e89"><title class="po-block e90 e90"><textual class="po-textual">XML for Configuration:  Background</textual></title><para class="po-block e91 e91"><textual class="po-textual">One of the consequences of the rapid development and dissemination of an ecosystem of XML technologies, including free and open source XML parsers, XSLT engines, and binding tools for various programming languages, was the widespread adoption of XML as a meta-format for the specification of application configuration information.  The XML ecosystem obviated the need to write custom parsers for one-off configuration formats.  This was true in part because, at least at the syntactic level, there was a tool-chain at hand to warrant the well-formedness and validity of those files.  XML also facilitated the use of richly structured configuration information.  Coincident with an increasing community of practice in architectural idioms such as abstract factories (see [</textual><xref class="po-milestone e92 e92" linkend="bib02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]), this capacity for rich configuration made XML the norm for configuration of such applications as Apache’s Tomcat server for Java servlets and Java Server Pages (JSP), Hibernate’s object/relational mapping framework, the Ant build tool, and the Spring application framework and inversion-of-control (IOC) container. </textual></para><para class="po-block e93 e93"><textual class="po-textual">These rich configuration files forward many diverse ends, ranging from (at least the possibility of) more cleanly engineered code, to hot-swappable web applications.  However, as even a cursory view of these projects’ listservs indicates, configuration files often are the cause of hiccups in application deployment.  Some of these problems can be alleviated by the application of standard XML validating parsers in the deployment process.  Other problems however do not yield themselves to the standard XML tool chain.</textual></para><para class="po-block e94 e94"><textual class="po-textual">Widely used applications such as the ones mentioned here often have interactive development environment (IDE) support for the creation of configuration files.  The IDE might make use of template files, for example, and provide hints when creating and populating configuration instances.  Such IDE support however is not typically robust in validating the content entered, whether or not the hints are taken.</textual></para><para class="po-block e95 e95"><textual class="po-textual">The information models of which these XML configuration files are instantiations (see
                [</textual><xref class="po-milestone e96 e96" linkend="bib01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]) entail constraints more complex than those enforced by XML
            well-formedness and validity. These constraints are not expressed, and are perhaps
            inexpressible, in a configuration file’s document type definition, whether that
            definition is a DTD, or an XSD schema, or a RelaxNG specification. How might we
            categorize at least some of these constraints? What techniques can we employ to enforce
            them before, or as part of, deployment?</textual></para></section><section class="po-hcontainer e97 e97"><title class="po-block e98 e98"><textual class="po-textual">XML for Configuration at Portico:  Issues</textual></title><section class="po-hcontainer e99 e99"><title class="po-block e100 e100"><textual class="po-textual">What is Portico?</textual></title><para class="po-block e101 e101"><link class="po-inline e102 e102" xlink:actuate="onRequest" xlink:href="http://www.portico.org/digital-preservation/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Portico</textual></link><textual class="po-textual"> is a digital preservation service for electronic journals, books, and other content. Portico is a service of </textual><link class="po-inline e103 e103" xlink:actuate="onRequest" xlink:href="http://ithaka.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">ITHAKA</textual></link><textual class="po-textual">, a not-for-profit organization dedicated to helping the academic community use digital technologies to preserve the scholarly record and to advance research and teaching in sustainable ways.  As of April 2012, Portico is preserving more than 17.7 million journal articles, nearly 17,000 books, and nearly 1.5 million items from digitized historical collections (for example digitized newspapers of the 18th century).</textual></para><para class="po-block e104 e104"><textual class="po-textual">Content comes to Portico in approximately 300 different XML and SGML vocabularies.
                These XML and SGML documents are accompanied by page image (PDF) and other
                supporting files such as still and moving images, spreadsheets, audio files, and
                others. Typically content providers do not have any sort of manifest or other
                explicit description of how files are related (which ones make up an article, an
                issue of a journal, a chapter of a book). This content is batched and fed into a
                Java workflow that is driven by XML configuration files, which Portico calls
                    </textual><quote class="po-inline e105 e105"><textual class="po-textual">profiles</textual></quote><textual class="po-textual"> (about 190, one for each publisher content stream), and
                    </textual><quote class="po-inline e106 e106"><textual class="po-textual">registries</textual></quote><textual class="po-textual"> (shared across all content streams). </textual></para><para class="po-block e107 e107"><textual class="po-textual">The Portico workflow maps the publisher-provided miscellany of files into bundles
                that comprise an article or book or other content item. </textual></para><para class="po-block e108 e108"><textual class="po-textual">
                </textual><figure class="po-container e109 e109" xml:id="fig01" xreflabel="Figure 1"><mediaobject class="po-container e110 e110"><imageobject class="po-container e111 e111"><imagedata class="po-meta e112 e112" fileref="../../../vol9/graphics/Morrissey01/Morrissey01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e113 e113"><para class="po-block e114 e114"><textual class="po-textual">Figure 1:  Mapping Files to Content Units</textual></para></caption></figure><textual class="po-textual">
                
            </textual></para><para class="po-block e115 e115"><textual class="po-textual">Publisher-provided XML and SGML files are normalized to the Portico profile of the
                National Library of Medicine’s Journal Archiving DTD. The workflow identifies the
                format of each of the component files, and, where a format specification and
                validation tool is available, validates each file against its format specification.
                It generates metadata considered important for preservation (descriptive, or
                bibliographic, metadata; technical metadata about files and their formats;
                provenance and event metadata, detailing the tool chain, including hardware and
                software information, used in processing the content). These metadata are formatted
                as XML, and are stored with the preserved digital object.</textual></para><para class="po-block e116 e116"><textual class="po-textual">
                </textual><figure class="po-container e117 e117" xml:id="fig02" xreflabel="Figure 2"><mediaobject class="po-container e118 e118"><imageobject class="po-container e119 e119"><imagedata class="po-meta e120 e120" fileref="../../../vol9/graphics/Morrissey01/Morrissey01-002.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e121 e121"><para class="po-block e122 e122"><textual class="po-textual">Figure 2: Portico High-Level Workflow</textual></para></caption></figure><textual class="po-textual">
                
            </textual></para><para class="po-block e123 e123"><textual class="po-textual">Some of the sub-steps in this workflow are explicit QA checks of the XML content –
                both that provided by the publishers, and that produced by Portico in the workflow
                itself. This QA includes XML validation, the assertion (via Schematron) of other
                constraints on content values, and visual inspection of sample content. We have
                written about some of the QA techniques and challenges associated with these content
                files for Balisage and other venues (see, for example, [</textual><xref class="po-milestone e124 e124" linkend="bib03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and
                    [</textual><xref class="po-milestone e125 e125" linkend="bib04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]). In this paper we would like to focus on the QA
                challenges associated with those XML registry files that drive our workflow.</textual></para></section><section class="po-hcontainer e126 e126"><title class="po-block e127 e127"><textual class="po-textual">Portico XML Configuration Files:  A Description</textual></title><para class="po-block e128 e128"><textual class="po-textual">The Portico workflow is a pluggable framework.  At each step, or activity, in the workflow, the particular tool to be employed is dynamically selected, based on the format or mime type of the file or files being processed at that step.  Thus, for example, the “de-layer” activity would invoke standard tar, gzip, or zip tools to expand and separate out the content of .tar, .gzip, or .zip files.  The same activity would invoke an XSL transform to split a publisher XML file containing bibliographic metadata for all the articles in an issue of a journal into separate XML files for each article (and would invoke a different XSL transform for each different publisher XML format).</textual></para><para class="po-block e129 e129"><textual class="po-textual">
                </textual><figure class="po-container e130 e130" xml:id="fig03" xreflabel="Figure 3"><mediaobject class="po-container e131 e131"><imageobject class="po-container e132 e132"><imagedata class="po-meta e133 e133" fileref="../../../vol9/graphics/Morrissey01/Morrissey01-003.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e134 e134"><para class="po-block e135 e135"><textual class="po-textual">Figure 3: Format-driven Tool and Tool Component Plugins for WorkFlow
                            Step</textual></para></caption></figure><textual class="po-textual">
                
            </textual></para><para class="po-block e136 e136"><textual class="po-textual">So, at the root of all the XML configuration files that drive and parameterize the Portico workflow is the format registry file: FormatRegistry.xml.  There is a </textual><code class="po-atom e137 e137"><textual class="po-textual">&lt;Format&gt;</textual></code><textual class="po-textual"> element for each distinct format for which the archive contains at least one instance.  This, for example, is part of the </textual><code class="po-atom e138 e138"><textual class="po-textual">&lt;Format&gt;</textual></code><textual class="po-textual"> element for one publisher’s profile of one version of the NLM Journal Publishing DTD:</textual></para><para class="po-block e139 e139"><textual class="po-textual">
                </textual><programlisting class="po-block e140 e140" xml:space="preserve"><textual class="po-textual">
  &lt;Format FormatId=</textual><emphasis class="po-inline e141 e141" role="bold"><textual class="po-textual">"XXX_NLM_Journal_Publishing_DTD_2.1"</textual></emphasis><textual class="po-textual"> 
          CreationTimestamp="2006-06-13T13:00:00-05:00"&gt;
	&lt;PorticoDefinedName&gt;XXX Journal Publishing DTD v2.1 20050630&lt;/PorticoDefinedName&gt;
	…
  &lt;Format&gt;
                </textual></programlisting></para><para class="po-block e142 e142"><textual class="po-textual">For each workflow step or activity, the tool registry file, ToolRegistry.xml, maps each format to the Java class to be plugged in, configured, and executed at that step.  So, for example, in the tool registry, we have entries such as:</textual></para><para class="po-block e143 e143"><textual class="po-textual">
                </textual><programlisting class="po-block e144 e144" xml:space="preserve"><textual class="po-textual">
  &lt;TransformationSet&gt;
	  &lt;ToolStrategy SupportingFormatId=</textual><emphasis class="po-inline e145 e145" role="bold"><textual class="po-textual">"XXX_NLM_Journal_Publishing_DTD_2.1"</textual></emphasis><textual class="po-textual">&gt;
		  &lt;Script Rid=</textual><emphasis class="po-inline e146 e146" role="bold"><textual class="po-textual">"scrxxx"/&gt;</textual></emphasis><textual class="po-textual">				
	  &lt;/ToolStrategy&gt;
	  ...
  &lt;/TransformationSet&gt;
                </textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e147 e147"><textual class="po-textual">This entry indicates that in the workflow </textual><quote class="po-inline e148 e148"><textual class="po-textual">Transform Files</textual></quote><textual class="po-textual"> step, if
                the Portico identifier (defined in the format registry) for the format of the file
                to be transformed is </textual><code class="po-atom e149 e149"><textual class="po-textual">XXX_NLM_Journal_Publishing_DTD_2.1</textual></code><textual class="po-textual">, then we should
                look for plug-in information about what tool to employ, and how to parameterize it,
                in a subsequent </textual><code class="po-atom e150 e150"><textual class="po-textual">ScriptInfo</textual></code><textual class="po-textual"> element with a </textual><code class="po-atom e151 e151"><textual class="po-textual">ScriptID</textual></code><textual class="po-textual">
                attribute value of </textual><code class="po-atom e152 e152"><textual class="po-textual">scrxxx</textual></code><textual class="po-textual">. In that element, we will see specified such
                things as a list of relative file paths to XSL transforms that comprise the
                transformation pipeline for instances of this format, along with (relative)
                directory names where those files are located; the Portico identifier for the format
                of the output of this transformation (also defined in the format registry); a
                fully-qualified Java class name for a filter through which the input file is to be
                passed; and an </textual><code class="po-atom e153 e153"><textual class="po-textual">Rid</textual></code><textual class="po-textual"> attribute referring to yet another subsequent
                element containing full information about the Java tool class that will invoke the
                filters and the XSL pipeline.</textual></para><para class="po-block e154 e154"><textual class="po-textual">
                </textual><programlisting class="po-block e155 e155" xml:space="preserve"><textual class="po-textual">
  &lt;ScriptInfoSet&gt;
  &lt;ScriptInfo ScriptId="</textual><emphasis class="po-inline e156 e156" role="bold"><textual class="po-textual">scrxxx</textual></emphasis><textual class="po-textual">" 
              ScriptType="transformation" 
              ScriptDir="</textual><emphasis class="po-inline e157 e157" role="bold"><textual class="po-textual">xxx</textual></emphasis><textual class="po-textual">"&gt;
   &lt;Tool Rid="</textual><emphasis class="po-inline e158 e158" role="bold"><textual class="po-textual">BaseTransform_1.0</textual></emphasis><textual class="po-textual">"&gt;
    &lt;Parameters&gt;
     &lt;Parameter&gt;
      &lt;Name&gt;</textual><emphasis class="po-inline e159 e159" role="bold"><textual class="po-textual">StyleSheetList</textual></emphasis><textual class="po-textual">&lt;/Name&gt;
      &lt;ValueOrderedList&gt;
        &lt;ValueOrderedListItem&gt;
          &lt;Number&gt;10&lt;/Number&gt;
          &lt;Value&gt;xxx2ptc_1_10.xsl&lt;/Value&gt;
        &lt;/ValueOrderedListItem&gt;
        &lt;ValueOrderedListItem&gt;
          &lt;Number&gt;20&lt;/Number&gt;
          &lt;Value&gt;fix-data_1.xsl&lt;/Value&gt;
        &lt;/ValueOrderedListItem&gt;
        ...
      &lt;/ValueOrderedList&gt;
    &lt;/Parameter&gt;
    ....
    &lt;Parameter&gt;
      &lt;Name&gt;</textual><emphasis class="po-inline e160 e160" role="bold"><textual class="po-textual">outputFormatId</textual></emphasis><textual class="po-textual">&lt;/Name&gt;
      &lt;Value&gt;PTC_Article_DTD_2.1&lt;/Value&gt;
    &lt;/Parameter&gt;
    &lt;Parameter&gt;
      &lt;Name&gt;</textual><emphasis class="po-inline e161 e161" role="bold"><textual class="po-textual">InputFilterClass</textual></emphasis><textual class="po-textual">&lt;/Name&gt;
      &lt;Value&gt;
         org.portico.threadedtool.tool.transform.filter.XmlPrologTransformFilter
      &lt;/Value&gt;
    &lt;/Parameter&gt;
    ...
   &lt;/Parameters&gt;
  &lt;/Tool&gt;
 &lt;/ScriptInfo&gt;
...
&lt;/ScriptInfoSet&gt;                   
                </textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e162 e162"><textual class="po-textual">Later in the tool registry, information about the </textual><code class="po-atom e163 e163"><textual class="po-textual">BaseTransform_1.0</textual></code><textual class="po-textual"> tool is specified, including its Java class name, and information about the parameters to be passed when instantiating that class (as we did in the </textual><code class="po-atom e164 e164"><textual class="po-textual">ScriptInfo</textual></code><textual class="po-textual"> element above), including whether or not the parameter is required, and what its type should be:</textual></para><para class="po-block e165 e165"><textual class="po-textual">
                </textual><programlisting class="po-block e166 e166" xml:space="preserve"><textual class="po-textual">
&lt;ToolInfoSet&gt;
   &lt;ToolInfo Id="</textual><emphasis class="po-inline e167 e167" role="bold"><textual class="po-textual">BaseTransform_1.0</textual></emphasis><textual class="po-textual">"&gt;
      &lt;Name&gt;BaseTransformTool:1.0:2007-05-01&lt;/Name&gt;
      &lt;Description&gt;
         Tool for transformation of XML files via XSL stylesheets.
      &lt;/Description&gt;
      &lt;Status&gt;ACTIVE&lt;/Status&gt;
      &lt;ClassName&gt;
         org.portico.threadedtool.tool.transform.BaseTransformTool
      &lt;/ClassName&gt;
      &lt;ToolParameters&gt;
        &lt;ToolParameter Name="</textual><emphasis class="po-inline e168 e168" role="bold"><textual class="po-textual">StyleSheetList</textual></emphasis><textual class="po-textual">" 
                       Required="true" 
                       ParameterType="ValueOrderedList"&gt;
          &lt;Description&gt;
             This is the list of XSL stylesheets that are to be processed and the 
             order in which they should be processed.
          &lt;/Description&gt;
        &lt;/ToolParameter&gt;
        &lt;ToolParameter Name="</textual><emphasis class="po-inline e169 e169" role="bold"><textual class="po-textual">outputFormatId</textual></emphasis><textual class="po-textual">" 
                       Required="true" 
                       ParameterType="Value"&gt;
          &lt;Description&gt;
             This identifies the output format ID of this set of transforms.
          &lt;/Description&gt;
        &lt;/ToolParameter&gt;
        &lt;ToolParameter Name="</textual><emphasis class="po-inline e170 e170" role="bold"><textual class="po-textual">InputFilterClass</textual></emphasis><textual class="po-textual">" 
                       Required="false" 
                       ParameterType="Value"&gt;
          &lt;Description&gt;
             This identifies the filter to be applied to the file before transforms.  
             It should contain the fully qualified class name of the filter. 
             If this Parameter is not supplied, the default BaseFilter 
             class is used. Legal values come from package
             org.portico.threadedtool.tool.transform.filter.
          &lt;/Description&gt;
        &lt;/ToolParameter&gt;
	...
      &lt;/ToolParameters&gt;
    &lt;/ToolInfo&gt;
    ...
&lt;ToolInfoSet&gt;
                </textual></programlisting><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e171 e171"><title class="po-block e172 e172"><textual class="po-textual">Portico XML Configuration Files:  Categories of Configuration Issues</textual></title><para class="po-block e173 e173"><textual class="po-textual">There are a lot of </textual><quote class="po-inline e174 e174"><textual class="po-textual">moving parts</textual></quote><textual class="po-textual"> in even this condensed description of the semantics of these two configuration files.  As more and more publisher streams were added to Portico’s workflow, more and more configuration information was added to these files, by more and more developers working at the same time to add new content streams and their accompanying Java tool and filter classes, and associated XSL transformations.  And these additions had to be made in several different workflow environments:  a developer environment; an integration environment where profiles and registries for new publisher streams are first worked out; a QA environment for regression testing of tool, transform, workflow, and configuration changes; and, finally, to the production environment.</textual></para><para class="po-block e175 e175"><textual class="po-textual">Perhaps to no one’s surprise, Portico began to experience deployment glitches.  None of these glitches occurred because the XML registry files were either not well formed or invalid, as developers consistently validated the files against their respective schemas before committing to Portico’s source control system, and the deployment scripts also invoked a parser to validate the files.  The workflow was paused; new configuration files and other resources were deployed; the workflow was cranked back up.  Then it would hum along through several workflow steps, before encountering what effectively was a configuration error that would bring one or more batches to a halt. </textual></para><para class="po-block e176 e176"><textual class="po-textual">So the first question we asked ourselves was, what is it about the semantics of the content of the elements in these files – and the relationship among elements in the same and in different XML configuration files, </textual><emphasis class="po-inline e177 e177" role="ital"><textual class="po-textual">and</textual></emphasis><textual class="po-textual"> the relationship between the content in those elements and other components of the workflow software and other resource files – that enabled configuration errors to pass undetected through the sieve of standard XML validation tools?</textual></para><section class="po-hcontainer e178 e178"><title class="po-block e179 e179"><textual class="po-textual">Consistency Issues</textual></title><para class="po-block e180 e180"><textual class="po-textual">At run time, every tool specified in the tool registry verifies the presence
                    or absence of various required and optional parameters, and checks to see, when
                    present, that they are of the required type before proceeding to execute the
                    tool. Just as the workflow that invokes the tools is a pluggable framework, so
                    too are the individual tools themselves pluggable (See </textual><xref class="po-milestone e181 e181" linkend="fig03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). This enables Portico to
                    use a single generic XML transformation Java tool on input that requires
                    slightly varying processing. </textual></para><para class="po-block e182 e182"><textual class="po-textual">Since the tool is in some sense generic, some parameters for the tool are
                    optional. However, it can be the case that if one of these optional parameters
                    is present, and if the parameter has a particular value, then other optional
                    parameters must be provided as well. For example, the
                        </textual><code class="po-atom e183 e183"><textual class="po-textual">InputFilterClass</textual></code><textual class="po-textual"> parameter is optional, but </textual><emphasis class="po-inline e184 e184" role="ital"><textual class="po-textual">if</textual></emphasis><textual class="po-textual"> it is present, and </textual><emphasis class="po-inline e185 e185" role="ital"><textual class="po-textual">if</textual></emphasis><textual class="po-textual"> its value is
                        </textual><code class="po-atom e186 e186"><textual class="po-textual">org.portico.threadedtool.tool.transform.filter.ExternalEntityReplacerFilter</textual></code><textual class="po-textual">,
                    then the tool registry must also provide the additional otherwise optional
                    parameters </textual><code class="po-atom e187 e187"><textual class="po-textual">AttributeValueSeparator</textual></code><textual class="po-textual">, </textual><code class="po-atom e188 e188"><textual class="po-textual">AttributeName</textual></code><textual class="po-textual">,
                        </textual><code class="po-atom e189 e189"><textual class="po-textual">ElementQNames</textual></code><textual class="po-textual">, </textual><code class="po-atom e190 e190"><textual class="po-textual">MatchString</textual></code><textual class="po-textual">, and
                        </textual><code class="po-atom e191 e191"><textual class="po-textual">ReplacementString</textual></code><textual class="po-textual">. </textual><footnote class="po-popup e192 e192" xml:id="fn01" xreflabel="1"><para class="po-block e193 e193"><textual class="po-textual">Portico filters incoming XML and SGML files for a variety of reasons.
                            The format validation step, for example, makes use of the JHOVE tool,
                            which is not able to make use of catalogs. The DOCTYPE statement will
                            therefore sometimes require filtering to cause the parser to resolve to
                            a local copy of the DTD or schema. Sometimes a filter is used to correct
                            syntactic errors in the DOCTYPE statement, such as white space or
                            comments before the XML declaration, encoding declarations inconsistent
                            with actual encoding used by the publisher (see </textual><xref class="po-milestone e194 e194" linkend="bib03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
                            for other examples)</textual></para></footnote><textual class="po-textual">
                </textual></para><para class="po-block e195 e195"><textual class="po-textual">If these constraints are not met, the tool registry file will pass schema validation, but the workflow step attempting to transform an instance of this file format will fail at runtime, because the tool it invokes requires more configuration information to perform the transformation.  So we have a need to check for consistency between the (variable, and complexly dependent) input expectations of the Java tool, and the configuration values provided in the XML registry. </textual></para></section><section class="po-hcontainer e196 e196"><title class="po-block e197 e197"><quote class="po-inline e198 e198"><textual class="po-textual">Referential Integrity</textual></quote><textual class="po-textual"> Issues</textual></title><para class="po-block e199 e199"><textual class="po-textual">As mentioned above, the Portico workflow is "format driven.” The choice of
                    tool to be plugged in at different steps in the workflow is determined by the
                    format of the object to be processed at the step (indeed, the sequence of
                    workflow steps itself is driven by the expected collection of format instances
                    in a content stream). And, as noted, we encounter many formats – the
                    FormatRegistry.xml file contains, at the time of writing, 545
                        </textual><code class="po-atom e200 e200"><textual class="po-textual">Format</textual></code><textual class="po-textual"> elements.</textual></para><para class="po-block e201 e201"><textual class="po-textual">Various constructs for defining an XML vocabulary (DTD, Schema, and RelaxNG) have provisions for specifying a constrained list of values for, for example, attributes.  These provisions typically are employed for a smaller number of values than would be required to cover the ever-growing list of formats Portico encounters.  Nor would such a constrained list of identifiers include the other information about the format that is associated with the identifier in the format registry. For our purposes, we would categorize that list of format identifiers (along with associated format information) as “data” rather than “structure”.  Further, if the list of constrained values were to be maintained in the document type definition itself – at “compile time”, so to speak, – we would be injecting what would be for us an unwanted level of complexity in the versioning of our schema.  </textual></para><para class="po-block e202 e202"><textual class="po-textual">Nevertheless, we have the requirement to ensure a sort of “referential integrity check” among XML files – that is, between the unique Portico format identifiers in the format registry, and the format identifiers employed in the tool registry and other Portico configuration files – to ensure successful runtime interaction between the workflow tools and the registries that drive them.</textual></para></section><section class="po-hcontainer e203 e203"><title class="po-block e204 e204"><textual class="po-textual">Existence Issues</textual></title><para class="po-block e205 e205"><textual class="po-textual">As seen above, the tool registry refers to many objects that are assumed to
                    exist at run time: Java tool and filter classes, XSL files, and other supporting
                    files. The existence or non-existence of such objects, even if their names are
                    specified in a document type definition, is extrinsic to the kind of structural
                    information a document type definition can provide, and which standard parsers
                    can validate. Yet a successful deployment of these XML configuration files
                    depends on verifying the actual existence of these objects in the total
                    deployment package. This was in fact the most frequent cause of
                    configuration-file-dependent deployment errors. An updated tool registry would
                    be deployed, but the new XSL files, or a new JAR file containing new Java tool
                    or filter classes specified in the updated registry, or the DTD or XSD files
                    associated with an XML  or SGML format, were not deployed along with the new
                    tool registry. When the workflow was restarted, a (Java) workflow step would
                    look to the tool registry to determine which Java tool or filter class it should
                    employ, or, if the workflow step was an XSL transformation, what list of XSL
                    makes up the transformation pipelene, or against which DTD or schema a format
                    instance was to be validated. If the classes or files specified in the tool
                    registry had not also been deployed, the workflow step would raise a fatal error
                    and halt processing.</textual></para></section></section></section><section class="po-hcontainer e206 e206"><title class="po-block e207 e207"><textual class="po-textual">XML for Configuration at Portico:  Solutions</textual></title><para class="po-block e208 e208"><textual class="po-textual">The second question we asked ourselves was whether we could devise some automated solutions to these consistency, referential integrity, and existence issues in order to avoid, or at least minimize, costly cycles of stop/deploy/restart/fail/stop/correct/redeploy/restart in our release deployments.  We found that we could, and that we could do so fairly simply with XSL transforms, assisted, in some cases, with Java extension functions.  We run these transform as part of deployment script before the stop/restart of the workflow.</textual></para><section class="po-hcontainer e209 e209"><title class="po-block e210 e210"><textual class="po-textual">Consistency Checker</textual></title><para class="po-block e211 e211"><textual class="po-textual">The tool registry’s </textual><code class="po-atom e212 e212"><textual class="po-textual">ToolInfo</textual></code><textual class="po-textual"> element documents all the possible calling parameters that can be passed to the Java tool class it specifies, indicating whether they are required or optional, and specifying the type of each parameter.  Assuming correct documentation (for ensuring which, to probably no one’s surprise, we have not yet invented a completely automated tool), this meant that we had sufficient information in the tool registry itself to perform consistency checks.  We use an XSL transform (Schematron is another obvious candidate for this) to compare the various </textual><code class="po-atom e213 e213"><textual class="po-textual">Paramter</textual></code><textual class="po-textual"> elements in the </textual><code class="po-atom e214 e214"><textual class="po-textual">ScriptInfo</textual></code><textual class="po-textual"> element that configures each invocation of a particular tool for a particular format, with the information in the </textual><code class="po-atom e215 e215"><textual class="po-textual">ToolInfo</textual></code><textual class="po-textual"> elements.  If an error message is created, the registry is not deployed until it is repaired. </textual></para></section><section class="po-hcontainer e216 e216"><title class="po-block e217 e217"><textual class="po-textual">“Referential Integrity” Checker</textual></title><para class="po-block e218 e218"><textual class="po-textual">Again, we used an XSL transform.  The transform extracts format and mime type information from the format registry being deployed with the tool registry, and uses that extracted information to verify that any referenced format id or mime type in the tool registry has been declared in the format registry.</textual></para></section><section class="po-hcontainer e219 e219"><title class="po-block e220 e220"><textual class="po-textual">Existence Checker</textual></title><para class="po-block e221 e221"><textual class="po-textual">Our existence checker also uses XSL, aided by extension functions, to look outside
                the XML box to determine that expected directories and XSL and other files exist in
                the target deployment directories, and that classes referenced in the tool registry
                exist in the .jar files also on the deployment path. In the case of XSL and other
                XML files, it would of course be possible to use </textual><code class="po-atom e222 e222"><textual class="po-textual">xsl-document</textual></code><textual class="po-textual"> to check
                for the existence of necessary resources. For non-XML file resources whose existence
                we wished to confirm, we could have used the </textual><code class="po-atom e223 e223"><textual class="po-textual">unparsed-text()</textual></code><textual class="po-textual"> function,
                interpreting an empty string result as a non-existent file. As we were using Java
                extension functions to confirm the existence (i.e. deployment) of Java classes on
                what would be the workflow's runtime Java classpath, and as the workflow uses the
                classpath to resolve the location of XSL and other file resources, we used Java
                extension functions to confirm the existence of these resources at deployment. </textual></para><para class="po-block e224 e224"><textual class="po-textual">
                </textual><programlisting class="po-block e225 e225" xml:space="preserve"><textual class="po-textual">
 &lt;xsl:stylesheet version="2.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    xmlns:jexist="java/org.portico.conprep.util.deployment.validatetoolregistry.ExistenceChecker" &gt;
  
  &lt;xsl:variable name="jExistInstance" select="jexist:new()"/&gt;
  
    &lt;!-- ==================================================== --&gt;
    &lt;!--          name="check-class-exists"                   --&gt;
    &lt;!-- ==================================================== --&gt;  
    &lt;xsl:template name="check-class-exists"&gt;
        &lt;xsl:param name="className"/&gt;
        &lt;xsl:param name="Path"/&gt;
        &lt;xsl:variable name="result" 
                select="jexist:classExistsOnClasspath($jExistInstance, $className)"/&gt;  
        &lt;xsl:if test="not($result)"&gt;
            &lt;xsl:message  terminate="no" &gt;
               Class  &lt;xsl:value-of select="$className"/&gt; does not exist.  
               &lt;xsl:value-of select="$Path"/&gt;
            &lt;/xsl:message&gt;
        &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- ==================================================== --&gt;
    &lt;!--           name="check-file-exists"                   --&gt;
    &lt;!-- ==================================================== --&gt;  
    &lt;xsl:template name="check-file-exists"&gt;
        &lt;xsl:param name="scriptType"/&gt;
        &lt;xsl:param name="scriptDir"/&gt;
        &lt;xsl:param name="fileName"/&gt;
        &lt;xsl:param name="Path"/&gt;
        &lt;xsl:variable name="result" 
                select="jexist:fileExistsOnClasspath($jExistInstance, 
                         $scriptType, $scriptDir, $fileName)"/&gt;  
        &lt;xsl:if test="not($result)"&gt;
            &lt;xsl:message  terminate="no" &gt;
               File  &lt;xsl:value-of select="$fileName"/&gt; does not exist.  
               ScriptType = &lt;xsl:value-of select="$scriptType"/&gt;, 
               ScriptDir = &lt;xsl:value-of select="$scriptDir"/&gt;  
               Path to script = &lt;xsl:value-of select="$Path"/&gt;
            &lt;/xsl:message&gt;
        &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;
                </textual></programlisting><textual class="po-textual">
            </textual></para></section></section><section class="po-hcontainer e226 e226"><title class="po-block e227 e227"><textual class="po-textual">Reflections</textual></title><para class="po-block e228 e228"><textual class="po-textual">Not all configuration files -- not even all Portico workflow configuration files --
            are XML files, of course, and not all are likely to be amenable to an XML-based QA
            solution. XML would be overkill for the sort of name-value pairs of configuration
            information more compactly expressed in conventional properties files. As the category
            name of one class of deployment issues suggests, a different implementation choice
            (relational database in lieu of XML registry files for configuration) would provide a
            different mechanism for enforcing at least one sort of consistency in deployment. </textual></para><para class="po-block e229 e229"><textual class="po-textual">There are some limitations to these tools, even as applied to XML configuration files.
            Our consistency checker, which validates the number, name, type, and compulsoriness of
            parameters passed to our Java tools, depends on a manual process of updating the
            ToolRegisty.xml file's </textual><code class="po-atom e230 e230"><textual class="po-textual">ToolInfo</textual></code><textual class="po-textual"> section whenever we update our Java tools.
            We could conceivably employ Java annotations, and a meta-process to generate appropriate
                </textual><code class="po-atom e231 e231"><textual class="po-textual">ToolInfo</textual></code><textual class="po-textual"> elements, and test to see if those generated elements matched
            the actual elements in the ToolRegistry.xml file (though this approach perhaps only
            pushes back our "manual" dependency on developer discipline to ensuring consistent
            annotation in the Java code). </textual></para><para class="po-block e232 e232"><textual class="po-textual"> A warrant of existence of a resource at deployment time, while reassuring, is not
            necessarily a warrant of existence at run time, particularly for resources outside of
            one's institutional domain or control (though this has not been an issue in Portico's
            deployment process). We have found a simple syntactic surrogate (a non-empty return from
            a method call) that reliably signifies the existence or non-existence of an artifact
            "out there" in the world extrinsic to the XML document we are interrogating. That
            surrogate is satisfactory for our purposes, but it might not be sufficient for all
            purposes. And it is certainly no magical solution to the general ontological problem of
            assessing an XML document's assertion about external reality.</textual></para><para class="po-block e233 e233"><textual class="po-textual">As mentioned above in the Background section, users of other applications with rich
            XML configuration files experience deployment problems. Many of these are caused by
            these same consistency, referential integrity, and existence issues experienced by
            Portico with its registry files. Spring, Hibernate, and Tomcat configuration files all
            contain elements whose contents are intended to be fully-qualified Java class names, for
            classes that are presumed to be on the application’s classpath at runtime, and hence
            available for instantiation via inversion of control. The XML configuration files for
            any of the applications mentioned above can contain elements whose content refers to
            files and directories, both local and non-local, assumed to exist at runtime (for
            example, the location for JSP files used by Apache, as well as “welcome” files and login
            pages, can be specified). Nothing in the schema for Ant files ensures that a developer
            using Ant to build and deploy a Java servlet populates the Ant configuration file so as
            to follow the Java servlet conventions for relative deployment location for servlet and
            other files. A Tomcat web.xml file specifying both type and values for JNDI can be
            well-formed and valid, and yet specify a value that cannot be instantiated as an
            instance of the specified type, or specify a type that in fact does not exist.</textual></para><para class="po-block e234 e234"><textual class="po-textual">What we have found is that, for our XML configuration files, where standard XML
            validation tools will not resolve these deployment issues, we can use XML-based tools
            for at least these categories of non-structural, “extrinsic” validation requirements.
            Further, because they are XML based, they can be employed in both in simple deployment
            scripts and in continuous integration tools, reducing many common deployment problems.  </textual></para><para class="po-block e235 e235"><textual class="po-textual">XML-based tools, though not the only possible solution for solving XML configuration
            file-related deployment issues, were a natural choice for Portico. In part this was a
            pragmatic choice: such XSL and Java-based solutions were well-supported by the skill set
            in our programming team, and the categories of deployment problems we experienced where
            amenable to solution by the means described. Standard XML parsers and XSL transform
            engines made it easy to "get at" the content of XML elements and attributes to test
            assertions about that content beyond the document's well-formedness and validity (Do
            certains things exist "out there" on the file system? Have we provided all the
            parameters that an optional Java filter plugin to a Java plugin tool to a Java framework
            requires at runtime?) . And they made it easy to "get at" them in different contexts
            --both a manual context (a developer updating an XML registry in Oxygen, for example)
            and an automated one (a deployment script that is part of a configuration management
            system).</textual></para><para class="po-block e236 e236"><textual class="po-textual">In part however this was also an aesthetic choice: there is a certain "turtles all the
            way down" appeal to applying XML-based QA tools to XML configuration files that drive a
            workflow for processing digital artifacts whose key components are XML files. The
            aesthetic shaded into the pragmatic, as it so often does in software engineering. The
            consistent, conventional reuse of large-scale structure and coding idioms across such a
            large application as the Portico workflow system helps in making that system
            comprehensible to the developers who support and extend it -- an approach, so to speak,
            toward the possibly asymptotic, reader-centric rather than process- or processor-centric
            goal of "Read once, understand everywhere" [</textual><xref class="po-milestone e237 e237" linkend="bib05"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] in complex
            systems.</textual></para><para class="po-block e238 e238"><textual class="po-textual">What precisely comprises the "beauty" or aesthetic appeal of a piece of software (both
            data structures and algorithms, and their instantiation in concrete formalisms such as
            languages) is a topic of much discussion. To what extent does a software instance
            provide, as mathematicians might say of a proof, an "elegant" or "economical" solution
            to the problem it was created to solve? The extent to which the XML community has
            grappled with the ways in which, and the degree to which, an XML document type
            definition can or might comprise a model homomorphic to some domain, suggests that such
            homomorphism is a key criterion. It might be argued that the choice of XML as a
            configuration language for these large-scale frameworks was in some sense opportunistic,
            or "merely pragmatic." The ecosystem of XML parsers provided a "good enough" solution to
            the expression of richly hierarchical configuration information, even if it did not
            provide a solution to the problem of the more complex relationships among components of
            these hierarchies, and to extrinsic realities. The necessity of performing QA on these
            files can be viewed as an indicator of the limits of the economy of XML as a solution to
            the original problem. Whether other software constructs would provide a more "beautiful"
            solution is an open question. That a partial solution to the limits of XML as a
            configuration language can be found in XML-based tools has, at least for Portico, its
            own economical appeal.</textual></para></section><bibliography class="po-hcontainer e239 e239"><title class="po-block e240 e240"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e241 e241" xml:id="bib01" xreflabel="abrams"><textual class="po-textual">Abrams, Stephen. </textual><quote class="po-inline e242 e242"><textual class="po-textual">File Formats</textual></quote><textual class="po-textual"> in DCC Digital Curation Manual.  S.Ross, M.Day (eds), (October 2007), Retrieved April 20, 2012, from </textual><link class="po-inline e243 e243" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.dcc.ac.uk/sites/default/files/documents/resource/curation-manual/chapters/file-formats/file-formats.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e244 e244" xml:id="bib02" xreflabel="gamma et al"><textual class="po-textual">Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. </textual><emphasis class="po-inline e245 e245" role="ital"><textual class="po-textual">Design Patterns:  Elements of Reusable Object-Oriented Software.</textual></emphasis><textual class="po-textual">Reading, MA: Addison-Wesley, 1995.</textual></bibliomixed><bibliomixed class="po-block e246 e246" xml:id="bib03" xreflabel="morrissey et al"><textual class="po-textual"> Morrissey, Sheila, John Meyer,
            Sushil Bhattarai, Sachin Kurdikar, Jie Ling, Matthew Stoeffler and Umadevi Thanneeru.
                "Portico: A Case Study in the Use of XML for the Long-Term Preservation of
                Digital Artifacts." Presented at International Symposium on XML for the Long
            Haul: Issues in the Long-term Preservation of XML, Montréal, Canada, August 2, 2010. In
                </textual><emphasis class="po-inline e247 e247" role="ital"><textual class="po-textual">Proceedings of the International Symposium on XML for the Long
                Haul: Issues in the Long-term Preservation of XML</textual></emphasis><textual class="po-textual"> Balisage Series on
          Markup Technologies, vol. 6 (2010). doi:</textual><biblioid class="po-atom e248 doi e248"><textual class="po-textual">10.4242/BalisageVol6.Morrissey01</textual></biblioid><textual class="po-textual">. Retrieved April 20, 2012, from
                </textual><link class="po-inline e249 e249" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol6/html/Morrissey01/BalisageVol6-Morrissey01.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e250 e250" xml:id="bib04" xreflabel="morrissey 2011"><textual class="po-textual">Morrissey, Sheila M. </textual><quote class="po-inline e251 e251"><textual class="po-textual">‘More What You’d Call ‘Guidelines’ Than Actual Rules' : Variation in the Use of Standards</textual></quote><textual class="po-textual">.  </textual><emphasis class="po-inline e252 e252" role="ital"><textual class="po-textual">Journal of Electronic Publishing </textual></emphasis><textual class="po-textual"> 14, no. 1: 14. doi:</textual><biblioid class="po-atom e253 doi e253"><textual class="po-textual">10.3998/3336451.0014.104</textual></biblioid><textual class="po-textual">. Retrieved April 20, 2012, from </textual><link class="po-inline e254 e254" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://quod.lib.umich.edu/cgi/t/text/text-idx?c=jep;view=text;rgn=main;idno=3336451.0014.104 </textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e255 e255" xml:id="bib05" xreflabel="reflection"><textual class="po-textual">Morrissey, Sheila  </textual><quote class="po-inline e256 e256"><textual class="po-textual">JHOVE2 and Java Reflection</textual></quote><textual class="po-textual">. (February 2009), Retrieved August 05, 2012, from </textual><link class="po-inline e257 e257" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://bitbucket.org/jhove2/main/wiki/Background_Papers</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>