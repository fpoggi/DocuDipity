<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">XQuery topic tools - concept, user interface, development framework</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2014</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 5 - 8, 2014</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">
                </textual><emphasis class="po-inline e8 e8" role="ital"><textual class="po-textual"> This paper defines the concept of topic tools, which are
                    command line tools providing a single point of access to a range of
                    functionality. Topic tools conform to a generic model of invocation syntax and
                    basic tool behaviour, concerning user assistence, error diagnostics and
                    invocation reuse. The paper proposes a comprehensive model of the
                    user-perspective - syntax and behaviour - and it introduces a simple development
                    framework making the creation of XQuery topic tools simple and fast. The support
                    offered by the framework includes code generation and the use of a message
                    interface which cleanly isolates the application code from user input and gives
                    it access to validated and augmented information, rather than the raw data of
                    user input. Key properties of framework-based topic tools are early
                    availability, extensibility, user convenience, behavioural consistency and
                    reliability based on very thorough and fully automated input validation.
                </textual></emphasis><textual class="po-textual">
            </textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Hans-Jürgen</textual></firstname><othername class="po-field e12 e12"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></othername><surname class="po-field e13 e13"><textual class="po-textual">Rennau</textual></surname></personname><personblurb class="po-container e14 e14"><para class="po-block e15 e15"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e16 e16"><jobtitle class="po-field e17 e17"><textual class="po-textual">Senior Java developer</textual></jobtitle><orgname class="po-block e18 e18"><textual class="po-textual">Traveltainment GmbH</textual></orgname></affiliation><email class="po-field e19 e19"><textual class="po-textual">hrennau@yahoo.de</textual></email></author><legalnotice class="po-container e20 e20"><para class="po-block e21 e21"><textual class="po-textual">Copyright © 2014 by the author. Used with permission.</textual></para></legalnotice><keywordset class="po-table e22 e22" role="author"><keyword class="po-field e23 e23"><textual class="po-textual">XQuery</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">Command line tools</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">RESTful web services</textual></keyword><keyword class="po-field e27 e27"><textual class="po-textual">RESTXQ</textual></keyword></keywordset></info><section class="po-hcontainer e28 e28"><title class="po-block e29 e29"><textual class="po-textual">Introduction</textual></title><para class="po-block e30 e30"><textual class="po-textual"> XQuery ([</textual><xref class="po-milestone e31 e31" linkend="w3c-xquery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]) is a W3C defined language for processing XML
            and other information resources. The name is a misnomer, as XQuery is a general
            information processing language, rather than a query language. XQuery certainly offers
            excellent support for querying XML data, but this support should be viewed as a
            prominent feature of the language, not as its scope. </textual></para><para class="po-block e32 e32"><textual class="po-textual"> XQuery has an amazing conceptual simplicity. It is an expression language –
            everything is an expression, a query is an expression tree. An expression is a shape
            which has a value, and the value of an XQuery expression is a sequence of items, where
            each item is either a node, an atomic value, or a function. Nodes are the foundation of
            a generic model of navigation, as they are interconnected by node properties, and these
            connections can be used as “roads” along which to move – the XPath axes (e.g. child,
            descendant, parent and ancestor). The XPath functions </textual><code class="po-atom e33 e33"><textual class="po-textual">doc()</textual></code><textual class="po-textual"> and
                </textual><code class="po-atom e34 e34"><textual class="po-textual">collection()</textual></code><textual class="po-textual"> enable URI based access to local and remote XML resources,
            and as these are modelled as node trees, and as node trees can be traversed using those
            axes, XQuery programs operate in a logical space of information which is homogeneously
            structured (everything is a node) and which exposes any grain of content of any
            accessible XML resource (accessible via </textual><code class="po-atom e35 e35"><textual class="po-textual">doc()</textual></code><textual class="po-textual"> or
            </textual><code class="po-atom e36 e36"><textual class="po-textual">collection()</textual></code><textual class="po-textual">), making it individually addressable. Powerful operations are
            available not only for addressing, but also for aggregating, transforming and evaluating
            those ubiquitous units of content. These capabilities, combined with utmost conceptual
            simplicity (expressions, values, full stop) might induce us to refer to XQuery not as a
            query language, but simply as </textual><emphasis class="po-inline e37 e37" role="ital"><textual class="po-textual"> the XML expression language
            </textual></emphasis><textual class="po-textual"> – call it XMLe. And perhaps we should regard XML syntax, the XML data model
            and XMLe as integral parts of a single, unified information architecture which
            constitutes the deeper meaning of the three letters XML ( XML = XMLs + XMLm + XMLe). </textual></para><para class="po-block e38 e38"><textual class="po-textual">XQuery is currently a niche language. Only a tiny fraction of developers has a solid
            understanding of its capabilities, let alone the skills to use them. It might even be
            the case that acknowledged experts of XML do not have a real understanding of XQuery and
            that their view of XML technology and the scope of its usefulness is profoundly affected
            by this lack of understanding and experience. </textual></para><para class="po-block e39 e39"><textual class="po-textual">Comparing the high capabilities of XQuery and its low adoption by developers, one may
            conclude that the industry is wasting a significant potential. To put it differently:
            the potential of XQuery is still locked. Any approaches designed to unlock the potential
            – facilitating the use of XQuery somehow and in some realm - might deserve special
            interest, as the possible gains are high. One such approach is RESTXQ ([</textual><xref class="po-milestone e40 e40" linkend="retter"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]), which simplifies the XQuery-based implementation of web
            services. This paper introduces another approach, </textual><code class="po-atom e41 e41"><textual class="po-textual">ttools</textual></code><textual class="po-textual">, a framework
            supporting the development of XQuery-based command line tools which are powerful,
            versatile and designed for continuous extensibility. The approach is based on the
            concept of a </textual><emphasis class="po-inline e42 e42" role="ital"><textual class="po-textual">topic tool</textual></emphasis><textual class="po-textual">. A topic tool is a program
            providing a single command line interface to a range of functionality – the available
            (and continuously growing) functionality related to a “topic”. This paper defines the
            concept, proposes a generic model of the user perspective and introduces a development
            framework enabling the fast and easy development of topic tools. It should be noted
            right at the start that the framework is extremely lightweight – 100% XQuery
            implemented, so that neither the use nor the development of topic tools requires any
            components apart from an XQuery processor. </textual></para></section><section class="po-hcontainer e43 e43"><title class="po-block e44 e44"><textual class="po-textual">XQuery for command line tools</textual></title><para class="po-block e45 e45"><textual class="po-textual">XQuery is well-suited for the rapid development of divers and powerful command line
            tools, enabling the evaluation of distributed information sources. Key reasons for this
            potential is the navigational power of XPath and the uniformity of a data model which
            allows seamless integration of navigation and construction. But this very efficiency of
            XQuery can seduce the developer to create - at an amazing speed - an amazingly
            unsatisfactory situation: a heap of command line tools inconsistently named, and using
            input parameters with inconsistent names and semantics. Each of these tools, inspected
            in isolation, might be very useful, and yet the sum is difficult to use and to maintain.
            The longer this undisciplined development continues, the greater the loss of efficiency
            on both sides – the developer’s and the user’s. Many tools are at length abandoned (by
            users and by the developer), as it becomes too difficult to remember what exactly is
            available and how to use it, precisely. Wheels are frequently reinvented, and yet, often
            no wheel can be found when it is really needed. The big bonus of efficiency offered by
            XQuery is lost.</textual></para><para class="po-block e46 e46"><textual class="po-textual">In similar situations a key problem is the lack of any structure integrating the
            individual tools into a conceptual whole. Compare this to the realm of web services.
            Their functionality is structured into named services which are in turn structured into
            named operations. Each service provides a scope for conventions concerning names,
            structures and semantics. But now imagine there were only operations without containing
            services – instead of web services we would deal with “web operations”. We would get
            into trouble. We would be threatened by the same predicament which is created by an
            uncoordinated growth of command line tools. </textual></para><para class="po-block e47 e47"><textual class="po-textual">A possible conclusion is that we should create command line tools which can be
            compared to web services. Service-like tools would act as containers for a set of
            related operations, providing a single point of access and the scope for a consistent
            vocabulary and patterns of tool behaviour. But this ambition is at cross purposes with a
            tool developer's desire to be agile and responsive. We want to add new functionality
            quickly and frequently. We want to be ready to augment the flexibility of existing
            functionality - adding further control parameters - as soon as the need is detected.
            XQuery is a scripting language, which encourages rapid and agile development. Committed
            to rapid development, we are reluctant to invest effort into structural integration. </textual></para><para class="po-block e48 e48"><textual class="po-textual"> The development of rich, service-like command line tools is very costly and
            challenging if starting from scratch – without purpose-designed development tools. This
            paper introduces a framework which changes the situation radically, enabling the
            instantiation of a service-like tool within seconds, the writing of a deliverable first
            version within an afternoon, and the continuous extension and refinement which always
            remains simple and straightforward, because extension can be accomplished without
            increasing the overall complexity. The second key benefit of framework based development
            is the high quality of the emerging tool, which is largely due to a rich input
            validation model, as well as the consistency of “look-and-feel” (invocation syntax and
            basic behaviour) across all tools built using the framework. </textual></para><para class="po-block e49 e49"><textual class="po-textual"> The framework is based on a generic concept of service-like tools, called </textual><emphasis class="po-inline e50 e50" role="ital"><textual class="po-textual">topic tools</textual></emphasis><textual class="po-textual">. We start with the concept, proceed to the
            user-perspective (tool usage) and then inspect the developer-perspective – how to write
            topic tools. </textual></para></section><section class="po-hcontainer e51 e51"><title class="po-block e52 e52"><textual class="po-textual">Concept: topic tool</textual></title><para class="po-block e53 e53"><textual class="po-textual">For the purposes of this discussion, the term "topic tool" denotes a particular class
            of programs. A </textual><emphasis class="po-inline e54 e54" role="bold"><textual class="po-textual">topic tool</textual></emphasis><textual class="po-textual"> is a program offering a
            single command line interface to multiple functionality, typically related to a single
            topic. The command line interface reflects a </textual><emphasis class="po-inline e55 e55" role="ital"><textual class="po-textual">unified</textual></emphasis><textual class="po-textual">
            invocation model: the invocation of all topic tools has the same structure and is
            evaluated in accordance with the same syntactic conventions. There are also behavioural
            rules to which any topic tool adheres, for example concerning usage hints, user input
            validation, user input error reporting and the possibility to use stored invocations.
            Uniformity and user convenience are further encouraged by the standardization of rich
            parameter types for specifying input resources, name filters, path filters and other
            entities expressing complex details of the user's intent. </textual></para></section><section class="po-hcontainer e56 e56"><title class="po-block e57 e57"><textual class="po-textual">Goals</textual></title><para class="po-block e58 e58"><textual class="po-textual">This paper describes a work with the following goals.</textual></para><orderedlist class="po-table e59 e59"><listitem class="po-container e60 e60"><para class="po-block e61 e61"><textual class="po-textual">To define a generic model of a topic tool command line interface</textual></para></listitem><listitem class="po-container e62 e62"><para class="po-block e63 e63"><textual class="po-textual">To define generic features of topic tool behaviour</textual></para></listitem><listitem class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">To provide a development framework for the implementation of topic tools,
                    emphasizing</textual></para><itemizedlist class="po-table e66 e66"><listitem class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">The speed of development (code generation, application code supported
                            by infrastructure code)</textual></para></listitem><listitem class="po-container e69 e69"><para class="po-block e70 e70"><textual class="po-textual">The ease of development (reduction of complexity)</textual></para></listitem><listitem class="po-container e71 e71"><para class="po-block e72 e72"><textual class="po-textual">Tool quality (robustness, predictability, validation and
                            diagnostics)</textual></para></listitem><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">Tool extensibility (low effort to add operations and to extend
                            existing operations)</textual></para></listitem><listitem class="po-container e75 e75"><para class="po-block e76 e76"><textual class="po-textual">Framework extensibility (possibility to define new parameter
                            types)</textual></para></listitem></itemizedlist></listitem></orderedlist></section><section class="po-hcontainer e77 e77"><title class="po-block e78 e78"><textual class="po-textual"> Topic tools: user perspective </textual></title><para class="po-block e79 e79"><textual class="po-textual"> The interface of topic tools reflects a unified invocation model: the invocation of
            all topic tools has the same structure, is evaluated in accordance with the same
            syntactic rules and can rely on the same set of behavioural features concerning error
            reporting, usage assistence and support for storing and reusing invocations. </textual></para><section class="po-hcontainer e80 e80"><title class="po-block e81 e81"><textual class="po-textual">Tool invocation model</textual></title><para class="po-block e82 e82"><textual class="po-textual"> The invocation of a topic tool specifies a named operation and (optionally) the
                values of named parameters. The syntax used is the same for any topic tool.
                Technically speaking, a topic tool has a single parameter named “request”, which is
                a structured string identifying the operation and supplying parameter values.
                Operation name and parameters are separated by a question mark, and parameters are
                separated by a comma. This is the general pattern:
                </textual><programlisting class="po-block e83 e83" xml:space="preserve"><textual class="po-textual">   operationName ? param1=value1, param2=value2</textual></programlisting><textual class="po-textual">
                Literal commas within parameter values must be escaped using a backslash. Literal
                uses of the backslash character must also be escaped. If the parameter value has
                multiple items, these are supplied as a concatenated string. The item separator is
                either whitespace (one or more characters) or a semicolon, optionally surrounded by
                whitespace. Which item separator to use is prescribed by the topic tool for each
                parameter individually. If a parameter supports multiple items, literal uses of the
                item separator within parameter values must be escaped using a backslash. If no
                parameters are supplied, the request consists only of the operation name. Here come
                a few requests addressed to a topic tool called </textual><code class="po-atom e84 e84"><textual class="po-textual">xclear</textual></code><textual class="po-textual">, which offers
                various operations for analyzing XML document contents. The creation of this topic
                tool will be described in the tutorial proposed by a later section of this paper. </textual></para><programlisting class="po-block e85 e85" xml:space="preserve"><textual class="po-textual">
   docs    ? doc=/logs/log01.xml /logs/log02.xml /logs/log03.xml                
   doctype ? docs=^/projects/xsd/xsd-fpml%*                
   names   ? docs=^/projects/xsd/niem-2.1%*
   names   ? docs=^/projects/xsd/niem-2.1%*, scope=elem, names=*augment*</textual></programlisting><para class="po-block e86 e86"><textual class="po-textual"> Which operations are available? Given an operation, which parameters are possible
                and which are mandatory, what is the minimum/maximum number of value items, and
                which character must be used as item separator? What are the parameter types, and
                what the default values, if any? The answers are stored in the </textual><emphasis class="po-inline e87 e87" role="ital"><textual class="po-textual">tool scheme</textual></emphasis><textual class="po-textual">, which models any aspect of the tool interface. Every
                topic tool supports a </textual><code class="po-atom e88 e88"><textual class="po-textual">_help</textual></code><textual class="po-textual"> operation providing usage assistence, which
                is based on the actual tool scheme. The </textual><code class="po-atom e89 e89"><textual class="po-textual">_help</textual></code><textual class="po-textual"> operation of every topic
                tool supports the same set of parameters. The use of </textual><code class="po-atom e90 e90"><textual class="po-textual">_help</textual></code><textual class="po-textual"> is
                facilitated by a syntactic shortcut: the operation name may be omitted (if
                parameters are specified) or replaced by a question mark (if no parameters are
                specified). Invocations #1 and #3, and invocations #2 and #4 are equivalent:</textual></para><programlisting class="po-block e91 e91" xml:space="preserve"><textual class="po-textual">
   _help
   _help?ops=paths, default=true, type=true   
   ?
   ?ops=paths, default=true, type=true</textual></programlisting><para class="po-block e92 e92"><textual class="po-textual"> Called without parameters, </textual><code class="po-atom e93 e93"><textual class="po-textual">_help</textual></code><textual class="po-textual"> displays a simple summary of the
                topic tool, consisting of operation names and the parameter names and cardinalities: </textual></para><programlisting class="po-block e94 e94" xml:space="preserve"><textual class="po-textual">
REQUEST:
?
   
==&gt;
TOOL: xclear

OPERATIONS   PARAMS
====================================================
_help        default, mode, ops?, type
dcat         dfd+
docs         dcat*, doc*, docs*
doctypes     attNames, dcat*, doc*, docs*, elemNames
names        dcat*, doc*, docs*, names?, scope
paths        dcat*, doc*, docs*, paths?
values       dcat*, doc*, docs*, nvalues?
====================================================</textual></programlisting><para class="po-block e95 e95"><textual class="po-textual"> To see the types and default values, set the parameters </textual><code class="po-atom e96 e96"><textual class="po-textual">type</textual></code><textual class="po-textual"> and
                    </textual><code class="po-atom e97 e97"><textual class="po-textual">default</textual></code><textual class="po-textual"> to "true". You can also restrict the report to particular
                operations by supplying a name filter as value of parameter </textual><code class="po-atom e98 e98"><textual class="po-textual">ops</textual></code><textual class="po-textual"> (more
                about name filters later). </textual></para><programlisting class="po-block e99 e99" xml:space="preserve"><textual class="po-textual">
REQUEST:
?type=true, default=true, ops=_h* do*

==&gt;
TOOL: xclear

OPERATIONS   PARAMS
============================================================================
_help        default=false....... : xs:boolean
             mode=overview....... : xs:string
             ops................. : nameFilter?
             type=false.......... : xs:boolean

docs         dcat................ : docCAT* (sep=;)
             doc................. : docURI* (sep=WS)
             docs................ : docDFD* (sep=;)
               At least 1 of these parameters must be set: dcat, doc, docs

doctypes     attNames=false...... : xs:boolean
             dcat................ : docCAT* (sep=;)
             doc................. : docURI* (sep=WS)
             docs................ : docDFD* (sep=;)
             elemNames=false..... : xs:boolean
               At least 1 of these parameters must be set: dcat, doc, docs
============================================================================</textual></programlisting><para class="po-block e100 e100"><textual class="po-textual"> Operation and parameter names can be abbreviated by leaving out trailing
                characters, as long as the used prefix unambiguously identifies the operation or
                parameter, respectively. Operation and parameter names are case sensitive from the
                developer perspective, but case insensitive from the user perspective; entered names
                are normalized to the case defined by the tool scheme. </textual></para><para class="po-block e101 e101"><textual class="po-textual"> Another syntactic shortcut applies to parameters of Boolean type. They can be
                specified by only supplying the name (equivalent to param=true), or the name
                preceded by a tilde (equivalent to param=false). Example: </textual></para><programlisting class="po-block e102 e102" xml:space="preserve"><textual class="po-textual">?ops=paths, ~default, type</textual></programlisting><para class="po-block e103 e103"><textual class="po-textual"> An XQuery based topic tool receives the invocation string as value of the single
                external variable, named </textual><code class="po-atom e104 e104"><textual class="po-textual">request</textual></code><textual class="po-textual">. Call syntax of course depends on the
                actual XQuery processor. Using </textual><code class="po-atom e105 e105"><textual class="po-textual">BaseX</textual></code><textual class="po-textual">, for example, calling a topic tool
                looks similar to this:
                </textual><programlisting class="po-block e106 e106" xml:space="preserve"><textual class="po-textual">
   basex -b "request=names ? docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq</textual></programlisting><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e107 e107"><title class="po-block e108 e108"><textual class="po-textual">Tool scheme</textual></title><para class="po-block e109 e109"><textual class="po-textual"> A topic tool is defined by a </textual><emphasis class="po-inline e110 e110" role="bold"><textual class="po-textual">tool scheme</textual></emphasis><textual class="po-textual"> which
                models every aspect of the tool interface. The tool scheme supports both, the tool
                user and the tool developer in their work. The tool scheme is automatically
                constructed by collecting annotations contained by the tool sources, augmenting them
                and integrating them into a single XML document. The scheme specifies: </textual></para><itemizedlist class="po-table e111 e111"><listitem class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">operation names</textual></para></listitem><listitem class="po-container e114 e114"><para class="po-block e115 e115"><textual class="po-textual">for each operation all parameter names</textual></para></listitem><listitem class="po-container e116 e116"><para class="po-block e117 e117"><textual class="po-textual">for each parameter …</textual></para><itemizedlist class="po-table e118 e118"><listitem class="po-container e119 e119"><para class="po-block e120 e120"><textual class="po-textual">type</textual></para></listitem><listitem class="po-container e121 e121"><para class="po-block e122 e122"><textual class="po-textual">cardinality</textual></para></listitem><listitem class="po-container e123 e123"><para class="po-block e124 e124"><textual class="po-textual">item separator (if maximum number of occurrences greater 1)</textual></para></listitem><listitem class="po-container e125 e125"><para class="po-block e126 e126"><textual class="po-textual">(optional) default value</textual></para></listitem><listitem class="po-container e127 e127"><para class="po-block e128 e128"><textual class="po-textual">(optional) facets</textual></para></listitem><listitem class="po-container e129 e129"><para class="po-block e130 e130"><textual class="po-textual">(optional) normalizations</textual></para></listitem></itemizedlist></listitem></itemizedlist><para class="po-block e131 e131"><textual class="po-textual">Every parameter has a </textual><emphasis class="po-inline e132 e132" role="ital"><textual class="po-textual">type</textual></emphasis><textual class="po-textual"> and a </textual><emphasis class="po-inline e133 e133" role="ital"><textual class="po-textual">cardinality</textual></emphasis><textual class="po-textual">. The type can be a built-in schema type, a
                    </textual><code class="po-atom e134 e134"><textual class="po-textual">ttools</textual></code><textual class="po-textual">-defined type (a generic type defined by the topic tools
                framework described in this paper, available in any framework-based topic tool) or a
                tool-specific type. All built-in schema types are supported, excepting
                    </textual><code class="po-atom e135 e135"><textual class="po-textual">xs:ID</textual></code><textual class="po-textual"> and </textual><code class="po-atom e136 e136"><textual class="po-textual">xs:NOTATION</textual></code><textual class="po-textual">.</textual></para><para class="po-block e137 e137"><textual class="po-textual"> An example of a framework-defined type is </textual><code class="po-atom e138 e138"><textual class="po-textual">docDFD</textual></code><textual class="po-textual">, which represents a
                filter extracting XML documents from directories. ("DFD" denotes "directory filter
                descriptor".) An example of a tool-specific type is </textual><code class="po-atom e139 e139"><textual class="po-textual">travelScenario</textual></code><textual class="po-textual">.
                This type is defined by a topic tool for evaluating touristic data; parameter values
                are structured strings describing a travel in terms of travel dates and traveller
                birthdates. </textual></para><para class="po-block e140 e140"><textual class="po-textual">A </textual><emphasis class="po-inline e141 e141" role="ital"><textual class="po-textual">facet</textual></emphasis><textual class="po-textual"> constrains the parameter value beyond the
                constraints implied by the parameter type. A facet has a facet type and a string
                value. Each facet type defines a particular type of constraint applying to parameter
                item values. The following table lists the framework-defined facets, as of writing.
                Besides these generic facets, topic tools may also define tool-specific facets (see
                    </textual><xref class="po-milestone e142 e142" linkend="dev-advanced-usage"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><para class="po-block e143 e143"><textual class="po-textual">
                </textual><table class="po-container e144 e144"><caption class="po-container e145 e145"><para class="po-block e146 e146"><textual class="po-textual">
                            </textual><emphasis class="po-inline e147 e147" role="bold"><emphasis class="po-inline e148 e148" role="ital"><textual class="po-textual"> Parameter facets defined by
                                    the </textual><code class="po-atom e149 e149"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> framework.</textual></emphasis></emphasis><textual class="po-textual">
                        </textual></para></caption><col align="left" class="po-meta e150 e150" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e151 e151" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e152 e152"><tr class="po-table e153 e153" valign="top"><th align="left" class="po-field e154 e154" valign="top"><textual class="po-textual">Facet</textual></th><th align="left" class="po-field e155 e155" valign="top"><textual class="po-textual">Meaning</textual></th></tr></thead><tbody class="po-table e156 e156"><tr class="po-table e157 e157" valign="top"><td class="po-block e158 e158"><textual class="po-textual">length</textual></td><td class="po-block e159 e159"><textual class="po-textual">string length</textual></td></tr><tr class="po-table e160 e160" valign="top"><td class="po-block e161 e161"><textual class="po-textual">minLength</textual></td><td class="po-block e162 e162"><textual class="po-textual">minimum string length</textual></td></tr><tr class="po-table e163 e163" valign="top"><td class="po-block e164 e164"><textual class="po-textual">maxLength</textual></td><td class="po-block e165 e165"><textual class="po-textual">maximum string length</textual></td></tr><tr class="po-table e166 e166" valign="top"><td class="po-block e167 e167"><textual class="po-textual">minInclusive</textual></td><td class="po-block e168 e168"><textual class="po-textual">minimum value, inclusive</textual></td></tr><tr class="po-table e169 e169" valign="top"><td class="po-block e170 e170"><textual class="po-textual">maxInclusive</textual></td><td class="po-block e171 e171"><textual class="po-textual">maximum value, inclusive</textual></td></tr><tr class="po-table e172 e172" valign="top"><td class="po-block e173 e173"><textual class="po-textual">minExclusive</textual></td><td class="po-block e174 e174"><textual class="po-textual">minimum value, exclusive</textual></td></tr><tr class="po-table e175 e175" valign="top"><td class="po-block e176 e176"><textual class="po-textual">maxExclusive</textual></td><td class="po-block e177 e177"><textual class="po-textual">maximum value, exclusive</textual></td></tr><tr class="po-table e178 e178" valign="top"><td class="po-block e179 e179"><textual class="po-textual">pattern</textual></td><td class="po-block e180 e180"><textual class="po-textual">regular expression</textual></td></tr><tr class="po-table e181 e181" valign="top"><td class="po-block e182 e182"><textual class="po-textual">values</textual></td><td class="po-block e183 e183"><textual class="po-textual">enumeration</textual></td></tr><tr class="po-table e184 e184" valign="top"><td class="po-block e185 e185"><textual class="po-textual">filter</textual></td><td class="po-block e186 e186"><textual class="po-textual">a name filter</textual></td></tr><tr class="po-table e187 e187" valign="top"><td class="po-block e188 e188"><textual class="po-textual">future</textual></td><td class="po-block e189 e189"><textual class="po-textual">in the future (applicable to </textual><code class="po-atom e190 e190"><textual class="po-textual">xs:date</textual></code><textual class="po-textual">,
                                    </textual><code class="po-atom e191 e191"><textual class="po-textual">xs:dateTime</textual></code><textual class="po-textual"> and </textual><code class="po-atom e192 e192"><textual class="po-textual">xs:time</textual></code><textual class="po-textual">)</textual></td></tr><tr class="po-table e193 e193" valign="top"><td class="po-block e194 e194"><textual class="po-textual">past</textual></td><td class="po-block e195 e195"><textual class="po-textual">in the past (applicable to </textual><code class="po-atom e196 e196"><textual class="po-textual">xs:date</textual></code><textual class="po-textual">,
                                    </textual><code class="po-atom e197 e197"><textual class="po-textual">xs:dateTime</textual></code><textual class="po-textual"> and </textual><code class="po-atom e198 e198"><textual class="po-textual">xs:time</textual></code><textual class="po-textual">)</textual></td></tr><tr class="po-table e199 e199" valign="top"><td class="po-block e200 e200"><textual class="po-textual">nonFuture</textual></td><td class="po-block e201 e201"><textual class="po-textual">not in the future (applicable to </textual><code class="po-atom e202 e202"><textual class="po-textual">xs:date</textual></code><textual class="po-textual">,
                                    </textual><code class="po-atom e203 e203"><textual class="po-textual">xs:dateTime</textual></code><textual class="po-textual"> and </textual><code class="po-atom e204 e204"><textual class="po-textual">xs:time</textual></code><textual class="po-textual">)</textual></td></tr><tr class="po-table e205 e205" valign="top"><td class="po-block e206 e206"><textual class="po-textual">nonPast</textual></td><td class="po-block e207 e207"><textual class="po-textual">not in the past (applicable to </textual><code class="po-atom e208 e208"><textual class="po-textual">xs:date</textual></code><textual class="po-textual">,
                                    </textual><code class="po-atom e209 e209"><textual class="po-textual">xs:dateTime</textual></code><textual class="po-textual"> and </textual><code class="po-atom e210 e210"><textual class="po-textual">xs:time</textual></code><textual class="po-textual">)</textual></td></tr></tbody></table><textual class="po-textual">
            </textual></para><para class="po-block e211 e211"><textual class="po-textual"> The </textual><code class="po-atom e212 e212"><textual class="po-textual">_help</textual></code><textual class="po-textual"> operation provides usage assistence, which is based on the
                tool scheme. An XML representation of the complete tool scheme can be obtained by
                calling </textual><code class="po-atom e213 e213"><textual class="po-textual">_help</textual></code><textual class="po-textual"> with parameter </textual><code class="po-atom e214 e214"><textual class="po-textual">mode</textual></code><textual class="po-textual"> set to
                    </textual><code class="po-atom e215 e215"><textual class="po-textual">scheme</textual></code><textual class="po-textual">, for example:
                </textual><programlisting class="po-block e216 e216" xml:space="preserve"><textual class="po-textual">   basex -b "request=? mode=scheme" /projects/xclear/xclear.xq</textual></programlisting><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e217 e217"><title class="po-block e218 e218"><textual class="po-textual">Object parameter types</textual></title><para class="po-block e219 e219"><textual class="po-textual">The topic tools framework defines several parameter types providing high value to
                the tool user, as well as to the tool developer. The parameter values are not
                treated as strings, but as shortcut representations of structured information. The
                structures obtained from the parameter values are recognized by powerful functions,
                and the behaviour of these functions conveys to the parameter value a special
                meaning. For example, when the string </textual></para><programlisting class="po-block e220 e220" xml:space="preserve"><textual class="po-textual">   get* fetch* ~*IFF#c*</textual></programlisting><para class="po-block e221 e221"><textual class="po-textual">is used as argument for a parameter of type </textual><code class="po-atom e222 e222"><textual class="po-textual">xs:string</textual></code><textual class="po-textual">, it is this
                string what arrives in the tool application. When the string is used as argument for
                a parameter of type </textual><code class="po-atom e223 e223"><textual class="po-textual">nameFilter</textual></code><textual class="po-textual">, however, the application does not
                receive a string, but a complex XML element, which contains elements and attributes
                representing positive and negative string matching conditions, regular expressions
                and regex options. The element is the XML representation of a filter, selecting
                names starting with “get” or “fetch” (case-insensitively), but excluding names
                ending with “IFF” (case-sensitively). The filtering behaviour is provided by
                functions that "understand" the element structure and to which the filter element is
                passed as a parameter. These functions and the XML element are of course designed
                jointly, the element for defining behaviour, and the functions for implementing
                behaviour. Element and functions should therefore be viewed as a conceptual unit
                encapsulating data and functionality, irrespective of whether the functions are
                formally bound to the element, as would only be possible when using an
                object-oriented language. Parameter types matching this pattern - they are parsed
                into specific elements which can be handled by specific functions - are therefore
                collectively called </textual><emphasis class="po-inline e224 e224" role="bold"><textual class="po-textual">object parameter types</textual></emphasis><textual class="po-textual">.
                Conceptually, the user supplies objects, rather than strings. The user benefits from
                the high expressiveness of such parameters – the possibility to convey much
                information in a very concise way. The developer benefits from the rich
                functionality immediately available to him. An additional advantage for the user is
                the stylistic consistency which object parameter types enforce. Dealing with
                different operations and even with different topic tools, the style of specifying,
                say, name-based filtering is always the same.</textual></para><section class="po-hcontainer e225 e225"><title class="po-block e226 e226"><textual class="po-textual">Name filter (</textual><code class="po-atom e227 e227"><textual class="po-textual">nameFilter</textual></code><textual class="po-textual">)</textual></title><para class="po-block e228 e228"><textual class="po-textual">The type </textual><code class="po-atom e229 e229"><textual class="po-textual">nameFilter</textual></code><textual class="po-textual"> enables the definition of a filter on names
                    which is very simple for simple requirements, and at the same time expressive
                    enough to enable very fine-grained filtering. The filter text is a
                    whitespace-separated list of one or more filter items. A filter item is either a
                    positive filter (if not prefixed by the character ~) or a negative filter (if
                    prefixed by ~). The filter retains all candidates which match at least one
                    positive item (if there are any positive items) and does not match any of the
                    negative items. Each filter item consists of a filter term, which may be
                    accompanied by options. Any options are appended to the term, using character #
                    as separator. A filter term can use glob syntax (if not accompanied by option
                        </textual><code class="po-atom e230 e230"><textual class="po-textual">r</textual></code><textual class="po-textual">) or regex syntax (if accompanied by option </textual><code class="po-atom e231 e231"><textual class="po-textual">r</textual></code><textual class="po-textual">).
                    By default, filter terms are matched case-insensitively, unless accompanied by
                    option </textual><code class="po-atom e232 e232"><textual class="po-textual">c</textual></code><textual class="po-textual">. The following table show a few examples of
                        </textual><code class="po-atom e233 e233"><textual class="po-textual">nameFilter</textual></code><textual class="po-textual"> values.</textual></para><table class="po-container e234 e234"><caption class="po-container e235 e235"><para class="po-block e236 e236"><textual class="po-textual">
                            </textual><emphasis class="po-inline e237 e237" role="bold"><emphasis class="po-inline e238 e238" role="ital"><textual class="po-textual"> Examples of name filter
                                    values and their meaning.</textual></emphasis></emphasis><textual class="po-textual">
                        </textual></para></caption><col align="left" class="po-meta e239 e239" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e240 e240" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e241 e241"><tr class="po-table e242 e242" valign="top"><th align="left" class="po-field e243 e243" valign="top"><textual class="po-textual">Filter string</textual></th><th align="left" class="po-field e244 e244" valign="top"><textual class="po-textual">Matches (case-insensitively if not
                                otherwise stated)</textual></th></tr></thead><tbody class="po-table e245 e245"><tr class="po-table e246 e246" valign="top"><td class="po-block e247 e247"><textual class="po-textual">Book</textual></td><td class="po-block e248 e248"><textual class="po-textual">the string "book"</textual></td></tr><tr class="po-table e249 e249" valign="top"><td class="po-block e250 e250"><textual class="po-textual">Book*</textual></td><td class="po-block e251 e251"><textual class="po-textual">a string starting with "book"</textual></td></tr><tr class="po-table e252 e252" valign="top"><td class="po-block e253 e253"><textual class="po-textual">~Book*</textual></td><td class="po-block e254 e254"><textual class="po-textual">any string not starting with "book"</textual></td></tr><tr class="po-table e255 e255" valign="top"><td class="po-block e256 e256"><textual class="po-textual">Find*Response</textual></td><td class="po-block e257 e257"><textual class="po-textual">a string starting with "find" and ending with "response"</textual></td></tr><tr class="po-table e258 e258" valign="top"><td class="po-block e259 e259"><textual class="po-textual">Find*Response#c</textual></td><td class="po-block e260 e260"><textual class="po-textual">a string starting with "Find" and ending with "Response,
                                case-sensitively</textual></td></tr><tr class="po-table e261 e261" valign="top"><td class="po-block e262 e262"><textual class="po-textual">Find(Scart|Booking)RQ#r</textual></td><td class="po-block e263 e263"><textual class="po-textual">a string matching the regular expression, using regex option
                                'i'</textual></td></tr><tr class="po-table e264 e264" valign="top"><td class="po-block e265 e265"><textual class="po-textual">Find(Scart|Booking)RQ#rc</textual></td><td class="po-block e266 e266"><textual class="po-textual">a string matching the regular expression, </textual><emphasis class="po-inline e267 e267" role="ital"><textual class="po-textual">not
                                </textual></emphasis><textual class="po-textual">using regex option 'i'</textual></td></tr><tr class="po-table e268 e268" valign="top"><td class="po-block e269 e269"><textual class="po-textual">*RQ#c *RS#c</textual></td><td class="po-block e270 e270"><textual class="po-textual">a string ending with “RQ” or “RS”, case-sensitively</textual></td></tr><tr class="po-table e271 e271" valign="top"><td class="po-block e272 e272"><textual class="po-textual">~*Help* ~Options*</textual></td><td class="po-block e273 e273"><textual class="po-textual">any string not containing "help" and not starting with
                                "options"</textual></td></tr><tr class="po-table e274 e274" valign="top"><td class="po-block e275 e275"><textual class="po-textual">*RQ#c *RS#c ~*Help* ~Options*</textual></td><td class="po-block e276 e276"><textual class="po-textual">a string ending with “RQ” or “RS”, case-sensitively, but excluding
                                any strings containing "help" or starting with "options"</textual></td></tr></tbody></table></section><section class="po-hcontainer e277 e277"><title class="po-block e278 e278"><textual class="po-textual">Name filter map (</textual><code class="po-atom e279 e279"><textual class="po-textual">nameFilterMap</textual></code><textual class="po-textual">)</textual></title><para class="po-block e280 e280"><textual class="po-textual">A related type is </textual><code class="po-atom e281 e281"><textual class="po-textual">nameFilterMap</textual></code><textual class="po-textual">, which is a mapping of name
                    filters to values. The values are themselves constrained by a type, which
                    defaults to </textual><code class="po-atom e282 e282"><textual class="po-textual">xs:string</textual></code><textual class="po-textual">. For example, the type specification
                        </textual><code class="po-atom e283 e283"><textual class="po-textual">nameFilterMap(xs:integer)</textual></code><textual class="po-textual"> denotes a name filter map using
                    integer values, and </textual><code class="po-atom e284 e284"><textual class="po-textual">nameFilterMap</textual></code><textual class="po-textual"> denotes a name filter map using
                    string values. The value text is a % concatenated list of one or more entries.
                    An entry specifies a mapping in the form "value : nameFilter", or the default
                    value. If the default value contains a literal colon, it must be escaped with a
                    backslash. For example, the following map </textual></para><programlisting class="po-block e285 e285" xml:space="preserve"><textual class="po-textual">   10 % 0 :  *id *timestamp* % 100 : status</textual></programlisting><para class="po-block e286 e286"><textual class="po-textual"> specifies a default value (10) as well as two values (0 and 100,
                    respectively) bound to different name filters. Such a map could be used, for
                    example, for specifying the number of data values to be reported, dependent on
                    the element names. Then no values would be reported for elements with a name
                    ending on “id” or containing “timestamp”, 100 values for "status" elements, and
                    10 values for any elements not matching any of the two name filters. </textual></para></section><section class="po-hcontainer e287 e287"><title class="po-block e288 e288"><textual class="po-textual">Path filter (</textual><code class="po-atom e289 e289"><textual class="po-textual">pathFilter</textual></code><textual class="po-textual">)</textual></title><para class="po-block e290 e290"><textual class="po-textual">Another derivative of name filters is the </textual><code class="po-atom e291 e291"><textual class="po-textual">pathFilter</textual></code><textual class="po-textual"> type. It
                    consists of a sequence of name filters, separated by single or double slashes,
                    and it can be used to filter name paths (e.g. XPath data paths or qualified file
                    names). Each name filter specifies a step, which is applied either to the
                    children of the previous step (if preceded by a single slash) or to its
                    descendants (if preceded by a double slash). If the first step is not preceded
                    by a slash, the filter behaves as if the first step were preceded by a double
                    slash: the first step may match any step in the path. Contrary, if the first
                    step is preceded by a slash, it must match the first step of the path. For
                    example, the following path filter: </textual></para><programlisting class="po-block e292 e292" xml:space="preserve"><textual class="po-textual">   2.0/*.xsd</textual></programlisting><para class="po-block e293 e293"><textual class="po-textual">matches any path with a last step matching </textual><code class="po-atom e294 e294"><textual class="po-textual">*.xsd</textual></code><textual class="po-textual"> and a second
                    last step matching </textual><code class="po-atom e295 e295"><textual class="po-textual">2.0</textual></code><textual class="po-textual">. Path filters may be used, for example, in
                    order to select XML items according to their name and location within a
                    document, or to select files according to their name and location in the file
                    system.</textual></para></section><section class="po-hcontainer e296 e296" xml:id="user-dfd"><title class="po-block e297 e297"><textual class="po-textual">Directory Filter Descriptors (</textual><code class="po-atom e298 e298"><textual class="po-textual">docDFD</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e299 e299"><textual class="po-textual">txtDFD</textual></code><textual class="po-textual">)</textual></title><para class="po-block e300 e300"><textual class="po-textual">A very important reuse of name and path filters is given by </textual><emphasis class="po-inline e301 e301" role="bold"><textual class="po-textual">Document Filter Descriptors</textual></emphasis><textual class="po-textual"> (the types
                        </textual><code class="po-atom e302 e302"><textual class="po-textual">docDFD</textual></code><textual class="po-textual">, </textual><code class="po-atom e303 e303"><textual class="po-textual">textDFD</textual></code><textual class="po-textual"> and </textual><code class="po-atom e304 e304"><textual class="po-textual">csvDFD</textual></code><textual class="po-textual">). They
                    serve to select files (XML, text or csv files) from directories. A filter
                    descriptor consists of two or three % separated fields. The first field is a
                    whitespace separated list of one or more directories in which to search for
                    files. If a directory name is preceded by character ^, the directory is searched
                    recursively, that is, the search includes all direct or indirect sub
                    directories. The second field specifies a name filter which is applied to file
                    names – only files with matching name may be selected. An optional third field
                    refines recursive search. It supplies a path filter, which constrains the (sub)
                    directories from which files can be selected. For example, the following
                    value</textual></para><programlisting class="po-block e305 e305" xml:space="preserve"><textual class="po-textual">   ^/projects/niem-2.1 ^/projects/niem-2.0 /project/niem-submissions % *.xsd</textual></programlisting><para class="po-block e306 e306"><textual class="po-textual">selects all xsd files in or under one of the niem directories, or in the
                    directory </textual><code class="po-atom e307 e307"><textual class="po-textual">niem-submissions</textual></code><textual class="po-textual">. Adding a path filter, like so:</textual></para><programlisting class="po-block e308 e308" xml:space="preserve"><textual class="po-textual">   ^/projects/niem-2.1 ^/projects/niem-2.0 /project/niem-submissions % *.xsd % edxl*//*</textual></programlisting><para class="po-block e309 e309"><textual class="po-textual">would restrict recursive findings to files found in a directory located under
                    (but not in) a directory with a name starting with “edxl”. A parameter of type
                        </textual><code class="po-atom e310 e310"><textual class="po-textual">docDFD</textual></code><textual class="po-textual"> only selects XML files, ignoring any non-XML files
                    matching the descriptor; the effective parameter value (the value delivered to
                    the application) is a sequence of document nodes. A parameter of type
                        </textual><code class="po-atom e311 e311"><textual class="po-textual">txtDFD</textual></code><textual class="po-textual"> selects all files matching the descriptor, and the
                    effective parameter value is a sequence of strings, each string providing the
                    contents of one file. A parameter of type </textual><code class="po-atom e312 e312"><textual class="po-textual">csvDFD</textual></code><textual class="po-textual">, finally, also
                    selects all files matching the desciptor, but treats them as csv files and
                    delivers to the application XML documents, each one representing the rows and
                    cells of one csv file.</textual></para></section><section class="po-hcontainer e313 e313" xml:id="user-dcat"><title class="po-block e314 e314"><textual class="po-textual">Document catalog (</textual><code class="po-atom e315 e315"><textual class="po-textual">docCAT</textual></code><textual class="po-textual">)</textual></title><para class="po-block e316 e316"><textual class="po-textual">A document catalog (dcat) is an XML document containing a collection of
                    references to other documents. The parameter type </textual><code class="po-atom e317 e317"><textual class="po-textual">dcat</textual></code><textual class="po-textual"> has the
                    following semantics: the user-supplied value is the document URI of a dcat; the
                    value delivered to the tool application is the collection of all documents
                    referenced by the dcat. A dcat can be created automatically by calling the
                    built-in operation </textual><code class="po-atom e318 e318"><textual class="po-textual">dcat</textual></code><textual class="po-textual"> and supplying to it a directory filter
                    descriptor.</textual></para></section><section class="po-hcontainer e319 e319"><title class="po-block e320 e320"><textual class="po-textual">Tool specific object parameter types</textual></title><para class="po-block e321 e321"><textual class="po-textual">The preceding sections introduced several object parameter types supported by
                    any topic tool conforming to the model described in this paper. Apart from
                    these, any topic tool may define </textual><emphasis class="po-inline e322 e322" role="ital"><textual class="po-textual">tool-specific</textual></emphasis><textual class="po-textual">
                    parameter types, including object parameter types. The </textual><code class="po-atom e323 e323"><textual class="po-textual">_help</textual></code><textual class="po-textual">
                    operation supports a mode </textual><code class="po-atom e324 e324"><textual class="po-textual">types</textual></code><textual class="po-textual"> which explains all generic as well
                    as any tool-specific parameter types. See </textual><xref class="po-milestone e325 e325" linkend="dev-advanced-usage"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
                    for details about the implementation of tool-specific parameter types.</textual></para><para class="po-block e326 e326"><textual class="po-textual">As an example, </textual><code class="po-atom e327 e327"><textual class="po-textual">otdsv</textual></code><textual class="po-textual">, a topic tool for inspecting touristic data
                    conforming to the OTDS data model ([</textual><xref class="po-milestone e328 e328" linkend="otds"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]), uses a
                    tool-specific parameter type </textual><code class="po-atom e329 e329"><textual class="po-textual">travelScenario</textual></code><textual class="po-textual">. A parameter value
                    defines a trip in terms of booking date, start date and duration, as well as the
                    ages or birthdates of all travellers. The following parameter value:</textual></para><programlisting class="po-block e330 e330" xml:space="preserve"><textual class="po-textual">   2014-04-02 2014-12-06 14 % 32 31 5 2</textual></programlisting><para class="po-block e331 e331"><textual class="po-textual">specifies a travel booked on 2014-04-02, starting on 2014-12-06 and lasting
                    for 14 days, made by four persons aged 32, 31, 5 and 2 years. The tool
                    implementation does not see the string, but a structured representation which is
                    understood by various functions related to travel scenarios.</textual></para></section></section><section class="po-hcontainer e332 e332"><title class="po-block e333 e333"><textual class="po-textual">Storing and reusing invocation</textual></title><para class="po-block e334 e334"><textual class="po-textual">Complex functionality tends to involve a considerable number of invocation
                parameters, and object parameter types invite rather complex parameter values. A
                call with four or more parameters is a bit of a strain, and the more so if they
                involve object parameters. On the other hand, routine use of topic tools can be
                fairly repetitive, using often very similar calls which are only distinguished by a
                parameter or two, whereas several other parameters are set to the same values every
                time. In such situations in can be helpful to store invocations and reuse them
                either verbatim or partially overwriting or extending them on a call by call basis.
                Every topic tool supports the </textual><code class="po-atom e335 e335"><textual class="po-textual">storeq</textual></code><textual class="po-textual"> feature: if called with two
                question marks (instead of a single question mark), the tool returns a simple XML
                representation of the invocation. After storing the invocation in a file, it can be
                referenced in future tool invocations, omitting the operation name and using the
                file name instead, preceded by the character @. An example follows.</textual></para><para class="po-block e336 e336"><textual class="po-textual">Saving an invocation:</textual></para><programlisting class="po-block e337 e337" xml:space="preserve"><textual class="po-textual">   basex –b 'request=priceItems??otds=/projects/otds/otds.xml, cond=occupancy personImpact 
   dayImpact conditionalTags, scope=all, class=*, absolute' otdsv.xq &gt; piStd.tti</textual></programlisting><para class="po-block e338 e338"><textual class="po-textual">Reusing it unchanged:</textual></para><programlisting class="po-block e339 e339" xml:space="preserve"><textual class="po-textual">   basex –b 'request=@piStd.tti' otdsv.xq</textual></programlisting><para class="po-block e340 e340"><textual class="po-textual">Reusing and partially overwriting and extending it:</textual></para><programlisting class="po-block e341 e341" xml:space="preserve"><textual class="po-textual">   basex –b 'request=@piStd.tti?scope=absolute, summary' otdsv.xq</textual></programlisting></section><section class="po-hcontainer e342 e342"><title class="po-block e343 e343"><textual class="po-textual">Summary</textual></title><para class="po-block e344 e344"><textual class="po-textual">To summarize, the user of topic tools benefits from several features:</textual></para><itemizedlist class="po-table e345 e345"><listitem class="po-container e346 e346"><para class="po-block e347 e347"><textual class="po-textual">single point of access to a whole range of functionality (a
                        "topic")</textual></para></listitem><listitem class="po-container e348 e348"><para class="po-block e349 e349"><textual class="po-textual">uniform invocation pattern for all operations and all topic tools</textual></para></listitem><listitem class="po-container e350 e350"><para class="po-block e351 e351"><textual class="po-textual">high expressiveness enabled by object type parameters</textual></para></listitem><listitem class="po-container e352 e352"><para class="po-block e353 e353"><textual class="po-textual">syntactical sugar (name completion, shortcut for Boolean values)</textual></para></listitem><listitem class="po-container e354 e354"><para class="po-block e355 e355"><textual class="po-textual">comprehensive help functionality</textual></para></listitem><listitem class="po-container e356 e356"><para class="po-block e357 e357"><textual class="po-textual">user-friendly input error diagnostics</textual></para></listitem><listitem class="po-container e358 e358"><para class="po-block e359 e359"><textual class="po-textual">invocation reuse</textual></para></listitem></itemizedlist><para class="po-block e360 e360"><textual class="po-textual">The next section explains how topic tools are developed. It introduces a very
                lightweight framework which enables the developer to create topic tools quickly, to
                extend them with minimum effort, and to achieve high quality.</textual></para></section></section><section class="po-hcontainer e361 e361"><title class="po-block e362 e362"><textual class="po-textual">Topic tools: developer perspective</textual></title><para class="po-block e363 e363"><textual class="po-textual">A topic tool is expected to support a well-structured command-line interface, perform
            fine-grained input validation, report user input errors in a comprehensive way and offer
            rich help functionality. Furthermore, remembering the high complexity which a topic tool
            may easily attain (many operations and all in all very many parameters), one might
            expect that topic tools are hard to create, to maintain and to extend. </textual></para><para class="po-block e364 e364"><textual class="po-textual">Using the </textual><code class="po-atom e365 e365"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> framework, the contrary is the case: development is
            easy, fast and, hopefully, enjoyable. Adding a topic tool operation is by far easier and
            faster than implementing its functionality by a new, non-topic tool written from
            scratch. An added topic tool operation conforms to the behavioural expectations (smart
            syntax, validation, error reporting and help) from the first minute of its prototypic
            existence. Achievement of this behaviour might easily take weeks to attain (and months
            to un-bug) if implemented as part of the tool development, rather than being provided by
            the framework via code generation and libraries. A new topic tool is instantiated in a
            minute, and in typical settings a first useful and deliverable version is ready after a
            few hours of work. After the initial shot, the tool tends to grow quickly and
            organically, no matter if guided by a complex set of initial requirements, or in
            response to frequently emerging requirements, or both. In all cases, growth is
            facilitated by the fact that the current amount of functionality does not create a
            burden making the addition of new functionality more difficult. To add a second or a
            twenty second operation tends to require the same amount of work, or usually the
            addition of operations even becomes increasingly simple thanks to utilities which have
            been created along the way to the current state.</textual></para><para class="po-block e366 e366"><textual class="po-textual"> This section explains how to write topic tools using the </textual><code class="po-atom e367 e367"><textual class="po-textual">ttools</textual></code><textual class="po-textual">
            framework. It starts with a high level overview of the support offered by
                </textual><code class="po-atom e368 e368"><textual class="po-textual">ttools</textual></code><textual class="po-textual">. It summarizes the workflow of tool development, describes how
            XQuery programming is facilitated and how code writing is complemented by the writing of
            annotations. This overview will be followed by a brief tutorial intended to give you a
            hands-on impression of the process of developing a topic tool. The tutorial takes you
            through the steps of creating a new topic tool and filling it with a first set of
            functionality. The final part of this section on topic tool development will discuss
            advanced usage of </textual><code class="po-atom e369 e369"><textual class="po-textual">ttools</textual></code><textual class="po-textual">: it explains how to extend the infrastructure
            provided by </textual><code class="po-atom e370 e370"><textual class="po-textual">ttools</textual></code><textual class="po-textual">, defining new parameter types and new parameter facets. </textual></para><section class="po-hcontainer e371 e371"><title class="po-block e372 e372"><textual class="po-textual">Overview</textual></title><para class="po-block e373 e373"><textual class="po-textual">The development support offered by </textual><code class="po-atom e374 e374"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> has four main
                aspects:</textual></para><itemizedlist class="po-table e375 e375"><listitem class="po-container e376 e376"><para class="po-block e377 e377"><textual class="po-textual">Code generation</textual></para></listitem><listitem class="po-container e378 e378"><para class="po-block e379 e379"><textual class="po-textual">Pseudo objects</textual></para></listitem><listitem class="po-container e380 e380"><para class="po-block e381 e381"><textual class="po-textual">Utility functions</textual></para></listitem><listitem class="po-container e382 e382"><para class="po-block e383 e383"><textual class="po-textual">Built-in operations</textual></para></listitem></itemizedlist><para class="po-block e384 e384"><textual class="po-textual">The main module of a topic tool is generated. Code generation is based on
                    </textual><emphasis class="po-inline e385 e385" role="ital"><textual class="po-textual">annotations</textual></emphasis><textual class="po-textual"> scattered over XQuery library
                modules. Annotations are not formal annotations as defined by XQuery 3.0, but XML
                snippets placed in XQuery comments conforming to a syntax convention. Annotations
                typically define tool operations in terms of an operation name and the names, types
                and other properties of operation parameters. Annotations may also define new
                parameter types and new kinds of parameter facets. </textual></para><para class="po-block e386 e386"><textual class="po-textual"> Code generation is effected by an application </textual><emphasis class="po-inline e387 e387" role="ital"><textual class="po-textual">build</textual></emphasis><textual class="po-textual">. The build is triggered by a command line call of
                    </textual><code class="po-atom e388 e388"><textual class="po-textual">ttools</textual></code><textual class="po-textual">, which is a topic tool for building topic tools. The build
                call provides a tool name and a tool directory. During an application build,
                    </textual><code class="po-atom e389 e389"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> investigates all library modules found in the application
                directory, and all annotations which they contain are used. The independent
                annotations scattered over the modules are integrated into a single model of tool
                functionality, called the </textual><emphasis class="po-inline e390 e390" role="ital"><textual class="po-textual">tool scheme</textual></emphasis><textual class="po-textual">. A tool
                scheme defines tool functionality in terms of named operations and
                operation-specific sets of parameters. </textual></para><para class="po-block e391 e391"><textual class="po-textual">The tool scheme is translated into an XQuery main module implementing a command
                line interface which gives access to all operations. On invocation, the main module
                parses, evaluates and validates user input, creating a comprehensive error report,
                if errors occur. Otherwise the main module integrates user input into an XML
                    </textual><emphasis class="po-inline e392 e392" role="ital"><textual class="po-textual">request message</textual></emphasis><textual class="po-textual"> and invokes the </textual><emphasis class="po-inline e393 e393" role="ital"><textual class="po-textual">operation provider function</textual></emphasis><textual class="po-textual">, the function which
                implements the operation. The provider function is hand-written by the tool
                developer. It has a standardized signature, receiving a single parameter which is
                the request message assembled by the main module, and producing an
                annotation-defined result type. The request message is an XML element intended to be
                used exclusively via a set of access functions designed for the purpose. These
                access functions can be regarded as the </textual><emphasis class="po-inline e394 e394" role="ital"><textual class="po-textual">message
                    interface</textual></emphasis><textual class="po-textual">, functionality bound to its data content. The request
                message thus resembles a program object, which hides user </textual><emphasis class="po-inline e395 e395" role="ital"><textual class="po-textual">input data</textual></emphasis><textual class="po-textual"> behind an interface of accessors to </textual><code class="po-atom e396 e396"><textual class="po-textual">input
                    information</textual></code><textual class="po-textual">.</textual></para><para class="po-block e397 e397"><textual class="po-textual">For example, if a parameter is typed as a document URI, the user data is a URI,
                but the accessor returns a document node. While the user supplies a multiple-valued
                parameter as a concatenated string, the accessor delivers the parameter as a
                sequence of typed items. Annotation-defined default values are delivered in a way
                indistinguishable from explicitly supplied parameters. The difference between input
                data and input information is especially relevant in the case of object parameters
                (e.g. name filters), where input data are strings from which “objects” are
                constructed: XML elements designed to provide functionality when passed to the
                appropriate functions (e.g. </textual><code class="po-atom e398 e398"><textual class="po-textual">tt:matchesNameFilter</textual></code><textual class="po-textual">). It is important to
                realize how the use of the request object and its accessor interface in general, and
                the use of object parameters in particular, may simplify the work of application
                writing significantly. </textual></para><para class="po-block e399 e399"><code class="po-atom e400 e400"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> based development profits from </textual><emphasis class="po-inline e401 e401" role="ital"><textual class="po-textual">utility
                    functions</textual></emphasis><textual class="po-textual"> in a dual way: (a) using “object functions”, as just
                described, which are functions designed for use with XML elements constructed by
                    </textual><code class="po-atom e402 e402"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> infrastructure; (b) general purpose functions, providing
                useful functionality not related to </textual><code class="po-atom e403 e403"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> specific structures.
                Examples of general purpose functions are a function for parsing CSV formatted text
                and a function for creating tabular text.</textual></para><para class="po-block e404 e404"><textual class="po-textual">Every </textual><code class="po-atom e405 e405"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> based topic tool supports a range of </textual><emphasis class="po-inline e406 e406" role="ital"><textual class="po-textual">built-in operations</textual></emphasis><textual class="po-textual">, implemented by modules which are
                automatically added to the tool directory during tool instantiation. A prominent
                role plays the generic </textual><emphasis class="po-inline e407 e407" role="ital"><textual class="po-textual">help operation</textual></emphasis><textual class="po-textual">, which
                translates the tool scheme into usage information. Other built-in operations provide
                generic functionality which may add to the usefulness of the topic tool. As an
                example, built-in operation </textual><code class="po-atom e408 e408"><textual class="po-textual">doctypes</textual></code><textual class="po-textual"> reports the document types (root
                element names and namespaces) encountered in a set of XML resources, which may be
                specified by any combination of document URIs, directory filter descriptors (see
                    </textual><xref class="po-milestone e409 e409" linkend="user-dfd"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and document catalogs. Using further parameters,
                additional information about the documents can be requested.</textual></para></section><section class="po-hcontainer e410 e410"><title class="po-block e411 e411"><textual class="po-textual">Workflow</textual></title><para class="po-block e412 e412"><textual class="po-textual">The </textual><code class="po-atom e413 e413"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> based development of a topic tool can be schematically
                described as the following workflow.</textual></para><orderedlist class="po-table e414 e414"><listitem class="po-container e415 e415"><para class="po-block e416 e416"><emphasis class="po-inline e417 e417" role="bold"><textual class="po-textual">Tool instantiation</textual></emphasis><textual class="po-textual"> – command line call
                        creating and initializing the new topic tool.</textual></para></listitem><listitem class="po-container e418 e418"><para class="po-block e419 e419"><emphasis class="po-inline e420 e420" role="bold"><textual class="po-textual">Prototyping</textual></emphasis><textual class="po-textual"> – command line call creating
                        the initial version of a new XQuery library module, intended to implement a
                        list of operations specified by a call parameter; the generated code
                        contains initial versions of annotations and function definitions; the
                        generated module is immediately callable after re-building the topic tool
                        (see below).</textual></para></listitem><listitem class="po-container e421 e421"><para class="po-block e422 e422"><emphasis class="po-inline e423 e423" role="bold"><textual class="po-textual">XQuery code writing </textual></emphasis><textual class="po-textual"> – developing the
                        functions which implement the operations, as well as auxiliary functions, as
                        appropriate.</textual></para></listitem><listitem class="po-container e424 e424"><para class="po-block e425 e425"><emphasis class="po-inline e426 e426" role="bold"><textual class="po-textual">Annotation editing </textual></emphasis><textual class="po-textual"> – adding the
                        definitions of new operations, or changing / extending the definitions of
                        existing operations.</textual></para></listitem><listitem class="po-container e427 e427"><para class="po-block e428 e428"><emphasis class="po-inline e429 e429" role="bold"><textual class="po-textual">Tool building </textual></emphasis><textual class="po-textual"> – command line call
                        re-building the tool, translating the current annotations into the command
                        line interface.</textual></para></listitem><listitem class="po-container e430 e430"><para class="po-block e431 e431"><emphasis class="po-inline e432 e432" role="bold"><textual class="po-textual">Tool testing.</textual></emphasis></para></listitem></orderedlist></section><section class="po-hcontainer e433 e433"><title class="po-block e434 e434"><textual class="po-textual">Writing XQuery code</textual></title><para class="po-block e435 e435"><textual class="po-textual">Coding is significantly simplified by the packaging of all input information into
                a single container (the request message) and its exposal via accessor functions
                (e.g. </textual><code class="po-atom e436 e436"><textual class="po-textual">tt:getParam</textual></code><textual class="po-textual">). Especially helpful are three facts:</textual></para><itemizedlist class="po-table e437 e437"><listitem class="po-container e438 e438"><para class="po-block e439 e439"><emphasis class="po-inline e440 e440" role="ital"><textual class="po-textual">Guaranteed availability</textual></emphasis><textual class="po-textual">. Any mandatory
                        operation parameter </textual><emphasis class="po-inline e441 e441" role="ital"><textual class="po-textual">is</textual></emphasis><textual class="po-textual"> supplied. If it were
                        not, the function would not be called in the first place. Whether or not the
                        annotation declares a default value, concerns user convenience, but not the
                        developer: a mandatory value is present.</textual></para></listitem><listitem class="po-container e442 e442"><para class="po-block e443 e443"><emphasis class="po-inline e444 e444" role="ital"><textual class="po-textual">Guaranteed validity</textual></emphasis><textual class="po-textual">. For any operation
                        parameter a </textual><emphasis class="po-inline e445 e445" role="ital"><textual class="po-textual">valid</textual></emphasis><textual class="po-textual"> value is supplied.
                        Validity refers to the type specification including item type, cardinality
                        constraints and optional facets. The developer can simplify his work by
                        protecting himself from inappropriate values: he can add facets to the
                        parameter annotation, e.g. specifying enumerated values, a regular
                        expression, minimum or maximum values. The infrastructure will not call the
                        function unless user input satisfies all constraints.</textual></para></listitem><listitem class="po-container e446 e446"><para class="po-block e447 e447"><emphasis class="po-inline e448 e448" role="ital"><textual class="po-textual">Object parameters</textual></emphasis><textual class="po-textual">. The definition of
                        particular parameter types prescribes the parsing of user-provided text
                        value, resulting in the construction of “objects”, which are XML elements
                        designed to be processed by functions. An example is the parsing of a name
                        filter string into a name filter element which can be passed to a
                            </textual><code class="po-atom e449 e449"><textual class="po-textual">tt:matchesNameFilter</textual></code><textual class="po-textual"> function. The use of object parameters
                        can reduce the complexity of application development, as the request
                        accessors deliver the objects, not the source text.</textual></para></listitem></itemizedlist><para class="po-block e450 e450"><textual class="po-textual">An interesting aspect concerns the information flow between XQuery functions. When
                the operation providing function delegates some tasks to other functions, these may
                have a function signature including a request message parameter. The request message
                passed on may be constructed from scratch, as the message interface includes
                functions enabling such a construction. But it may also be the original request, or
                a modified copy of it - the request interface includes functions for creating copies
                with parameters removed, overwritten or added. When the request passed on is not
                constructed from scratch, but received from the outside, whether or not subsequently
                modified before being passed on, it may carry information which the called function
                evaluates, but which the calling function need not be aware of. As an example,
                consider a function which operates on the results of some kind of search. Such a
                function may pass the original request on to the search function, trusting the
                request (which it received from the user and which has passed validation) to contain
                all information relevant to the search function. Now the search function may
                    </textual><emphasis class="po-inline e451 e451" role="ital"><textual class="po-textual">evolve</textual></emphasis><textual class="po-textual">, incrementally extend its parameter
                usage and evaluate additional input parameters, without the calling function being
                aware of it – search control parameters do not concern it and are not inspected. As
                a result, the search function may evolve freely and independently of other functions
                operating on the search results, as the request message </textual><emphasis class="po-inline e452 e452" role="ital"><textual class="po-textual">hides</textual></emphasis><textual class="po-textual"> the changes of search related input. If today the search
                function begins to evaluate some additional input, the code of search result
                processing functions need not be changed. The only adaptation necessary concerns the
                annotations: in order to benefit from the extended search functionality, a search
                result processing operation should add the new, search related parameters to its own
                operation signature. But even this adaptation can as well be postponed, until the
                need is felt. </textual></para><para class="po-block e453 e453"><textual class="po-textual">Such an interaction of functions may be called message-based – as opposed to
                parameter list based. </textual><code class="po-atom e454 e454"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> provides a sophisticated set of message
                related functionality, including functions for transforming messages by extension,
                value overwriting and reduction. The primary use of this functionality is the
                dealing with the original request message, constructed by infrastructure from user
                input. However, beyond that, the availability of message related functionality
                encourages the practise of message-based interactions among functions. A recommended
                design pattern of topic tools can be summarized as follows: (a) identify pieces of
                core functionality, which have a </textual><emphasis class="po-inline e455 e455" role="ital"><textual class="po-textual">potentially growing set of
                    input information</textual></emphasis><textual class="po-textual">; (b) provide such functionality with a
                message-based signature, rather than a parameter list based signature. This approach
                can considerably help in the process of evolving complex applications in a safe
                way.</textual></para></section><section class="po-hcontainer e456 e456"><title class="po-block e457 e457"><textual class="po-textual">Writing annotations</textual></title><para class="po-block e458 e458"><textual class="po-textual">Writing code and editing the annotations are two activities performed in tandem.
                While writing the code of an operation, the developer switches over to the
                annotations whenever he decides to modify operation input, typically by adding a
                further control parameter. Then he resumes code writing, referring to the added
                parameters using request message accessors.</textual></para><para class="po-block e459 e459"><textual class="po-textual">The annotation of an operation defines the operation in terms of its parameters.
                For every parameter, the following information is specified (the last two items
                optionally):</textual></para><itemizedlist class="po-table e460 e460"><listitem class="po-container e461 e461"><para class="po-block e462 e462"><textual class="po-textual">parameter name</textual></para></listitem><listitem class="po-container e463 e463"><para class="po-block e464 e464"><textual class="po-textual">parameter type, including cardinality (e.g. ?, *, {3}, {1,3})</textual></para></listitem><listitem class="po-container e465 e465"><para class="po-block e466 e466"><textual class="po-textual">facets (e.g. regular expression, value list, minimum/maximum
                        values)</textual></para></listitem><listitem class="po-container e467 e467"><para class="po-block e468 e468"><textual class="po-textual">membership in parameter groups (for joint cardinality constraints, e.g.
                        when at least one of several parameters must be supplied)</textual></para></listitem></itemizedlist><para class="po-block e469 e469"><textual class="po-textual">The editing of annotations takes effect immediately after re-building the topic
                tool. This is achieved by a command line call (invoking the </textual><code class="po-atom e470 e470"><textual class="po-textual">build</textual></code><textual class="po-textual">
                operation of </textual><code class="po-atom e471 e471"><textual class="po-textual">ttools</textual></code><textual class="po-textual">) and usually lasts less than a second.</textual></para></section><section class="po-hcontainer e472 e472" xml:id="dev-advanced-usage"><title class="po-block e473 e473"><textual class="po-textual">Advanced usage - extending the framework</textual></title><para class="po-block e474 e474"><textual class="po-textual">Developing topic tools using the </textual><code class="po-atom e475 e475"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> framework gives access to the
                automated construction of object parameters and automated facet validation.
                    </textual><code class="po-atom e476 e476"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> ships with a range of built-in object parameter types and
                facet kinds.</textual></para><para class="po-block e477 e477"><textual class="po-textual">A topic tool may extend the framework by defining </textual><emphasis class="po-inline e478 e478" role="ital"><textual class="po-textual">tool
                    specific</textual></emphasis><textual class="po-textual"> parameter types and facet kinds. This is very easily done.
                In order to define a tool specific object parameter type, one has to write a parsing
                function which constructs from an input string an element of the appropriate
                structure. The signature must take a single input parameter of type
                    </textual><code class="po-atom e479 e479"><textual class="po-textual">xs:string</textual></code><textual class="po-textual">, and the return value must be a single item of
                arbitrary type (</textual><code class="po-atom e480 e480"><textual class="po-textual">item()</textual></code><textual class="po-textual">).
                Similarly, in order to define an additional facet kind, one must write a facet
                validation function which will validate a parameter value item against the new facet
                kind. The signature must take two input parameters, the first of type
                    </textual><code class="po-atom e481 e481"><textual class="po-textual">item()</textual></code><textual class="po-textual"> receiving the value item to be checked, the second of type
                    </textual><code class="po-atom e482 e482"><textual class="po-textual">xs:string</textual></code><textual class="po-textual"> receiving the facet value; the return value must be
                    </textual><code class="po-atom e483 e483"><textual class="po-textual">element(z:errors)?</textual></code><textual class="po-textual">. A library module containing type definitions
                and/or facet validation functions must contain an annotation of type
                    </textual><code class="po-atom e484 e484"><textual class="po-textual">extensions</textual></code><textual class="po-textual">, which binds the parsing functions to parameter types
                and the facet validation functions to facet kinds. The implementation of framework
                extensions may for example look as follows:</textual></para><programlisting class="po-block e485 e485" xml:space="preserve"><textual class="po-textual">
(:~ 
 : ttoolsExtensions.mod.xq - application specific extensions of the parameter parser and facet validator.
 :)

(:~@extensions
&lt;extensions&gt;
    &lt;type name="travelScenario" parser='parseTravelScenario'/&gt;
    &lt;facet name="blacklisted" validator='checkBlacklisted'/&gt;    
&lt;/extensions&gt;    
:)
module namespace m="http://www.ttools.org/otdsv/xquery-functions";
...
declare namespace z="http://www.ttools.org/structure";
...
declare function m:parseTravelScenario($text as xs:string)    
        as item() {...}

declare function m:checkBlacklisted($item as item(), $facetValue as xs:string)    
        as element(z:errors)? {...}</textual></programlisting><para class="po-block e486 e486"><textual class="po-textual">After dropping this library module into the tool directory, the annotations of
                operations may define parameters of type </textual><code class="po-atom e487 e487"><textual class="po-textual">travelScenario</textual></code><textual class="po-textual"> and constrain
                parameters to conform to a </textual><code class="po-atom e488 e488"><textual class="po-textual">blacklisted</textual></code><textual class="po-textual"> facet. The definition of
                additional object parameter types is typically accompanied by functions taking
                elements of the respective structure as input. These functions constitute the
                "interface" of the new object type and largely determine the value which the object
                type has for the tool application. </textual></para><para class="po-block e489 e489"><textual class="po-textual">It should be remembered that object construction and facet validation are
                performed automatically, so that the application never needs to call the functions
                which it provides for the definition of additional types and the evaluation of
                additional facet kinds.</textual></para></section><section class="po-hcontainer e490 e490"><title class="po-block e491 e491"><textual class="po-textual">Summary</textual></title><para class="po-block e492 e492"><textual class="po-textual">The development of a topic tool is simplified by code generation. What remains to
                be done is the writing of functions which are exposed as operations. Code writing is
                accompanied by annotation editing, which provides the code with an environment of
                validated information. Frequent extension of this information – for example caused
                by stepwise refinement of functionality – is accomplished in a painless way.
                Whenever the need arises, just add a parameter to the operation annotation: from now
                on the parameter value is available to the operation code.</textual></para><para class="po-block e493 e493"><textual class="po-textual">Code writing is greatly simplified by having all external input encapsulated in a
                single container – the request message – which is accessed via functions, completely
                isolating application code from the original forms of external input. Application
                code is thus embedded in an infrastructure which takes on the responsibility of
                input validation and input augmentation. In the case of so-called object parameter
                types, the embedding infrastructure transforms user input into entities
                corresponding to program objects. </textual></para><para class="po-block e494 e494"><textual class="po-textual">The message-related functionality provided by </textual><code class="po-atom e495 e495"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> also encourages
                the use of messages in function signatures in general, whether or not the function
                is exposed as a topic tool operation. Messages enable the "tunneling" of
                information, so that a calling function may be unawares of the information
                requirements of the called function. The use of message-controlled functions thus
                favours a robust integration of complex functionalities - like search and
                processings of search result - which is an important concern in general, and when
                developing topic tools in particular.</textual></para></section></section><section class="po-hcontainer e496 e496"><title class="po-block e497 e497"><textual class="po-textual">Getting started with topic tools</textual></title><para class="po-block e498 e498"><textual class="po-textual">This part of the paper proposes a short tutorial which may give you some hands-on
            impressions of the development of topic tools. We set out to create the first version of
            a command line tool which assists the user in the analysis of XML resources. We have
            already downloaded </textual><code class="po-atom e499 e499"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> (download URI will be added here), which is
            itself a topic tool supporting the development of topic tools. We have further installed
            BaseX ([</textual><xref class="po-milestone e500 e500" linkend="w3c-xquery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]), an open source XQuery processor supporting
            XQuery 3.0.</textual></para><para class="po-block e501 e501"><textual class="po-textual"> We decide to call the new tool </textual><code class="po-atom e502 e502"><textual class="po-textual">xclear</textual></code><textual class="po-textual">, and we plan to supply the first
            version with three operations: </textual></para><itemizedlist class="po-table e503 e503"><listitem class="po-container e504 e504"><para class="po-block e505 e505"><code class="po-atom e506 e506"><textual class="po-textual">names</textual></code><textual class="po-textual"> - reports names of elements and attributes</textual></para></listitem><listitem class="po-container e507 e507"><para class="po-block e508 e508"><code class="po-atom e509 e509"><textual class="po-textual">paths</textual></code><textual class="po-textual"> - reports data paths of elements and attributes</textual></para></listitem><listitem class="po-container e510 e510"><para class="po-block e511 e511"><code class="po-atom e512 e512"><textual class="po-textual">values</textual></code><textual class="po-textual"> - reports data content of elements and attributes</textual></para></listitem></itemizedlist><para class="po-block e513 e513"><textual class="po-textual"> In what follows, we assume that the </textual><code class="po-atom e514 e514"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> installation directory is
                </textual><code class="po-atom e515 e515"><textual class="po-textual">/projects/ttools</textual></code><textual class="po-textual">, and that </textual><code class="po-atom e516 e516"><textual class="po-textual">xclear</textual></code><textual class="po-textual"> shall be installed in
            directory </textual><code class="po-atom e517 e517"><textual class="po-textual">/projects/xclear</textual></code><textual class="po-textual">. </textual></para><section class="po-hcontainer e518 e518"><title class="po-block e519 e519"><textual class="po-textual">Tool instantiation</textual></title><para class="po-block e520 e520"><textual class="po-textual">The very first step of tool development is tool instantiation. We call the
                    </textual><code class="po-atom e521 e521"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> operation </textual><code class="po-atom e522 e522"><textual class="po-textual">new</textual></code><textual class="po-textual">, specifying a 
                tool directory whose name is equal to the intended tool name:</textual></para><programlisting class="po-block e523 e523" xml:space="preserve"><textual class="po-textual">
basex -b "request=new?dir=/projects/xclear" /projects/ttools/ttools.xq

==&gt;
===============================================================

Topic tool created:  xclear
Tool directory:      /projects/xclear

The tool can already be called. Example:
   basex -b "request=?" /projects/xclear/xclear.xq

Use operation 'add' for adding module prototypes. Example:
   basex -b "request=add?dir=/projects/xclear, mod=fooMod, ops=fooOp barOp foobarOp" /projects/ttools/ttools.xq
   
===============================================================</textual></programlisting><para class="po-block e524 e524"><textual class="po-textual"> As a result, the tool directory </textual><code class="po-atom e525 e525"><textual class="po-textual">xclear</textual></code><textual class="po-textual"> has been created and filled
                with various XQuery library modules, as well as a generated main module
                </textual><code class="po-atom e526 e526"><textual class="po-textual">xclear.xq</textual></code><textual class="po-textual">, which can be called. </textual></para><programlisting class="po-block e527 e527" xml:space="preserve"><textual class="po-textual">
01.07.2014  22:12             4.473 xclear.xq
07.04.2014  23:47               599 _constants.mod.xq
27.04.2014  12:50             8.656 _csvParser.mod.xq
28.06.2014  13:11            11.855 _dcat.mod.xq
28.06.2014  12:39             5.172 _docs.mod.xq
01.07.2014  22:12             1.155 _extensions.mod.xq
29.06.2014  08:52             8.333 _help.mod.xq
15.04.2014  00:09            19.666 _nameFilter.mod.xq
15.04.2014  00:13            14.944 _nameFilter_parser.mod.xq
07.04.2014  22:29            20.893 _namespaceTools.mod.xq
07.04.2014  22:29             1.744 _reportAssistent.mod.xq
29.06.2014  09:38            55.935 _request.mod.xq
28.06.2014  13:18            10.144 _request_getters.mod.xq
12.04.2014  08:29             2.908 _request_parser.mod.xq
28.06.2014  12:02             3.260 _request_setters.mod.xq
27.04.2014  14:37             3.606 _stringTools.mod.xq</textual></programlisting></section><section class="po-hcontainer e528 e528"><title class="po-block e529 e529"><textual class="po-textual">Exploring the initial tool version</textual></title><para class="po-block e530 e530"><textual class="po-textual">A topic tool has a single parameter, </textual><code class="po-atom e531 e531"><textual class="po-textual"> request</textual></code><textual class="po-textual">. If supplied with the
                parameter value “?”, a topic tool is expected to give an overview of its operations.
                We give it a try:</textual></para><programlisting class="po-block e532 e532" xml:space="preserve"><textual class="po-textual">
basex -b "request=?" /projects/xclear/xclear.xq            

==&gt;
TOOL: xclear

OPERATIONS   PARAMS
====================================================
_help        default, mode, ops?, type
dcat         dfd+
docs         dcat*, doc*, docs*
doctypes     attNames, dcat*, doc*, docs*, elemNames
====================================================</textual></programlisting><para class="po-block e533 e533"><textual class="po-textual"> Our freshly created tool has already four operations! Operation
                    </textual><code class="po-atom e534 e534"><textual class="po-textual">_help</textual></code><textual class="po-textual"> is what is called when the request value starts with a
                question mark, rather than an operation name. The other three operations are
                built-in operations augmenting the functionality of any topic tool we build using
                    </textual><code class="po-atom e535 e535"><textual class="po-textual">ttools</textual></code><textual class="po-textual">. For example, operation </textual><code class="po-atom e536 e536"><textual class="po-textual">doctypes</textual></code><textual class="po-textual"> provides basic
                information about a set of documents. In order to take a closer look at its
                parameters, we refine our </textual><code class="po-atom e537 e537"><textual class="po-textual">_help</textual></code><textual class="po-textual"> request, specifying the Boolean
                parameters </textual><code class="po-atom e538 e538"><textual class="po-textual">type</textual></code><textual class="po-textual"> and </textual><code class="po-atom e539 e539"><textual class="po-textual">default</textual></code><textual class="po-textual">, in order to learn the
                parameter types and see any default values. We narrow down the response to operation
                    </textual><code class="po-atom e540 e540"><textual class="po-textual">doctypes</textual></code><textual class="po-textual"> by setting the optional parameter </textual><code class="po-atom e541 e541"><textual class="po-textual">ops</textual></code><textual class="po-textual"> to the
                value </textual><code class="po-atom e542 e542"><textual class="po-textual">doct*</textual></code><textual class="po-textual">: </textual></para><programlisting class="po-block e543 e543" xml:space="preserve"><textual class="po-textual">
basex -b "request=?default, type, ops=doct*" /projects/xclear/xclear.xq

==&gt;
TOOL: xclear

OPERATIONS   PARAMS
==========================================================================
doctypes     attNames=false...... : xs:boolean
             dcat................ : docCAT* (sep=WS)
             doc................. : docURI* (sep=WS)
             docs................ : docDFD* (sep=;)
             elemNames=false..... : xs:boolean
               At least 1 of these parameters must be set: dcat, doc, docs
==========================================================================</textual></programlisting><para class="po-block e544 e544"><textual class="po-textual">The parameter types </textual><code class="po-atom e545 e545"><textual class="po-textual">docURI</textual></code><textual class="po-textual">, </textual><code class="po-atom e546 e546"><textual class="po-textual">docDFD</textual></code><textual class="po-textual"> and
                    </textual><code class="po-atom e547 e547"><textual class="po-textual">docCAT</textual></code><textual class="po-textual"> are very important, because they are </textual><emphasis class="po-inline e548 e548" role="ital"><textual class="po-textual">the</textual></emphasis><textual class="po-textual"> parameter types used for supplying the tool with 
                XML documents. If an operation demands input which may consist of a set of documents,
                rather than necessarily a single document, it is a recommended pattern to use a
                triple of parameters of type </textual><code class="po-atom e549 e549"><textual class="po-textual">docURI</textual></code><textual class="po-textual">, </textual><code class="po-atom e550 e550"><textual class="po-textual">docDFD</textual></code><textual class="po-textual"> and
                    </textual><code class="po-atom e551 e551"><textual class="po-textual">docCAT</textual></code><textual class="po-textual">, respectively, and (if appropriate) mark them as a group of
                which at least one parameter must be set. This gives the user great freedom how to
                supply input documents, as he can use any combination of three approaches:</textual></para><itemizedlist class="po-table e552 e552"><listitem class="po-container e553 e553"><para class="po-block e554 e554"><code class="po-atom e555 e555"><textual class="po-textual">docURI</textual></code><textual class="po-textual"> typed parameter: expects a document URI</textual></para></listitem><listitem class="po-container e556 e556"><para class="po-block e557 e557"><code class="po-atom e558 e558"><textual class="po-textual">docDFD</textual></code><textual class="po-textual"> typed parameter: expects a directory filter
                        descriptor</textual></para></listitem><listitem class="po-container e559 e559"><para class="po-block e560 e560"><code class="po-atom e561 e561"><textual class="po-textual">docCAT</textual></code><textual class="po-textual"> typed parameter: expects the document URI of a
                        document catalog ("dcat")</textual></para></listitem></itemizedlist><para class="po-block e562 e562"><textual class="po-textual"> A dcat can be created calling operation </textual><code class="po-atom e563 e563"><textual class="po-textual">dcat</textual></code><textual class="po-textual"> and supplying it with a
                document filter descriptor. If stored in a file, the dcat can later be supplied to
                any parameter of type </textual><code class="po-atom e564 e564"><textual class="po-textual">docCAT</textual></code><textual class="po-textual">. To get a feeling for our new tool, we
                invoke operation </textual><code class="po-atom e565 e565"><textual class="po-textual">doctypes</textual></code><textual class="po-textual">, supplying it with a directory filter
                descriptor. Suppose we are interested in the XML resources directly or indirectly
                contained by a directory </textual><code class="po-atom e566 e566"><textual class="po-textual">/projects/xsd/niem-2.1</textual></code><textual class="po-textual">. This is how we request
                a </textual><code class="po-atom e567 e567"><textual class="po-textual">doctypes</textual></code><textual class="po-textual"> report: </textual></para><programlisting class="po-block e568 e568" xml:space="preserve"><textual class="po-textual">
basex -b "request=doctypes?docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq

==&gt;
  &lt;z:doctype name="schema@http://www.w3.org/2001/XMLSchema" count="123"&gt;
    &lt;doc href="file:///C:/projects/xsd/niem-2.1/ansi-nist/2.0/ansi-nist.xsd"/&gt;
    &lt;doc href="file:///C:/projects/xsd/niem-2.1/ansi_d20/2.0/ansi_d20.xsd"/&gt;
    &lt;doc href="file:///C:/projects/xsd/niem-2.1/apco/2.1/apco.xsd"/&gt;
    ...
  &lt;/z:doctype&gt;</textual></programlisting><para class="po-block e569 e569"><textual class="po-textual">We just used a directory filter descriptor as input to an operation. One may also
                first use it to create a dcat, and later use this dcat in order to supply an
                operation with all documents which the dcat references. To create a dcat, we call
                the built-in </textual><code class="po-atom e570 e570"><textual class="po-textual">dcat</textual></code><textual class="po-textual"> operation, supplying the directory filter descriptor
                as value of parameter </textual><code class="po-atom e571 e571"><textual class="po-textual">dfd</textual></code><textual class="po-textual">:</textual></para><programlisting class="po-block e572 e572" xml:space="preserve"><textual class="po-textual">
basex -b "request=dcat?dfd=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq

==&gt;
&lt;dcat dirs="^/projects/xsd/niem-2.1" files="" subDirs="" countFiles="123" t="2014-04-18T12:57:44+02:00" 
xml:base="file:///C:/projects/xclear/"&gt;
  &lt;doc href="file:/projects/xsd/niem-2.1/ansi-nist/2.0/ansi-nist.xsd"/&gt;
  &lt;doc href="file:/projects/xsd/niem-2.1/ansi_d20/2.0/ansi_d20.xsd"/&gt;
  &lt;doc href="file:/projects/xsd/niem-2.1/apco/2.1/apco.xsd"/&gt;
   ...
&lt;/dcat&gt;</textual></programlisting><para class="po-block e573 e573"><textual class="po-textual">If we store the output in a file (say,
                    </textual><code class="po-atom e574 e574"><textual class="po-textual">/projects/dcats/dcat-niem-2.1.xml</textual></code><textual class="po-textual">), we can then supply the file
                name to any parameter of type </textual><code class="po-atom e575 e575"><textual class="po-textual">docCAT</textual></code><textual class="po-textual">, effectively passing to the tool
                all documents referenced by the catalog. For example, the following call of
                    </textual><code class="po-atom e576 e576"><textual class="po-textual">doctypes</textual></code><textual class="po-textual"> yields the same result as the first one:</textual></para><programlisting class="po-block e577 e577" xml:space="preserve"><textual class="po-textual">basex -b "request=doctypes?dcat=^/projects/dcats/dcat-niem-2.1.xml" /projects/xclear/xclear.xq</textual></programlisting><para class="po-block e578 e578"><textual class="po-textual"> By now we have some feeling how to </textual><emphasis class="po-inline e579 e579" role="ital"><textual class="po-textual">use</textual></emphasis><textual class="po-textual"> a topic
                tool, namely how to specify aggregate input in alternative ways. We are ready to
                fill our tool with new functionality. </textual></para></section><section class="po-hcontainer e580 e580"><title class="po-block e581 e581"><textual class="po-textual">Adding prototypes</textual></title><para class="po-block e582 e582"><textual class="po-textual">Our tool shall be helpful when we want to explore an XML document, or a set of
                documents. The first version shall have three operations: </textual><code class="po-atom e583 e583"><textual class="po-textual">names</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e584 e584"><textual class="po-textual">paths</textual></code><textual class="po-textual"> and </textual><code class="po-atom e585 e585"><textual class="po-textual">values</textual></code><textual class="po-textual">. We decide to place their
                implementation in a single module, called </textual><code class="po-atom e586 e586"><textual class="po-textual">items</textual></code><textual class="po-textual">. A convenient way to
                create the module is to use the </textual><code class="po-atom e587 e587"><textual class="po-textual">add</textual></code><textual class="po-textual"> operation of
                </textual><code class="po-atom e588 e588"><textual class="po-textual">ttools</textual></code><textual class="po-textual">. We specify the topic tool (parameter </textual><code class="po-atom e589 e589"><textual class="po-textual">dir</textual></code><textual class="po-textual">), 
                the module name (parameter </textual><code class="po-atom e590 e590"><textual class="po-textual">mod</textual></code><textual class="po-textual">) and the
                operations (parameter </textual><code class="po-atom e591 e591"><textual class="po-textual">ops</textual></code><textual class="po-textual">): </textual></para><programlisting class="po-block e592 e592" xml:space="preserve"><textual class="po-textual">
basex -b "request=add?dir=/projects/xclear, mod=items, ops=names paths values" /projects/ttools/ttools.xq

==&gt;
===============================================================
XQuery module created: items.mod.xq
Operations:            names paths values

Directory:             /projects/xclear
Topic tool:            xclear
           
The new operations are available. Example:

   basex -b "request=names?doc=doc1.xml doc2.xml doc3.xml" /projects/xclear/xclear.xq
   
To implement them, edit these functions: names paths values    
===============================================================</textual></programlisting><para class="po-block e593 e593"><textual class="po-textual"> We check that new operations have appeared in the
                tool interface: </textual></para><programlisting class="po-block e594 e594" xml:space="preserve"><textual class="po-textual">basex -b "request=?" /projects/xclear/xclear.xq

==&gt;
TOOL: xclear

OPERATIONS   PARAMS
====================================================
_help        default, mode, ops?, type
dcat         dfd+
docs         dcat*, doc*, docs*
doctypes     attNames, dcat*, doc*, docs*, elemNames
names        dcat*, doc*, docs*
paths        dcat*, doc*, docs*
values       dcat*, doc*, docs*
====================================================</textual></programlisting><para class="po-block e595 e595"><textual class="po-textual">Indeed, the tool now has three new operations - </textual><code class="po-atom e596 e596"><textual class="po-textual">names</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e597 e597"><textual class="po-textual">paths</textual></code><textual class="po-textual"> and </textual><code class="po-atom e598 e598"><textual class="po-textual">values</textual></code><textual class="po-textual">. Their parameter sets are just a
                first proposal which we will extend or change. Now we inspect the generated module
                    </textual><code class="po-atom e599 e599"><textual class="po-textual">items.mod.xq</textual></code><textual class="po-textual">. A complete listing can be found in the appendix </textual><xref class="po-milestone e600 e600" linkend="items-module-initial"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Here we look at selected parts. The text
                begins with this:</textual></para><programlisting class="po-block e601 e601" xml:space="preserve"><textual class="po-textual">
(:
 : -------------------------------------------------------------------------
 :
 : items.mod.xq - Document me!
 :
 : -------------------------------------------------------------------------
 :)
 
(:~@interface
&lt;interface&gt;
   &lt;operations&gt;
      &lt;operation name="names" type="node()" func="names"&gt;     
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt; 
      &lt;operation name="paths" type="node()" func="paths"&gt;     
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt; 
      &lt;operation name="values" type="node()" func="values"&gt;     
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt;
    &lt;/operations&gt;
&lt;/interface&gt;    
:)  

module namespace f="http://www.ttools.org/xclear/xquery-functions";
...</textual></programlisting><para class="po-block e602 e602"><textual class="po-textual">The </textual><code class="po-atom e603 e603"><textual class="po-textual">build</textual></code><textual class="po-textual"> operation of </textual><code class="po-atom e604 e604"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> searches all library
                modules in the tool directory for text enclosed between </textual><code class="po-atom e605 e605"><textual class="po-textual">(:~@interface</textual></code><textual class="po-textual">
                and the closing </textual><code class="po-atom e606 e606"><textual class="po-textual">:)</textual></code><textual class="po-textual">. This text is interpreted as XML annotation
                declaring operations which the containing library module contributes to the topic
                tool. Each operation is defined in terms of a name, a function implementing it
                (@func, defaulting to the operation name), a return type (@type, defaulting to
                    </textual><code class="po-atom e607 e607"><textual class="po-textual">node()</textual></code><textual class="po-textual">), parameters (&lt;param&gt;) and optional parameter groups
                (&lt;pgroup&gt;). Parameter groups can be used for expressing cardinality constraints
                referring to a group of parameters, rather than to a single parameter - for example
                "at least one (at most one / exactly one) of these parameters ( ... ) must be
                specified". </textual></para><para class="po-block e608 e608"><textual class="po-textual">Each parameter is defined in terms of a name (@name), a type (@type), (optionally)
                facets (@fct_xyz) and (optionally) membership in a parameter group (@pgroup). Facets
                constrain valid parameter values beyond the constraints implied by the type. The
                type consists of an item type, optionally followed by a cardinality constraint. The
                parameters as they were generated are of course only meant as a starting point, to
                be extended and/or changed. We note that the generated module conforms to the
                recommended practise to support three alternative ways of specifying input documents. 
                It uses three parameters of types </textual><code class="po-atom e609 e609"><textual class="po-textual">docURI</textual></code><textual class="po-textual">, </textual><code class="po-atom e610 e610"><textual class="po-textual">docDFD</textual></code><textual class="po-textual"> and
                </textual><code class="po-atom e611 e611"><textual class="po-textual">docCAT</textual></code><textual class="po-textual"> and joins them into a parameter group, constraining the user
                to provide at least one of these parameters. </textual></para><para class="po-block e612 e612"><textual class="po-textual">Now we inspect the generated functions implementing the operations. For
                example:</textual></para><programlisting class="po-block e613 e613" xml:space="preserve"><textual class="po-textual">
(:~
 : Document me!
 :
 : @param request the operation request
 : @return a report describing ...
 :) 
declare function f:names($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')    
    return
        &lt;z:names countDocs="{count($docs)}"&gt;{
           ()
        }&lt;/z:names&gt;
};</textual></programlisting><para class="po-block e614 e614"><textual class="po-textual">So the initial version just creates an element echoing the operation name and
                fills it with a @countDocs attribute displaying the number of input documents. Let’s
                try, using a directory </textual><code class="po-atom e615 e615"><textual class="po-textual">/projects/xsd/niem-2.1</textual></code><textual class="po-textual"> as input:</textual></para><programlisting class="po-block e616 e616" xml:space="preserve"><textual class="po-textual">
basex -b "request=names?docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq

==&gt;
&lt;z:names xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"/&gt;</textual></programlisting></section><section class="po-hcontainer e617 e617"><title class="po-block e618 e618"><textual class="po-textual">First operation, first implementation</textual></title><para class="po-block e619 e619"><textual class="po-textual">Now we know that we are “connected” – the tool can be supplied with input documents - and we
                are ready to add code. Here comes a first version of the </textual><code class="po-atom e620 e620"><textual class="po-textual">names</textual></code><textual class="po-textual">
                operation: </textual></para><programlisting class="po-block e621 e621" xml:space="preserve"><textual class="po-textual">
declare function f:names($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat') 
    let $atts := 
        for $n in distinct-values($docs//@*/local-name(.))
        order by lower-case($n) return &lt;z:a n="{$n}"/&gt;
    let $elems := 
        for $n in distinct-values($docs//*/local-name(.))
        order by lower-case($n) return &lt;z:e n="{$n}"/&gt;
    return
        &lt;z:names countDocs="{count($docs)}"&gt;{
           &lt;z:atts count="{count($atts)}"&gt;{$atts}&lt;/z:atts&gt;,
           &lt;z:elems count="{count($elems)}"&gt;{$elems}&lt;/z:elems&gt;           
        }&lt;/z:names&gt;
};</textual></programlisting><para class="po-block e622 e622"><textual class="po-textual">We repeat our call of the </textual><code class="po-atom e623 e623"><textual class="po-textual">names</textual></code><textual class="po-textual">
                operation:</textual></para><programlisting class="po-block e624 e624" xml:space="preserve"><textual class="po-textual">basex -b "request=names?docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq

==&gt;
&lt;z:names xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
  &lt;z:atts count="29"&gt;
    &lt;z:a n="abstract"/&gt;
    &lt;z:a n="attributeFormDefault"/&gt;
    &lt;z:a n="base"/&gt;
    ...
  &lt;/z:atts&gt;
  &lt;z:elems count="40"&gt;
    &lt;z:e n="annotation"/&gt;
    &lt;z:e n="any"/&gt;
    &lt;z:e n="anyAttribute"/&gt;
    ...
  &lt;/z:elems&gt;
&lt;/z:names&gt;</textual></programlisting></section><section class="po-hcontainer e625 e625"><title class="po-block e626 e626"><textual class="po-textual">First refinement - adding a parameter</textual></title><para class="po-block e627 e627"><textual class="po-textual">Now let us think about refinement. We want to give the user the possibility to
                determine the scope – only elements, only attributes, or both. To achieve this, we
                add to the annotation of operation </textual><code class="po-atom e628 e628"><textual class="po-textual">names</textual></code><textual class="po-textual"> a new parameter: </textual></para><programlisting class="po-block e629 e629" xml:space="preserve"><textual class="po-textual">
&lt;param name="scope" type="xs:string" fct_values="att, elem, all" default="all"/&gt;</textual></programlisting><para class="po-block e630 e630"><textual class="po-textual"> Note the default value and the </textual><code class="po-atom e631 e631"><textual class="po-textual">values</textual></code><textual class="po-textual"> facet, constraining valid
                parameter values to the strings “att”, “elem” and “all”. The function is easy to
                adapt: (a) add a line for reading the parameter value and (b) wrap the output of
                attribute and element names in </textual><code class="po-atom e632 e632"><textual class="po-textual">if</textual></code><textual class="po-textual"> expressions dependent on the
                parameter value. Here comes the new version:</textual></para><programlisting class="po-block e633 e633" xml:space="preserve"><textual class="po-textual">
declare function f:names($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')
    let $scope as xs:string := tt:getParams($request, 'scope')      (: READ PARAM :)
    let $atts :=    
        for $n in distinct-values($docs//@*/local-name(.))
        order by lower-case($n) return &lt;z:a n="{$n}"/&gt;
    let $elems := 
        for $n in distinct-values($docs//*/local-name(.))
        order by lower-case($n) return &lt;z:e n="{$n}"/&gt;
    return
        &lt;z:names countDocs="{count($docs)}"&gt;{
            if ($scope eq 'elem') then () else                      (: DEPENDENT ON PARAM :)
                &lt;z:atts count="{count($atts)}"&gt;{$atts}&lt;/z:atts&gt;,
            if ($scope eq 'att') then () else                       (: DEPENDENT ON PARAM :)
                &lt;z:elems count="{count($elems)}"&gt;{$elems}&lt;/z:elems&gt;           
        }&lt;/z:names&gt;
};</textual></programlisting><para class="po-block e634 e634"><textual class="po-textual">Note the type of the parameter value in this line:</textual></para><programlisting class="po-block e635 e635" xml:space="preserve"><textual class="po-textual">let $scope as xs:string := tt:getParams($request, 'scope')</textual></programlisting><para class="po-block e636 e636"><textual class="po-textual">We can confidently use the type without “?”, as the annotation implies a
                cardinality of exactly one item, and the framework will never call the function
                unless the user input is valid. We re-build and call </textual><code class="po-atom e637 e637"><textual class="po-textual">_help</textual></code><textual class="po-textual"> in order to
                verify that our annotations have been compiled into code:</textual></para><programlisting class="po-block e638 e638" xml:space="preserve"><textual class="po-textual">
basex -b "request=build?dir=/projects/xclear" /projects/ttools/ttools.xq
basex -b "request=?type, default, ops=names" /projects/xclear/xclear.xq

==&gt;
TOOL: xclear

OPERATIONS   PARAMS
============================================================================
names        dcat................ : docCAT* (sep=WS)
             doc................. : docURI* (sep=WS)
             docs................ : docDFD* (sep=;)
             scope=all........... : xs:string; facets: values=att, elem, all
               At least 1 of these parameters must be set: dcat, doc, docs
============================================================================</textual></programlisting><para class="po-block e639 e639"><textual class="po-textual">We check that validation proceeds as it should, supplying an invalid
                    </textual><code class="po-atom e640 e640"><textual class="po-textual">scope</textual></code><textual class="po-textual"> value:</textual></para><programlisting class="po-block e641 e641" xml:space="preserve"><textual class="po-textual">
basex -b "request=names?docs=^/projects/xsd/niem-2.1/*,scope=attributes" /projects/xclear/xclear.xq

==&gt;
Invalid call
============

INVALID_PARAMETER_FACET       Parameter 'scope': item value (attributes) not among the valid item 
                                 values (att, elem, all).

-------------------------------------</textual></programlisting><para class="po-block e642 e642"><textual class="po-textual">Calling the tool correctly, we get the correct result:</textual></para><programlisting class="po-block e643 e643" xml:space="preserve"><textual class="po-textual">
basex -b "request=names?docs=^/projects/xsd/niem-2.1,scope=att" /projects/xclear/xclear.xq

==&gt;
&lt;z:names xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
  &lt;z:atts count="29"&gt;
    &lt;z:a n="abstract"/&gt;
    &lt;z:a n="attributeFormDefault"/&gt;
    &lt;z:a n="base"/&gt;
    ...
    &lt;z:a n="use"/&gt;
    &lt;z:a n="value"/&gt;
    &lt;z:a n="version"/&gt;
  &lt;/z:atts&gt;
&lt;/z:names&gt;</textual></programlisting></section><section class="po-hcontainer e644 e644"><title class="po-block e645 e645"><textual class="po-textual">Adding a name filter</textual></title><para class="po-block e646 e646"><textual class="po-textual">We add one more refinement: the user may optionally specify a name filter, so that
                only items with a matching name are returned. It does not take more than a minute to
                achieve this. First we add an optional parameter </textual><code class="po-atom e647 e647"><textual class="po-textual">names</textual></code><textual class="po-textual"> to the
                annotation, using the object parameter type </textual><code class="po-atom e648 e648"><textual class="po-textual">nameFilter</textual></code><textual class="po-textual">:</textual></para><programlisting class="po-block e649 e649" xml:space="preserve"><textual class="po-textual">   &lt;param name="names" type="nameFilter?"/&gt;</textual></programlisting><para class="po-block e650 e650"><textual class="po-textual">The adaptation of the function is minimalistic. We read the parameter
                value:</textual></para><programlisting class="po-block e651 e651" xml:space="preserve"><textual class="po-textual">   let $filter as element(nameFilter)? := tt:getParams($request, 'names')</textual></programlisting><para class="po-block e652 e652"><textual class="po-textual">and add a couple of predicates to the path expressions returning attributes and
                elements, respectively:</textual></para><programlisting class="po-block e653 e653" xml:space="preserve"><textual class="po-textual">
    let $atts :=    
        for $n in distinct-values($docs//@*
            [not($filter) or tt:matchesNameFilter(local-name(.), $filter)]/local-name(.))    (: FILTER ! :)
        order by lower-case($n) return &lt;z:a n="{$n}"/&gt;    
    let $elems := 
        for $n in distinct-values($docs//*
            [not($filter) or tt:matchesNameFilter(local-name(.), $filter)]/local-name(.))    (: FILTER ! :)
        order by lower-case($n) return &lt;z:a n="{$n}"/&gt;</textual></programlisting><para class="po-block e654 e654"><textual class="po-textual">Done! After a re-build, we can retrieve name-filtered item names:</textual></para><programlisting class="po-block e655 e655" xml:space="preserve"><textual class="po-textual">
basex -b "request=build?dir=/projects/xclear" /projects/ttools/ttools.xq
basex -b "request=names?docs=^/projects/xsd/niem-2.1/*,scope=att, names=*min*" /projects/xclear/xclear.xq

==&gt;
&lt;z:names xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
  &lt;z:atts count="1"&gt;
    &lt;z:a n="minOccurs"/&gt;
  &lt;/z:atts&gt;
&lt;/z:names&gt;</textual></programlisting></section><section class="po-hcontainer e656 e656"><title class="po-block e657 e657"><textual class="po-textual">Second operation, first implementation</textual></title><para class="po-block e658 e658"><textual class="po-textual">Now we tackle the second operation, returning data paths. First we write a little
                function which returns for any XML attribute or element its data path:</textual></para><programlisting class="po-block e659 e659" xml:space="preserve"><textual class="po-textual">
declare function f:path($n as node())
        as xs:string {
    string-join(
        $n/ancestor-or-self::node()/concat(self::attribute()/'@', local-name(.)),    
        '/')        
};</textual></programlisting><para class="po-block e660 e660"><textual class="po-textual">With this function in place, the operation is implemented very quickly:</textual></para><programlisting class="po-block e661 e661" xml:space="preserve"><textual class="po-textual">
declare function f:paths($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')   
    let $paths := 
        for $p in distinct-values($docs//(*, @*)/f:path(.))
        order by lower-case($p)
        return &lt;z:path p="{$p}"/&gt;
    return
        &lt;z:paths countDocs="{count($docs)}" countPaths="{count($paths)}"&gt;{
           $paths
        }&lt;/z:paths&gt;
};</textual></programlisting><para class="po-block e662 e662"><textual class="po-textual">After a re-build, we can retrieve a path list:</textual></para><programlisting class="po-block e663 e663" xml:space="preserve"><textual class="po-textual">
basex -b "request=build?dir=/projects/xclear" /projects/ttools/ttools.xq
basex -b "request=paths?docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq

==&gt;
&lt;z:paths xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123" countPaths="653"&gt;
  &lt;z:path p="/schema"/&gt;
  &lt;z:path p="/schema/@attributeFormDefault"/&gt;
  &lt;z:path p="/schema/@elementFormDefault"/&gt;
   ...
&lt;/z:paths&gt;</textual></programlisting></section><section class="po-hcontainer e664 e664"><title class="po-block e665 e665"><textual class="po-textual">Adding a path filter</textual></title><para class="po-block e666 e666"><textual class="po-textual">Now we refine the operation by adding a path filter parameter. This enables the
                user to search for paths with a particular pattern, e.g. ending with a particular
                element or attribute, or all children or descendants of elements with a particular
                name. This is easily done. We extend the operation annotation by an optional filter
                parameter, using the object parameter type </textual><code class="po-atom e667 e667"><textual class="po-textual">pathFilter</textual></code><textual class="po-textual">:</textual></para><programlisting class="po-block e668 e668" xml:space="preserve"><textual class="po-textual">
   &lt;param name="paths" type="pathFilter?"/&gt;</textual></programlisting><para class="po-block e669 e669"><textual class="po-textual">And we change the function code as follows. We read the parameter value:</textual></para><programlisting class="po-block e670 e670" xml:space="preserve"><textual class="po-textual">
   let $filter as element(pathFilter)? := tt:getParams($request, 'paths')</textual></programlisting><para class="po-block e671 e671"><textual class="po-textual">and we introduce a predicate which filters the paths, rejecting any candidates not
                matching the path filter, if a path filter has been supplied:</textual></para><programlisting class="po-block e672 e672" xml:space="preserve"><textual class="po-textual">
   distinct-values($docs//(*, @*)/f:path(.))[not($filter) or tt:matchesPathFilter(., $filter)]</textual></programlisting><para class="po-block e673 e673"><textual class="po-textual"> After a re-build, we can, for example, learn all data paths pointing to elements
                and attributes under </textual><code class="po-atom e674 e674"><textual class="po-textual">xs:appInfo</textual></code><textual class="po-textual"> elements:</textual></para><programlisting class="po-block e675 e675" xml:space="preserve"><textual class="po-textual">
basex -b "request=build?dir=/projects/xclear" /projects/ttools/ttools.xq
basex -b "request=paths?docs=^/projects/xsd/niem-2.1/*, paths=appinfo//*" /projects/xclear/xclear.xq &gt; paths.xml

==&gt;
&lt;z:paths xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123" countPaths="27"&gt;
  &lt;z:path p="/schema/annotation/appinfo/@source"/&gt;
  &lt;z:path p="/schema/annotation/appinfo/ConformantIndicator"/&gt;
  &lt;z:path p="/schema/annotation/appinfo/resource"/&gt;
  ... 
&lt;/z:paths&gt;</textual></programlisting></section><section class="po-hcontainer e676 e676"><title class="po-block e677 e677"><textual class="po-textual">Third operation, first implementation</textual></title><para class="po-block e678 e678"><textual class="po-textual">This operation reports data values found in attributes and elements. For each
                attribute and element name, a sample of values is displayed. In the first version,
                the sample size is set to the value 10. The complete code looks like this:</textual></para><programlisting class="po-block e679 e679" xml:space="preserve"><textual class="po-textual">
declare function f:values($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')   
    
    let $limit := 10
    let $atts := $docs//@*
    let $elems := $docs//*[not(*)][text()]
    let $attNames := distinct-values($atts/local-name(.))    
    let $elemNames := distinct-values($elems/local-name(.))
    let $attValues :=
        for $name in $attNames
        let $values := distinct-values($atts[local-name(.) eq $name])
        let $show := for $v in $values[position() le $limit] 
                     order by lower-case($v) return &lt;z:v v="{$v}"/&gt;
        order by lower-case($name) return
            &lt;z:a n="{$name}" count="{concat(count($show), '/', count($values))}"&gt;{$show}&lt;/z:a&gt;            
    let $elemValues :=
        for $name in $elemNames
        let $values := distinct-values($elems[local-name(.) eq $name])
        let $show := for $v in $values[position() le $limit] 
                     order by lower-case($v) return &lt;z:v v="{$v}"/&gt;
        order by lower-case($name) return
            &lt;z:e n="{$name}" count="{concat(count($show), '/', count($values))}"&gt;{$show}&lt;/z:e&gt;            
    return
        &lt;z:values countDocs="{count($docs)}"&gt;{
            &lt;z:atts countAtts="{count($atts)}"&gt;{$attValues}&lt;/z:atts&gt;,
            &lt;z:elems countAtts="{count($elems)}"&gt;{$elemValues}&lt;/z:elems&gt;            
        }&lt;/z:values&gt;
};</textual></programlisting><para class="po-block e680 e680"><textual class="po-textual">After a re-build we can request reports which yield for each attribute and element
                name a sample of values found in items with that name:</textual></para><programlisting class="po-block e681 e681" xml:space="preserve"><textual class="po-textual">
basex -b "request=build?name=xclear, dir=/projects/xclear" /projects/ttools/ttools.xq
basex -b "request=values?docs=^/projects/xsd/niem-2.1" /projects/xclear/xclear.xq

==&gt;
&lt;z:values xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
  &lt;z:atts countAtts="102132"&gt;
    &lt;z:a n="abstract" count="1/1"&gt;
      &lt;z:v v="true"/&gt;
    &lt;/z:a&gt;
    &lt;z:a n="attributeFormDefault" count="2/2"&gt;
      &lt;z:v v="qualified"/&gt;
      &lt;z:v v="unqualified"/&gt;      
    &lt;/z:a&gt;
    &lt;z:a n="base" count="10/816"&gt;
      &lt;z:v v="ansi-nist:ALSCodeSimpleType"/&gt;
      &lt;z:v v="ansi-nist:BTYCodeSimpleType"/&gt;
      &lt;z:v v="ansi-nist:COLCodeSimpleType"/&gt;
      &lt;z:v v="ansi-nist:CSICodeSimpleType"/&gt;
      &lt;z:v v="ansi-nist:CSNCodeSimpleType"/&gt;
      &lt;z:v v="ansi-nist:CSPCodeSimpleType"/&gt;
      &lt;z:v v="ansi-nist:NISTImageType"/&gt;
      &lt;z:v v="s:AugmentationType"/&gt;
      &lt;z:v v="s:ComplexObjectType"/&gt;
      &lt;z:v v="xsd:token"/&gt;
    &lt;/z:a&gt;    
    ...
&lt;/z:values&gt;</textual></programlisting></section><section class="po-hcontainer e682 e682"><title class="po-block e683 e683"><textual class="po-textual">Adding a name filter map</textual></title><para class="po-block e684 e684"><textual class="po-textual">Now we want to make the size of value samples dependent on the item name, so that
                the user may instruct the tool, for example, to return no values at all for some
                names, and different numbers for different name patterns. To achieve this, we extend
                the operation annotation, adding a parameter of type
                    </textual><code class="po-atom e685 e685"><textual class="po-textual">nameFilterMap(xs:integer)</textual></code><textual class="po-textual">:</textual></para><programlisting class="po-block e686 e686" xml:space="preserve"><textual class="po-textual">
   &lt;param name="nvalues" type="nameFilterMap(xs:integer)?"/&gt;</textual></programlisting><para class="po-block e687 e687"><textual class="po-textual">Then we modify the function code as follows. We read the parameter value:</textual></para><programlisting class="po-block e688 e688" xml:space="preserve"><textual class="po-textual">
   let $fmap as element(nameFilterMap)? := tt:getParams($request, 'nvalues')</textual></programlisting><para class="po-block e689 e689"><textual class="po-textual">and set the number of terms dependently on the item name:</textual></para><programlisting class="po-block e690 e690" xml:space="preserve"><textual class="po-textual">
   let $limit := tt:nameFilterMapValue($name, $fmap, $defaultLimit)</textual></programlisting><para class="po-block e691 e691"><textual class="po-textual">That was it. The following call, for example:</textual></para><programlisting class="po-block e692 e692" xml:space="preserve"><textual class="po-textual">
basex -b "request=values?docs=^/projects/xsd/niem-2.1/*, nvalues=0 % 5:docum* block % 10:target* % 20:use" 
/projects/xclear/xclear.xq</textual></programlisting><para class="po-block e693 e693"><textual class="po-textual">sets the value sample sizes to the following values:</textual></para><itemizedlist class="po-table e694 e694"><listitem class="po-container e695 e695"><para class="po-block e696 e696"><textual class="po-textual">0 : by default</textual></para></listitem><listitem class="po-container e697 e697"><para class="po-block e698 e698"><textual class="po-textual">5 : if the name starts with “docum” or equals ”block”</textual></para></listitem><listitem class="po-container e699 e699"><para class="po-block e700 e700"><textual class="po-textual">10: if the name starts with “target”</textual></para></listitem><listitem class="po-container e701 e701"><para class="po-block e702 e702"><textual class="po-textual">20: if the name equals “use”</textual></para></listitem></itemizedlist><para class="po-block e703 e703"><textual class="po-textual">The result looks accordingly:</textual></para><programlisting class="po-block e704 e704" xml:space="preserve"><textual class="po-textual">
&lt;z:values xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
  &lt;z:atts countAtts="102132"&gt;
    &lt;z:a n="abstract" count="0/1"/&gt;
    &lt;z:a n="attributeFormDefault" count="0/2"/&gt;
    &lt;z:a n="base" count="0/816"/&gt;
    &lt;z:a n="block" count="2/2"&gt;
      &lt;z:v v="extension"/&gt;
      &lt;z:v v="restriction"/&gt;
    &lt;/z:a&gt;
    &lt;z:a n="default" count="0/12"/&gt;
    ...
&lt;/z:values&gt;</textual></programlisting><para class="po-block e705 e705"><textual class="po-textual">See appendix for the full source code of this operation, as well as module
                    </textual><code class="po-atom e706 e706"><textual class="po-textual">items.mod.xq</textual></code><textual class="po-textual"> as a whole, both its initial state as generated by
                    </textual><code class="po-atom e707 e707"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> (</textual><xref class="po-milestone e708 e708" linkend="items-module-initial"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), and the final
                state after our coding work (</textual><xref class="po-milestone e709 e709" linkend="items-module-edited"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para></section></section><section class="po-hcontainer e710 e710"><title class="po-block e711 e711"><textual class="po-textual">Discussion</textual></title><para class="po-block e712 e712"><textual class="po-textual">The present work is closely related to RESTXQ ([</textual><xref class="po-milestone e713 e713" linkend="retter"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]), and it is
            revealing to study similarities and differences. Both approaches reduce the writing of
            XQuery applications to the writing of XQuery functions, and in both cases infrastructure
            takes the responsibility to call the appropriate function. In both cases, infrastructure
            not only calls the function, but supplies it with information input which represents the
            information supplied by the triggering event. The approaches are, of course, concerned
            with different types of events – an HTTP request in the case of RESTXQ, a command line
            call in the case of topic tools. But both models are essentially models how to map an
            external event and its information content to (a) the selection of a function to be
            called, (b) input information accessible to the function called. </textual></para><para class="po-block e714 e714"><textual class="po-textual">Many differences between RESTXQ and topic tools are consequences of the different
            types of events with which they are concerned. For example, RESTXQ deals with HTTP
            header fields, path segments and URI parameters, as these are natural parts of an HTTP
            request. Topic tools, on the other hand, essentially deals with a </textual><emphasis class="po-inline e715 e715" role="ital"><textual class="po-textual">single string</textual></emphasis><textual class="po-textual"> - user input without any pre-given structure, so that
            topic tools has the freedom – and responsibility – to define a structural model into
            which the string is translated and which transforms the string into structured
            information. </textual></para><para class="po-block e716 e716"><textual class="po-textual">But there is one meaningful difference between RESTXQ and topic tools, and this is the
                </textual><emphasis class="po-inline e717 e717" role="ital"><textual class="po-textual">model of function input information</textual></emphasis><textual class="po-textual">. RESTXQ makes
            an apparently obvious choice: function input is defined by the </textual><emphasis class="po-inline e718 e718" role="ital"><textual class="po-textual">function signature</textual></emphasis><textual class="po-textual">. Each logical input parameter is a function argument,
            and the model of function input is a sequence of parameters defined in terms of a name
            and an XQuery sequence type. </textual></para><para class="po-block e719 e719"><textual class="po-textual">Topic tools chooses a different input model: function input is an instance of the
                </textual><emphasis class="po-inline e720 e720" role="ital"><textual class="po-textual">operation interface</textual></emphasis><textual class="po-textual"> as defined by the tool scheme,
            instantiated as a message element. The logical input parameters are hidden
            behind message accessor functions, and the model of input is a set of parameters
            defined in terms of the tool scheme meta model. </textual></para><para class="po-block e721 e721"><textual class="po-textual">This difference –</textual></para><itemizedlist class="po-table e722 e722"><listitem class="po-container e723 e723"><para class="po-block e724 e724"><textual class="po-textual">“input model = function signature / input parameter = function argument” vs.</textual></para></listitem><listitem class="po-container e725 e725"><para class="po-block e726 e726"><textual class="po-textual">“input model = operation interface / input parameter - supplied by message accessor” </textual></para></listitem></itemizedlist><para class="po-block e727 e727"><textual class="po-textual">has three significant consequences. The latter approach offers a </textual><emphasis class="po-inline e728 e728" role="ital"><textual class="po-textual">richer parameter model</textual></emphasis><textual class="po-textual">, it implies a </textual><emphasis class="po-inline e729 e729" role="ital"><textual class="po-textual">stable
                function signature</textual></emphasis><textual class="po-textual"> and it enables a </textual><emphasis class="po-inline e730 e730" role="ital"><textual class="po-textual">functional
                abstraction</textual></emphasis><textual class="po-textual"> of parameter values. We inspect these aspects in turn.</textual></para><para class="po-block e731 e731"><textual class="po-textual">The operation interface consists of parameters defined in terms of a name, a sequence
            type and further properties implied by the tool scheme meta model. These further
            parameters are above all facets. Facets extend the built-in item types in the same way
            as user-defined XSD types extend the built-in simple types. It is a key feature
            of topic tools to enable fine-grained validation controlled by facets independently of
            imported schemas. More generally speaking, uncoupling the model of an operation
            parameter from the concept of a function parameter thus enables a </textual><emphasis class="po-inline e732 e732" role="ital"><textual class="po-textual">richer parameter model</textual></emphasis><textual class="po-textual">, partially implemented by code (facet
            validation), rather than being restricted to native language support.</textual></para><para class="po-block e733 e733"><textual class="po-textual"> The operation providing functions of topic tools have a uniform signature, accepting
            a single input parameter which is a message element. More important than the uniformity
            across different functions is the uniformity of a given function over time: topic tools
            imply a </textual><emphasis class="po-inline e734 e734" role="ital"><textual class="po-textual">stable function signature</textual></emphasis><textual class="po-textual">. This facilitates
            agile development and the stepwise addition of features. Refinement of functionality
            typically entails the addition of further control parameters. If each input parameter is
            represented by a function argument, agile development means that the function signatures
            change often. Apart from that, operations offering rich functionality tend to have an
            ever growing list of parameters. If this implies an ever growing function signature,
            things become unwieldy. Who wants to handle functions with 10 or even 20 parameters? </textual></para><para class="po-block e735 e735"><textual class="po-textual">Obtaining input parameters by calling a message function means a </textual><emphasis class="po-inline e736 e736" role="ital"><textual class="po-textual">functional abstraction</textual></emphasis><textual class="po-textual">. This can be used in various ways. For example,
            it becomes possible to define a parameter as a huge document set without loading the
            complete set into memory: this can be avoided by using an accessor function which
            supports the retrieval of a subset. More generally speaking, the message interface
            enables lazy evaluation and modification of access details at access time.</textual></para><para class="po-block e737 e737"><textual class="po-textual">On first sight, the use of object parameter types also seems to be a case of
            functional abstraction. But in fact it is not, as RESTXQ might, in principle, define the
            same mappings from strings to objects (elements) and support the use of such objects in
            the function signatures. The concept of object parameter types, however, creates a
            different aspect to be considered when evaluating RESTXQ and topic tools. The definition
            of object parameter types introduces a mapping of lexical entities to the logical
            parameters of operation input. So in fact we are dealing with </textual><emphasis class="po-inline e738 e738" role="ital"><textual class="po-textual">two</textual></emphasis><textual class="po-textual"> mappings: (a) from lexical input to logical input (aka operation
            parameters), and (b) from logical input to its representation in XQuery. Speaking about
            function arguments versus message object we dwelt on the differences concerning mapping
            (b). Remembering object parameter types, we take notice that topic tools puts also
            emphasis on mappings (a). It expresses them by the definition of object parameter types. </textual></para><para class="po-block e739 e739"><textual class="po-textual"> The tool scheme, however, is not concerned with these mappings. The mappings deal
            with lexical input, but the tool scheme is composed of logical parameters. For example,
            the tool scheme states that a certain parameter is a name filter; the tool scheme does
            not prescribe that it is constructed from a string with a certain syntax, this is only
            implied by the used typed, </textual><code class="po-atom e740 e740"><textual class="po-textual">nameFilter</textual></code><textual class="po-textual">. We arrive at a clear distinction
            between the tool scheme and the mappings used to supply it with actual values. The
            distinction opens an interesting vista: although this paper defined and viewed topic
            tools as a particular kind of command line tools, the core of the concept is not bound
            to the notion of a command line - it is bound to the logical model of an operation.
            There is an input source (for example – a command line) which is mapped to an instance
            of an operation interface. The type of input source may be exchanged for a different
            type, if we have access to an alternative mapping, translating this other type into the
            tool scheme. As the original mapping – as well as the hypothetical alternative mapping –
            is accomplished by infrastructure, the replacement would in no way affect the
            application code hand-written by the developer. For instance, the topic tools model
            might be employed as an alternative model for the development of RESTful web services.
            In order to accomplish this, it would suffice to add a sub model which maps HTTP
            requests to instances of an operation interface. This would be very easy, as the RESTXQ
            defined mappings could be reused, redirected from one target, function arguments, to
            another, logical operation parameters.</textual></para></section><appendix class="po-hcontainer e741 e741" xml:id="items-module-initial"><title class="po-block e742 e742"><textual class="po-textual">The </textual><code class="po-atom e743 e743"><textual class="po-textual">items</textual></code><textual class="po-textual"> module as generated by </textual><code class="po-atom e744 e744"><textual class="po-textual">ttools</textual></code></title><para class="po-block e745 e745"><textual class="po-textual">The following listing shows the </textual><code class="po-atom e746 e746"><textual class="po-textual">items</textual></code><textual class="po-textual"> module generated by
                </textual><code class="po-atom e747 e747"><textual class="po-textual">ttools</textual></code><textual class="po-textual"> in response to the following call:</textual></para><programlisting class="po-block e748 e748" xml:space="preserve"><textual class="po-textual">
basex -b "request=add?dir=/projects/xclear, mod=items, ops=names paths values" /projects/ttools/ttools.xq</textual></programlisting><programlisting class="po-block e749 e749" xml:space="preserve"><textual class="po-textual">
(:
 : -------------------------------------------------------------------------
 :
 : items.mod.xq - Document me!
 :
 : -------------------------------------------------------------------------
 :)
 
(:~@interface
&lt;interface&gt;
   &lt;operations&gt;
      &lt;operation name="names" type="node()" func="names"&gt;     
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt; 
      &lt;operation name="paths" type="node()" func="paths"&gt;     
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt; 
      &lt;operation name="values" type="node()" func="values"&gt;     
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt;
    &lt;/operations&gt;
&lt;/interface&gt;    
:)  

module namespace f="http://www.ttools.org/xclear/xquery-functions";
import module namespace tt="http://www.ttools.org/xquery-functions" at 
    "_request.mod.xq",
    "_reportAssistent.mod.xq",
    "_nameFilter.mod.xq";
    
declare namespace z="http://www.ttools.org/xclear/structure";

(:~
 : Document me!
 :
 : @param request the operation request
 : @return a report describing ...
 :) 
declare function f:names($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')    
    return
        &lt;z:names countDocs="{count($docs)}"&gt;{
           ()
        }&lt;/z:names&gt;
};        
 
(:~
 : Document me!
 :
 : @param request the operation request
 : @return a report describing ...
 :) 
declare function f:paths($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')    
    return
        &lt;z:paths countDocs="{count($docs)}"&gt;{
           ()
        }&lt;/z:paths&gt;
};        
 
(:~
 : Document me!
 :
 : @param request the operation request
 : @return a report describing ...
 :) 
declare function f:values($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')    
    return
        &lt;z:values countDocs="{count($docs)}"&gt;{
           ()
        }&lt;/z:values&gt;
};</textual></programlisting></appendix><appendix class="po-hcontainer e750 e750" xml:id="items-module-edited"><title class="po-block e751 e751"><textual class="po-textual">The </textual><code class="po-atom e752 e752"><textual class="po-textual">items</textual></code><textual class="po-textual"> module after editing it in the tutorial</textual></title><para class="po-block e753 e753"><textual class="po-textual">The following listing shows the </textual><code class="po-atom e754 e754"><textual class="po-textual">items</textual></code><textual class="po-textual"> module as it looks after editing
            the generated prototype as guided by the tutorial. The listing is an example of a first
            version of a topic tool, as it can be developed within a couple of hours and yet be
            useful enough to be handed over to users.</textual></para><programlisting class="po-block e755 e755" xml:space="preserve"><textual class="po-textual">
(:
 : -------------------------------------------------------------------------
 :
 : items.mod.xq - a module for inspecting item names, paths and data values
 :
 : -------------------------------------------------------------------------
 :)
 
(:~@interface
&lt;interface&gt;
   &lt;operations&gt;   
      &lt;operation name="names" func="names" type="node()"&gt;  
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;         
         &lt;param name="scope" type="xs:string" fct_values="att, elem, all" default="all"/&gt;         
         &lt;param name="names" type="nameFilter?"/&gt;    
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt; 
      &lt;operation name="paths" func="paths" type="node()"&gt;     
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;         
         &lt;param name="paths" type="pathFilter?"/&gt;        
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt; 
      &lt;operation name="values" func="values" type="node()"&gt;     
         &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
         &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
         &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;         
         &lt;param name="nvalues" type="nameFilterMap(xs:integer)?"/&gt;
         &lt;pgroup name="input" minOccurs="1"/&gt;         
      &lt;/operation&gt;
    &lt;/operations&gt;
&lt;/interface&gt;    
:)  

module namespace f="http://www.ttools.org/xclear/xquery-functions";
import module namespace tt="http://www.ttools.org/xquery-functions" at 
    "_request.mod.xq",
    "_reportAssistent.mod.xq",
    "_nameFilter.mod.xq";
    
declare namespace z="http://www.ttools.org/xclear/structure";

(:~
 : Document me!
 :
 : @param request the operation request
 : @return a report describing ...
 :) 
declare function f:names($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')
    let $scope as xs:string := tt:getParams($request, 'scope')
    let $filter as element(nameFilter)? := tt:getParams($request, 'names')    
    
    let $atts :=    
        for $n in distinct-values($docs//@*
            [not($filter) or tt:matchesNameFilter(local-name(.), $filter)]/local-name(.))
        order by lower-case($n) return &lt;z:a n="{$n}"/&gt;
    let $elems := 
        for $n in distinct-values($docs//*
            [not($filter) or tt:matchesNameFilter(local-name(.), $filter)]/local-name(.))
        order by lower-case($n) return &lt;z:e n="{$n}"/&gt;
    let $infoAtts := $filter/@source/attribute nameFilter {.}
    return
        &lt;z:names countDocs="{count($docs)}"&gt;{
            $infoAtts,
            if ($scope eq 'elem') then () else
                &lt;z:atts count="{count($atts)}"&gt;{$atts}&lt;/z:atts&gt;,
            if ($scope eq 'att') then () else                
                &lt;z:elems count="{count($elems)}"&gt;{$elems}&lt;/z:elems&gt;           
        }&lt;/z:names&gt;
};        
 
(:~
 : Document me!
 :
 : @param request the operation request
 : @return a report describing ...
 :) 
declare function f:paths($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')
    let $filter as element(pathFilter)? := trace( tt:getParams($request, 'paths') , 'FILTER: ')
    let $paths := 
        for $p in distinct-values($docs//(*, @*)/f:path(.))[not($filter) or tt:matchesPathFilter(., $filter)]
        order by lower-case($p)
        return &lt;z:path p="{$p}"/&gt;
    let $infoAtts := $filter/@source/attribute pathFilter {.}        
    return
        &lt;z:paths countDocs="{count($docs)}" countPaths="{count($paths)}"&gt;{
           $infoAtts,
           $paths
        }&lt;/z:paths&gt;
};        
 
(:~
 : Document me!
 :
 : @param request the operation request
 : @return a report describing ...
 :) 
declare function f:values($request as element())
        as element() {
    let $docs := tt:getParams($request, 'doc docs dcat')   
    let $fmap as element(nameFilterMap)? := tt:getParams($request, 'nvalues')
    
    let $defaultLimit := 10
    let $atts := $docs//@*
    let $elems := $docs//*[not(*)][text()]
    let $attNames := distinct-values($atts/local-name(.))    
    let $elemNames := distinct-values($elems/local-name(.))
    let $attValues :=
        for $name in $attNames
        let $limit := tt:nameFilterMapValue($name, $fmap, $defaultLimit)
        let $values := distinct-values($atts[local-name(.) eq $name])
        let $show := for $v in $values[position() le $limit] 
                     order by lower-case($v) return &lt;z:v v="{$v}"/&gt;
        order by lower-case($name) return
            &lt;z:a n="{$name}" count="{concat(count($show), '/', count($values))}"&gt;{$show}&lt;/z:a&gt;            
    let $elemValues :=
        for $name in $elemNames
        let $limit := tt:nameFilterMapValue($name, $fmap, $defaultLimit)        
        let $values := distinct-values($elems[local-name(.) eq $name])
        let $show := for $v in $values[position() le $limit] 
                     order by lower-case($v) return &lt;z:v v="{$v}"/&gt;
        order by lower-case($name) return
            &lt;z:e n="{$name}" count="{concat(count($show), '/', count($values))}"&gt;{$show}&lt;/z:e&gt;            
    return
        &lt;z:values countDocs="{count($docs)}"&gt;{
            &lt;z:atts countAtts="{count($atts)}"&gt;{$attValues}&lt;/z:atts&gt;,
            &lt;z:elems countAtts="{count($elems)}"&gt;{$elemValues}&lt;/z:elems&gt;            
        }&lt;/z:values&gt;
};   

declare function f:path($n as node())
        as xs:string {
    string-join($n/ancestor-or-self::node()/concat(self::attribute()/'@', local-name(.)), '/')        
};</textual></programlisting></appendix><bibliography class="po-hcontainer e756 e756"><title class="po-block e757 e757"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e758 e758" xml:id="basex" xreflabel="1"><textual class="po-textual">BaseX GmbH, Germany. Homepage. </textual><link class="po-inline e759 e759" xlink:actuate="onRequest" xlink:href="http://www.otds.de" xlink:show="new" xlink:type="simple"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></link></bibliomixed><bibliomixed class="po-block e760 e760" xml:id="otds" xreflabel="2"><textual class="po-textual">OTDS e.V., Schicklerstrasse 5-7, 10179 Berlin,
            Germany. Homepage. </textual><link class="po-inline e761 e761" xlink:actuate="onRequest" xlink:href="http://www.otds.de" xlink:show="new" xlink:type="simple"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></link></bibliomixed><bibliomixed class="po-block e762 e762" xml:id="retter" xreflabel="3"><textual class="po-textual">Retter, Adam. RESTful XQuery. XML Prague 2012,
            Conference Proceedings, p. 91-124. </textual><link class="po-inline e763 e763" xlink:actuate="onRequest" xlink:href="http://archive.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e764 e764" xml:id="w3c-xquery" xreflabel="4"><textual class="po-textual">Robie, Jonathan et al, eds. XQuery 3.0: An
            XML Query Language (Second Edition). W3C Recommendation 8 April 2014. </textual><link class="po-inline e765 e765" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></link></bibliomixed></bibliography></article></classedDocument>