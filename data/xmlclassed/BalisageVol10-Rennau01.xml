<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">The XML info space</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual"> XML-related standards imply an architecture of distributed information which
                integrates all accessible XML resources into a coherent whole. Attempting to capture
                the key properties of this architecture, the concept of an info space is defined.
                The concept is used as a tool for deriving desirable extensions of the standards.
                The proposed extensions aim at a fuller realization of the potential offered by the
                architecture. Main aspects are better support for resource discovery and the
                integration of non-XML resources. If not adopted by standards, the extensions may
                also be emulated by application-level design patterns and product-specific features.
                Knowledge of them might therefore be of immediate interest to application developers
                and product designers. </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Hans-Jürgen</textual></firstname><othername class="po-field e11 e11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></othername><surname class="po-field e12 e12"><textual class="po-textual">Rennau</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Senior Java developer</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">Traveltainment GmbH</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">hrennau@yahoo.de</textual></email></author><legalnotice class="po-container e19 e19"><para class="po-block e20 e20"><textual class="po-textual">Copyright © 2013 by the author.  Used with permission.</textual></para></legalnotice><keywordset class="po-table e21 e21" role="author"><keyword class="po-field e22 e22"><textual class="po-textual">XML info space</textual></keyword><keyword class="po-field e23 e23"><textual class="po-textual">property-faced collection</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">XPath</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">XQuery</textual></keyword><keyword class="po-field e27 e27"><textual class="po-textual">XSLT</textual></keyword><keyword class="po-field e28 e28"><textual class="po-textual">JSON&gt;</textual></keyword><keyword class="po-field e29 e29"><textual class="po-textual">XDM</textual></keyword><keyword class="po-field e30 e30"><textual class="po-textual">UDL</textual></keyword></keywordset></info><section class="po-hcontainer e31 e31"><title class="po-block e32 e32"><textual class="po-textual">Introduction</textual></title><para class="po-block e33 e33"><textual class="po-textual"> The first version of a successful program is not the last one. But the more complex
            the program, the more care is required when making changes. When technologies and the
            underlying standards are concerned, any changes must certainly be based on a deep
            understanding of the status quo. But the nature of the required understanding is not
            obvious. </textual></para><para class="po-block e34 e34"><textual class="po-textual">In 1938, Albert Einstein and Leopold Infeld published a book about the evolution of
            physics [</textual><xref class="po-milestone e35 e35" linkend="einstein"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The focus was on the crucial role played by named
                </textual><emphasis class="po-inline e36 e36" role="ital"><textual class="po-textual">concepts</textual></emphasis><textual class="po-textual">, guiding and at times limiting our
            thoughts and understanding. A striking example involves the concepts of "force" and
            "field". At a point in time, the scientific understanding of forces was a sort of
            interaction between two bodies. Then the field was discovered as a new reality, existing
            independently of the presence and absence of bodies. Without this image of a field,
            understanding simply could not have passed beyond a certain point.</textual></para><para class="po-block e37 e37"><textual class="po-textual"> In information technology, named concepts can play an important role in the
            development of industry standards. Fielding [</textual><xref class="po-milestone e38 e38" linkend="fielding"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] gave a detailed
            account how the abstractions of a "resource" and "resource representations" enabled a
            unified vision of the emerging internet and led to the definition of an architectural
            style (REST - Representational State Transfer) which provided guidance in the evaluation
            of proposed changes to the standards.</textual></para><para class="po-block e39 e39"><textual class="po-textual"> How about XML – is it final or in need of a new version? Is there a direction to go?
            This paper proposes a novel abstraction to guide a better understanding of the
            technological reality already created, an abstraction intended to help in the evaluation
            of further steps. The reality implemented by XML technology is very versatile, and
            doubtless many conceptualizations are useful and important. Nevertheless, this paper
            suggests a new concept or image - the info space. The concept evokes a potential which
            is at the same time so large and so much limited by the current state of affairs that
            the perspective of a fuller realization may affect our sense of priorities. The
            remaining sections define the concept, explore the current limitations and suggest steps
            towards an increasing realization of its potential. </textual></para></section><section class="po-hcontainer e40 e40"><title class="po-block e41 e41"><textual class="po-textual">Experiments and observations</textual></title><para class="po-block e42 e42"><textual class="po-textual">To get started, we examine a few simple programming tasks and possible solutions using
            XPath. The experience will invite some observations, which we then attempt to translate
            into a concept characterizing the new situation which XML technology has created.</textual></para><section class="po-hcontainer e43 e43" xml:id="experiments" xreflabel="Experiments"><title class="po-block e44 e44"><textual class="po-textual">Experiments</textual></title><para class="po-block e45 e45"><textual class="po-textual">Assume we have an XML file (</textual><code class="po-atom e46 e46"><textual class="po-textual">foo.xml</textual></code><textual class="po-textual">) and want to retrieve all
                    </textual><code class="po-atom e47 e47"><textual class="po-textual">countryCode</textual></code><textual class="po-textual"> elements, no matter where they occur in the document.
                The following XPath expression does just that:
                </textual><programlisting class="po-block e48 e48" xml:space="preserve"><textual class="po-textual">   doc("foo.xml")//countryCode</textual></programlisting><textual class="po-textual"> Now we want to
                detect all </textual><code class="po-atom e49 e49"><textual class="po-textual">countryCode</textual></code><textual class="po-textual"> instances that do not contain a valid two-letter
                code according to ISO 3166. As a code dictionary in XML format is available in the
                internet</textual><footnote class="po-popup e50 e50" xml:id="uri-iata"><para class="po-block e51 e51"><textual class="po-textual">
                      http://www.iso.org/iso/home/standards/country_codes/country_names_and_code_elements_xml.htm
                    </textual></para></footnote><textual class="po-textual">
                we can solve the problem by adding a simple filter expression:
                </textual><programlisting class="po-block e52 e52" xml:space="preserve"><textual class="po-textual">   doc("foo.xml")//countryCode[not(. = doc("http://...")//code]</textual></programlisting><textual class="po-textual">
                When the check should be applied to several files, we only have to replace the first
                step by an expression which yields several documents, rather than a single document:
                </textual><programlisting class="po-block e53 e53" xml:space="preserve"><textual class="po-textual">   (doc("foo.xml"), doc("foo2.xml"))
                 //countryCode[not(. = doc("http://...")//code]</textual></programlisting><textual class="po-textual">
                As there may be many documents to be checked, we introduce a helper resource, an XML
                document listing all documents concerned. The list represents each document by a
                    </textual><code class="po-atom e54 e54"><textual class="po-textual">uri</textual></code><textual class="po-textual"> element containing the document URI, which may be a file name
                or an HTTP address. In order to apply the check to all documents found in the
                document list, again we adapt the first step of our navigation:
                </textual><programlisting class="po-block e55 e55" xml:space="preserve"><textual class="po-textual">   doc("docs.xml")//uri/doc(.)
                 //countryCode[not(. = doc("http://...")//code]</textual></programlisting><textual class="po-textual">
                The documents may be found in the file system, an intranet or the internet, and
                their number could be large. If a specific document list has to be created for our
                checking task, this might become inconvenient, too. So we introduce a general
                purpose inventory of document URIs which describes a whole domain of documents, only
                some of which have to be checked in this particular case. We create a
                tree-structured document list in which only the leaf elements are </textual><code class="po-atom e56 e56"><textual class="po-textual">uri</textual></code><textual class="po-textual">
                elements containing a document URI, whereas all inner nodes have the purpose of
                adding structure, implicitly creating groups of documents. All elements - inner
                nodes and </textual><code class="po-atom e57 e57"><textual class="po-textual">uri</textual></code><textual class="po-textual"> elements - may have attributes supplying metadata
                pertaining to the document(s) referenced by the element itself or its descendants.
                Schematically, such an inventory might look like this: </textual><programlisting class="po-block e58 e58" xml:space="preserve"><textual class="po-textual">   &lt;doctree&gt;
      &lt;department name="d1"&gt;
         &lt;project name="p1"&gt;
            &lt;xsd&gt; 
               &lt;uri app="a1"&gt;…&lt;/uri&gt; 
               &lt;uri app="a2"&gt;…&lt;/uri&gt; 
            &lt;/xsd&gt;
            &lt;msg&gt;…	
               &lt;uri srv="s1"&gt;…&lt;/uri&gt; 
               &lt;uri srv="s2"&gt;…&lt;/uri&gt; 
            &lt;/msg&gt;…
         &lt;/project&gt;
      &lt;/department&gt;
   &lt;/doctree&gt;</textual></programlisting><textual class="po-textual"> Now we can combine the selection of documents and their checking
                into a single expression:
                </textual><programlisting class="po-block e59 e59" xml:space="preserve"><textual class="po-textual">   doc("doctree.xml")//project[@name="p1"]/msg/uri/doc(.)/
                 //countryCode[not(. = doc("http://...")//code]</textual></programlisting><textual class="po-textual">
                A navigation across multiple resources - an inventory, all resources referenced by
                    </textual><code class="po-atom e60 e60"><textual class="po-textual">uri</textual></code><textual class="po-textual"> elements which match certain conditions, and finally the code
                dictionary – is achieved by a single expression, without taking actions like opening
                a file and without shifting information from data sources into intermediate
                variables.</textual></para><para class="po-block e61 e61"><textual class="po-textual"> The expression does not only yield the faulty codes; it resolves to the </textual><emphasis class="po-inline e62 e62" role="ital"><textual class="po-textual">nodes</textual></emphasis><textual class="po-textual"> containing them, which means information </textual><emphasis class="po-inline e63 e63" role="ital"><textual class="po-textual">and</textual></emphasis><textual class="po-textual"> its location. Assigning the nodes to an XQuery
                variable (</textual><code class="po-atom e64 e64"><textual class="po-textual">$faultyCodes</textual></code><textual class="po-textual">), we can later resume navigation, using those
                nodes as starting points. If the documents contain somewhere a
                    </textual><code class="po-atom e65 e65"><textual class="po-textual">changeLog</textual></code><textual class="po-textual"> element, we can collect the change logs of all faulty
                documents:
                </textual><programlisting class="po-block e66 e66" xml:space="preserve"><textual class="po-textual">   $faultyCodes/ancestor::document-node()//changeLog</textual></programlisting><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e67 e67"><title class="po-block e68 e68"><textual class="po-textual">Observations</textual></title><para class="po-block e69 e69"><textual class="po-textual">This little programming experience may give a feeling of handling information in a
                different way than when using a general purpose language like Java or Perl. What was
                different? </textual></para><para class="po-block e70 e70"><textual class="po-textual"> First, we did not "load" resources - we just </textual><emphasis class="po-inline e71 e71" role="ital"><textual class="po-textual">addressed</textual></emphasis><textual class="po-textual"> them using an expression which was equivalent to the
                complete information content. Compare this to Java code extracting data from a CSV
                file. The equivalence enables us to to use the expression as input to navigation:
                </textual><programlisting class="po-block e72 e72" xml:space="preserve"><textual class="po-textual">   doc("…")//countryCode</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e73 e73"><textual class="po-textual"> Second, navigation can be downward (e.g. "…//..") or upward (e.g.
                "ancestor::...") in a </textual><emphasis class="po-inline e74 e74" role="ital"><textual class="po-textual">vertically unbounded</textual></emphasis><textual class="po-textual"> way,
                moving from any current location in a single bout down to the very leaves under it
                and up to the very root above it. Compare this to the navigation in an object tree:
                a downward move can only be achieved recursively, one level per invocation, and
                upward navigation is impossible. </textual></para><para class="po-block e75 e75"><textual class="po-textual"> Third, </textual><emphasis class="po-inline e76 e76" role="ital"><textual class="po-textual">resource boundaries</textual></emphasis><textual class="po-textual"> do not impose a
                resistence to navigation: the effort to enter a different document is not greater
                than the effort to move within the same document. The following expression moves
                down to </textual><code class="po-atom e77 e77"><textual class="po-textual">uri</textual></code><textual class="po-textual"> elements, crosses over into the referenced documents and
                continues its path down into that document:
                </textual><programlisting class="po-block e78 e78" xml:space="preserve"><textual class="po-textual">   //uri/doc(.)//countryCode</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e79 e79"><textual class="po-textual"> Fourth, navigation is a </textual><emphasis class="po-inline e80 e80" role="ital"><textual class="po-textual">parallel operation</textual></emphasis><textual class="po-textual">,
                multiply rooted and cascading: the starting point may be one or many locations, and
                subsequent steps resume the movement at every location reached by the preceding
                step. This is different from navigation of an object tree, which is a movement from
                single item to single item.</textual></para><para class="po-block e81 e81"><textual class="po-textual"> Fifth, navigation is a </textual><emphasis class="po-inline e82 e82" role="ital"><textual class="po-textual">generic operation</textual></emphasis><textual class="po-textual">: the
                inventory, the resources to be checked and the code dictionary have different
                semantics, but they are navigated in the same way. Navigation of an object tree, on
                the other hand, must adapt each single step to object types.</textual></para><para class="po-block e83 e83"><textual class="po-textual"> Summarizing the observations, one perceives a continuous space of information: we
                can enter and leave resources at will, and within them we can move up, down, forward
                and backward in a uniform and effortless way. The space is a sum total of
                information which integrates every single accessible XML document. Within this
                space, every item of information is visible and addressable. </textual></para></section></section><section class="po-hcontainer e84 e84"><title class="po-block e85 e85"><textual class="po-textual">The XML info space</textual></title><para class="po-block e86 e86"><textual class="po-textual">This section proposes the notion of an </textual><emphasis class="po-inline e87 e87" role="bold"><textual class="po-textual">info space</textual></emphasis><textual class="po-textual"> as
            an architecture of distributed information which comprises two models, describing
            content and navigation. The definition of the space is guided by the reality introduced
            by XML technology but, being an abstraction, does in no way depend on XML as its
            implementation. Let us summarize some important properties:</textual></para><section class="po-hcontainer e88 e88"><title class="po-block e89 e89"><textual class="po-textual">The definition</textual></title><itemizedlist class="po-table e90 e90"><listitem class="po-container e91 e91"><para class="po-block e92 e92"><textual class="po-textual">Space content is decomposable into information items</textual><itemizedlist class="po-table e93 e93"><listitem class="po-container e94 e94"><para class="po-block e95 e95"><textual class="po-textual">The space is an unstructured collection of resources</textual></para></listitem><listitem class="po-container e96 e96"><para class="po-block e97 e97"><textual class="po-textual">A resource is a structured collection of items</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e98 e98"><para class="po-block e99 e99"><textual class="po-textual">Inter-item relationships are well defined</textual><itemizedlist class="po-table e100 e100"><listitem class="po-container e101 e101"><para class="po-block e102 e102"><textual class="po-textual">Items within a resource are related by axes</textual></para></listitem><listitem class="po-container e103 e103"><para class="po-block e104 e104"><textual class="po-textual">Items in different resources are related by URI+axes</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e105 e105"><para class="po-block e106 e106"><textual class="po-textual">Navigation is item-oriented</textual><itemizedlist class="po-table e107 e107"><listitem class="po-container e108 e108"><para class="po-block e109 e109"><textual class="po-textual">Input, output, intermediaries are sets of items</textual></para></listitem><listitem class="po-container e110 e110"><para class="po-block e111 e111"><textual class="po-textual">Input, output, intermediaries can reside in multiple
                                    resources</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">Navigation is generic</textual></para><itemizedlist class="po-table e114 e114"><listitem class="po-container e115 e115"><para class="po-block e116 e116"><textual class="po-textual">The specification of a movement can be separated from the choice
                                of start items</textual></para></listitem><listitem class="po-container e117 e117"><para class="po-block e118 e118"><textual class="po-textual">Any specification of a movement can be applied to any choice of
                                start items</textual></para></listitem></itemizedlist></listitem><listitem class="po-container e119 e119"><para class="po-block e120 e120"><textual class="po-textual">Information is well defined</textual></para><itemizedlist class="po-table e121 e121"><listitem class="po-container e122 e122"><para class="po-block e123 e123"><textual class="po-textual">Information is a sequence of items</textual></para></listitem><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">An item is a component with properties</textual></para></listitem><listitem class="po-container e126 e126"><para class="po-block e127 e127"><textual class="po-textual">Semantics and value space of item properties are well
                                defined</textual></para></listitem></itemizedlist></listitem><listitem class="po-container e128 e128"><para class="po-block e129 e129"><textual class="po-textual">Information is expressible</textual></para><itemizedlist class="po-table e130 e130"><listitem class="po-container e131 e131"><para class="po-block e132 e132"><textual class="po-textual">Information is expressible as navigation leading to it</textual></para></listitem></itemizedlist></listitem></itemizedlist><para class="po-block e133 e133"><textual class="po-textual">It is easy to see how all properties are implemented by current XML technology.
                The resources in question are XML documents [</textual><xref class="po-milestone e134 e134" linkend="w3c-xml"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], their
                itemized structure is defined by the node model part of the XDM [</textual><xref class="po-milestone e135 e135" linkend="w3c-xdm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] (which is more suitable as a substrate for navigation than
                the info set model [</textual><xref class="po-milestone e136 e136" linkend="w3c-infoset"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]), intra-resource relationships
                are defined by XPath axes [</textual><xref class="po-milestone e137 e137" linkend="w3c-xpath"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and inter-resource
                relationships by the URI standard [</textual><xref class="po-milestone e138 e138" linkend="uri"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The navigation model is
                provided by XPath [</textual><xref class="po-milestone e139 e139" linkend="w3c-xpath"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and XQuery [</textual><xref class="po-milestone e140 e140" linkend="w3c-xquery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and the information model by the XDM in its entirety
                    [</textual><xref class="po-milestone e141 e141" linkend="w3c-xdm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></section><section class="po-hcontainer e142 e142"><title class="po-block e143 e143"><textual class="po-textual"> The limitations</textual></title><para class="po-block e144 e144"><textual class="po-textual">The URIs of all accessible documents are an unstructured collection of strings.
                There is no built-in way how to navigate this collection, iterate over its members
                or in some other way discover URIs. Document access simply requires beforehand
                knowledge of a document URI. If relying on standard XPath functions only, even file
                directories cannot be inspected in order to discover the files it contains. To throw
                light on this limitation, think of a stock of information distributed over thousands
                of XML documents which are accessible either as local files or via HTTP address.
                While on the one hand it is a fascinating thought that anything within that pool of
                documents can be immediately </textual><emphasis class="po-inline e145 e145" role="ital"><textual class="po-textual">addressed</textual></emphasis><textual class="po-textual">, it can
                become a serious problem how to </textual><emphasis class="po-inline e146 e146" role="ital"><textual class="po-textual">discover</textual></emphasis><textual class="po-textual"> the
                resources: to find out which URI to use. If we compared XML documents to relational
                table rows, the info space would resemble a relational database in which
                    </textual><code class="po-atom e147 e147"><textual class="po-textual">select</textual></code><textual class="po-textual"> commands are constrained to specify a primary key. </textual></para></section><section class="po-hcontainer e148 e148"><title class="po-block e149 e149"><textual class="po-textual"> The boundaries</textual></title><para class="po-block e150 e150"><textual class="po-textual">Given a computing site - which part of the resources of the world are in the info
                space, and which are not? Any resource not accessible via network or file system is
                obviously not within the info space: this is the </textual><emphasis class="po-inline e151 e151" role="ital"><textual class="po-textual">physical
                    boundary</textual></emphasis><textual class="po-textual">. But also when physical access is possible, the protocol
                requirements may not be supported by XPath functions providing document access
                (namely the </textual><code class="po-atom e152 e152"><textual class="po-textual">fn:doc</textual></code><textual class="po-textual"> function), for example due to the need of supplying
                authorization information or an HTTP body: this is the </textual><emphasis class="po-inline e153 e153" role="ital"><textual class="po-textual">API
                    boundary</textual></emphasis><textual class="po-textual">. Those resources which are accessible both physically and
                API-wise can be grouped into two categories: XML documents and other resources. The
                former are in the XML info space, the latter are not: the </textual><emphasis class="po-inline e154 e154" role="ital"><textual class="po-textual">media type boundary</textual></emphasis><textual class="po-textual"> excludes any non-XML resources.</textual></para></section></section><section class="po-hcontainer e155 e155"><title class="po-block e156 e156"><textual class="po-textual"> Addressing the limitations of the info space </textual></title><para class="po-block e157 e157"><textual class="po-textual"> XPath navigation has a strong part and a weak part. Within-resource movement is
            governed by a powerful model – the application of semantic filters (name test and
            predicates) to structural relationships (navigational axes). Between-resource movement,
            on the other hand, is mainly enabled by the </textual><code class="po-atom e158 e158"><textual class="po-textual">fn:doc</textual></code><textual class="po-textual"> function, which resolves
            a URI to the corresponding document. This is a lookup requiring beforehand knowledge of
            the key – neither structural nor semantic conditions can be specified. Regarded as a
            means of navigation, the </textual><code class="po-atom e159 e159"><textual class="po-textual">fn:doc</textual></code><textual class="po-textual"> function produces “manifold motion making
            little speed” (S. T. Coleridge, “The butterfly”), as it delivers only one result item
            per item of knowledge. The </textual><code class="po-atom e160 e160"><textual class="po-textual">fn:collection</textual></code><textual class="po-textual"> function offers multiple items for
            the price of a single URI, but the collection is a pre-defined unit, which often will
            not match the actual requirements. </textual></para><para class="po-block e161 e161"><textual class="po-textual"> These limitations reflect the nature of the info space, which is an unstructured set
            of unrelated, indistinguishable trees. Or more precisely: trees that cannot be
            distinguished or related until an in-memory representation is constructed, as URIs are
            devoid of semantics. The info space does not relate resource URIs to a structure (like
            directories), does not define inter-resource relationships (like XLink links) and does
            not provide any way how to search for resources (as a database does). </textual></para><para class="po-block e162 e162"><textual class="po-textual"> Space structure, resource relationships and searchability may, however, be introduced
            on the grounds of </textual><emphasis class="po-inline e163 e163" role="ital"><textual class="po-textual">data</textual></emphasis><textual class="po-textual"> which create a second layer of
            information, built upon the first layer consisting of the resources themselves. Think of
            a linkbase defining relationships between documents, or a data set associating URIs with
            meta information. Data-based navigation aids can be introduced on the application level.
            But they might also be supported by standardization. The basic principle would be to
                </textual><emphasis class="po-inline e164 e164" role="ital"><textual class="po-textual">extend the dynamic context</textual></emphasis><textual class="po-textual"> of XPath evaluation by
            novel components which expose those data to the navigational engine of XPath - enabling
            novel XPath functions, perhaps even novel navigational axes. </textual></para><para class="po-block e165 e165"><textual class="po-textual"> This section explores some possibilities how standards may be extended in order to
            enhance the possibilities of between-resource navigation. </textual></para><section class="po-hcontainer e166 e166"><title class="po-block e167 e167"><textual class="po-textual">XLink per XPath</textual></title><para class="po-block e168 e168"><textual class="po-textual"> XLink [</textual><xref class="po-milestone e169 e169" linkend="w3c-xlink"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is a specification that defines XML syntax
                for describing links between resources. Although these resources are not necessarily
                nodes, we can for the sake of our discussion treat XLink as a language for defining
                node relationships. The basic unit of resource linkage is an </textual><emphasis class="po-inline e170 e170" role="ital"><textual class="po-textual">arc</textual></emphasis><textual class="po-textual"> which maps one set of resources (the starting resources) to
                another set of resources (the ending resources). The arc enables “traversal” from
                any one of the starting resources to any one of the ending resources. This concept
                of XLink traversal is similar, though not identical, to XPath navigation. Both rely
                on a unidirectional mapping from a start or context node to a set of result nodes.
                Consequently, the definition of XLink arcs might be viewed as the definition of
                potential navigation steps available to XPath. Let us investigate possibilities to
                translate XLink-defined arcs into XPath steps. </textual></para><para class="po-block e171 e171"><textual class="po-textual"> XLink defines containers, called extended links, which hold together a set of
                resource locators and associated arcs, which are mappings between subsets of the
                complete set. (For the sake of clarity, we ignore the possibility of using local
                resources instead of or together with resource locators.) The extended link can
                assign to each of its resources an optional label (NCName). The label is like a
                property attached to the resources which allows them to be identified and grouped
                into subsets of the complete set contained by the extended link. The start and the
                end of an arc is defined in terms of an optional label value: if a label value is
                set, the corresponding subset of resources comprises all resources which have this
                label; if no label value is set, the subset is equal to the complete set. Consider
                the following extended link containing four arcs: </textual><programlisting class="po-block e172 e172" xml:space="preserve"><textual class="po-textual">
   &lt;foo xlink:type='extended'&gt;
      &lt;a1 xlink:type='arc' xlink:from='a' xlink:to='b'/&gt;
      &lt;a2 xlink:type='arc' xlink:to='b'/&gt;
      &lt;a3 xlink:type='arc' xlink:from='a'/&gt;
      &lt;a4 xlink:type='arc' /&gt;
    
      &lt;res xlink:type='locator' xlink:href='…1' xlink:label='a'/&gt;
      &lt;res xlink:type='locator' xlink:href='…2' xlink:label='b'/&gt;
      &lt;res xlink:type='locator' xlink:href='…3' xlink:label='b'/&gt;
      &lt;res xlink:type='locator' xlink:href='…4' xlink:label='b'/&gt;
      &lt;res xlink:type='locator' xlink:href='…5' xlink:label='c'/&gt;
   &lt;/foo&gt;</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e173 e173"><textual class="po-textual"> The arc &lt;a1&gt; leads from the single one resource associated with a label “a” to
                all three resources with a label “b”; &lt;a2&gt; leads from any one of the five
                resources to the three resources with a label “b”; &lt;a3&gt; leads from the resource
                with a label “a” to all five resources, including itself; and &lt;a4&gt; leads from any
                one of the five resources to all five resources, including itself. </textual></para><para class="po-block e174 e174"><textual class="po-textual"> An arc is an option for navigation. Given a node (N), a navigation step may be
                specified by </textual><emphasis class="po-inline e175 e175" role="ital"><textual class="po-textual">selecting a particular arc</textual></emphasis><textual class="po-textual"> (A). The
                destination is the collection of nodes which </textual><itemizedlist class="po-table e176 e176"><listitem class="po-container e177 e177"><para class="po-block e178 e178"><textual class="po-textual">is empty if N is not among the starting resources of A</textual></para></listitem><listitem class="po-container e179 e179"><para class="po-block e180 e180"><textual class="po-textual">comprises the ending resources of A, otherwise</textual></para></listitem></itemizedlist><textual class="po-textual"> Such navigation might be integrated into XPath if two changes are
                applied to the current standards: </textual><itemizedlist class="po-table e181 e181"><listitem class="po-container e182 e182"><para class="po-block e183 e183"><textual class="po-textual">extend the static context of XPath by a component </textual><emphasis class="po-inline e184 e184" role="bold"><textual class="po-textual">Available extended links</textual></emphasis><textual class="po-textual">, comprising the
                            extended links which are “in scope”. (These extended links may be
                            imported as linkbase documents, analogously to the import of in-scope
                            schemas as schema documents.) </textual></para></listitem><listitem class="po-container e185 e185"><para class="po-block e186 e186"><textual class="po-textual"> define a new kind of navigation step which is based on the selection
                            of a particular arc </textual></para></listitem></itemizedlist><textual class="po-textual"> The new kind of navigation step may be a combination of an
                    </textual><code class="po-atom e187 e187"><textual class="po-textual">xlink</textual></code><textual class="po-textual"> axis with an “arc test” selecting arcs. The expression result
                could then be collected from the ending resources of the selected arcs. </textual></para><para class="po-block e188 e188"><textual class="po-textual"> How to specify the selection of arcs? The XLink standard defines extended links
                to have an optional </textual><code class="po-atom e189 e189"><textual class="po-textual">role</textual></code><textual class="po-textual"> property and arcs to have an optional
                    </textual><code class="po-atom e190 e190"><textual class="po-textual">arcrole</textual></code><textual class="po-textual"> property, where both properties have as value a URI.
                Therefore a selection of arcs might be specified by two URIs, a </textual><code class="po-atom e191 e191"><textual class="po-textual">role</textual></code><textual class="po-textual">
                selecting extended links and an </textual><code class="po-atom e192 e192"><textual class="po-textual">arcrole</textual></code><textual class="po-textual"> selecting arcs within those
                links. If we now deviate from the XLink standard and assume that arcs have an
                additional property, an </textual><code class="po-atom e193 e193"><textual class="po-textual">“arclabel”</textual></code><textual class="po-textual"> with an NCName as value, then arc
                selection might be specified by a single QName, as a QName consists of a URI plus an
                NCName. The “arc test” selecting an arc might now be specified by a QName, in
                analogy to the name test which is also specified by a QName, but selects elements or
                attributes . Consider the following expression:
                </textual><programlisting class="po-block e194 e194" xml:space="preserve"><textual class="po-textual">   xlink::x:y</textual></programlisting><textual class="po-textual"> Its value would be determined as
                follows. </textual><orderedlist class="po-table e195 e195"><listitem class="po-container e196 e196"><para class="po-block e197 e197"><textual class="po-textual"> select from the </textual><emphasis class="po-inline e198 e198" role="bold"><textual class="po-textual">Available extended
                                links</textual></emphasis><textual class="po-textual"> those with a </textual><code class="po-atom e199 e199"><textual class="po-textual">role</textual></code><textual class="po-textual"> equal to the URI
                            bound to prefix “x” </textual></para></listitem><listitem class="po-container e200 e200"><para class="po-block e201 e201"><textual class="po-textual"> within the selected extended links select all arcs with an
                                </textual><code class="po-atom e202 e202"><textual class="po-textual">arclabel</textual></code><textual class="po-textual"> equal to “y” </textual></para></listitem><listitem class="po-container e203 e203"><para class="po-block e204 e204"><textual class="po-textual"> filter the selected arcs, retaining only those whose set of starting
                            resources “matches” the context node (see below for details) </textual></para></listitem><listitem class="po-container e205 e205"><para class="po-block e206 e206"><textual class="po-textual"> obtain as the expression value the union of the ending resources of
                            all arcs retained by the previous step </textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para><para class="po-block e207 e207"><textual class="po-textual"> A remaining issue is the definition of when a set of starting resources “matches”
                the context node. The proposal is to define matching as containment: the starting
                resources include a node which is either identical to or contains the context node.
                Consider this expression:
                </textual><programlisting class="po-block e208 e208" xml:space="preserve"><textual class="po-textual">
   doc('foo.xml')//a/xlink::x:y</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e209 e209"><textual class="po-textual"> The selected arcs may include as starting resource either the document “foo.xml”,
                or the “a” element to which the </textual><code class="po-atom e210 e210"><textual class="po-textual">xlink</textual></code><textual class="po-textual"> step is applied, or any ancestor
                of that “a” element. </textual></para><para class="po-block e211 e211"><textual class="po-textual"> As an alternative to using a new </textual><code class="po-atom e212 e212"><textual class="po-textual">xlink</textual></code><textual class="po-textual"> axis, XLink navigation might
                be supported by a new standard function, </textual><code class="po-atom e213 e213"><textual class="po-textual">fn:xlink</textual></code><textual class="po-textual">. In this case, the
                set of extended links to be considered might alternatively be taken from the static
                context or from linkbase documents supplied as a parameter: </textual><programlisting class="po-block e214 e214" xml:space="preserve"><textual class="po-textual">
   fn:xlink($arcTest as xs:QName) as node()*
   fn:xlink($arcTest as xs:QName, $linkbases as node()*) as node()*</textual></programlisting><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e215 e215" xml:id="pfc-semantic-navigation"><title class="po-block e216 e216"><textual class="po-textual">XLink versus data-driven navigation</textual></title><para class="po-block e217 e217"><textual class="po-textual"> XLink defines resource relationships in terms of URI relationships - static
                mappings between single URIs and/or URI collections. The XLink model does not cover
                well a frequent requirement – data-driven navigation, which is guided by data and
                unawares of structural relationships between a current context and the destination.
                For example, assume a document D containing a country code, and further assume a
                collection of documents describing countries, one country per document: how can the
                evaluation of D take advantage of the country description matching the country code? </textual></para><para class="po-block e218 e218"><textual class="po-textual"> Currently, the navigation model of XPath does not offer standardized support for
                such tasks. Working within the bounds of a single document, this is felt less
                acutely as expressions like </textual><code class="po-atom e219 e219"><textual class="po-textual">//country[@code eq 'FR']</textual></code><textual class="po-textual"> have a sweeping
                nature which removes any structural assumptions apart from which document the
                information is located in. But when the target might be located in other documents,
                the lack of support may become an issue. Navigation between documents requires
                knowledge of a URI. In the general case this will be the target document URI, as
                support for named collections (the </textual><code class="po-atom e220 e220"><textual class="po-textual">fn:collection</textual></code><textual class="po-textual"> function) is
                implementation-defined and hence not portable. Without such support we simply cannot
                “look into” other documents without first providing a document URI. </textual></para><para class="po-block e221 e221"><textual class="po-textual"> If the processor does support the </textual><code class="po-atom e222 e222"><textual class="po-textual">fn:collection</textual></code><textual class="po-textual"> function, we can
                access documents without knowledge of individual document URIs. But collections are
                a problematic answer to the challenge of data-driven navigation. The collection is
                not yet the destination of our navigation, but a set of candidates from which to
                select the destination. In order to navigate into one country description, two
                hundred country descriptions have to be parsed (unless they are located in an XML
                database) and queried (unless we can resort to a database index). The greater the
                collection, the greater the overhead incurred by processing the collection in order
                to identify the one or few matching items. When there are a large number of
                candidates – e.g. accumulated log messages – the approach of constructing all
                candidate nodes and then filtering them can quickly become unfeasible. </textual></para><para class="po-block e223 e223"><textual class="po-textual"> The problem is deep-rooted. As navigational axes are bounded by the document
                border, conventional navigation cannot lead to the discovery of information in other
                documents, unless the URIs of those documents are either known beforehand or
                supplied by a document visited at an earlier navigation step. The next section
                develops a concept of data-driven navigation which is based on a filtering of
                collections which does not require the prior in-memory construction of its
                nodes.</textual></para></section><section class="po-hcontainer e224 e224"><title class="po-block e225 e225"><textual class="po-textual">Property-faced collections</textual></title><section class="po-hcontainer e226 e226"><title class="po-block e227 e227"><textual class="po-textual">External node properties</textual></title><para class="po-block e228 e228"><textual class="po-textual"> Every XML node has a set of properties defined by the XDM data model. An
                    element node, for example, has twelve properties, which include the name,
                    relationships to other nodes ([parent], [children], [attributes]), a type, a
                    typed value and a string value. Evaluation of these properties is what drives
                    XPath navigation, guiding it from a set of starting points to a set of
                    destination nodes. </textual></para><para class="po-block e229 e229"><textual class="po-textual"> In certain situations, however, the locating of nodes might be greatly
                    simplified if we manage to associate nodes with </textual><emphasis class="po-inline e230 e230" role="ital"><textual class="po-textual">additional</textual></emphasis><textual class="po-textual"> properties which help us to identify the nodes of
                    interest. Such properties could represent metadata, or they could reflect the
                    contained data, for example echoing a value found at a particular data path
                    within the node, or providing a value derived from contained data, like a
                    minimum or maximum. As these additional properties are not XDM properties, their
                    values are not part of the node data. Hence we call them </textual><emphasis class="po-inline e231 e231" role="bold"><textual class="po-textual">external node properties</textual></emphasis><textual class="po-textual">. Their nature implies an interesting
                    possibility: they can provide information about a node which is </textual><emphasis class="po-inline e232 e232" role="ital"><textual class="po-textual">accessible without constructing the node</textual></emphasis><textual class="po-textual">. Access to
                    such information might enhance the navigational model of XPath in general, and
                    add support for data-driven navigation in particular. The following sections
                    describe an approach how to achieve this. </textual></para><para class="po-block e233 e233"><textual class="po-textual"> An external property has a name and a value. A set of external node
                    properties can be modelled as a map with which the node is associated. The map
                    entries have a key which represents the property name, and a value which
                    represents the property value. Such a map we call a </textual><emphasis class="po-inline e234 e234" role="ital"><textual class="po-textual">property face</textual></emphasis><textual class="po-textual"> of the node, or </textual><emphasis class="po-inline e235 e235" role="bold"><textual class="po-textual">p-face</textual></emphasis><textual class="po-textual"> for short. Striving to keep things simple, we constrain
                    external node properties to have an NCName and a value which is a sequence of
                    atomic items of type </textual><code class="po-atom e236 e236"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual">. The value space of p-faces
                    is accordingly constrained. </textual></para></section><section class="po-hcontainer e237 e237"><title class="po-block e238 e238"><textual class="po-textual">Property-faced collections</textual></title><para class="po-block e239 e239"><textual class="po-textual"> A p-face is not part of the node data – it is merely </textual><emphasis class="po-inline e240 e240" role="ital"><textual class="po-textual">associated</textual></emphasis><textual class="po-textual"> with them. This relationship can be compared to the
                    general relationship between the keys and values of a map: the keys are not part
                    of the values, but only associated with them in the context of the map. Such an
                    association is not global, but scoped to the map. </textual></para><para class="po-block e241 e241"><textual class="po-textual"> The association between a node and its p-face is provided by a node
                    collection which contains the node. We introduce the concept of a </textual><emphasis class="po-inline e242 e242" role="bold"><textual class="po-textual">p-faced collection</textual></emphasis><textual class="po-textual"> (short for property-faced
                    collection), which is a conventional node collection plus a mapping associating
                    each node with a p-face. We do not constrain the individual p-faces to use the
                    same property names: the number and names of external properties can vary from
                    node to node. </textual></para><para class="po-block e243 e243"><textual class="po-textual"> The following table shows a simple example of a p-faced collection. In this
                    case, all collection members are associated with the same set of external
                    properties. The collection may therefore be represented by a table in which one
                    column identifies the node and the remaining columns represent external
                    properties. </textual><table class="po-container e244 e244"><caption class="po-container e245 e245"><para class="po-block e246 e246"><textual class="po-textual">
                                </textual><emphasis class="po-inline e247 e247" role="bold"><emphasis class="po-inline e248 e248" role="ital"><textual class="po-textual"> Example of a p-faced
                                        collection. </textual></emphasis></emphasis><textual class="po-textual"> The collection associates
                                each node with three external properties. Property value items are
                                separated by comma. </textual></para></caption><col align="left" class="po-meta e249 e249" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e250 e250" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e251 e251"><tr class="po-table e252 e252" valign="top"><th align="left" class="po-field e253 e253" valign="top"><textual class="po-textual">node URI</textual></th><th align="left" class="po-field e254 e254" valign="top"><textual class="po-textual">countryCode</textual></th><th align="left" class="po-field e255 e255" valign="top"><textual class="po-textual">neighbourCountries</textual></th><th align="left" class="po-field e256 e256" valign="top"><textual class="po-textual">rivers</textual></th></tr></thead><tbody class="po-table e257 e257"><tr class="po-table e258 e258" valign="top"><td class="po-block e259 e259"><code class="po-atom e260 e260"><textual class="po-textual">file://countries/fr.xml</textual></code></td><td class="po-block e261 e261"><textual class="po-textual">fr</textual></td><td class="po-block e262 e262"><textual class="po-textual">at, be, ch, de, es, it, lu, mc</textual></td><td class="po-block e263 e263"><textual class="po-textual">Rhein, Loire, Maas, Rhone, Seine, Garonne, Mosel, Marne, …</textual></td></tr><tr class="po-table e264 e264" valign="top"><td class="po-block e265 e265"><code class="po-atom e266 e266"><textual class="po-textual">file://countries/de.xml</textual></code></td><td class="po-block e267 e267"><textual class="po-textual">de</textual></td><td class="po-block e268 e268"><textual class="po-textual">at, be, ch, cz, dk, fr, lu, nl, pl</textual></td><td class="po-block e269 e269"><textual class="po-textual">Donau, Elbe, Rhein, Oder, Weser, Main, Havel, Mosel, …</textual></td></tr><tr class="po-table e270 e270" valign="top"><td class="po-block e271 e271"><code class="po-atom e272 e272"><textual class="po-textual">file://countries/it.xml</textual></code></td><td class="po-block e273 e273"><textual class="po-textual">it</textual></td><td class="po-block e274 e274"><textual class="po-textual">at, ch, fr, sm, si, va</textual></td><td class="po-block e275 e275"><textual class="po-textual">Drava, Po, Adige, Tevere, Adda, Oglio, Tanaro, Ticino, ...</textual></td></tr></tbody></table><textual class="po-textual">
                </textual></para><para class="po-block e276 e276"><textual class="po-textual"> A p-faced collection can be filtered by supplying a set of conditions to be
                    tested against the p-faces of its nodes. Such a set of conditions we call a
                        </textual><emphasis class="po-inline e277 e277" role="bold"><textual class="po-textual">p-filter</textual></emphasis><textual class="po-textual">. The result of applying a p-filter
                    to a p-faced collection is a sub collection of the original collection, which we
                    call a </textual><emphasis class="po-inline e278 e278" role="bold"><textual class="po-textual">p-filtered collection</textual></emphasis><textual class="po-textual">. </textual></para><para class="po-block e279 e279"><textual class="po-textual"> A subsequent section will define the syntax and semantics of property filters
                    in detail. For the moment, assume that such a filter may be represented by a
                    string, and further assume that a p-faced collection is identified by a URI.
                    Concatenating the URI and the query string, we can then identify sub collections
                    by a single string, for example:
                    </textual><programlisting class="po-block e280 e280" xml:space="preserve"><textual class="po-textual">
   http://example.com/pcollections/countries?neighbourCountries=be</textual></programlisting><textual class="po-textual">
                    A new XPath function may provide the functionality of resolving such strings to
                    the node sequences they identify. If the model were adopted by the XPath
                    standard, such a function might be </textual><code class="po-atom e281 e281"><textual class="po-textual">fn:nodes</textual></code><textual class="po-textual">, and one of its
                    signatures might be:
                    </textual><programlisting class="po-block e282 e282" xml:space="preserve"><textual class="po-textual">
   fn:nodes($uriQuery as xs:string) as node()*</textual></programlisting><textual class="po-textual">
                    The following snippet shows a simple XQuery program using this function: </textual><programlisting class="po-block e283 e283" xml:space="preserve"><textual class="po-textual">
   declare variable $country external;
   declare variable $countries := "http://example.com/pcollections/countries";

   &lt;neighbours cy="{$country}"&gt;{
      fn:nodes(concat($countries, '?', $country))
   }&lt;/neighbours&gt;</textual></programlisting><textual class="po-textual"> A crucial aspect
                    of p-faced collections is the possibility to separate the evaluation of the
                    p-filter from the construction of the selected nodes. Filter evaluation does not
                    require looking “into” the candidate nodes, in fact it does not require the
                    construction of any nodes. Filter evaluation is an operation on a collection of
                    logical maps, the p-faces. The </textual><emphasis class="po-inline e284 e284" role="bold"><textual class="po-textual">p-filter engine</textual></emphasis><textual class="po-textual">
                    may treat the nodes as opaque strings, to be delivered as such. Resolving these
                    strings to the nodes they represent is the task of an independent component, the
                        </textual><emphasis class="po-inline e285 e285" role="bold"><textual class="po-textual">node builder</textual></emphasis><textual class="po-textual">. The operations of p-filter
                    evaluation and node construction are distinct and independent. It follows that
                    the p-filter engine need not be based on XML technology. It is possible, for
                    example, to store the p-faced collection in a relational database table and use
                    as p-filter engine the relational database system. In this case, the p-filter
                    supplied to the </textual><code class="po-atom e286 e286"><textual class="po-textual">fn:nodes</textual></code><textual class="po-textual"> function would be translated into a SQL
                    query. It is also possible to store the p-faced collection in a NOSQL object
                    collection. The p-filter engine would then be the NOSQL data base system, and
                    the p-filter would be translated into a NOSQL query. Any p-filter engine can be
                    combined with the same node builder, as the mapping of a string to a node is in
                    no way influenced by the way how the string was obtained. </textual></para><para class="po-block e287 e287"><textual class="po-textual"> In summary, p-faced collections promise two distinct benefits. First, they
                    augment the navigational model of XPath with data-based access to information,
                    overcoming the current limitation that document access requires knowledge of the
                    document URI. Second, they offer the possibility to integrate non-XML
                    technologies into the implementation of XML data storage and XPath navigation,
                    which may enhance the scalability of XML based systems significantly. The
                    concept of p-faced collections must now provide </textual><itemizedlist class="po-table e288 e288"><listitem class="po-container e289 e289"><para class="po-block e290 e290"><textual class="po-textual">a model of p-filters in terms of data model, syntax and
                                semantics</textual></para></listitem><listitem class="po-container e291 e291"><para class="po-block e292 e292"><textual class="po-textual">a proposal how to integrate p-faced collections into the XPath
                                language</textual></para></listitem><listitem class="po-container e293 e293"><para class="po-block e294 e294"><textual class="po-textual">an outline how XPath processors may support the implementation of
                                p-faced collections using non-XML technologies </textual></para></listitem></itemizedlist><textual class="po-textual">
                </textual></para></section><section class="po-hcontainer e295 e295" xml:id="pfc-filter-model" xreflabel="Filter model"><title class="po-block e296 e296"><textual class="po-textual">Filter model</textual></title><para class="po-block e297 e297"><textual class="po-textual"> A p-filter defines a condition which can be applied to a p-face and yields a
                    Boolean result. As every node in a p-faced collection is associated with a
                    p-face, a p-filter can be used to specify sub collections. This section proposes
                    a generic model of a p-filter, which includes the data model, syntax and
                    semantics. </textual></para><section class="po-hcontainer e298 e298" xml:id="pfc-concept" xreflabel="Concept"><title class="po-block e299 e299"><textual class="po-textual">Concept</textual></title><para class="po-block e300 e300"><textual class="po-textual"> Attempting to strike a balance between simplicity and expressiveness, we
                        constrain a p-filter to consist only of atomic conditions and Boolean
                        conditions. An atomic condition submits the value of one particular property
                        to a particular test, and a Boolean condition is a Boolean operation
                            (</textual><code class="po-atom e301 e301"><textual class="po-textual">and, or, not</textual></code><textual class="po-textual">) applied to the results of atomic and/or
                        Boolean conditions. A p-filter can therefore be viewed as a logical tree
                        with leaves representing atomic conditions and inner nodes representing
                        Boolean conditions. </textual></para><para class="po-block e302 e302"><textual class="po-textual"> Atomic conditions are modelled as comparisons between a property value
                        and a test value. Like the property value, also the test value is a sequence
                        of atomic items. These items are specified as literal strings or string
                        patterns – they cannot be references to other property values. The
                        comparison is defined in terms of an operator (=, &lt;, &lt;=, …) and a
                        quantifier (</textual><code class="po-atom e303 e303"><textual class="po-textual">some</textual></code><textual class="po-textual"> or </textual><code class="po-atom e304 e304"><textual class="po-textual">every</textual></code><textual class="po-textual">) specifying if all
                        property value items or only at least one item must pass the test. </textual></para><para class="po-block e305 e305"><textual class="po-textual"> The information content of a p-filter is defined in terms of the XDM data
                        model, namely as an element information item constrained in particular ways.
                        The data model must be distinguished from the syntax model which defines
                        string representations of this information content. The semantics of a
                        p-filter consist of the rules how to evaluate a p-filter in the context of a
                        p-face to a Boolean result. </textual></para><para class="po-block e306 e306"><textual class="po-textual"> The generic p-filter model allows the use of a p-filter engine (for
                        example a particular relational database system) which does not support all
                        possibilities implied by the model. To this end, the model includes the
                        definition of </textual><emphasis class="po-inline e307 e307" role="ital"><textual class="po-textual">features</textual></emphasis><textual class="po-textual"> with
                        implementation-defined values. This approach combines the precise
                        specification of a fairly rich functionality with conformance criteria based
                        on a subset of the functionality, and it provides for a standard way how to
                        express implementation-specific limitations. </textual></para></section><section class="po-hcontainer e308 e308" xml:id="pfc-data-model" xreflabel="Data model"><title class="po-block e309 e309"><textual class="po-textual">Data model</textual></title><para class="po-block e310 e310"><textual class="po-textual"> A p-filter is an element information item with the local name
                            </textual><code class="po-atom e311 e311"><textual class="po-textual">filter</textual></code><textual class="po-textual"> and a namespace URI yet to be decided. (For the time
                        being we assume the URI
                        </textual><code class="po-atom e312 e312"><textual class="po-textual">http://www.w3.org/2013/xpath-structures</textual></code><textual class="po-textual">). In the following text
                        we use the prefix p to denote this URI. The filter element is either empty
                        or has element-only content. It can have any number of child elements. Each
                        child element represents either a property condition or a Boolean condition. </textual></para><para class="po-block e313 e313"><textual class="po-textual"> A </textual><emphasis class="po-inline e314 e314" role="bold"><textual class="po-textual">property condition</textual></emphasis><textual class="po-textual"> specifies a
                        condition referring to a particular property. It is represented by an
                        element information item in no namespace and with a local name equal to the
                        property name. The condition can be structured into four logical components,
                        described by the following table. </textual></para><table class="po-container e315 e315"><caption class="po-container e316 e316"><para class="po-block e317 e317"><textual class="po-textual">
                                </textual><emphasis class="po-inline e318 e318" role="bold"><emphasis class="po-inline e319 e319" role="ital"><textual class="po-textual"> The components of a
                                        property condition and their XML representation.
                                    </textual></emphasis></emphasis><textual class="po-textual">
                            </textual></para></caption><col align="left" class="po-meta e320 e320" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e321 e321" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e322 e322"><tr class="po-table e323 e323" valign="top"><th align="left" class="po-field e324 e324" valign="top"><textual class="po-textual">Condition component</textual></th><th align="left" class="po-field e325 e325" valign="top"><textual class="po-textual">XML representationn</textual></th><th align="left" class="po-field e326 e326" valign="top"><textual class="po-textual">Explanation</textual></th></tr></thead><tbody class="po-table e327 e327"><tr class="po-table e328 e328" valign="top"><td class="po-block e329 e329"><textual class="po-textual">Property name</textual></td><td class="po-block e330 e330"><textual class="po-textual">The local name of the element.</textual></td><td class="po-block e331 e331"><textual class="po-textual">Note that property names are constrained to be NCNames. If this
                                    is changed, the property name will be represented by the value
                                    of a @name attribute.</textual></td></tr><tr class="po-table e332 e332" valign="top"><td class="po-block e333 e333"><textual class="po-textual">Test value</textual></td><td class="po-block e334 e334"><textual class="po-textual">Either the single text child of the element, or the
                                        </textual><code class="po-atom e335 e335"><textual class="po-textual">p:term</textual></code><textual class="po-textual"> child elements.</textual></td><td class="po-block e336 e336"><textual class="po-textual">If there is only one test value item, it is represented by the
                                    text content of the element. If there are several items, use for
                                    each item a </textual><code class="po-atom e337 e337"><textual class="po-textual">p:term</textual></code><textual class="po-textual"> child element with a single text
                                    child. Note that test value items are literal – they cannot be
                                    references to other property values. Also note that test value
                                    items cannot be accompanied by type information.</textual></td></tr><tr class="po-table e338 e338" valign="top"><td class="po-block e339 e339"><textual class="po-textual">Operator</textual></td><td class="po-block e340 e340"><textual class="po-textual">Optional @op attribute; default value: =; valid values: =, !=,
                                    &lt;, &lt;=, &gt;, &gt;=, ~, %, #=, #!=, #&lt;, #&lt;=, #&gt;, #&gt;= </textual></td><td class="po-block e341 e341"><textual class="po-textual">A leading # indicates a numeric comparison; ~ is a regex match
                                    governed by the XPath regex rules; % is a regex or pattern match
                                    with implementation-defined semantics.</textual></td></tr><tr class="po-table e342 e342" valign="top"><td class="po-block e343 e343"><textual class="po-textual">Quantifier</textual></td><td class="po-block e344 e344"><textual class="po-textual">Option @qua attribute; default value: </textual><code class="po-atom e345 e345"><textual class="po-textual">some</textual></code><textual class="po-textual">; valid
                                    values: </textual><code class="po-atom e346 e346"><textual class="po-textual">some, every</textual></code><textual class="po-textual">
                                </textual></td><td class="po-block e347 e347"><textual class="po-textual">If the value is </textual><code class="po-atom e348 e348"><textual class="po-textual">every</textual></code><textual class="po-textual">, the condition requires every
                                    item of the property value to meet the condition; otherwise,
                                    only at least one item must meet the condition.</textual></td></tr></tbody></table><para class="po-block e349 e349"><textual class="po-textual"> An additional detail concerns the use of regex matching (@op equal ~). In
                        this case test value items containing a # are interpreted as follows: the
                        substring preceding the # is the pattern, the substring following it is a
                        set of match option flags (s, m, x, m, q) as they can be used in the third
                        parameter of standard function </textual><code class="po-atom e350 e350"><textual class="po-textual">fn:matches</textual></code><textual class="po-textual">. </textual></para><para class="po-block e351 e351"><textual class="po-textual"> Some examples of property conditions: </textual></para><programlisting class="po-block e352 e352" xml:space="preserve"><textual class="po-textual">
   &lt;time&gt;2013-01-01T00:00:00&lt;/time&gt;
   &lt;time op="&amp;lt;"&gt;2013-01-01T00:00:00&lt;/time&gt;
   &lt;time op="&amp;lt;" qua="every"&gt;2013-01-01T00:00:00&lt;/time&gt;
   &lt;keywords op="~"&gt;^semantic.*&lt;/keywords&gt;
   &lt;keywords op="~"&gt;^semantic.*#i&lt;/keywords&gt;
   &lt;keywords op="~"&gt;semantic%&lt;/keywords&gt;
   &lt;codes&gt;
      &lt;p:item&gt;DUS&lt;/p:item&gt;
      &lt;p:item&gt;CGN&lt;/p:item&gt;
   &lt;/codes</textual></programlisting><para class="po-block e353 e353"><textual class="po-textual"> A </textual><emphasis class="po-inline e354 e354" role="bold"><textual class="po-textual">Boolean condition</textual></emphasis><textual class="po-textual"> specifies a Boolean
                        operation applied to the results of other conditions which are property
                        conditions and/or Boolean conditions. A Boolean condition is an element
                        information item with a local name equal to </textual><code class="po-atom e355 e355"><textual class="po-textual">and, or</textual></code><textual class="po-textual"> or
                            </textual><code class="po-atom e356 e356"><textual class="po-textual">not</textual></code><textual class="po-textual"> and the same namespace URI as the </textual><code class="po-atom e357 e357"><textual class="po-textual">p:filter</textual></code><textual class="po-textual">
                        element. Examples: </textual><programlisting class="po-block e358 e358" xml:space="preserve"><textual class="po-textual">
   &lt;p:and&gt;
      &lt;time op="&amp;gt;"&gt;2012-12-31T22:30:00&lt;/time&gt;
      &lt;time op="&amp;lt;"&gt;2013-01-01T00:00:00&lt;/time&gt;
      &lt;p:or&gt;
         &lt;travelType op="~"&gt;^accommodation.*&lt;/travelType&gt;
         &lt;supplier&gt;TUI&lt;/supplier&gt;
      &lt;/p:or&gt;	
      &lt;p:not&gt;
         &lt;eventDate op="&amp;lt;" qua="every"&gt;2013-08-01&lt;/eventDate&gt;
      &lt;/p:not&gt;
   &lt;/p:and&gt;</textual></programlisting><textual class="po-textual">
                    </textual></para></section><section class="po-hcontainer e359 e359" xml:id="pfc-syntax" xreflabel="Syntax"><title class="po-block e360 e360"><textual class="po-textual">Syntax</textual></title><para class="po-block e361 e361"><textual class="po-textual"> Being defined as an element information item, a p-filter can be
                        serialized to a string like any other XML data. However, in certain
                        situations a more compact and intuitive syntax is desirable - for example
                        when passing a p-filter to a REST service as part of a URI. Therefore we
                        define a “query syntax” which represents a p-filter by a non-XML string. The
                        syntax represents a </textual><emphasis class="po-inline e362 e362" role="ital"><textual class="po-textual">property condition</textual></emphasis><textual class="po-textual"> by
                        these patterns: </textual><programlisting class="po-block e363 e363" xml:space="preserve"><textual class="po-textual">
   property-name operator testvalue
   property-name operator (testvalueItem-1, testvalueItem-2, ...)</textual></programlisting><textual class="po-textual">and a </textual><emphasis class="po-inline e364 e364" role="ital"><textual class="po-textual">Boolean condition</textual></emphasis><textual class="po-textual"> by these patterns: </textual><programlisting class="po-block e365 e365" xml:space="preserve"><textual class="po-textual">
   condition and condition
   condition or condition                        
   not condition
   not (condition1, condition2, ...)</textual></programlisting><textual class="po-textual">Parentheses can be used to change the
                        binding of operands to operator (by default: and &gt; or &gt; not). A non-default
                        quantifier (that is, </textual><code class="po-atom e366 e366"><textual class="po-textual">every</textual></code><textual class="po-textual">) is encoded by a prefix character
                        preceding the operator string (e.g. $=). Example of a p-filter rendered in
                        query syntax:</textual><programlisting class="po-block e367 e367" xml:space="preserve"><textual class="po-textual">
   time &gt;= 2012… 
   and time &lt;=2013…
   and (travelType ~ ^accommodation.* or supplier=TUI) 
   and not(eventData $&gt; 2013-01-01)</textual></programlisting><textual class="po-textual">Note that this is only a sketch of the
                        intended syntax – a detailed specification is left to future investigation.
                        In particular it must be decided if test values are quoted. </textual></para></section><section class="po-hcontainer e368 e368" xml:id="pfc-semantics" xreflabel="Semantics"><title class="po-block e369 e369"><textual class="po-textual">Semantics</textual></title><para class="po-block e370 e370"><textual class="po-textual"> A p-filter can be applied to a p-face in order to obtain a Boolean
                        result. The atomic operation of this evaluation is the checking of a single
                        property value item against a single test value item. Such a test is called
                        a </textual><emphasis class="po-inline e371 e371" role="bold"><textual class="po-textual">comparison constraint</textual></emphasis><textual class="po-textual">. Consequently, the
                        semantics of p-filter evaluation can be divided into general rules and rules
                        governing the evaluation of a comparison constraint. These are the general
                        rules: </textual><itemizedlist class="po-table e372 e372"><listitem class="po-container e373 e373"><para class="po-block e374 e374"><textual class="po-textual"> an empty p-filter evaluates to </textual><code class="po-atom e375 e375"><textual class="po-textual">true</textual></code><textual class="po-textual">
                                </textual></para></listitem><listitem class="po-container e376 e376"><para class="po-block e377 e377"><textual class="po-textual"> a non-empty p-filter evaluates to </textual><code class="po-atom e378 e378"><textual class="po-textual">false</textual></code><textual class="po-textual"> if at
                                    least one child element evaluates to </textual><code class="po-atom e379 e379"><textual class="po-textual">false</textual></code><textual class="po-textual">
                                </textual></para></listitem><listitem class="po-container e380 e380"><para class="po-block e381 e381"><textual class="po-textual"> an </textual><code class="po-atom e382 e382"><textual class="po-textual">and</textual></code><textual class="po-textual"> condition evaluations to
                                        </textual><code class="po-atom e383 e383"><textual class="po-textual">false</textual></code><textual class="po-textual"> if at least one child element evaluates
                                    to </textual><code class="po-atom e384 e384"><textual class="po-textual">false</textual></code><textual class="po-textual">
                                </textual></para></listitem><listitem class="po-container e385 e385"><para class="po-block e386 e386"><textual class="po-textual"> an </textual><code class="po-atom e387 e387"><textual class="po-textual">or</textual></code><textual class="po-textual"> condition evaluates to </textual><code class="po-atom e388 e388"><textual class="po-textual">true</textual></code><textual class="po-textual">
                                    if at least one child element evaluates to </textual><code class="po-atom e389 e389"><textual class="po-textual">true</textual></code><textual class="po-textual">
                                </textual></para></listitem><listitem class="po-container e390 e390"><para class="po-block e391 e391"><textual class="po-textual"> a </textual><code class="po-atom e392 e392"><textual class="po-textual">not</textual></code><textual class="po-textual"> condition evaluates to </textual><code class="po-atom e393 e393"><textual class="po-textual">false</textual></code><textual class="po-textual">
                                    if at least one child element evaluates to </textual><code class="po-atom e394 e394"><textual class="po-textual">true</textual></code><textual class="po-textual">
                                </textual></para></listitem><listitem class="po-container e395 e395"><para class="po-block e396 e396"><textual class="po-textual"> a property condition referencing a missing property evaluates
                                    to </textual><code class="po-atom e397 e397"><textual class="po-textual">false</textual></code><textual class="po-textual">
                                </textual></para></listitem><listitem class="po-container e398 e398"><para class="po-block e399 e399"><textual class="po-textual"> a property condition with quantifier </textual><code class="po-atom e400 e400"><textual class="po-textual">some</textual></code><textual class="po-textual">
                                    evaluates to </textual><code class="po-atom e401 e401"><textual class="po-textual">true</textual></code><textual class="po-textual"> if at least one property value
                                    item and at least one test value item meet the comparison
                                    constraint </textual></para></listitem><listitem class="po-container e402 e402"><para class="po-block e403 e403"><textual class="po-textual"> a property condition with quantifier </textual><code class="po-atom e404 e404"><textual class="po-textual">every</textual></code><textual class="po-textual">
                                    evaluates to </textual><code class="po-atom e405 e405"><textual class="po-textual">false</textual></code><textual class="po-textual"> if for at least one property
                                    value item there is no test value item with which it meets the
                                    comparison constraint </textual></para></listitem></itemizedlist><textual class="po-textual"> A comparison constraint is specified in terms of an
                        operator. These are the evaluation rules: </textual><itemizedlist class="po-table e406 e406"><listitem class="po-container e407 e407"><para class="po-block e408 e408"><textual class="po-textual"> the operators =, !=, &lt;, &lt;= &gt;, &gt;= are evaluated by
                                    applying to the operands the corresponding XPath operator;
                                    operands are typed as </textual><code class="po-atom e409 e409"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual">
                                </textual></para></listitem><listitem class="po-container e410 e410"><para class="po-block e411 e411"><textual class="po-textual"> a comparison operator with a leading # is evaluated by
                                    applying to the operands the corresponding XPath operator;
                                    operands are converted to </textual><code class="po-atom e412 e412"><textual class="po-textual">xs:double</textual></code><textual class="po-textual">
                                </textual></para></listitem><listitem class="po-container e413 e413"><para class="po-block e414 e414"><textual class="po-textual"> the operand ~ is evaluated by evaluating the
                                        </textual><code class="po-atom e415 e415"><textual class="po-textual">fn:matches</textual></code><textual class="po-textual"> function, using the property value
                                    item as first argument and the regex and options parts of the
                                    test value item as second and third arguments. If the test value
                                    item contains a # character, the regex and options parts are the
                                    substrings before and after the character; otherwise, the regex
                                    part is the complete item and the options part is the empty
                                    string. </textual></para></listitem><listitem class="po-container e416 e416"><para class="po-block e417 e417"><textual class="po-textual"> the operator % has implementation-defined matching semantics
                                </textual></para></listitem></itemizedlist><textual class="po-textual">
                    </textual></para></section></section><section class="po-hcontainer e418 e418" xml:id="new-xpath-functions" xreflabel="New XPath functions"><title class="po-block e419 e419"><textual class="po-textual">New XPath functions</textual></title><para class="po-block e420 e420"><textual class="po-textual"> Given a p-faced collection, p-filters can be used to select a sub collection,
                    retaining only those nodes whose p-face passes the p-filter. This amounts to a
                    logical operation, mapping a collection URI and a p-filter to a sub collection.
                    New XPath functions can make this operation available. Assuming as a tentative
                    function name </textual><code class="po-atom e421 e421"><textual class="po-textual">fn:nodes</textual></code><textual class="po-textual">, three variants may be useful: </textual><programlisting class="po-block e422 e422" xml:space="preserve"><textual class="po-textual">   fn:nodes($collectionUri as xs:string, p:filter as element(p:filter)) as node()*
   fn:nodes($collectionUri as xs:string, p:filter as xs:string) as node()*
   fn:nodes($filteredCollectionUri as xs:string) as node()*</textual></programlisting><textual class="po-textual">The second signature
                    expects the p-filter in query syntax (see </textual><link class="po-inline e423 e423" linkend="pfc-syntax" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        </textual><emphasis class="po-inline e424 e424" role="under"><textual class="po-textual">Syntax</textual></emphasis><textual class="po-textual">)</textual></link><textual class="po-textual">. The third signature
                    expects a string composed of a collection URI and a p-filter in query syntax,
                    separated by a ? character, for example:
                    </textual><programlisting class="po-block e425 e425" xml:space="preserve"><textual class="po-textual">   http://www.traveltainment.de/pfc/shoppingCart?booking-date=2013-08-01</textual></programlisting><textual class="po-textual">Also
                    when concatenated with the collection URI, the p-filter in query syntax is not
                    URI-encoded. </textual></para><para class="po-block e426 e426"><textual class="po-textual"> The introduction of these functions should be accompanied by an extension of
                    the dynamic context of XPath evaluation: an additional component </textual><emphasis class="po-inline e427 e427" role="bold"><textual class="po-textual">available property-faced collections</textual></emphasis><textual class="po-textual"> provides a
                    mapping of URIs to property-faced collections. A property-faced collection is
                    formally defined as a collection which is associated with a mapping of p-filter
                    instances to sub collections </textual></para></section><section class="po-hcontainer e428 e428" xml:id="pfc-rest" xreflabel="Exposure by REST-ful web services"><title class="po-block e429 e429"><textual class="po-textual">Exposure by REST-ful web services</textual></title><para class="po-block e430 e430"><textual class="po-textual"> A p-faced collection can be exposed as a REST-full web service, using as URI
                    the concatenation of collection URI and (URI-encoded) p-filter described in the
                    previous section. As a web service is expected to return a single document,
                    rather than a sequence of nodes, the selected sub collection may be wrapped by
                    an element and thus integrated into a single document. The proposed convention
                    is to use a </textual><code class="po-atom e431 e431"><textual class="po-textual">&lt;p:collection&gt;</textual></code><textual class="po-textual"> element with two attributes providing
                    the collection URI and the (not URI-encoded) p-filter. Example: </textual><programlisting class="po-block e432 e432" xml:space="preserve"><textual class="po-textual">   &lt;p:collection uri="http://www.traveltainment.de/pfc/offers" p-filter="destination=PMI"
         xmlns="http://www.traveltainment.de/pfc/offers"
         xmlns:p="http://www.w3.org/2013/xpath-structures"&gt; 
      &lt;offer&gt;...&lt;/offer&gt;
      &lt;offer&gt;...&lt;/offer&gt;
      &lt;offer&gt;...&lt;/offer&gt;
   &lt;/p:collection&gt;</textual></programlisting><textual class="po-textual">
                </textual></para></section><section class="po-hcontainer e433 e433" xml:id="pfc-deployed-and-external-collections"><title class="po-block e434 e434"><textual class="po-textual">Deployed and external collections</textual></title><para class="po-block e435 e435"><textual class="po-textual"> An XPath processor may provide access to two different groups of p-faced
                    collections: </textual><itemizedlist class="po-table e436 e436"><listitem class="po-container e437 e437"><para class="po-block e438 e438"><textual class="po-textual">deployed collections</textual></para></listitem><listitem class="po-container e439 e439"><para class="po-block e440 e440"><textual class="po-textual">external collections</textual></para></listitem></itemizedlist><textual class="po-textual">
                </textual></para><para class="po-block e441 e441"><textual class="po-textual"> A deployed collection is accessed according to configuration data. This
                    might, for example, involve the translation of the p-filter into a SQL query,
                    its execution and the construction of nodes from result set data. See </textual><link class="po-inline e442 e442" linkend="pfc-implementation-and-configuration" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        </textual><emphasis class="po-inline e443 e443" role="under"><textual class="po-textual">Implementation and configuration</textual></emphasis></link><textual class="po-textual">
                    for details about the deployment of p-faced collection. </textual></para><para class="po-block e444 e444"><textual class="po-textual"> An external collection is accessed by applying the </textual><code class="po-atom e445 e445"><textual class="po-textual">fn:doc</textual></code><textual class="po-textual">
                    function to a URI which is a concatenation of collection URI and (URI-encoded)
                    p-filter in query syntax. The URI is expected to yield a document which
                    represents the selected nodes as child elements of the document element (see
                        </textual><link class="po-inline e446 e446" linkend="pfc-rest" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        </textual><emphasis class="po-inline e447 e447" role="under"><textual class="po-textual">Exposure as REST-ful web
                    services</textual></emphasis><textual class="po-textual">)</textual></link><textual class="po-textual">). The </textual><code class="po-atom e448 e448"><textual class="po-textual">fn:nodes</textual></code><textual class="po-textual"> function might operate
                    as follows: </textual><itemizedlist class="po-table e449 e449"><listitem class="po-container e450 e450"><para class="po-block e451 e451"><textual class="po-textual"> if the collection URI identifies a deployed collection – evaluate
                                the selection in accordance with the configuration data </textual></para></listitem><listitem class="po-container e452 e452"><para class="po-block e453 e453"><textual class="po-textual"> otherwise – construct a URI concatenating the collection URI and
                                the p-filter, resolve this URI to a document and deliver the child
                                nodes of the document element </textual></para></listitem></itemizedlist><textual class="po-textual">
                </textual></para></section><section class="po-hcontainer e454 e454" xml:id="pfc-implementation-and-configuration"><title class="po-block e455 e455"><textual class="po-textual">Implementation and configuration</textual></title><para class="po-block e456 e456"><textual class="po-textual"> A crucial aspect of p-faced collections is that they may be implemented using
                    non-XML technologies, namely relational database tables and NOSQL object
                    collections. This follows from the fact that the node itself is represented by a
                    string and that it is not inspected during the filtering operation.
                    Consequently, the implementation of a p-faced collection is not dealing with any
                    tree structure. The implementation must provide for each node the representation
                    of a logical map in which one entry represents the node itself and the remaining
                    entries represent the names and values of properties. Configuration data include
                    the name of the entry representing the node and specify how the node (if
                    selected) is constructed from the string representing it. The string may be a
                    serialization of the node, or it may consist of locator information, either a
                    regular URI or a locator with implementation-defined semantics. </textual></para><para class="po-block e457 e457"><textual class="po-textual"> If the p-faced collection is “homogeneous” in the sense of every node having
                    the same external properties, a relational table is a straightforward choice. If
                    the nodes have different sets of properties, a NOSQL collection may be more
                    appropriate. An example for the latter case are log data, where each log entry
                    has some generic properties including an event type and further properties which
                    are event type-specific. An event of type “file-not-found” may have a property
                    “file-name”, whereas an event “container-delivered” may have properties
                    specifying a container-number and a location. </textual></para><para class="po-block e458 e458"><textual class="po-textual"> Configuration data are required in order to enable an XPath processor to
                    access the implementation of a p-faced collection: </textual><itemizedlist class="po-table e459 e459"><listitem class="po-container e460 e460"><para class="po-block e461 e461"><textual class="po-textual">the collection URI</textual></para></listitem><listitem class="po-container e462 e462"><para class="po-block e463 e463"><textual class="po-textual"> the implementation technology, implying the backend query
                                language to use </textual></para></listitem><listitem class="po-container e464 e464"><para class="po-block e465 e465"><textual class="po-textual"> connection data (e.g. database name and credentials and a
                                database table name, or the name of an object collection) </textual></para></listitem><listitem class="po-container e466 e466"><para class="po-block e467 e467"><textual class="po-textual"> the type of node representation (serialized node, or URI, or an
                                implementation-defined kind of locator) </textual></para></listitem></itemizedlist><textual class="po-textual">
                </textual></para></section><section class="po-hcontainer e468 e468" xml:id="pfc-collection-features"><title class="po-block e469 e469"><textual class="po-textual">Collection features</textual></title><para class="po-block e470 e470"><textual class="po-textual"> The model of a p-filter includes details which may not be well supported by a
                    particular technology which on the whole seems well-suited to implement p-faced
                    collections. For example, the used technology may not support … </textual><itemizedlist class="po-table e471 e471"><listitem class="po-container e472 e472"><para class="po-block e473 e473"><textual class="po-textual">the regular expression dialect used by XPath</textual></para></listitem><listitem class="po-container e474 e474"><para class="po-block e475 e475"><textual class="po-textual">case-sensitive property names</textual></para></listitem><listitem class="po-container e476 e476"><para class="po-block e477 e477"><textual class="po-textual">case-sensitive property values</textual></para></listitem><listitem class="po-container e478 e478"><para class="po-block e479 e479"><textual class="po-textual">property values with multiple items</textual></para></listitem><listitem class="po-container e480 e480"><para class="po-block e481 e481"><textual class="po-textual"> searches requiring all property value items to meet a
                                condition</textual></para></listitem></itemizedlist><textual class="po-textual"> Two perspectives must be distinguished: </textual><itemizedlist class="po-table e482 e482"><listitem class="po-container e483 e483"><para class="po-block e484 e484"><textual class="po-textual"> the collection provider – using a particular implementation
                                technology, his choices of property names and values may be limited
                            </textual></para></listitem><listitem class="po-container e485 e485"><para class="po-block e486 e486"><textual class="po-textual"> the collection user – certain aspects of selection may not be
                                supported </textual></para></listitem></itemizedlist><textual class="po-textual"> Defining the integration of p-faced collections into XPath, only
                    the second perspective is relevant, as it impacts the semantics of XPath
                    expressions. The first perspective may affect the names and values of
                    properties, but not the syntax and semantics of XPath expressions. Such
                    limitations are hidden from the collection user by the actual use of property
                    names and values. For example, if the technology excludes multiple property
                    values, the collection simply does not use multiple-valued properties; or if the
                    technology does not support case-sensitive property names or values, the
                    collection arbitrarily defines all property names to be lower case (or upper
                    case). </textual></para><para class="po-block e487 e487"><textual class="po-textual"> The concept of </textual><emphasis class="po-inline e488 e488" role="bold"><textual class="po-textual">collection features</textual></emphasis><textual class="po-textual"> is
                    introduced in order to enable a standardized representation of limitations, and
                    to enable a definition of conformance which can be achieved in spite of limited
                    support of the p-filter model. The following table presents a tentative set of
                    collection features.</textual><table class="po-container e489 e489"><caption class="po-container e490 e490"><para class="po-block e491 e491"><textual class="po-textual">
                                </textual><emphasis class="po-inline e492 e492" role="bold"><emphasis class="po-inline e493 e493" role="ital"><textual class="po-textual"> Collection features.
                                    </textual></emphasis></emphasis><textual class="po-textual">
                            </textual></para></caption><col align="left" class="po-meta e494 e494" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e495 e495" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e496 e496"><tr class="po-table e497 e497" valign="top"><th align="left" class="po-field e498 e498" valign="top"><textual class="po-textual">Collection feature</textual></th><th align="left" class="po-field e499 e499" valign="top"><textual class="po-textual">Description</textual></th><th align="left" class="po-field e500 e500" valign="top"><textual class="po-textual">Remark</textual></th></tr></thead><tbody class="po-table e501 e501"><tr class="po-table e502 e502" valign="top"><td class="po-block e503 e503"><textual class="po-textual">{operators}</textual></td><td class="po-block e504 e504"><textual class="po-textual">A list of supported operators. The list must contain the “=”
                                    operator, all other operators are optional.</textual></td><td class="po-block e505 e505"><textual class="po-textual">A p-filter must not use an operator not contained in
                                    {operators}.</textual></td></tr><tr class="po-table e506 e506" valign="top"><td class="po-block e507 e507"><textual class="po-textual">{every-supported}</textual></td><td class="po-block e508 e508"><textual class="po-textual">If </textual><code class="po-atom e509 e509"><textual class="po-textual">false</textual></code><textual class="po-textual">, a p-filter must not contain the
                                        </textual><code class="po-atom e510 e510"><textual class="po-textual">every</textual></code><textual class="po-textual"> quantifier.</textual></td><td class="po-block e511 e511"><textual class="po-textual">Every implementation must support the </textual><code class="po-atom e512 e512"><textual class="po-textual">some</textual></code><textual class="po-textual">
                                    quantifier.</textual></td></tr><tr class="po-table e513 e513" valign="top"><td class="po-block e514 e514"><textual class="po-textual">{multiple-test-supported}</textual></td><td class="po-block e515 e515"><textual class="po-textual">If </textual><code class="po-atom e516 e516"><textual class="po-textual">false</textual></code><textual class="po-textual">, a p-filter must not specify test values
                                    with multiple items.</textual></td><td class="po-block e517 e517"><textual class="po-textual">The use of multiple test values can be emulated using
                                        </textual><code class="po-atom e518 e518"><textual class="po-textual">p:or</textual></code><textual class="po-textual">.</textual></td></tr></tbody></table><textual class="po-textual">
                </textual></para></section></section></section><section class="po-hcontainer e519 e519"><title class="po-block e520 e520"><textual class="po-textual"> Pushing the boundaries of the info space </textual></title><para class="po-block e521 e521"><textual class="po-textual">The boundaries of the info space distinguish resources that belong to the space from
            resources that do not belong to the space. A resource is excluded from the info space
            for one of these reasons: </textual><itemizedlist class="po-table e522 e522"><listitem class="po-container e523 e523"><para class="po-block e524 e524"><textual class="po-textual">Physical inaccessibility</textual></para></listitem><listitem class="po-container e525 e525"><para class="po-block e526 e526"><textual class="po-textual">API-based inaccessibility</textual></para></listitem><listitem class="po-container e527 e527"><para class="po-block e528 e528"><textual class="po-textual">Media type-based inaccessibility</textual></para></listitem></itemizedlist><textual class="po-textual"> Physical access is out of scope. API-based inaccessibility is a target
            for extensions of the XPath function library. Media type-based inaccessibility presently
            amounts to the simple rule: XML resources are within, non-XML resources are not within
            the space. This is the basic weakness of the info space seen as an information
            architecture, and it is arguably the greatest challenge for a well-guided evolution of
            XML. Accordingly, this paper concentrates on the media type boundary and limits itself
            to a couple of notes concerning the API-based boundary. </textual></para><para class="po-block e529 e529"><textual class="po-textual"> The API-based boundary can be shifted by the introduction of new standard functions
            for accessing XML documents which are presently not accessible using
            </textual><code class="po-atom e530 e530"><textual class="po-textual">fn:doc</textual></code><textual class="po-textual">. These functions might address: </textual><itemizedlist class="po-table e531 e531"><listitem class="po-container e532 e532"><para class="po-block e533 e533"><textual class="po-textual">Documents requiring HTTP authorization</textual></para></listitem><listitem class="po-container e534 e534"><para class="po-block e535 e535"><textual class="po-textual">Documents requiring special HTTP header settings</textual></para></listitem><listitem class="po-container e536 e536"><para class="po-block e537 e537"><textual class="po-textual">Documents requiring the HTTP POST method</textual></para></listitem><listitem class="po-container e538 e538"><para class="po-block e539 e539"><textual class="po-textual">Documents within archives (e.g. zip)</textual></para></listitem></itemizedlist><textual class="po-textual"> Conceivable signatures would be (informally, for the sake of brevity):
            </textual><programlisting class="po-block e540 e540" xml:space="preserve"><textual class="po-textual">   httpDoc($uri, $username, $password, $headerFields, $body) as document-node() 
   zipDocs($uri, $directories, $namePatterns) as document-node()*</textual></programlisting><textual class="po-textual">
        </textual></para><section class="po-hcontainer e541 e541"><title class="po-block e542 e542"><textual class="po-textual">Model oriented resource representation</textual></title><para class="po-block e543 e543"><textual class="po-textual"> The most critical limitation of the info space is its commitment to the XML media
                type. The most important extension of the space can be achieved by overcoming this
                limitation.</textual></para><para class="po-block e544 e544"><textual class="po-textual"> An integration of non-XML resources into the info space is enabled by a
                consistent distinction between information and representation: between model and
                format. The basic principle of XML technology might be applied to non-XML resources:
                information </textual><emphasis class="po-inline e545 e545" role="ital"><textual class="po-textual">is</textual></emphasis><textual class="po-textual"> an instance of the data model. The
                info space can be extended by redefining non-XML formats to be </textual><emphasis class="po-inline e546 e546" role="ital"><textual class="po-textual">representations</textual></emphasis><textual class="po-textual"> of XDM node trees. </textual></para><para class="po-block e547 e547"><textual class="po-textual"> A format defined to represent node trees might be called a </textual><emphasis class="po-inline e548 e548" role="bold"><textual class="po-textual">model oriented resource representation</textual></emphasis><textual class="po-textual">: a resource is viewed as a
                unit of information which is captured by a model instance, and this instance is
                represented by the format. The format instance is an expression, the model instance
                its value. </textual></para><section class="po-hcontainer e549 e549"><title class="po-block e550 e550"><textual class="po-textual">Introductory example</textual></title><para class="po-block e551 e551"><textual class="po-textual"> Scenario: we want to check some country codes, we have access to a dictionary
                    of country codes and names, but this dictionary is represented by a CSV dataset. </textual></para><para class="po-block e552 e552"><textual class="po-textual"> Now let us assume there is a standardized XML vocabulary for table data,
                    comprising "table", "row" and "cell" elements. And we further assume the
                    existence of a new </textual><code class="po-atom e553 e553"><textual class="po-textual">fn:doc</textual></code><textual class="po-textual"> variant which delivers CSV data as an XML
                    node tree based on the table vocabulary. It enables us to select all invalid
                    country codes by a simple expression:
                    </textual><programlisting class="po-block e554 e554" xml:space="preserve"><textual class="po-textual">   doc("foo.xml")//countryCode
      [not(. = doc("countries.csv", "csv")//row/cell[1])]</textual></programlisting><textual class="po-textual">
                </textual></para><para class="po-block e555 e555"><textual class="po-textual"> This example demonstrates a seamless integration of data from XML and non-XML
                    resources: both participate in the info space. </textual></para></section><section class="po-hcontainer e556 e556" xml:id="generic-pattern-of-integration"><title class="po-block e557 e557"><textual class="po-textual">A generic pattern of integration</textual></title><para class="po-block e558 e558"><textual class="po-textual"> Let us assume that for a given data format F three sets of rules have been
                    defined: </textual><variablelist class="po-table e559 e559"><varlistentry class="po-record e560 e560"><term class="po-block e561 e561"><textual class="po-textual">R1</textual></term><listitem class="po-container e562 e562"><para class="po-block e563 e563"><textual class="po-textual">Rules how to map an instance of F to a node tree</textual></para></listitem></varlistentry><varlistentry class="po-record e564 e564"><term class="po-block e565 e565"><textual class="po-textual">R2</textual></term><listitem class="po-container e566 e566"><para class="po-block e567 e567"><textual class="po-textual">Rules how to map a node tree to an instance of F</textual></para></listitem></varlistentry><varlistentry class="po-record e568 e568"><term class="po-block e569 e569"><textual class="po-textual">R3</textual></term><listitem class="po-container e570 e570"><para class="po-block e571 e571"><textual class="po-textual">Rules how to decide whether a given node tree can or cannot be
                                    mapped to an instance of F </textual></para></listitem></varlistentry></variablelist><textual class="po-textual"> And let us further assume that these rules satisfy two
                    conditions: </textual><variablelist class="po-table e572 e572"><varlistentry class="po-record e573 e573"><term class="po-block e574 e574"><textual class="po-textual">C1</textual></term><listitem class="po-container e575 e575"><para class="po-block e576 e576"><textual class="po-textual">For any format instance G: R1(G) satisfies R3</textual></para></listitem></varlistentry><varlistentry class="po-record e577 e577"><term class="po-block e578 e578"><textual class="po-textual">C2</textual></term><listitem class="po-container e579 e579"><para class="po-block e580 e580"><textual class="po-textual">For any R3-conformant node tree N: R1(R2(N)) is deep-equal to
                                    N</textual></para></listitem></varlistentry></variablelist><textual class="po-textual"> where </textual><code class="po-atom e581 e581"><textual class="po-textual">R1(G)</textual></code><textual class="po-textual"> denotes the result of applying R1 to a
                    format instance G and </textual><code class="po-atom e582 e582"><textual class="po-textual">R2(N)</textual></code><textual class="po-textual"> denotes the result of applying R2 to a
                    node tree N. </textual></para><para class="po-block e583 e583"><textual class="po-textual"> C1 and C2 imply a constraint concerning round-tripping which starts with a
                    format instance G: the result is a format instance G' which is not necessarily
                    equal G but which is "FORMAT-deep-equal": R1(G) is deep-equal R1(G'). This
                    amounts to defining the information content of a format instance G: it is the
                    node tree provided by R1. Relying on this definition of information content,
                    instances of F can be safely evaluated or modified by evaluating or modifying
                    the corresponding node tree. This is the foundation of an integration of format
                    F into the info space. </textual></para><para class="po-block e584 e584"><textual class="po-textual"> A normative definition of rule sets R1, R2 and R3 enables the standardized
                    integration of a non-XML format into the info space. This requires two
                    extensions of the XML standards. The first extension is an XPath function which
                    parses an instance of the format into a node tree, reflecting R1. The second
                    change extends the XML serialization model [</textual><xref class="po-milestone e585 e585" linkend="w3c-serialization"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]
                    by the definition of a serialization to format F, reflecting R2 and R3. The
                    interface of serialization is accordingly extended by an additional value of the
                    serialization parameter </textual><code class="po-atom e586 e586"><textual class="po-textual">model</textual></code><textual class="po-textual">. </textual></para><para class="po-block e587 e587"><textual class="po-textual"> A concrete proposal for the required XPath function is the introduction of a
                    second variant of </textual><code class="po-atom e588 e588"><textual class="po-textual">fn:doc</textual></code><textual class="po-textual"> which has an additional parameter
                    specifying the source data format:
                    </textual><programlisting class="po-block e589 e589" xml:space="preserve"><textual class="po-textual">   fn:doc($uri as xs:string, $mediaType as xs:string) as document-node()</textual></programlisting><textual class="po-textual">
                    Assuming that rule sets have been standardized for the formats HTML, JSON, CSV,
                    SQL and CSS, access to non-XML resources might look like this:
                    </textual><programlisting class="po-block e590 e590" xml:space="preserve"><textual class="po-textual">   fn:doc("http://example.com/foo.htm", "htm")
   fn:doc("http://example.com/foo.jsn", "jsn")                        
   fn:doc("http://example.com/foo.csv", "csv")
   fn:doc("http://example.com/foo.sql", "sql")
   fn:doc("http://example.com/foo.css", "css")</textual></programlisting><textual class="po-textual">
                    The following sections explore how the rule sets govering parsing and
                    serialization may be defined. </textual></para></section><section class="po-hcontainer e591 e591"><title class="po-block e592 e592"><textual class="po-textual">Vocabulary based integration</textual></title><para class="po-block e593 e593"><textual class="po-textual"> Domain-specific languages (like SQL) and non-recursive generic formats (like
                    CSV) may be represented by a particular XML vocabulary. The formal definition of
                    such a vocabulary might comprise an XSD and a (possibly empty) set of additional
                    constraints expressible as XPath assertions. As a simple example, the vocabulary
                    for representing CSV data might be defined as a schema containing element
                    declarations with names like "table", "row" and "cell" as well as type
                    definitions constraining a </textual><code class="po-atom e594 e594"><textual class="po-textual">table</textual></code><textual class="po-textual"> element to have only
                        </textual><code class="po-atom e595 e595"><textual class="po-textual">row</textual></code><textual class="po-textual"> children and </textual><code class="po-atom e596 e596"><textual class="po-textual">row</textual></code><textual class="po-textual"> elements to have only
                        </textual><code class="po-atom e597 e597"><textual class="po-textual">cell</textual></code><textual class="po-textual"> children. An additional constraint might prescribe that
                    every </textual><code class="po-atom e598 e598"><textual class="po-textual">row</textual></code><textual class="po-textual"> element has the same number of cell children:
                    </textual><programlisting class="po-block e599 e599" xml:space="preserve"><textual class="po-textual">   count(distinct-values(//row/count(cell))) eq 1</textual></programlisting><textual class="po-textual">
                    As a second example, an SQL vocabulary might contain a specific element for each
                    SQL statement, with a content model designed to capture all information which
                    the SQL syntax may convey. </textual></para><para class="po-block e600 e600"><textual class="po-textual"> Wiki dialects are non-XML formats representing a node vocabulary (XHTML). The
                    motivation is of course not integration into the info space, but access to a
                    rendering processor. And here a format was added to an existing node vocabulary,
                    whereas integration adds a node vocabulary to an existing format. Nevertheless,
                    it is interesting to notice the popularity which a non-XML/HTML representation
                    of node trees can attain. Standardization work might take this phenomenon into
                    consideration. </textual></para></section><section class="po-hcontainer e601 e601"><title class="po-block e602 e602"><textual class="po-textual">Vocabulary-assisted integration</textual></title><para class="po-block e603 e603"><textual class="po-textual">Vocabulary-based integration is natural for formats which do not themselves
                    generate vocabularies as JSON does. Such a generative format might in principle
                    be mapped to a fixed XML vocabulary, by mapping the names supplied by the format
                    instance to XML </textual><emphasis class="po-inline e604 e604" role="ital"><textual class="po-textual">data</textual></emphasis><textual class="po-textual">, rather than to XML names.
                    However, if the format has a recursive structure – like JSON – the resulting XML
                    would look unnatural and be inconvenient to evaluate. Such a mapping would have
                    very limited practical value, and it would violate the concept of integration as
                    explained in </textual><link class="po-inline e605 e605" linkend="generic-pattern-of-integration" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        </textual><emphasis class="po-inline e606 e606" role="under"><textual class="po-textual">a generic pattern of integration</textual></emphasis></link><textual class="po-textual">.
                    The concept is based on regarding non-XML formats as alternative representations
                    of node trees, as if the node trees were the original information and the format
                    were a means to capture this information. If the node tree looks unnatural, the
                    image presupposes the desire to convey information which is unnaturally
                    structured in the first place, which is absurd. </textual></para><para class="po-block e607 e607"><textual class="po-textual"> If JSON is redefined to be the representation of node trees, these node trees
                    should probably capture JSON names by node names. Several approaches of mapping
                    JSON to XML have done that as far as possible (e.g. [</textual><xref class="po-milestone e608 e608" linkend="couthures"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e609 e609" linkend="basex-json"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e610 e610" linkend="hunter"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e611 e611" linkend="lee"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e612 e612" linkend="pemberton"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]) but they could not achieve
                    two goals: </textual><itemizedlist class="po-table e613 e613"><listitem class="po-container e614 e614"><para class="po-block e615 e615"><textual class="po-textual">Represent any JSON name by an equal node name</textual></para></listitem><listitem class="po-container e616 e616"><para class="po-block e617 e617"><textual class="po-textual">Renounce the use of XML nodes containing JSON-related control
                                information</textual></para></listitem></itemizedlist><textual class="po-textual"> The first problem arises from the fact that XML names are
                    QNames. The second problem reflects a mismatch of data models: whereas JSON uses
                    two distinct content models, one a map and the other a sequence of anonymous
                    items, XML has a single content model which is sequence-and-name based. The XML
                    model can be used to emulate the JSON models, but it cannot express them
                    natively. Those mapping approaches might be classified as vocabulary-assisted:
                    the bulk of items is named after their JSON counterparts, but a small additional
                    vocabulary is used in order to specify relationships between the nodes and their
                    JSON counterparts. These additional items prevent an evaluation of the node tree
                    from ignoring representations and only seeing the node tree itself. </textual></para></section><section class="po-hcontainer e618 e618"><title class="po-block e619 e619"><textual class="po-textual">Native integration</textual></title><para class="po-block e620 e620"><textual class="po-textual"> JSON is, like XML, recursively defined and generates vocabularies. The ideal
                    way to integrate it into the info space would be native integration: every JSON
                    instance should be the representation of a node tree which natively expresses
                    the JSON content, so that it can be serialized to JSON based on the node
                    properties only, without requiring the presence of additional nodes guiding the
                    serialization. Native integration of JSON is not possible due to differences of
                    the XML and JSON data models: the XML model is </textual><emphasis class="po-inline e621 e621" role="ital"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> a superset of the JSON model. </textual></para></section></section><section class="po-hcontainer e622 e622"><title class="po-block e623 e623"><textual class="po-textual">The extension of XML</textual></title><para class="po-block e624 e624"><textual class="po-textual">JSON is a very popular generic markup language. If the XML data model is not a
                superset of the JSON model, it must be questioned if the XML data model is qualified
                to define the info space - an information architecture not tied to a particular
                markup language. The XML data model is very expressive and allows representing
                virtually any tree-structured data as long as each node cannot have more than one
                parent. But in three cases (at least) a given structure must be emulated, rather
                than be expressed natively. Calling the data to be represented a source tree
                composed of nodes, these are: </textual><orderedlist class="po-table e625 e625"><listitem class="po-container e626 e626"><para class="po-block e627 e627"><textual class="po-textual">If a source node has a name which is not a valid QName, the XML node
                            has a different name.</textual></para></listitem><listitem class="po-container e628 e628"><para class="po-block e629 e629"><textual class="po-textual"> If a source node is anonymous, the XML node must nevertheless have a
                            name. </textual></para></listitem><listitem class="po-container e630 e630"><para class="po-block e631 e631"><textual class="po-textual"> If a source node has unordered content, the XML node cannot avoid
                            adding the information of a particular order – the data model does not
                            allow “switching off” the meaningfulness of order. </textual></para></listitem></orderedlist><textual class="po-textual"> The emulation may deal with arbitrary names either by mapping the
                original name to an NCName or by shifting the source name into data (e.g. an
                attribute). Anonymous nodes can be represented by nodes with an arbitrary name. The
                insignificance of order can be conveyed by out-of-band information. As long as one
                can start and end with XML, these workarounds are not perceived as serious issues.
                Likewise, as long as an initial JSON representation can be permanently replaced by
                XML, there is also no problem as the emulation provides semantic equivalence. But if
                there is a need to </textual><emphasis class="po-inline e632 e632" role="ital"><textual class="po-textual">maintain</textual></emphasis><textual class="po-textual"> a relationship between
                node tree and JSON representation, one discovers that there is no way to natively
                express arbitrary JSON data by an XML node tree. </textual></para><para class="po-block e633 e633"><textual class="po-textual"> (2) and (3) amount to a mismatch between XML and the dominant content model used
                in programming languages: which is a choice between sequence-based (an "array" of
                anonymous items) and key-based content ("map", "hash", etc.: an unordered collection
                of keyed items). XML has one single content model which is a curious hybrid:
                sequence+name based, which means the content is always ordered (array-like), but
                each sequence item has a name, which is key-like but not a key, as it is not
                required to be unique among the siblings. </textual></para><para class="po-block e634 e634"><textual class="po-textual"> The fact that virtually any tree-structured information can be emulated in XML
                has encouraged the view that the content model is sufficient. The fact that the
                content model is not as generic as it seems on first sight – that it is incapable of
                expressing natively arrays, maps and string-based names – has not yet caught much
                attention. This might change if the concept of an info space gains momentum. The
                concept implies a certain shift of priorities, attaching importance to a native
                representation of non-XML resources by the XML data model. Such a representation is
                required for seamless navigation: navigation which sees the information content (the
                model instance) and is unaware of future or past representations. </textual></para><section class="po-hcontainer e635 e635"><title class="po-block e636 e636"><textual class="po-textual">Extension of the XML data model</textual></title><para class="po-block e637 e637"><textual class="po-textual"> Rennau [</textual><xref class="po-milestone e638 e638" linkend="rennau"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] proposed an extension of the XML data model
                    which claims to enable a native representation of JSON data. The proposal
                    introduces the same boolean choice of content organization as is used in common
                    programming language like Java: a choice between the sequence based model (which
                    is the only model in current XML) and an alternative model which is truly
                    map-based: the child elements are unordered, and every child element has a
                    string-typed key – which is a new node property, [key]. The choice between the
                    two content models is made by each complex element, and therefore it is modeled
                    as a second new node property, [model]. It has two values, "sequence" and "map",
                    and the relationship between the two new properties is constrained as follows:
                    (a) an element with a non-null [key] must have a parent element with [model]
                    equal "map"; (b) an element with a null [key] must not have a parent element
                    with [model] equal "map". In other words: "map" elements have unordered children
                    which must have keys, and "sequence" elements have ordered children which must
                    not have keys.</textual></para><para class="po-block e639 e639"><textual class="po-textual"> Concerning the handling of anonymous items, Rennau proposed the introduction
                    of "unspecific standard names", but this is unsatisfactory, as it renounces the
                    goal of a genuinely native representation: the only natural representation of an
                    anonymous item is an anonymous item. Therefore we should modify the XML data
                    model by allowing anonymous elements. A JSON array would thus be an elegant
                    representation of an element node with [model] equal "sequence" and anonymous
                    child elements. </textual></para><para class="po-block e640 e640"><textual class="po-textual"> In summary, the following extensions of the XML data model should be
                    considered, as they promise to overcome the limitations which disqualify the
                    model as foundation of the info space: (a) addition of two new node properties,
                    [model] and [key]; (b) modification of the property [node-name], introducing the
                    possibility of a null value. </textual></para></section><section class="po-hcontainer e641 e641" xml:id="extension-xml-syntax"><title class="po-block e642 e642"><textual class="po-textual">Extension of the XML syntax</textual></title><para class="po-block e643 e643"><textual class="po-textual"> Introducing new node properties implies the necessity to define the
                    representation of these properties in XML syntax. Rennau proposed the use of
                    "pseudo attributes" which look like attributes but do not represent attribute
                    nodes, as they represent node properties: </textual><itemizedlist class="po-table e644 e644"><listitem class="po-container e645 e645"><para class="po-block e646 e646"><textual class="po-textual">udl:model - indicates the value of the [model] property</textual></para></listitem><listitem class="po-container e647 e647"><para class="po-block e648 e648"><textual class="po-textual">udl:key - indicates the value of the [key] property</textual></para></listitem></itemizedlist><textual class="po-textual"> where the prefix "udl" stands for "unified document language".
                    As a consequence, however, the XML representation of a JSON instance tends to be
                    cluttered with pseudo-attributes, which is perhaps a less important disadvantage
                    as it may seem, as the processing of JSON-supplied data is as elegant as the
                    processing of XML-supplied data (see below, </textual><emphasis class="po-inline e649 e649" role="under"><xref class="po-milestone e650 e650" linkend="xml-extension-xpath"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></emphasis><textual class="po-textual">) and the very info space
                    architecture encourages the use of JSON notation whereever it seems more
                    attractive than XML notation (see below, </textual><emphasis class="po-inline e651 e651" role="under"><xref class="po-milestone e652 e652" linkend="markup-integration"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></emphasis><textual class="po-textual">) . </textual></para><para class="po-block e653 e653"><textual class="po-textual"> However, a refusal to express the new node properties with the same
                    immediateness as the other properties is unsatisfactory. Pseudo-attributes are
                    an adequate representation of a node property when they can be expected to be
                    rare, as for example </textual><code class="po-atom e654 e654"><textual class="po-textual">xml:type</textual></code><textual class="po-textual"> attributes. However, knowing in
                    advance that the XML representation of JSON-supplied data will produce XML
                    documents which are studded with pseudo-attributes - rendering them hardly
                    readable - we are motivated to go a step further and truly extend the XML
                    syntax, introducing new syntax constructs. The goal is to ensure readable XML
                    representations also of such node trees as are constructed from JSON instances.
                    The following syntax extensions should therefore be considered: </textual><itemizedlist class="po-table e655 e655"><listitem class="po-container e656 e656"><para class="po-block e657 e657"><textual class="po-textual"> A special character preceding an element name indicates that its
                                [model] is "map", rather than "sequence". Example: &lt;~foo&gt; </textual></para></listitem><listitem class="po-container e658 e658"><para class="po-block e659 e659"><textual class="po-textual"> The key can be expressed within the element tag by the quoted key
                                value. Example: &lt;foo "2012"&gt; </textual></para></listitem><listitem class="po-container e660 e660"><para class="po-block e661 e661"><textual class="po-textual"> Anonymous elements which do not have a key use instead of an
                                element name a special character. Example: &lt;*&gt; </textual></para></listitem><listitem class="po-container e662 e662"><para class="po-block e663 e663"><textual class="po-textual"> Anonymous elements which do have a key are represented by
                                shifting the quoted key value to the beginning of the tag. Example:
                                &lt;"2012"&gt; </textual></para></listitem></itemizedlist><textual class="po-textual"> These rules would allow an acceptable representation of JSON
                    data in XML syntax. A special advantage is that a given information content –
                    e.g. a web service response – might then be served </textual><emphasis class="po-inline e664 e664" role="ital"><textual class="po-textual">without
                        changes</textual></emphasis><textual class="po-textual"> alternatively in JSON or XML. Example: </textual><programlisting class="po-block e665 e665" xml:space="preserve"><textual class="po-textual">   &lt;~getWeatherResponse&gt;
         &lt;"temperature min"&gt;28&lt;/"temperature min"&gt;
         &lt;"temperature max"&gt;32&lt;/"temperature max"&gt; 
   &lt;/~getWeatherResponse&gt;
                        
   {
      "temperature min" : 28,
      "temperature max" : 32
   }</textual></programlisting><textual class="po-textual"> To round these considerations off, a further detail of Rennau's proposal
                    which concerns the XML syntax should be retained: for elements which have a
                    parent element with [model] equal "map", the key defaults to the local name.
                    Therefore, a slight modification of the above example would look like this: </textual><programlisting class="po-block e666 e666" xml:space="preserve"><textual class="po-textual">   &lt;~getWeatherResponse&gt;
      &lt;temperatureMin&gt;28&lt;/temperatureMin&gt;
      &lt;temperatureMax&gt;32&lt;/temperatureMax&gt; 
   &lt;/~getWeatherResponse&gt;</textual></programlisting><textual class="po-textual"> In this variant the child elements are not any more
                    anonymous but have a local name equal to the key. </textual></para></section><section class="po-hcontainer e667 e667" xml:id="xml-extension-xpath" xreflabel="Extension of the XPath/XQuery language"><title class="po-block e668 e668"><textual class="po-textual">Extension of the XPath/XQuery language</textual></title><para class="po-block e669 e669"><textual class="po-textual"> Integration of non-XML resources into the info space is driven by the desire
                    to make them accessible to navigation and evaluation. The extension of the data
                    model by a new [key] property must therefore be mirrored by an extension of the
                    XPath semantics. Rennau proposed the introduction of a third node test, the "key
                    test" which functions in analogy to the name test: selecting elements with a
                    given key, rather than elements with a given name. Being a node test, the key
                    test is combined with navigational axes in the same way as a name test. The
                    syntax of a key test is a special character (proposed: "#") followed by the key
                    value within quotes. Examples:
                    </textual><programlisting class="po-block e670 e670" xml:space="preserve"><textual class="po-textual">   $response/#"temperature min"
   $response//#"2012"                        
   $item/ancestor-or-self::#"AC#A-2917"</textual></programlisting><textual class="po-textual">
                    Thanks to the key test, JSON-supplied data can be navigated with the same ease
                    as XML-supplied data, using key tests to select among object members and
                    conventional numerical predicates to select among array items:
                    </textual><programlisting class="po-block e671 e671" xml:space="preserve"><textual class="po-textual">   $response//#"weather"/#"temperatures"/*[3]</textual></programlisting><textual class="po-textual">
                </textual></para><para class="po-block e672 e672"><textual class="po-textual"> Whereas the key test provides for navigation, Rennau also proposed an
                    extension of XQuery which enables the construction of nodes using JSON syntax.
                    The extension is purely syntactical: an additional syntax which is a JSON-style
                    shorthand notation for the construction of nodes which, due to their properties,
                    correspond to JSON objects and arrays. For example, the following XQuery
                    constructor: </textual><programlisting class="po-block e673 e673" xml:space="preserve"><textual class="po-textual">   &lt;*&gt;
      &lt;"temperature min"&gt;{$min}&lt;/"temperature min"&gt;                        
      &lt;"temperature max"&gt;{$max}&lt;/"temperature max"&gt;
      &lt;"temperatures"&gt;{for $v in $values return &lt;*&gt;{$v}&lt;/*&gt;}&lt;/"temperatures"&gt;
   &lt;/*&gt;</textual></programlisting><textual class="po-textual"> can equivalently be written using JSON syntax: </textual><programlisting class="po-block e674 e674" xml:space="preserve"><textual class="po-textual">   {
      "temperature min" : $min,
      "temperature max" : $max,
      "temperatures" : [ $values ]
   }</textual></programlisting><textual class="po-textual"> The XQuery construction of JSON data using JSON syntax is as convenient as
                    the construction of XML data using XML syntax. Taken together, the proposed
                    extensions of XPath and XQuery ensure a complete integration of JSON into the
                    info space: </textual><itemizedlist class="po-table e675 e675"><listitem class="po-container e676 e676"><para class="po-block e677 e677"><textual class="po-textual"> JSON instances can be navigated as easily as any other node
                                trees. </textual></para></listitem><listitem class="po-container e678 e678"><para class="po-block e679 e679"><textual class="po-textual"> JSON instances can be constructed using JSON syntax. </textual></para></listitem></itemizedlist><textual class="po-textual">
                </textual></para></section></section><section class="po-hcontainer e680 e680" xml:id="markup-integration" xreflabel="Markup integration"><title class="po-block e681 e681"><textual class="po-textual">Markup integration</textual></title><para class="po-block e682 e682"><textual class="po-textual"> Every syntax which is defined to be the representation of a node tree might be
                integrated into XML markup. Provided that any section using non-XML syntax </textual><itemizedlist class="po-table e683 e683"><listitem class="po-container e684 e684"><para class="po-block e685 e685"><textual class="po-textual">identifies the syntax it uses</textual></para></listitem><listitem class="po-container e686 e686"><para class="po-block e687 e687"><textual class="po-textual">is clearly delimited</textual></para></listitem><listitem class="po-container e688 e688"><para class="po-block e689 e689"><textual class="po-textual">appears in a place where a sequence of elements might appear</textual></para></listitem></itemizedlist><textual class="po-textual"> the document text is guaranteed to be parsable into a node tree in
                an unambiguous way. Rennau proposed a restricted use of this new possibility which
                allows to provide </textual><emphasis class="po-inline e690 e690" role="ital"><textual class="po-textual">element contents</textual></emphasis><textual class="po-textual"> in non-XML
                syntax. The proposal is to introduce a pseudo-attribute (</textual><code class="po-atom e691 e691"><textual class="po-textual">udl:markup</textual></code><textual class="po-textual">)
                which identifies the syntax used to encode the element content. As a consequence,
                the following text would be a valid XML document: </textual><programlisting class="po-block e692 e692" xml:space="preserve"><textual class="po-textual">   &lt;~getWeatherResponse udl:markup="json"&gt;
      "temperature min" : 28,
      "temperature max" : 32
      "temperatures" : [28, 28, 30, 32, 31]
   &lt;/~getWeatherResponse&gt;</textual></programlisting><textual class="po-textual"> Note that the </textual><code class="po-atom e693 e693"><textual class="po-textual">getWeatherResponse</textual></code><textual class="po-textual"> element
                has three child elements, as the content of an element with
                    </textual><code class="po-atom e694 e694"><textual class="po-textual">udl:markup='...'</textual></code><textual class="po-textual"> is defined to be the nodes resulting from parsing
                the text found between start tag and end tag according to the parsing rules for
                format '...'. </textual></para></section></section><section class="po-hcontainer e695 e695"><title class="po-block e696 e696"><textual class="po-textual">Wrapping up</textual></title><para class="po-block e697 e697"><textual class="po-textual"> The info space is an information architecture consisting of distributed resources
            whose information content is defined to be a node tree, understood as an instance of the
            (slightly extended) XDM data model. The resources are identified by URIs and accessed by
            XPath functions (</textual><code class="po-atom e698 e698"><textual class="po-textual">fn:doc</textual></code><textual class="po-textual">, </textual><code class="po-atom e699 e699"><textual class="po-textual">fn:httpDoc</textual></code><textual class="po-textual">, ...) which hide the
            actual data formats and expose the node structure. Taken together, the node structure of
            all accessible resources provides a uniform substrate for navigation and discovery. </textual></para><para class="po-block e700 e700"><textual class="po-textual"> It should be noted that the concept of a "resource" as used in the info space model
            is different from the use in Fielding's REST model [</textual><xref class="po-milestone e701 e701" linkend="fielding"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The
            latter defines a resource as a conceptual unit whose mapping to concrete representations
            is a function of time. The resources of the info space are units of information which
            are </textual><emphasis class="po-inline e702 e702" role="ital"><textual class="po-textual">values</textual></emphasis><textual class="po-textual">, precisely defined in terms of a node tree.
            As such, they are more closely related to Fielding's concept of a resource
            representation than to his concept of a resource. On the other hand, the insistence on a
            well-defined </textual><emphasis class="po-inline e703 e703" role="ital"><textual class="po-textual">information content</textual></emphasis><textual class="po-textual"> is in sharp contrast
            with Fielding's model, in which there is no place for such a thing. Resources of the
            info space are the accessible resource representations (in Fielding's sense) which can
            be resolved to a node tree. As such, the info space is a </textual><emphasis class="po-inline e704 e704" role="ital"><textual class="po-textual">snapshot</textual></emphasis><textual class="po-textual"> of all accessible resource representations (in Fielding's
            sense) which have a media type defined to represent a node tree, according to the
            standardizations endorsed by the W3C. </textual></para><para class="po-block e705 e705"><textual class="po-textual"> Fielding's REST model is aimed at an architecture for the internet, understood as a
            distributed hypermedia system. His view of resource navigation assumes a model of
            application behaviour in which the rendering of resource representations powers
            subsequent navigation by supplying embedded links. The info space model, on the other
            hand, is unconcerned with application behaviour and paints a picture in which nothing
            appears but information, aggregated into distinct resources and nevertheless coalesced
            into a single, homogeneous substrate of information. Embedded links are predefined
            point-to-point connections. The connectivity of the info space, however, relies on XPath
            navigation, which is like an ubiquitous field of possibility, potentially leading from
            anywhere to anywhere. Therefore the info space is not a net but more like a space: it
            integrates anything (any resource) appearing within it.</textual></para><para class="po-block e706 e706"><textual class="po-textual"> The info space integrates information on a global scale, relying on a 
            uniform data model. The same can be said about RDF [</textual><xref class="po-milestone e707 e707" linkend="w3c-rdf"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. 
            What is the relationship
            between the XML info space and RDF? RDF is about 
            </textual><emphasis class="po-inline e708 e708" role="ital"><textual class="po-textual">semantic integration</textual></emphasis><textual class="po-textual">,
            establishing the identities of real world resources described
            by the data. The RDF data model is designed to enable the
            assembling of distributed items into synthetic descriptions,
            which are organized by the identities of the described
            resources. </textual></para><para class="po-block e709 e709"><textual class="po-textual"> The XML info space, on the other hand, is about 
            </textual><emphasis class="po-inline e710 e710" role="ital"><textual class="po-textual">navigational integration</textual></emphasis><textual class="po-textual">, offering
            it as a possible foundation for semantic integration. The semantic integration
            is left to applications which are supposed to understand
            the trees they are dealing with as a coherent, structured unit - 
            rather than regarding them as a
            "mine" from which to undig self-contained items of information (triples).
            Such a dealing with </textual><emphasis class="po-inline e711 e711" role="ital"><textual class="po-textual">well-understood resources</textual></emphasis><textual class="po-textual">
            is the typical task of conventional applications. They know
            what to do with, say, /a/b/c taken from one resource and with
            /x/y/z taken from another resource, and how they are related. 
            For such applications the benefit of simple and efficient 
            navigation is probably
            greater than the benefit of further aids how to find out those
            meanings and relationships. Therefore conventional
            applications 
            may profit from the navigational info space
            immensely and probably far less from the semantic space created by RDF.
            Nevertheless, there may be a wonderful synergy between the
            XML space and the RDF space yet to be explored.</textual></para></section><bibliography class="po-hcontainer e712 e712"><title class="po-block e713 e713"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e714 e714" xml:id="w3c-xpath" xreflabel="1"><textual class="po-textual">Berglund, Anders et al, eds. XML Path Language
            (XPath) 2.0 (Second Edition). W3C Recommendation 14 November 2010. </textual><link class="po-inline e715 e715" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath20/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath20/</textual></link></bibliomixed><bibliomixed class="po-block e716 e716" xml:id="w3c-xdm" xreflabel="2"><textual class="po-textual">Berglund, Anders et al, eds. XQuery 1.0 and
            XPath 2.0 Data Model (XDM) (Second Edition). W3C Recommendation 23 January 2007. </textual><link class="po-inline e717 e717" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel/</textual></link></bibliomixed><bibliomixed class="po-block e718 e718" xml:id="uri" xreflabel="3"><textual class="po-textual">Berners-Lee, Tim et al. Uniform Resource Identifier
            (URI): Generic Syntax. Network Working Group, Request for Comments: 3986. January 2005.
                </textual><link class="po-inline e719 e719" xlink:actuate="onRequest" xlink:href="http://tools.ietf.org/html/rfc3986" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/rfc3986</textual></link></bibliomixed><bibliomixed class="po-block e720 e720" xml:id="w3c-xquery" xreflabel="4"><textual class="po-textual">Boag, Scott et al, eds. XQuery 1.0: An XML
            Query Language (Second Edition). W3C Recommendation 14 December 2010. </textual><link class="po-inline e721 e721" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery/</textual></link></bibliomixed><bibliomixed class="po-block e722 e722" xml:id="w3c-serialization" xreflabel="5"><textual class="po-textual">Boag, Scott et al, eds. XSLT 2.0 and
            XQuery 1.0 Serialization (Second Edition). W3C Recommendation 14 December 2010. </textual><link class="po-inline e723 e723" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-xquery-serialization/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt-xquery-serialization/</textual></link></bibliomixed><bibliomixed class="po-block e724 e724" xml:id="w3c-xml" xreflabel="6"><textual class="po-textual">Bray, Tim et al, eds. Extensible Markup Language
            (XML) 1.0 (Fifth Edition). W3C Recommendation 26 November 2008. </textual><link class="po-inline e725 e725" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/REC-xml/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/REC-xml/</textual></link></bibliomixed><bibliomixed class="po-block e726 e726" xml:id="couthures" xreflabel="7"><textual class="po-textual">Couthures, Alain. JSON for XForms - adding
            JSON support in XForms data instances. XML Prague 2011, Conference Proceedings, p.
            13-24. </textual><link class="po-inline e727 e727" xlink:actuate="onRequest" xlink:href="http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</textual></link><textual class="po-textual">
            .</textual></bibliomixed><bibliomixed class="po-block e728 e728" xml:id="w3c-infoset" xreflabel="8"><textual class="po-textual">Cowan, John &amp; Tobin R., eds. XML
            Information Set (Second Edition). W3C Recommendation 4 February 2004. </textual><link class="po-inline e729 e729" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml-infoset/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml-infoset/</textual></link></bibliomixed><bibliomixed class="po-block e730 e730" xml:id="w3c-xlink" xreflabel="9"><textual class="po-textual">DeRose, Steve et al, eds. XML Linking Language
            (XLink) Version 1.1. W3C Recommendation 6 May 2010. </textual><link class="po-inline e731 e731" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xlink11/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xlink11/</textual></link></bibliomixed><bibliomixed class="po-block e732 e732" xml:id="einstein" xreflabel="10"><textual class="po-textual">Einstein, Albert &amp; Infield, L. The
            evolution of physics. Edited by C.P. Snow. Cambridge University Press, ASIN: B000S52QZ4,
            1938 </textual><link class="po-inline e733 e733" xlink:actuate="onRequest" xlink:href="http://archive.org/details/evolutionofphysi033254mbp" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://archive.org/details/evolutionofphysi033254mbp</textual></link><textual class="po-textual">
            .</textual></bibliomixed><bibliomixed class="po-block e734 e734" xml:id="fielding" xreflabel="11"><textual class="po-textual">Fielding, Roy T. Architectural Styles and the
            Design of Network-based Software Architectures. Ph.D. Dissertation, University of
            California, Irvine, 2000. </textual><link class="po-inline e735 e735" xlink:actuate="onRequest" xlink:href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</textual></link><textual class="po-textual">
            .</textual></bibliomixed><bibliomixed class="po-block e736 e736" xml:id="basex-json" xreflabel="12"><textual class="po-textual">Gruen, Christian, et al. BaseX Documentation
            Version 7.3, section "JSON Module", p. 161-166. </textual><link class="po-inline e737 e737" xlink:actuate="onRequest" xlink:href="http://docs.basex.org/wiki/Main_Page" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.basex.org/wiki/Main_Page</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e738 e738" xml:id="hunter" xreflabel="13"><textual class="po-textual">Hunter, Jason. A JSON facade on MarkLogic
            Server. XML Prague 2011, Conference Proceedings, p. 25-34. </textual><link class="po-inline e739 e739" xlink:actuate="onRequest" xlink:href="http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e740 e740" xml:id="lee" xreflabel="14"><textual class="po-textual">Lee, David A. JXON: an Architecture for Schema and
            Annotation Driven JSON/XML Bidirectional Transformations. Presented at Balisage: The
            Markup Conference 2011, Montréal, Canada, August 2 - 5, 2011. In Proceedings of
            Balisage: The Markup Conference 2011. Balisage Series on Markup Technologies, vol. 7
            (2011). doi:</textual><biblioid class="po-atom e741 doi e741"><textual class="po-textual">10.4242/BalisageVol7.Lee01</textual></biblioid><textual class="po-textual">. </textual><link class="po-inline e742 e742" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e743 e743" xml:id="w3c-rdf" xreflabel="15"><textual class="po-textual">Manola, Frank &amp; Miller E., eds. RDF Primer. 
            W3C Recommendation 10 February 2004. </textual><link class="po-inline e744 e744" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/rdf-primer/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/rdf-primer/</textual></link></bibliomixed><bibliomixed class="po-block e745 e745" xml:id="pemberton" xreflabel="16"><textual class="po-textual">Pemberton, Steven. Treating JSON as a subset
            of XML. XML Prague 2012, Conference Proceedings, p. 81-90. </textual><link class="po-inline e746 e746" xlink:actuate="onRequest" xlink:href="http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e747 e747" xml:id="rennau" xreflabel="17"><textual class="po-textual">Rennau, Hans-Jürgen. "From XML to UDL: a unified
            document language, supporting multiple markup languages." Presented at Balisage: The
            Markup Conference 2012, Montréal, Canada, August 7 - 10, 2012. In Proceedings of
            Balisage: The Markup Conference 2012. Balisage Series on Markup Technologies, vol. 8
            (2012). doi:</textual><biblioid class="po-atom e748 doi e748"><textual class="po-textual">10.4242/BalisageVol8.Rennau01</textual></biblioid><textual class="po-textual">. </textual><link class="po-inline e749 e749" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol8/html/Rennau01/BalisageVol8-Rennau01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol8/html/Rennau01/BalisageVol8-Rennau01.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e750 e750" xml:id="xml-catalog" xreflabel="18"><textual class="po-textual">Walsh, Norman, ed. XML Catalogs. OASIS
            Standard V1.1, 7 October 2005. </textual><link class="po-inline e751 e751" xlink:actuate="onRequest" xlink:href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e752 e752" xml:id="json" xreflabel="19"><textual class="po-textual">Web resource without source information:
            Introducing JSON. </textual><link class="po-inline e753 e753" xlink:actuate="onRequest" xlink:href="http://json.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://json.org</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>