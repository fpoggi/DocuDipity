<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="Bal2010Lewi0417"><title class="po-block e1 e1"><textual class="po-textual">gXML, a New Approach to Cultivating XML Trees in Java</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2010</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 3 - 6, 2010</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">A number of issues facing the use of XML tree models in Java
                are enumerated: multiplicity, interoperability, variability,
                and weight.  The gXML API, following the </textual><emphasis class="po-inline e8 e8"><textual class="po-textual">Handle/Body</textual></emphasis><textual class="po-textual">
                design pattern and conforming to the XQuery Data Model specification
                </textual><xref class="po-milestone e9 e9" linkend="XDM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, is
                proposed as a solution to these problems, and as a platform for
                advancing the state of the art for XML in Java.  gXML is not
                a new tree model, but a unified API and model following a
                rigorous, external specification, which can be used with any
                tree model for which a "bridge" has been developed.  Applications
                and processors targeting the gXML API may then use any supported
                tree model, as appropriate for the task.</textual></para></abstract><author class="po-record e10 e10"><personname class="po-record e11 e11"><firstname class="po-field e12 e12"><textual class="po-textual">Amelia</textual></firstname><othername class="po-field e13 e13"><textual class="po-textual">A.</textual></othername><surname class="po-field e14 e14"><textual class="po-textual">Lewis</textual></surname></personname><personblurb class="po-container e15 e15"><para class="po-block e16 e16"><textual class="po-textual">Amelia Lewis is a senior architect with the TIBCO/Extensibility
                division of TIBCO Software Inc.  Her primary focus, since 2000,
                has been XML technologies, inside and outside TIBCO.  She has
                been active in a variety of XML-related specifications efforts
                and developer-oriented XML mailing lists; she has extensive
                experience with implementation of a variety of XML technologies,
                using most of the tree models mentioned in this paper.</textual></para></personblurb><affiliation class="po-record e17 e17"><jobtitle class="po-field e18 e18"><textual class="po-textual">Senior Architect</textual></jobtitle><orgname class="po-block e19 e19"><textual class="po-textual">TIBCO Software Inc.</textual></orgname></affiliation><email class="po-field e20 e20"><textual class="po-textual">alewis@tibco.com</textual></email></author><author class="po-record e21 e21"><personname class="po-record e22 e22"><firstname class="po-field e23 e23"><textual class="po-textual">Eric</textual></firstname><othername class="po-field e24 e24"><textual class="po-textual">E.</textual></othername><surname class="po-field e25 e25"><textual class="po-textual">Johnson</textual></surname></personname><personblurb class="po-container e26 e26"><para class="po-block e27 e27"><textual class="po-textual">Eric Johnson is a principal architect at TIBCO Software Inc. Eric joined TIBCO
                in 2000, a part of TIBCO's acquisition of Extensibility, an XML tools company.
                While Eric now works in a variety of areas, including governance, build
                architecture, and various standards including SOAP/JMS, SCA, and OSGi, he has
                also maintained a strong interest in improving the core technologies that
                TIBCO uses, especially those related to XML.</textual></para></personblurb><affiliation class="po-record e28 e28"><jobtitle class="po-field e29 e29"><textual class="po-textual">Principal Architect</textual></jobtitle><orgname class="po-block e30 e30"><textual class="po-textual">TIBCO Software Inc.</textual></orgname></affiliation><email class="po-field e31 e31"><textual class="po-textual">eric@tibco.com</textual></email></author><legalnotice class="po-container e32 e32"><para class="po-block e33 e33"><textual class="po-textual">Copyright Â© 2010 TIBCO Software Inc.  All rights reserved.</textual></para></legalnotice><keywordset class="po-table e34 e34" role="author"><keyword class="po-field e35 e35"><textual class="po-textual">XQuery Data Model</textual></keyword><keyword class="po-field e36 e36"><textual class="po-textual">Handle/Body design pattern</textual></keyword><keyword class="po-field e37 e37"><textual class="po-textual">Document Object Model</textual></keyword><keyword class="po-field e38 e38"><textual class="po-textual">DOM</textual></keyword><keyword class="po-field e39 e39"><textual class="po-textual">JDOM</textual></keyword><keyword class="po-field e40 e40"><textual class="po-textual">DOM4J</textual></keyword><keyword class="po-field e41 e41"><textual class="po-textual">AxiOM</textual></keyword><keyword class="po-field e42 e42"><textual class="po-textual">XOM</textual></keyword><keyword class="po-field e43 e43"><textual class="po-textual">XPath</textual></keyword><keyword class="po-field e44 e44"><textual class="po-textual">XML Infoset</textual></keyword></keywordset></info><note class="po-container e45 e45" xml:id="acknowledgements"><title class="po-block e46 e46"><textual class="po-textual">Acknowledgements</textual></title><para class="po-block e47 e47"><textual class="po-textual">This paper describes concepts and source code originally
        developed by David G. Holmes, formerly of TIBCO Software Inc., without
        whose innovation and energy neither the paper nor the material that it
        describes would be possible.  David was the senior architect responsible
        for driving the development (over several iterations) of the gXML
        code base, and the original advocate of opening the source.</textual></para></note><section class="po-hcontainer e48 e48" xml:id="introduction"><title class="po-block e49 e49"><textual class="po-textual">The Problem(s) with XML Tree APIs in Java</textual></title><para class="po-block e50 e50"><textual class="po-textual">Java was one of the first major programming languages with support for
XML. It was one of the targets for the Interface Definition Language modules
that were developed as the basis of the Document Object Model </textual><xref class="po-milestone e51 e51" linkend="DOM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Early adoption helped to prove the capabilities of both XML
and of Java, but as might be expected, early adoption also has its drawbacks.
A number of developers using XML in Java have noted these problems. For
instance, Dennis Sosnoski compared a number of tree models in a two-part
investigation in 2001 and 2002 (see "XML and Java technologies: Document
models, Part 1: Performance" </textual><xref class="po-milestone e52 e52" linkend="DMPerf"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and "XML and Java
technologies: Java Document Model Usage" </textual><xref class="po-milestone e53 e53" linkend="DMUse"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). More
recently, Elliotte Harold documented "What's Wrong with XML APIs" </textual><xref class="po-milestone e54 e54" linkend="WhatsWrong"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> as part of the development of the XOM </textual><xref class="po-milestone e55 e55" linkend="XOM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> API. This analysis falls into that tradition, though it does not agree
wholly with the previous analyses. We identify four classes of problem with
existing tree model APIs.</textual></para><para class="po-block e56 e56"><textual class="po-textual">The first problem is </textual><emphasis class="po-inline e57 e57"><textual class="po-textual">multiplicity</textual></emphasis><textual class="po-textual">. For a variety of
reasons, Java developers have not, on the whole, been enthusiastic partisans
of the DOM. Alternatives were proposed early; Xalan </textual><xref class="po-milestone e58 e58" linkend="Xalan"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,
one of the major early XSLT processors, defined its own internal XML tree
model (the Data Table Model </textual><xref class="po-milestone e59 e59" linkend="XalanDTM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) in preference to
using the DOM. At present, there are at least five well-known tree models for
XML in Java: DOM </textual><xref class="po-milestone e60 e60" linkend="DOM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, JDOM </textual><xref class="po-milestone e61 e61" linkend="JDOM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, DOM4J
</textual><xref class="po-milestone e62 e62" linkend="DOM4J"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, XOM </textual><xref class="po-milestone e63 e63" linkend="XOM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, and AxiOM </textual><xref class="po-milestone e64 e64" linkend="AxiOM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, as well as an unknown number of proprietary APIs to the
same purpose (the authors of this paper know of at least six such private
APIs). Applications and processors written for one of these models are
generally not usable with other models.</textual></para><para class="po-block e65 e65"><textual class="po-textual">The second problem is </textual><emphasis class="po-inline e66 e66"><textual class="po-textual">interoperability</textual></emphasis><textual class="po-textual">. The first
tree model to appear on the scene has had a first mover advantage. Subsequent
tree model designs have intended to address the shortcomings of the DOM, but
not to interoperate with it (note that both DOM4J and AxiOM later added
optional DOM interface implementations to address this
problemâaccepting the disadvantages of the DOM in order to achieve
compatibility in this mode). Knowledge of the tricks and optimizations
appropriate to one model do not transfer to other tree models. Though the
successor models have all positioned themselves as better solutions than the
DOM, they have not been adopted as widely. This is most likely due to the
DOM's first mover advantage, and the consequent network effect: although other
models may have technical advantages that make them more suitable than the DOM
for a given application, in order to use those new models efficiently within
the JVM, all parts of the application need to use the same tree model.
Developers must solve a cruel equation in which the marginal benefits of
switching from the DOM are typically low, whereas the marginal costs are
always high. The alternatives seem to be to write multiple code paths to
achieve the same purpose (with different tree models), or to wrap each node of
each tree model in an application-specific abstraction. Some projects, such as
Woden </textual><xref class="po-milestone e67 e67" linkend="Woden"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and Jaxen </textual><xref class="po-milestone e68 e68" linkend="Jaxen"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, have taken one
or the other of these approaches in preference to adopting the DOM as the sole
programming model.</textual></para><para class="po-block e69 e69"><textual class="po-textual">The DOM, as the first XML tree model for Java, established the universe of
discussion for design of tree models. Development of the DOM preceded the
</textual><emphasis class="po-inline e70 e70"><textual class="po-textual">Namespaces in XML</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e71 e71" linkend="XMLNS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and
</textual><emphasis class="po-inline e72 e72"><textual class="po-textual">XML Infoset</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e73 e73" linkend="Infoset"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> specifications.
For backward compatibility, the DOM could never enforce these specifications,
though it could enable them. Further development of the DOM may be
characterized as too closely approaching the </textual><emphasis class="po-inline e74 e74"><textual class="po-textual">Lava Flow</textual></emphasis><textual class="po-textual">
</textual><xref class="po-milestone e75 e75" linkend="LavaFlow"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> anti-pattern. Indeed, the DOM exposes fifteen
"basic" abstractions (node types), compared to eleven in the Infoset, and
seven in the XDM. Successor APIs have generally targeted the Infoset, but with
widely varying interpretations. This is the problem of </textual><emphasis class="po-inline e76 e76"><textual class="po-textual">
variability</textual></emphasis><textual class="po-textual">. Each model exposes different property sets. The
boundaries between lexical, syntactic, and semantic are drawn at different
points. One consequence of this variability is that it is difficult or awkward
to add support for specifications "higher in the stack." For instance, XPath
1.0 </textual><xref class="po-milestone e77 e77" linkend="XPath1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and XSLT 1.0 </textual><xref class="po-milestone e78 e78" linkend="XSLT1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> work
perfectly adequately as external tools (one per tree model, or by generalizing
the concept of "Node" to "Object"), and some models have built-in support (at
least for XPath). XML Schema support (see </textual><xref class="po-milestone e79 e79" linkend="WXS1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e80 e80" linkend="WXS2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) is rarely foundâa DOM Level 3 module supports it,
but in a fashion that is not noted for ease of use, and the module is not
widely implemented. Similar situations exist for specifications such as XQuery
1.0, XPath 2.0, and XSLT 2.0. Even SOAP/XMLP is arguably under-supported.
AxiOM, after all, is an entire XML tree model built largely so that the SOAP
abstractions could be represented cleanly as extensions.</textual></para><para class="po-block e81 e81"><textual class="po-textual">Finally, the problem of </textual><emphasis class="po-inline e82 e82"><textual class="po-textual">weight</textual></emphasis><textual class="po-textual"> plagues most of
these tree models. The DOM itself is notoriously heavyweight, typically occupying
</textual><link class="po-inline e83 e83" xlink:actuate="onRequest" xlink:href="http://www.cafeconleche.org/books/xmljava/chapters/ch09s05.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">three to ten times the space</textual></link><textual class="po-textual">, in memory, that theâalready
verboseâXML occupies as a character stream, according to Harold's
</textual><emphasis class="po-inline e84 e84"><textual class="po-textual">Processing XML with Java</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e85 e85" linkend="XMLInJava"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
Sucessor models have done better in this area. Dennis Sosnoski's evaluation,
"Document Models Part 1: Performance" </textual><xref class="po-milestone e86 e86" linkend="DMPerf"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, though dated,
provides an excellent illustration of this problem. A large part of the
problem lies in the unrestricted mutability of these models. All of the
prominent XML tree models for Java must restrict programming to serial,
synchronous access. A mutable tree model is effectively a mutable collection,
so any changes made to it by a single writer may have disastrous effects upon
multiple readers. Issues of weight cannot easily be addressed by storing the
bulk of the document on disk, or by concurrent processing, because the
document may be modified during processing.</textual></para><para class="po-block e87 e87"><textual class="po-textual">There are alternatives: applications and processors with higher
performance requirements are often written to abstractions that do not model
XML as a tree, such as SAX, StAX, or XML data binding (in its various
flavors). Sosnoski's article discusses some of these alternatives; Harold's
presentation also notes both advantages and disadvantages. The chief drawback
to these approaches is that they expose paradigms which are not as easily or
intuitively understood as the tree model, which are more of a challenge for
some developers. A tree model is preferred. A single model for navigation and
interrogation seems best. To date, attempts to create this single model have
proven suboptimal in most environments.</textual></para></section><section class="po-hcontainer e88 e88" xml:id="gxml-overview"><title class="po-block e89 e89"><textual class="po-textual">gXML Design Considerations</textual></title><para class="po-block e90 e90"><textual class="po-textual">gXML is a new API for analyzing, creating, and manipulating XML in Java.
It embodies the XQuery Data Model, and is consequently a tree-oriented API,
but it does not introduce a new tree model comparable to existing models.
Instead, it is intended to run over existing tree models, and to permit the
introduction of new, specialized models optimized for a particular purpose.
Its design rests on four pillars: the </textual><emphasis class="po-inline e91 e91"><textual class="po-textual">Handle/Body</textual></emphasis><textual class="po-textual"> design
pattern, Java generics, the XQuery Data Model, and immutability for XML
processing as a paradigm.  These four principles answer the four problems
outlined above.</textual></para><section class="po-hcontainer e92 e92" xml:id="gxml-handle-body"><title class="po-block e93 e93"><textual class="po-textual">The Handle/Body Pattern</textual></title><para class="po-block e94 e94"><textual class="po-textual">gXML makes extensive use of the </textual><emphasis class="po-inline e95 e95"><textual class="po-textual">Handle/Body</textual></emphasis><textual class="po-textual"> pattern
(called the </textual><emphasis class="po-inline e96 e96"><textual class="po-textual">Bridge</textual></emphasis><textual class="po-textual"> pattern in </textual><emphasis class="po-inline e97 e97"><textual class="po-textual">Design
Patterns</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e98 e98" linkend="GOF"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). This pattern provides a
well-defined set of operations over an abstraction (the handle), which may
then be adapted to specific implementations (the body). For gXML, the primary
"handles" are the Model or Cursor, the Processing Context, the Node Factory in
the mutable API, and the type (Meta) and typed-value (Atom) Bridges in the
schema-aware API.</textual></para><para class="po-block e99 e99"><textual class="po-textual">When presenting gXML to a new audience, one of the most common stumbling
points is the distinction between </textual><emphasis class="po-inline e100 e100"><textual class="po-textual">Handle/Body</textual></emphasis><textual class="po-textual"> and
</textual><emphasis class="po-inline e101 e101"><textual class="po-textual">Wrapper</textual></emphasis><textual class="po-textual"> (called </textual><emphasis class="po-inline e102 e102"><textual class="po-textual">Facade</textual></emphasis><textual class="po-textual"> in
</textual><emphasis class="po-inline e103 e103"><textual class="po-textual">Design Patterns</textual></emphasis><textual class="po-textual">). gXML </textual><emphasis class="po-inline e104 e104"><textual class="po-textual">does not</textual></emphasis><textual class="po-textual"> wrap
every node in the tree. Applications and processors are presented with one new
abstraction, represented by a single instance (a
</textual><emphasis class="po-inline e105 e105"><textual class="po-textual">Singleton</textual></emphasis><textual class="po-textual"> for model, or a single instance per tree for
cursor). gXML adds very little weight to the existing tree model, compared to
the significant additional weight added by the necessity to wrap every node in
a tree. Although there is a cost (in memory and performance) to using the
handles rather than directly manipulating the bodies, the benefits (in
flexibility and capability) are more nearly commensurate: in exchange for a
memory/performance impact measured in low single-digit percentages (for most tree
model APIs), an application or processor gains the ability to manipulate all
supported tree model APIs (currently three; more are anticipated).</textual></para><para class="po-block e106 e106"><textual class="po-textual">There are a number of attractive consequences of using
this design pattern. First, since applications and processors need not write
separate code paths for different tree models, these models can be injected
very late, even at runtime. That suggests that they can be compared, based on
the application's or processor's requirements, and the tree model best suited
to the problem at hand preferred. It also suggests that application and
processor developers might have a sounder foundation to suggest improvements
to developers of the models. Second, by bringing peace to these warring
models, by allowing developers to choose a model based on technical merits
</textual><emphasis class="po-inline e107 e107"><textual class="po-textual">without</textual></emphasis><textual class="po-textual"> considering the importance of the network effect
for the DOM, gXML also enables the creation of "niche" tree models for XML, models
designed and optimized for particular use cases. In other words, by always
using these handles for access, special-purpose bodies become more practical.
These topics will be revisited in </textual><xref class="po-milestone e108 e108" linkend="advancing-the-state-of-the-art"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, below.</textual></para><para class="po-block e109 e109"><textual class="po-textual">gXML's use of the </textual><emphasis class="po-inline e110 e110"><textual class="po-textual">Handle/Body</textual></emphasis><textual class="po-textual"> pattern for XML tree
models might be compared to the similar pattern used for database drivers in
the Java Database Connection (JDBC) API. Each bridge may be viewed as
equivalent to a vendor-specific driver.</textual></para></section><section class="po-hcontainer e111 e111" xml:id="gxml-in"><title class="po-block e112 e112"><textual class="po-textual">The 'G' in 'XML'</textual></title><para class="po-block e113 e113"><textual class="po-textual">gXML makes extensive use of Java generics. First, it defines two common
parameters, N and A. N is the "node" handle; A is the "atom" or "atomic value"
handle. Furthermore, gXML makes extensive use of Java's built-in generics;
APIs that accept or return collections typically use </textual><code class="po-atom e114 e114"><textual class="po-textual">Iterable</textual></code><textual class="po-textual"> in
their signatures (as opposed to counts, specialized objects with
pseudo-iterators, single-use iterators, or arrays).</textual></para><para class="po-block e115 e115"><textual class="po-textual">The use of generics is the primary answer, in gXML, to the problem of
interoperability. By defining these parameters, particularly the &lt;N&gt;ode
handle, each of the tree models can be viewed and manipulated through the lens
of the XQuery Data Model. One notable consequence is that the enormous network
effect created by the existence of parsers, processors, and applications that
understand no model but the DOM, regardless of its fitness for their domain of
operation, no longer matters to developers of gXML-based processors and
applications. gXML includes a DOM bridge; it is thereby able to leverage that
network effect. Every bridge added, adds to the network effectâthough
not, as a rule, for a single document: conversion from model to model remains
expensive.</textual></para></section><section class="po-hcontainer e116 e116" xml:id="gxml-xdm"><title class="po-block e117 e117"><textual class="po-textual">The XQuery Data Model</textual></title><para class="po-block e118 e118"><textual class="po-textual">Perhaps the most important driver for the development of gXML was the
desire to have a Java API that embodied the XQuery Data Model.  The XDM is
more rigorous than its predecessor, the XML Infoset specification (which
was driven in part from a need to model existing APIs, including DOM, SAX,
XPath, and Namespaces in XML).  It is conceptually complete, and defined in
a context that permits type definition, navigation operations, and more
advanced functions.  This rigorous, well-defined specification was adopted
as the basis for the API, and represents gXML's answer to the problem of
variability.  Is a property or concept in the XDM specification?  Then it
should be in the gXML API.  If it is not in the specification, then either
it should not be exposed in the API, or it should be compatible with the
well-specified API. For instance, the entire mutable API was added as an
extension; XQuery does not define operations that modify trees.</textual></para><para class="po-block e119 e119"><textual class="po-textual">Another important reason to adopt the XQuery Data Model is that it
provides the first well-integrated access to XML Schema information
(one might argue that XQuery and XSLT2 provide the "missing language" for
the XML Schema type system).  A great deal of XML processing has no need to
concern itself with validation, typing, and particularly with the post-Schema
validation infoset; those applications and processors that need it, however,
need it very badly.  gXML defines a common model for XML Schema, compatible
with the XDM's definition and use of XML Schema types and typed values, as a
standard extension.</textual></para><para class="po-block e120 e120"><textual class="po-textual">gXML is not the only model to provide support for XML Schema, but the
schema-aware extensions in gXML can be implemented for any tree model, and are
exposed via APIs that are clearly related to (usually extensions of) the core
gXML APIs. In other words, by addressing the problem of variability via
adherence to and conformance with the XQuery Data Model Specification, gXML
enables the development of a "next wave" of XML processing technologies, based
on XPath 2.0, XSLT 2.0, and XQuery 1.0 (including the new generation of
XQuery-conformant databases).</textual></para></section><section class="po-hcontainer e121 e121" xml:id="gxml-immutable"><title class="po-block e122 e122"><textual class="po-textual">The Immutable Approach</textual></title><para class="po-block e123 e123"><textual class="po-textual">In the experience of the developers of gXML, most of the nodes in any
given XML instance document are never modified. These nodes need not be
mutableâbut because some nodes are modified in the common paradigm of
XML processing, all nodes must be defined to be mutable. The core gXML API
dispenses with mutability. Instead, it promotes a paradigm in which a received
or generated XML document is an input, and the XML supplied to other processes
(in the same VM, on the same machine, or somewhere else on the network) is a
transformation of the input. This approach addresses the problem of weight. In
combination with the enabling of custom, potentially domain-specific XML tree
models accessed via a gXML bridge, the immutable paradigm (over an immutable
tree model) can achieve optimizations not possible for a tree model in which
the existence of mutability militates against caching, compaction, and
deferred loading. It is not possible, at this point, to quantify the potential
performance benefits rigorously because the pure-immutable model remains
hypothetical (other priorities have taken precedence). Here we
speculate.</textual></para><para class="po-block e124 e124"><textual class="po-textual">Such a hypothetical immutable model would not need to guard against
modification of a document in one thread while another thread reads it.  It
would provide guarantees that would permit processing of large documents to
be parallelized; an immutable, late-loading model might be able to provide
access to XML documents of a size infeasible for mutable models.  A certain
number of these optimizations are available even for bridges over mutable
models; if the convention encourages immutability, then processors can define
their operations only when the convention is adhered to, warning users that
breaking the convention may lead to undefined (and incorrect) results.</textual></para><para class="po-block e125 e125"><textual class="po-textual">Immutability enables performance enhancementsâfor instance,
models in memory which occupy a fraction of the size of the XML as a character
stream rather than a multiple of its size; concurrent processing of XML
documents; storage of the bulk of a document on disk with indexing and a very
light footprint in memory. We've noticed unanticipated potential as well: if
there is no requirement to modify the document in memory, then a gXML bridge
may reasonably be defined over any structured hierarchical data format
analagous to XML: JSON, CSV, a file system, a MIME multipart message. Perhaps
more strikingly, immutable models can potentially cross the VM boundary, via
JNI to other languages, into hardware accelerators, and so on.</textual></para></section></section><section class="po-hcontainer e126 e126" xml:id="gxml-apis"><title class="po-block e127 e127"><textual class="po-textual">The gXML Core</textual></title><para class="po-block e128 e128"><textual class="po-textual">The gXML API is designed for rapid understanding.  The core API can be
described as a collection of five interfaces. In practice, more interfaces
are available, but understanding these five is necessary and sufficient to
understand and use the gXML base API.  These abstractions adhere to the
design principle of immutability, and do not introduce any dependency upon
XML Schema.</textual></para><para class="po-block e129 e129"><textual class="po-textual">The core API is completed with two extensions.  The mutable extension
adds mutability by adding methods to the base interfaces, or by adding new
interfaces.  The schema-aware extension adds schema awareness, again by adding
methods to base interfaces, or by adding new interfaces; the schema-aware
extension also introduces the "atom" parameter.</textual></para><section class="po-hcontainer e130 e130" xml:id="api-base"><title class="po-block e131 e131"><textual class="po-textual">Untyped, Immutable</textual></title><para class="po-block e132 e132"><textual class="po-textual">The heart of the gXML API is an abstraction called </textual><xref class="po-milestone e133 e133" linkend="Model"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. </textual><code class="po-atom e134 e134"><textual class="po-textual">Model</textual></code><textual class="po-textual"> is stateless; each bridge implements it. The methods on
</textual><code class="po-atom e135 e135"><textual class="po-textual">Model</textual></code><textual class="po-textual"> permit interrogation of XQuery Data Model properties
(</textual><code class="po-atom e136 e136"><textual class="po-textual">getNamespaceURI(N)</textual></code><textual class="po-textual">, </textual><code class="po-atom e137 e137"><textual class="po-textual">getLocalName(N)</textual></code><textual class="po-textual">,
</textual><code class="po-atom e138 e138"><textual class="po-textual">getStringValue(N)</textual></code><textual class="po-textual">, </textual><code class="po-atom e139 e139"><textual class="po-textual">getNodeKind(N)</textual></code><textual class="po-textual">, etc.), and
provide XQuery/XPath navigation (child, descendant, ancestor, sibling,
attribute, namespace axes). Since this abstraction is stateless, each method's
first parameter is a context node, the node for which information is
requested, or from which navigation begins. The XQuery Data Model defines
seven node types: </textual><code class="po-atom e140 e140"><textual class="po-textual">Document</textual></code><textual class="po-textual">, </textual><code class="po-atom e141 e141"><textual class="po-textual">Element</textual></code><textual class="po-textual">,
</textual><code class="po-atom e142 e142"><textual class="po-textual">Text</textual></code><textual class="po-textual">, </textual><code class="po-atom e143 e143"><textual class="po-textual">Attribute</textual></code><textual class="po-textual">, </textual><code class="po-atom e144 e144"><textual class="po-textual">Namespace</textual></code><textual class="po-textual">,
</textual><code class="po-atom e145 e145"><textual class="po-textual">Comment</textual></code><textual class="po-textual">, and </textual><code class="po-atom e146 e146"><textual class="po-textual">ProcessingInstruction</textual></code><textual class="po-textual">. Returns from
each method vary by node type, in conformance with the Data Model
specification, but the API does not distinguish node types (the argument or
return value is &lt;N&gt;, not &lt;? extends N&gt;). The </textual><xref class="po-milestone e147 e147" linkend="gxml-code"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> documents this interface.</textual></para><para class="po-block e148 e148"><textual class="po-textual">For convenience, a very similar API, with minimal (positional) state is
also defined: </textual><code class="po-atom e149 e149"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">. </textual><code class="po-atom e150 e150"><textual class="po-textual">Cursor</textual></code><textual class="po-textual"> provides a common
idiom, maintaining its positional state within the target tree, which is
frequently encountered in processing XML. Where </textual><code class="po-atom e151 e151"><textual class="po-textual">Model</textual></code><textual class="po-textual">'s
navigation APIs typically return a node (</textual><code class="po-atom e152 e152"><textual class="po-textual">N getFirstChildElement(N
context)</textual></code><textual class="po-textual">), </textual><code class="po-atom e153 e153"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">'s corresponding APIs return true or
false and change the </textual><code class="po-atom e154 e154"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">'s state (</textual><code class="po-atom e155 e155"><textual class="po-textual">boolean
moveToFirstChildElement()</textual></code><textual class="po-textual">). Where </textual><code class="po-atom e156 e156"><textual class="po-textual">Model</textual></code><textual class="po-textual">'s property
accessors require a context node (</textual><code class="po-atom e157 e157"><textual class="po-textual">String getStringValue(N
context)</textual></code><textual class="po-textual">), </textual><code class="po-atom e158 e158"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">'s use its current state (</textual><code class="po-atom e159 e159"><textual class="po-textual">String
getStringValue()</textual></code><textual class="po-textual">). The design intent is that anything that may be
accomplished with a </textual><code class="po-atom e160 e160"><textual class="po-textual">Model</textual></code><textual class="po-textual"> may also be accomplished with a
</textual><code class="po-atom e161 e161"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">. Note that </textual><code class="po-atom e162 e162"><textual class="po-textual">Cursor</textual></code><textual class="po-textual"> is not forward-only.</textual></para><para class="po-block e163 e163"><textual class="po-textual">When processing XML, some applications can make use of gXML with nothing
more than </textual><code class="po-atom e164 e164"><textual class="po-textual">Model</textual></code><textual class="po-textual"> or </textual><code class="po-atom e165 e165"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">. More advanced uses might
need the third primary abstraction in the core gXML API, the
</textual><code class="po-atom e166 e166"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual">. A processing context is precisely what it
claims to be: a specialized (for the target tree model), stateful abstraction
which provides uniform access to the collection of abstractions which together
make up a bridge. </textual><code class="po-atom e167 e167"><textual class="po-textual">Model</textual></code><textual class="po-textual">, </textual><code class="po-atom e168 e168"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">, and
</textual><code class="po-atom e169 e169"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> are all parameterized only by &lt;N&gt;ode. The
</textual><code class="po-atom e170 e170"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual"> extension introduces the &lt;A&gt;tom parameter.</textual></para><para class="po-block e171 e171"><code class="po-atom e172 e172"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> provides </textual><code class="po-atom e173 e173"><textual class="po-textual">Model&lt;N&gt;
getModel()</textual></code><textual class="po-textual"> and </textual><code class="po-atom e174 e174"><textual class="po-textual">Cursor&lt;N&gt; newCursor(N context)</textual></code><textual class="po-textual"> methods,
an accessor for the (singleton) </textual><code class="po-atom e175 e175"><textual class="po-textual">Model</textual></code><textual class="po-textual"> and a factory for the
</textual><code class="po-atom e176 e176"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">. Several additional accessors, functions, and factory
methods are available from the context: it is the source for the mutable and
typed context extensions (</textual><code class="po-atom e177 e177"><textual class="po-textual">getMutableContext()</textual></code><textual class="po-textual"> and
</textual><code class="po-atom e178 e178"><textual class="po-textual">getTypedContext()</textual></code><textual class="po-textual">), and for </textual><code class="po-atom e179 e179"><textual class="po-textual">DocumentHandler</textual></code><textual class="po-textual"> and
</textual><code class="po-atom e180 e180"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual">; it can report whether candidate objects are
compatible with the bridge's specialization of &lt;N&gt;ode; it includes a
mechanism to permit feature-based extension. For greatest generality,
applications should access a bridge via its processing context. An optional
</textual><code class="po-atom e181 e181"><textual class="po-textual">ProcessingContextFactory</textual></code><textual class="po-textual"> interface is also included in the API,
but experience suggests that provision of instances of the factory is an
impediment to the target design pattern, dependency injection. That is,
applications ought to instantiate the factory interface themselves, consistent
with the injection mechanism or API which they use.</textual></para><para class="po-block e182 e182"><textual class="po-textual">The processing context provides access to </textual><code class="po-atom e183 e183"><textual class="po-textual">DocumentHandler</textual></code><textual class="po-textual">,
which in turn provides methods to parse from and serialize to streams, readers
and writers. </textual><code class="po-atom e184 e184"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> is also a factory for
</textual><code class="po-atom e185 e185"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual">, which </textual><emphasis class="po-inline e186 e186"><textual class="po-textual">is-a</textual></emphasis><textual class="po-textual">
</textual><code class="po-atom e187 e187"><textual class="po-textual">ContentHandler</textual></code><textual class="po-textual"> (for the XDM, not the SAX interface of the same
name) and </textual><emphasis class="po-inline e188 e188"><textual class="po-textual">is-a</textual></emphasis><textual class="po-textual"> </textual><code class="po-atom e189 e189"><textual class="po-textual">NodeSource</textual></code><textual class="po-textual">.
</textual><code class="po-atom e190 e190"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual"> is used to programmatically build trees or tree
fragments in memory, parallel to parsing a document into memory via the
document handler's various parse methods. </textual><code class="po-atom e191 e191"><textual class="po-textual">Model</textual></code><textual class="po-textual"> and
</textual><code class="po-atom e192 e192"><textual class="po-textual">Cursor</textual></code><textual class="po-textual"> also accept a </textual><code class="po-atom e193 e193"><textual class="po-textual">ContentHandler</textual></code><textual class="po-textual"> argument to
stream or write themselves. In short, these abstractions provide a range
of input/output operations for XML using a particular bridge. </textual></para><para class="po-block e194 e194"><textual class="po-textual">These five abstractions make up the core of the gXML API. There are
other, supporting abstractions, some of which become more significant in
particular contexts. An untyped, immutable bridge implementation (minimally)
provides implementations for these five abstractions over a given tree
model.</textual></para></section><section class="po-hcontainer e195 e195" xml:id="api-mutable"><title class="po-block e196 e196"><textual class="po-textual">Mutability</textual></title><para class="po-block e197 e197"><textual class="po-textual">gXML provides two standard extensions in the core
</textual><code class="po-atom e198 e198"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> to permit bridges to signal support for
optional functionality. The first extension permits mutability. Immutability
provides important benefits for XML processing, but all currently-available
tree models are mutable, and nearly all processors and applications expect
mutability. To ease migration, </textual><code class="po-atom e199 e199"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> provides a
method, </textual><code class="po-atom e200 e200"><textual class="po-textual">getMutableContext()</textual></code><textual class="po-textual"> which permits the bridge to signal
that it supports mutability, by returning an implementation of the
</textual><code class="po-atom e201 e201"><textual class="po-textual">MutableContext</textual></code><textual class="po-textual"> extension. A mutable context, in turn, provides
access to </textual><code class="po-atom e202 e202"><textual class="po-textual">MutableModel</textual></code><textual class="po-textual"> and </textual><code class="po-atom e203 e203"><textual class="po-textual">MutableCursor</textual></code><textual class="po-textual">, each of
which extend the corresponding immutable interfaces (adding methods to add and
remove nodes, and to change the content of a document or element node), and also
provides access to a </textual><code class="po-atom e204 e204"><textual class="po-textual">NodeFactory</textual></code><textual class="po-textual"> implementation which permits the
creation of nodes in memory, independent of any tree (within the limits of the
underlying tree model).</textual></para><para class="po-block e205 e205"><emphasis class="po-inline e206 e206"><textual class="po-textual">Nota bene</textual></emphasis><textual class="po-textual">: the mutable interfaces, unlike other
abstractions in gXML, are not attempts to implement a portion of the XQuery
Data Model in Java. The XQuery Data Model (and, in fact, XQuery 1.0, XSLT 2.0,
and XPath 2.0) do not provide specification of property mutators.
Consequently, this portion of the API has been designed to be roughly
compatible with the XDM, as an extension, and to be roughly compatible with
the corresponding mutable APIs in dominant tree models. However, once XQuery
produces its "update" mechanism, this portion of the API is unlikely to prove
conformant.</textual></para></section><section class="po-hcontainer e207 e207" xml:id="api-sa"><title class="po-block e208 e208"><textual class="po-textual">Schema Awareness</textual></title><para class="po-block e209 e209"><textual class="po-textual">The </textual><code class="po-atom e210 e210"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual"> extension parallels the
</textual><code class="po-atom e211 e211"><textual class="po-textual">MutableContext</textual></code><textual class="po-textual"> extension. It provides the XDM-defined
schema-aware properties and manipulations. Most notably, the typed context
introduces an additional parameter, the &lt;A&gt;tom handle. The base and mutable
interfaces deal only with string values for text node and attribute content
(in XDM terms, actually </textual><emphasis class="po-inline e212 e212"><textual class="po-textual">untyped atomic</textual></emphasis><textual class="po-textual">). The XQuery Data
Model defines the concept of "atom", which corresponds to a typed value or
list of typed values. Atoms are inherently sequences of atoms (a single atom
is a one-element list); "sequence" is also introduced in the schema-aware API,
but unlike atom, is not represented by an independent common parameter.</textual></para><para class="po-block e213 e213"><code class="po-atom e214 e214"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual"> is more complex than
</textual><code class="po-atom e215 e215"><textual class="po-textual">MutableContext</textual></code><textual class="po-textual">. As a mutable context provides access to mutable
models and cursors, a typed context provides an accessor for a
</textual><code class="po-atom e216 e216"><textual class="po-textual">TypedModel</textual></code><textual class="po-textual"> and is a factory for </textual><code class="po-atom e217 e217"><textual class="po-textual">TypedCursor</textual></code><textual class="po-textual">, which
are extensions of the base </textual><code class="po-atom e218 e218"><textual class="po-textual">Model</textual></code><textual class="po-textual"> and </textual><code class="po-atom e219 e219"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">, adding
methods to access the type-name and typed-value properties. As the base
processing context can identify &lt;N&gt;odes, so the typed context can identify
&lt;A&gt;toms. </textual><code class="po-atom e220 e220"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual"> enhances the base
</textual><code class="po-atom e221 e221"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual"> as a type- and atom-aware
</textual><code class="po-atom e222 e222"><textual class="po-textual">SequenceBuilder</textual></code><textual class="po-textual">. To handle typed values,
</textual><code class="po-atom e223 e223"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual"> provides an accessor for the
</textual><code class="po-atom e224 e224"><textual class="po-textual">AtomBridge</textual></code><textual class="po-textual">, which in turn provides facilities to create, compile,
cast, convert (to Java native types), and query atoms, in a fashion consistent
with the XDM.</textual></para><para class="po-block e225 e225"><code class="po-atom e226 e226"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual"> also provides access to the
</textual><code class="po-atom e227 e227"><textual class="po-textual">MetaBridge</textual></code><textual class="po-textual">, which primarily serves to map the names of types to
their corresponding implmentations in the (included) XML Schema model.
</textual><code class="po-atom e228 e228"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual"> makes use of this bridge itself, because it extends
the core schema model interface, </textual><code class="po-atom e229 e229"><textual class="po-textual">SmSchema</textual></code><textual class="po-textual">. </textual><code class="po-atom e230 e230"><textual class="po-textual">SmSchema</textual></code><textual class="po-textual">
permits definition and declaration of custom types, registry of types, and
lookup of types. In other words, the typed context provides a cache of types
(supplied via parsing of schemas or programmatically) which are being used in
the processing of a collection of XML documents. This is actually the origin
of the concept and term "processing context," though it now exists for the
untyped API as well.</textual></para></section></section><section class="po-hcontainer e231 e231" xml:id="gxml-bridges"><title class="po-block e232 e232"><textual class="po-textual">Building Bridges with gXML</textual></title><para class="po-block e233 e233"><textual class="po-textual">For greatest utility, gXML ought to have bridges on every tree model for
XML in Java. The authors have not been able to accomplish this themselves, but
can demonstrate that creating additional bridges is a straightforward
task.</textual></para><para class="po-block e234 e234"><textual class="po-textual">The three bridges included in the gXML source tree provide examples of
the finished product. The development process is easily described. Note,
however, that most tree models present unique challenges when adapted to the
XQuery Data Model; our experience suggests that most development time is
consumed by handling these impedance mismatches.</textual></para><section class="po-hcontainer e235 e235" xml:id="gxml-base"><title class="po-block e236 e236"><textual class="po-textual">Untyped, Immutable</textual></title><para class="po-block e237 e237"><textual class="po-textual">What needs to be done to create a new base bridge (untyped, immutable)
for an as-yet unsupported tree model? There are five steps:</textual></para><orderedlist class="po-table e238 e238"><listitem class="po-container e239 e239"><para class="po-block e240 e240"><textual class="po-textual">Implement </textual><code class="po-atom e241 e241"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> and </textual><code class="po-atom e242 e242"><textual class="po-textual">Model</textual></code><textual class="po-textual">.
Decide what the &lt;N&gt; (node) abstraction must be.</textual></para><para class="po-block e243 e243"><textual class="po-textual">For instance: the DOM defines &lt;N&gt; as
</textual><code class="po-atom e244 e244"><textual class="po-textual">Node</textual></code><textual class="po-textual">. AxiOM defines it as </textual><code class="po-atom e245 e245"><textual class="po-textual">Object</textual></code><textual class="po-textual">
(AxiOM does not have a single base interface that marks all node types).  The Cx bridge
proof-of-concept uses </textual><code class="po-atom e246 e246"><textual class="po-textual">XmlNode</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e247 e247"><para class="po-block e248 e248"><textual class="po-textual">Use the </textual><code class="po-atom e249 e249"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual"> module to get a simple,
generic implementation of </textual><code class="po-atom e250 e250"><textual class="po-textual">Cursor</textual></code><textual class="po-textual"> (over the custom </textual><code class="po-atom e251 e251"><textual class="po-textual">Model</textual></code><textual class="po-textual">).</textual></para><para class="po-block e252 e252"><textual class="po-textual">The </textual><code class="po-atom e253 e253"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual"> module is a collection of utilities intended
to help bridge developers.  It includes, for instance, an implementation of the XML
Schema model (</textual><code class="po-atom e254 e254"><textual class="po-textual">SmSchema</textual></code><textual class="po-textual">) and the </textual><code class="po-atom e255 e255"><textual class="po-textual">XmlAtom</textual></code><textual class="po-textual"> typed-value implementation,
as well as the </textual><code class="po-atom e256 e256"><textual class="po-textual">CursorOnModel</textual></code><textual class="po-textual"> helper used here.</textual></para></listitem><listitem class="po-container e257 e257"><para class="po-block e258 e258"><textual class="po-textual">Implement </textual><code class="po-atom e259 e259"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual">.</textual></para><para class="po-block e260 e260"><textual class="po-textual">The </textual><code class="po-atom e261 e261"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual"> interface has five methods for creating
Text, Attribute, Namespace, Comment, and Processing Instruction node types, and an
additional two each (start and end) for the container node types, Element and Document.</textual></para></listitem><listitem class="po-container e262 e262"><para class="po-block e263 e263"><textual class="po-textual">Use the generic implementation of </textual><code class="po-atom e264 e264"><textual class="po-textual">DocumentHandler</textual></code><textual class="po-textual">
from the </textual><code class="po-atom e265 e265"><textual class="po-textual">input-output</textual></code><textual class="po-textual"> processor.</textual></para><para class="po-block e266 e266"><textual class="po-textual">The generic </textual><code class="po-atom e267 e267"><textual class="po-textual">DocumentHandler</textual></code><textual class="po-textual"> in the </textual><code class="po-atom e268 e268"><textual class="po-textual">input-output</textual></code><textual class="po-textual">
module is not terribly mature or robust, but can do the job for an initial implementation.</textual></para></listitem><listitem class="po-container e269 e269"><para class="po-block e270 e270"><textual class="po-textual">Use the </textual><code class="po-atom e271 e271"><textual class="po-textual">bridgetest</textual></code><textual class="po-textual"> module to verify equivalence with
existing bridges.</textual></para><para class="po-block e272 e272"><textual class="po-textual">The </textual><code class="po-atom e273 e273"><textual class="po-textual">bridgetest</textual></code><textual class="po-textual"> module is designed to make implementation
easy; enabling each test requires only that the bridge implement the single abstract
method, which returns the bridge's implementation of </textual><code class="po-atom e274 e274"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> (from
which all other abstractions can be reached).  Adding a test implementation is thus mostly
a mechanical task.</textual></para></listitem></orderedlist><para class="po-block e275 e275"><textual class="po-textual">This is all that's required. For this minimum,
</textual><code class="po-atom e276 e276"><textual class="po-textual">getMutableContext()</textual></code><textual class="po-textual"> and </textual><code class="po-atom e277 e277"><textual class="po-textual">getTypedContext()</textual></code><textual class="po-textual"> (on
</textual><code class="po-atom e278 e278"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual">) should both return null, indicating no
support.</textual></para></section><section class="po-hcontainer e279 e279" xml:id="gxml-mutable"><title class="po-block e280 e280"><textual class="po-textual">Mutability</textual></title><para class="po-block e281 e281"><textual class="po-textual">To add support for mutability:</textual></para><orderedlist class="po-table e282 e282"><listitem class="po-container e283 e283"><para class="po-block e284 e284"><textual class="po-textual">Implement </textual><code class="po-atom e285 e285"><textual class="po-textual">MutableContext</textual></code><textual class="po-textual"> and return it from
</textual><code class="po-atom e286 e286"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> instead of null.</textual></para><para class="po-block e287 e287"><code class="po-atom e288 e288"><textual class="po-textual">MutableModel</textual></code><textual class="po-textual"> provides access the </textual><code class="po-atom e289 e289"><textual class="po-textual">NodeFactory</textual></code><textual class="po-textual">,
        </textual><code class="po-atom e290 e290"><textual class="po-textual">MutableModel</textual></code><textual class="po-textual">, and </textual><code class="po-atom e291 e291"><textual class="po-textual">MutableCursor</textual></code><textual class="po-textual"> implementations.</textual></para></listitem><listitem class="po-container e292 e292"><para class="po-block e293 e293"><textual class="po-textual">Implement </textual><code class="po-atom e294 e294"><textual class="po-textual">MutableModel</textual></code><textual class="po-textual"> as an extension of the
base </textual><code class="po-atom e295 e295"><textual class="po-textual">Model</textual></code><textual class="po-textual"> from above.</textual></para><para class="po-block e296 e296"><code class="po-atom e297 e297"><textual class="po-textual">MutableModel</textual></code><textual class="po-textual"> adds methods to set attributes and namespaces,
        to add, remove, and replace children.</textual></para></listitem><listitem class="po-container e298 e298"><para class="po-block e299 e299"><textual class="po-textual">Use the </textual><code class="po-atom e300 e300"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual"> module to base the bridge's
</textual><code class="po-atom e301 e301"><textual class="po-textual">MutableCursor</textual></code><textual class="po-textual"> on its </textual><code class="po-atom e302 e302"><textual class="po-textual">MutableModel</textual></code><textual class="po-textual">.</textual></para><para class="po-block e303 e303"><textual class="po-textual">The </textual><code class="po-atom e304 e304"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual"> implementations are reasonable starting
        points, though optimization is likely to require a custom implementation.</textual></para></listitem><listitem class="po-container e305 e305"><para class="po-block e306 e306"><textual class="po-textual">Implement </textual><code class="po-atom e307 e307"><textual class="po-textual">NodeFactory</textual></code><textual class="po-textual">.</textual></para><para class="po-block e308 e308"><code class="po-atom e309 e309"><textual class="po-textual">NodeFactory</textual></code><textual class="po-textual"> contains methods to create each node type,
        where </textual><code class="po-atom e310 e310"><textual class="po-textual">MutableModel</textual></code><textual class="po-textual"> establishes the relationships between nodes.</textual></para></listitem><listitem class="po-container e311 e311"><para class="po-block e312 e312"><textual class="po-textual">Add tests from the </textual><code class="po-atom e313 e313"><textual class="po-textual">bridgetest</textual></code><textual class="po-textual"> module.</textual></para><para class="po-block e314 e314"><textual class="po-textual">In this case, there's only one, at present.</textual></para></listitem></orderedlist><para class="po-block e315 e315"><textual class="po-textual">This is admittedly easier to describe than to accomplish.  Approaches
to mutability among tree models vary </textual><emphasis class="po-inline e316 e316"><textual class="po-textual">much</textual></emphasis><textual class="po-textual"> more widely
than approaches to navigation and analysis.</textual></para><para class="po-block e317 e317"><textual class="po-textual">On the other hand, gXML's approach to mutability is more restricted than
most current tree APIs. The gXML mutable API does </textual><emphasis class="po-inline e318 e318"><textual class="po-textual">not</textual></emphasis><textual class="po-textual">
support changing the value of a text or attribute node, for instance. Leaf
nodes remain immutable; container nodes (document and element) are mutable in
content (contained nodes) only.</textual></para></section><section class="po-hcontainer e319 e319" xml:id="gxml-sa"><title class="po-block e320 e320"><textual class="po-textual">Schema Awareness</textual></title><para class="po-block e321 e321"><textual class="po-textual">To add support for schema-awareness:</textual></para><orderedlist class="po-table e322 e322"><listitem class="po-container e323 e323"><para class="po-block e324 e324"><textual class="po-textual">Implement </textual><code class="po-atom e325 e325"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual"> and return it from
</textual><code class="po-atom e326 e326"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual"> instead of null; note that </textual><code class="po-atom e327 e327"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual">
</textual><emphasis class="po-inline e328 e328"><textual class="po-textual">is-a</textual></emphasis><textual class="po-textual"> </textual><code class="po-atom e329 e329"><textual class="po-textual">SmSchema</textual></code><textual class="po-textual">. Decide what the &lt;A&gt; (atom)
abstraction must be.</textual></para><para class="po-block e330 e330"><textual class="po-textual">Current implementations all define &lt;A&gt; as </textual><code class="po-atom e331 e331"><textual class="po-textual">XmlAtom</textual></code><textual class="po-textual">.
This is not required.</textual></para></listitem><listitem class="po-container e332 e332"><para class="po-block e333 e333"><textual class="po-textual">Implement </textual><code class="po-atom e334 e334"><textual class="po-textual">TypedModel</textual></code><textual class="po-textual"> as an extension of the
base </textual><code class="po-atom e335 e335"><textual class="po-textual">Model</textual></code><textual class="po-textual"> from above.</textual></para><para class="po-block e336 e336"><textual class="po-textual">The </textual><code class="po-atom e337 e337"><textual class="po-textual">TypedModel</textual></code><textual class="po-textual"> interface adds only five methods to
</textual><code class="po-atom e338 e338"><textual class="po-textual">Model</textual></code><textual class="po-textual">, all related to the introduction of type names and typed values.
Actually ensuring that the type annotations and typed values are associated with the
nodes in the tree is one of the most challenging tasks in implementation.</textual></para></listitem><listitem class="po-container e339 e339"><para class="po-block e340 e340"><textual class="po-textual">Use the </textual><code class="po-atom e341 e341"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual"> module to base the bridge's
</textual><code class="po-atom e342 e342"><textual class="po-textual">TypedCursor</textual></code><textual class="po-textual"> on its </textual><code class="po-atom e343 e343"><textual class="po-textual">TypedModel</textual></code><textual class="po-textual">.</textual></para><para class="po-block e344 e344"><code class="po-atom e345 e345"><textual class="po-textual">CursorOnTypedModel</textual></code><textual class="po-textual"> extends </textual><code class="po-atom e346 e346"><textual class="po-textual">CursorOnModel</textual></code><textual class="po-textual">
as expected.</textual></para></listitem><listitem class="po-container e347 e347"><para class="po-block e348 e348"><textual class="po-textual">Implement or reuse from the </textual><code class="po-atom e349 e349"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual"> module
an </textual><code class="po-atom e350 e350"><textual class="po-textual">AtomBridge</textual></code><textual class="po-textual"> (typed value support).</textual></para><para class="po-block e351 e351"><textual class="po-textual">If the chosen &lt;A&gt;tom is </textual><code class="po-atom e352 e352"><textual class="po-textual">XmlAtom</textual></code><textual class="po-textual">, the </textual><code class="po-atom e353 e353"><textual class="po-textual">XmlAtomBridge</textual></code><textual class="po-textual">
already exists.</textual></para></listitem><listitem class="po-container e354 e354"><para class="po-block e355 e355"><textual class="po-textual">Implement or reuse from the </textual><code class="po-atom e356 e356"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual"> module a
</textual><code class="po-atom e357 e357"><textual class="po-textual">MetaBridge</textual></code><textual class="po-textual"> (type support).</textual></para><para class="po-block e358 e358"><textual class="po-textual">Again, if the &lt;A&gt;tom is </textual><code class="po-atom e359 e359"><textual class="po-textual">XmlAtom</textual></code><textual class="po-textual">, a </textual><code class="po-atom e360 e360"><textual class="po-textual">MetaBridge</textual></code><textual class="po-textual">
exists in the </textual><code class="po-atom e361 e361"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e362 e362"><para class="po-block e363 e363"><textual class="po-textual">Implement </textual><code class="po-atom e364 e364"><textual class="po-textual">SequenceBuilder</textual></code><textual class="po-textual"> as an extension of
the </textual><code class="po-atom e365 e365"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual"> from above.</textual></para><para class="po-block e366 e366"><code class="po-atom e367 e367"><textual class="po-textual">SequenceBuilder</textual></code><textual class="po-textual"> adds overrides for the </textual><code class="po-atom e368 e368"><textual class="po-textual">attribute()</textual></code><textual class="po-textual">, 
</textual><code class="po-atom e369 e369"><textual class="po-textual">startElement()</textual></code><textual class="po-textual">, and </textual><code class="po-atom e370 e370"><textual class="po-textual">text()</textual></code><textual class="po-textual"> methods (adding type names and
typed values), plus methods to create an atom and to start and end a sequence.</textual></para></listitem><listitem class="po-container e371 e371"><para class="po-block e372 e372"><textual class="po-textual">Add the typed tests from the </textual><code class="po-atom e373 e373"><textual class="po-textual">bridgetest</textual></code><textual class="po-textual"> module.</textual></para><para class="po-block e374 e374"><textual class="po-textual">As with the standard tests, these are easy to implement, following the
same pattern.</textual></para></listitem></orderedlist><para class="po-block e375 e375"><textual class="po-textual">For schema awareness, the most straightforward approach is going to be
reusing the generic implementations found in the </textual><code class="po-atom e376 e376"><textual class="po-textual">bridgekit</textual></code><textual class="po-textual">
module, but better results may be achieved by customizing the code. This is an
area requiring further experience before establishing guidelines for best
practices.</textual></para></section><section class="po-hcontainer e377 e377" xml:id="gxml-using"><title class="po-block e378 e378"><textual class="po-textual">Bridge Traffic</textual></title><para class="po-block e379 e379"><textual class="po-textual">Using bridges is a little less amenable to slideshow style lists, but
the principles remain straightforward. When using gXML, it is important to
understand "dependency inversion": bridges should be injected, if at all
possible, rather than directly instantiated. It is possible to design an
application or processor that can react to input by directly instantiating the
needed bridge, but it's best to reduce the number of places that contain
reference to the tree model packages to as few as possible. One class is
ideal; it is then responsible for providing a processing context for a given
bridge on demand.</textual></para><para class="po-block e380 e380"><textual class="po-textual">Most applications will spend most of their time with the
</textual><code class="po-atom e381 e381"><textual class="po-textual">Model</textual></code><textual class="po-textual"> or </textual><code class="po-atom e382 e382"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">) interfaces, which
permit navigation and interrogation. Methods provide access to names, values,
and other characteristics (XQuery Data Model properties) of the node, and
permit navigation in a variety of ways to target nodes.  An appendix shows
the content of the </textual><xref class="po-milestone e383 e383" linkend="Model"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> interface.
</textual><code class="po-atom e384 e384"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual"> (for construction in memory) and
</textual><code class="po-atom e385 e385"><textual class="po-textual">DocumentHandler</textual></code><textual class="po-textual"> (for parsing and serializing) are likely to be
important. Existing applications or developers wedded to the concept of
mutability are likely to make use of the APIs in the mutable model (or cursor)
and the </textual><code class="po-atom e386 e386"><textual class="po-textual">NodeFactory</textual></code><textual class="po-textual">. Applications or processors needing W3C XML
Schema support (common inside the enterprise, for instance) are likely to make
extensive use of </textual><code class="po-atom e387 e387"><textual class="po-textual">TypedContext</textual></code><textual class="po-textual">, particularly as a schema cache and
for access to typed models and cursors.</textual></para><para class="po-block e388 e388"><textual class="po-textual">At present, gXML has bridges, in varying states of maturity, for the DOM
(level 3 support currently required), for AxiOM (LLOM only; support for typed
context rather weak), and for a reference bridge called Cx (a clean, if naive,
reimplementation of the XQuery Data Model from scratch, and a gXML bridge over
that implementation). The DOM was chosen because of its ubiquity; AxiOM because
the web services area is a target for gXML proselytizers; Cx exists primarily
to demonstrate that the shared idiosyncracies of DOM and AxiOM (there are a
few) are not fundamental to gXML.</textual></para></section></section><section class="po-hcontainer e389 e389" xml:id="gxml-processing"><title class="po-block e390 e390"><textual class="po-textual">Processing XML with gXML</textual></title><para class="po-block e391 e391"><textual class="po-textual">gXML provides an extensive API for bridges, which not only provides the
entry point for applications and processors, but also makes the development of
new bridges easy to describe. In sharp contrast, no interface, no contract, is
specified for XML processors designed for use with gXML. While some processors
might reasonably be defined to have a method with the signature: </textual><code class="po-atom e392 e392"><textual class="po-textual">N
process(N, Model&lt;N&gt;)</textual></code><textual class="po-textual">, for others this is entirely inappropriate.
Even for processors that might reasonably "process" a node, their function is
more clearly expressed if they "transform" or "extract" or "enhance", or
otherwise mark their "processing" by its specific name, not the more general
one.</textual></para><para class="po-block e393 e393"><textual class="po-textual">So, what is a gXML processor? As the gXML team uses the term, a
processor is a code library that performs some specific, well-described
function over XML. Most processors can be described with a single word or
phrase: "serializer," "parser," "converter," "validator," "transformer,"
"signer," and so on. A processor is distinguished from an "application," which
may create (generate), destroy (consume), modify, and otherwise manipulate XML
in multiple steps. Where a processor contributes special functionality to the
performance of a goal, the application oversees and orchestrates achievement
of the goal from receipt to completion. To further distinguish, a bridge
provides the abstraction over which the applications and processors operate,
including the model, input/output, and a context that associates related
tree-specific functions.</textual></para><section class="po-hcontainer e394 e394" xml:id="stateful-processing"><title class="po-block e395 e395"><textual class="po-textual">Stateful</textual></title><para class="po-block e396 e396"><textual class="po-textual">gXML processors may be divided, for purposes of discussion, into two
classes: stateful and stateless. Here, "state" refers to the processor's need
to maintain state in the form of any of the parameters specialized by a
particular bridge implementation (&lt;N&gt; and &lt;A&gt;), disregarding maintenance
of state unrelated to gXML parameters. A stateful processor is ideally written
generically, but certain of its component classes will themselves be
parameterized with one or both of the node and atom handles. Consequently, at
instantiation, a given instance of a processor is tied, </textual><emphasis class="po-inline e397 e397"><textual class="po-textual">ipso
facto</textual></emphasis><textual class="po-textual">, to a particular bridge implementation. Like
</textual><code class="po-atom e398 e398"><textual class="po-textual">java.util.List&lt;QName&gt;</textual></code><textual class="po-textual">, a generic processor taking only &lt;N&gt;
as a parameter would have to be specialized as
</textual><code class="po-atom e399 e399"><textual class="po-textual">GenericProcessor&lt;Node&gt;</textual></code><textual class="po-textual"> for use with the DOM bridge; the same
class would be separately instantiated for use with the Cx bridge as
</textual><code class="po-atom e400 e400"><textual class="po-textual">GenericProcessor&lt;XmlNode&gt;</textual></code><textual class="po-textual">. Stateful processors typically
contain one or more member fields whose type is specified as a parameter (or
which is a parameterized class, such as an instance of
</textual><code class="po-atom e401 e401"><textual class="po-textual">Cursor&lt;N&gt;</textual></code><textual class="po-textual"> or </textual><code class="po-atom e402 e402"><textual class="po-textual">Bookmark&lt;N&gt;</textual></code><textual class="po-textual">).</textual></para><para class="po-block e403 e403"><textual class="po-textual">For example, an input-output module is included in the gXML source tree.
This module includes a stateful processor implementing
</textual><code class="po-atom e404 e404"><textual class="po-textual">DocumentHandler&lt;N&gt;</textual></code><textual class="po-textual">. This </textual><code class="po-atom e405 e405"><textual class="po-textual">DocumentHandler</textual></code><textual class="po-textual"> contains
a member field which is a </textual><code class="po-atom e406 e406"><textual class="po-textual">FragmentBuilder&lt;N&gt;</textual></code><textual class="po-textual"> supplied by the
bridge's </textual><code class="po-atom e407 e407"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual">. This is a good example of the
stateful style: at instantiation, each
</textual><code class="po-atom e408 e408"><textual class="po-textual">DefaultDocumentHandler&lt;N&gt;</textual></code><textual class="po-textual"> is specialized for the bridge's
definition of &lt;N&gt;, associating this handler instance with a particular
bridge (in fact, associating it with a single instance of the bridge's
implementation of </textual><code class="po-atom e409 e409"><textual class="po-textual">ProcessingContext</textual></code><textual class="po-textual">). This processor's "process"
methods are defined by the </textual><code class="po-atom e410 e410"><textual class="po-textual">DocumentHandler</textual></code><textual class="po-textual"> interface, found in
the core API.</textual></para></section><section class="po-hcontainer e411 e411" xml:id="stateless-processing"><title class="po-block e412 e412"><textual class="po-textual">Stateless</textual></title><para class="po-block e413 e413"><textual class="po-textual">An alternate style of implementation is the stateless processor. If no class
in the processor needs to retain state typed as or with a gXML parameter, then the
processor may be used by declaring the necessary parameters on a method, and
supplying the necessary disambiguation as arguments to the method. For
instance, a stateless processor might expose the method:</textual></para><programlisting class="po-block e414 e414" xml:space="preserve"><textual class="po-textual">
    &lt;N&gt; N nearestAncestor(Iterable&lt;N&gt; context, Model&lt;N&gt; model)
</textual></programlisting><para class="po-block e415 e415"><textual class="po-textual">The arguments to the method are both parameterized: the context provides
a collection of nodes; the model provides the tool to interrogate each of the
nodes in the supplied context (this hypothetical example finds the nearest
common ancestor of all the nodes supplied in the list, or </textual><code class="po-atom e416 e416"><textual class="po-textual">null</textual></code><textual class="po-textual"> if
no such common ancestor exists).</textual></para><para class="po-block e417 e417"><textual class="po-textual">An extremely simple example of a stateless processor may be found in the
</textual><code class="po-atom e418 e418"><textual class="po-textual">convert</textual></code><textual class="po-textual"> module, in the gXML source tree. It's so simple that it's debatable
whether it's a processor, or simply an instantiation of an idiom.
</textual><code class="po-atom e419 e419"><textual class="po-textual">StaticConverter</textual></code><textual class="po-textual"> has a single, static method, with the
signature:</textual></para><programlisting class="po-block e420 e420" xml:space="preserve"><textual class="po-textual">
    &lt;Nsrc, Ntrg&gt; Ntrg convert(Cursor&lt;Nsrc&gt; cursor, FragmentBuilder&lt;Ntrg&gt; builder)
</textual></programlisting><para class="po-block e421 e421"><textual class="po-textual">It does what it says on the tin: using the supplied </textual><code class="po-atom e422 e422"><textual class="po-textual">Cursor</textual></code><textual class="po-textual">
and </textual><code class="po-atom e423 e423"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual">, from one or two different bridges, it
converts from one tree model representation to another (strictly speaking,
this is a transforming copy, rather than a conversion; also, if the
</textual><code class="po-atom e424 e424"><textual class="po-textual">Cursor</textual></code><textual class="po-textual"> and </textual><code class="po-atom e425 e425"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual"> are supplied by the same bridge,
this is simply a copy).</textual></para><para class="po-block e426 e426"><textual class="po-textual">A more complex example may be found in the same module: </textual><code class="po-atom e427 e427"><textual class="po-textual">Converter</textual></code><textual class="po-textual"> mixes
the stateful and stateless styles.  It is instantiated with a (source)
processing context; it is then able, on request, to convert to any supplied
target processing contextâretaining type information, if possible (if
both source and target bridges advertise themselves as schema-aware, it uses
</textual><code class="po-atom e428 e428"><textual class="po-textual">SequenceBuilder</textual></code><textual class="po-textual"> and the </textual><code class="po-atom e429 e429"><textual class="po-textual">TypedModel</textual></code><textual class="po-textual">'s atom-aware
</textual><code class="po-atom e430 e430"><textual class="po-textual">stream()</textual></code><textual class="po-textual"> method in preference to the untyped </textual><code class="po-atom e431 e431"><textual class="po-textual">FragmentBuilder</textual></code><textual class="po-textual">
and </textual><code class="po-atom e432 e432"><textual class="po-textual">Model</textual></code><textual class="po-textual">).</textual></para></section><section class="po-hcontainer e433 e433" xml:id="other-processing" xreflabel="Refactoring Processors"><title class="po-block e434 e434"><textual class="po-textual">Developing and Refactoring</textual></title><para class="po-block e435 e435"><textual class="po-textual">The gXML source tree contains, in addition to the processors mentioned
above, an XPath 1.0 processor, a schema parser, and a schema validator. The
XPath processor is stateless; the schema processors (unsurprisingly) stateful.
Processors for XPath 2.0, XSLT 2.0, and XQuery 1.0 have also been explored,
although this code is not included in the distribution.</textual></para><para class="po-block e436 e436"><textual class="po-textual">During the development of the API, in early 2009, the Apache Woden
project (1.0M8) was refactored as a proof of concept. This effort was based on an
earlier revision of the API; the refactoring was extensive, taking advantage
of the immutable paradigm. Woden was chosen as an example because it contained
an example of multi-tree abstraction: wrapper classes permit Woden to
parse and analyze WSDL supplied either as AxiOM or as DOM trees. The project
required about a month, but the result seemed a dramatic validation of of gXML
principles and design: the lines of code (LOC) count was reduced by about 15%,
inconsistencies in the handling of DOM versus AxiOM were eliminated, and
supported models grew from two to five (including DOM, AxiOM, the Cx reference
model, a proprietary internal model, and an experimental model based on EXI).
There is no guarantee of such an LOC count reduction, of course; results will
depend upon the original source.</textual></para><para class="po-block e437 e437"><textual class="po-textual">As part of the preparation for release as open source, a similar effort
was undertaken to refactor the Apache XML Security project in early 2010. This
was a more cautious effort, adopting as a guideline that no externally used API
should change. Instead, the existing interfaces were enhanced with a gXML code
path. In addition to preservation of backward compatibility in the API, this
refactoring did not attempt a wholesale restatement of the security problem in
immutable context, but relied extensively upon </textual><code class="po-atom e438 e438"><textual class="po-textual">MutableContext</textual></code><textual class="po-textual"> and
the capabilities supported therein. This effort is ongoing, and does not
appear to promise a reduction in code size, given its goals. It has provided
the team with an excellent test case for the mutable APIs (and even
demonstrated missing XDM-defined functionality in the core APIs) which have
been used to improve both areas. Nonetheless, it appears to validate the
concept of cautious, compatibility-maintaining refactoring; the refactored
API appears able to pass the same tests that the original DOM-based API passed.</textual></para><para class="po-block e439 e439"><textual class="po-textual">The experience from these (and other) proofs of concept, refactoring
existing XML processors and developing new processors, leads to some tentative
conclusions about the efforts involved and the possible development patterns.
We note that because all current tree models incorporate mutability without
questioning its utility, most processors approach problems of XML manipulation
as a tree mutation.</textual></para><section class="po-hcontainer e440 e440" xml:id="ProcessorNew"><title class="po-block e441 e441"><textual class="po-textual">New Development</textual></title><para class="po-block e442 e442"><textual class="po-textual">The time required for development of a new processor varies depending
upon the complexity of the processing. In our experience, adopting the
immutable paradigm can actually simplify development, though it requires an
effort to state the problem as a transformation rather than as a mutation.
Processors developed for gXML take no more, and often less time to develop
(and debug) than processors over a single tree model. When designed for
immutability, the resulting processor often shows excellent performance
characteristics, without requiring significant attention to this area.</textual></para><para class="po-block e443 e443"><textual class="po-textual">Examples are included in the distribution, in the </textual><code class="po-atom e444 e444"><textual class="po-textual">processor</textual></code><textual class="po-textual">
module and its children: </textual><code class="po-atom e445 e445"><textual class="po-textual">input-output</textual></code><textual class="po-textual">, </textual><code class="po-atom e446 e446"><textual class="po-textual">convert</textual></code><textual class="po-textual">,
</textual><code class="po-atom e447 e447"><textual class="po-textual">w3c.xs</textual></code><textual class="po-textual"> (schema parsing), and </textual><code class="po-atom e448 e448"><textual class="po-textual">w3c.xs.validation</textual></code><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e449 e449" xml:id="ProcessorOldMutable"><title class="po-block e450 e450"><textual class="po-textual">Refactoring: Processing Mutable Trees</textual></title><para class="po-block e451 e451"><textual class="po-textual">Existing processorsâsuch as the Apache XML Security
exampleâthat have already released are apt to wish to maintain existing
customer bases. The approach to take, in this case, seems to be to produce an
extended, parallel API: where the existing API takes a </textual><code class="po-atom e452 e452"><textual class="po-textual">Node</textual></code><textual class="po-textual">,
provide an override that accepts (for example) </textual><code class="po-atom e453 e453"><textual class="po-textual">N, Model&lt;N&gt;</textual></code><textual class="po-textual">, or
(if changing the state of the supplied argument is acceptable)
</textual><code class="po-atom e454 e454"><textual class="po-textual">Cursor&lt;N&gt;</textual></code><textual class="po-textual">.  Then change the original DOM-based function so that
it merely calls the new gXML-based method.  This approach increases the size
of the code base, but preserves the logic of the API, validation via the
existing test suite, and compatibility with existing clients.</textual></para><para class="po-block e455 e455"><textual class="po-textual">Firm estimates depend upon the size and complexity of the code base,
but experience seems to demonstrate that once the principles are understood,
much of the refactoring proceeds in a nearly mechanical fashion. The primary
advantage to this form of refactoring is the addition of support for all
defined gXML bridges (or all bridges that support mutability); this in turn
may permit customers to choose models better suited for a particular problem
domain.  In the XML Security case, the refactoring produces the ability to
use the processor with AxiOM (in the current state of the art; potentially
with other tree models as those are developed as well).</textual></para></section><section class="po-hcontainer e456 e456" xml:id="ProcessorOldImmutable"><title class="po-block e457 e457"><textual class="po-textual">Refactoring: Processing Immutable Trees</textual></title><para class="po-block e458 e458"><textual class="po-textual">Refactoring an XML processor for immutable operation is more
challenging. The general principle is that instead of considering the problem
as one of modifying a tree, the problem is stated as a transforming copy. The
XML document is an input; other inputs guide the processing; the output is a
new XML document (the original is then typically discarded, or sometimes
archived). Our experience addressed Apache Woden, in part because the project
was then recently graduated from incubation (that is, it had just made a
public 1.0 release), so preservation of API compatibility was deemed less
critical; widespread adoption had not yet occurred. Another example is the
</textual><code class="po-atom e459 e459"><textual class="po-textual">xpath.impl</textual></code><textual class="po-textual"> processor, based on the </textual><code class="po-atom e460 e460"><textual class="po-textual">xpath</textual></code><textual class="po-textual"> API module;
these modules were both created by refactoring a portion of James Clark's and
Bill Lindsey's </textual><code class="po-atom e461 e461"><textual class="po-textual">XT</textual></code><textual class="po-textual"> </textual><xref class="po-milestone e462 e462" linkend="XT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. XPath has no need for
mutability, obviously; stating the XPath processing problem in immutable
context is trivial.</textual></para><para class="po-block e463 e463"><textual class="po-textual">This approach typically changes the logic of processing as well as
changing the public API; developers may find that the code that "enhances"
(mutates) a tree with information must be localized. That is, instead of
receiving, analyzing, modifying, analyzing further, etc., the process is
receiving, analyzing, generating/transforming, analyzing further. Creation of
new documents is potentially expensive; this is apt to lead developers to
minimize occurrences of the event. Awareness of this issue, in our experience,
led to code that was more straightforward, easier to understand, and better
encapsulated. Note
also that a refactoring of a publicly released API might proceed first by
preserving API compatibility, and later providing an alternate, transformative
code path that parallels the modification path.</textual></para></section></section></section><section class="po-hcontainer e464 e464" xml:id="advancing-the-state-of-the-art" xreflabel="Advancing the State of the Art"><title class="po-block e465 e465"><textual class="po-textual">Advancing the State of the Art</textual></title><para class="po-block e466 e466"><textual class="po-textual">The gXML team believes that this API presents an exciting opportunity to
change the paradigms for XML processing in Java, and to enable a host of
additional opportunities for advancing the state of the art. We have discussed
the API, bridges, and processors in some detail, above. Now, let's examine the
further opportunities that gXML enables.</textual></para><para class="po-block e467 e467"><textual class="po-textual">Because gXML encourages the practice of dependency inversion, of
injecting a particular tree model (bridge) at runtime, it effectively
bypassesâeven leverages, by inclusion of a bridge for the DOM in the
distributionâthe DOM network effect that has presented Java developers
of XML processors and applications with a Hobson's choice: choose a tree model
which is technically superior or less awkward to program against but lose
interoperability with the vast majority of existing processors and
applications, or choose the DOM with its peculiarities and quirks and
limitations but gain interoperability with the wider XML ecosystem. Developers
of alternative Java XML tree models will (we hope) welcome this, and
contribute bridges. Moreover, by permitting this late binding of the tree
model, gXML enables use-case specific comparisons of models to each other.
This capability for comparison, without losing interoperability, may lead to
wider adoption of one or more of the successor models, in one application
domain or across domains. Further, given the ability to compare two models in
such a way, application and processor developers can provide clear test cases
demonstrating issues, which developers of the tree model may find more
compelling, more deserving of attention, than is currently the case when any
comparison must first develop a custom framework/harness.</textual></para><para class="po-block e468 e468"><textual class="po-textual">By enabling injection of the model, gXML also potentially permits the
development of domain-specific tree models, optimized for particular use
cases. Such "niche" models are actively discouraged in the current state of
the art: they lead in the direction of private code, difficult to learn and
difficult to maintain. AxiOM provides an example of a domain-specific model
that has survived the process of marginalization; one might argue that it has
done so in part through its strong association with the high-profile project
Apache Axis 2. Other domains such as strongly typed XML, large XML
processing, and XML in constrained memory environments come to mind as
potential targets. Customization and optimization are possible both for the
underlying tree model, and for the bridge implementation. There is no
restriction against implementing multiple bridges for a single underlying tree
modelâsince the pattern is injection, two significantly different
bridge implementations over the same underlying tree model may be used by a
single application. Here again, there are significant opportunities for domain
optimization, in this case by optimizing the bridge implementation rather than
changing the underlying tree model.</textual></para><para class="po-block e469 e469"><textual class="po-textual">gXML's championing of the immutable paradigm for XML processing carries
powerful potentials for performance enhancements. We cannot, at this point,
quantify these benefits (they may even be chimerical), but we have seen
immutability adopted in other areas specifically in order to improve
performance. Immutability provides guarantees that enable concurrent
processing, an increasingly common requirement for applications and processors
that must scale to handle large volumes of traffic. With a custom tree model
(even an immutable implementation of the DOM, potentially), the notorious
impact of XML on memory can potentially be reduced. For applications and
processors that already address multiple tree models, significant reductions
in code size may accompany improved performance and consistency. Our
experience suggests that restating problems as transformation rather than
mutation tends to lead to cleaner, better-encapsulated, and typically more
performant code.</textual></para><para class="po-block e470 e470"><textual class="po-textual">One particular area in which gXML holds enormous promise is in the
processing of "large XML". This is, in a way, the same problem as processing
XML with "constrained memory;" whether one identifies the XML as too-large, or
memory as too-small, the problem is the same. How can XML be processed if it
is too large to fit at once into memory? The obvious answer is a custom tree
model, but this answer immediately presents the developer with the DOM "Hobson's
choice" outlined above. gXML removes that issue; a processor or application
programmed against the gXML API can inject a simple, mature tree model for
most processing, or a custom, stored-to-disk, low-memory tree model when the
size of the target document exceeds a specified threshold.</textual></para><para class="po-block e471 e471"><textual class="po-textual">Developers of technologies that compete with XML as descriptions of
structured, hierarchical data may have no interest in presenting their formats
as XML (may even resent the suggestion), but there are advantages to doing so:
the XML programming environment is a large one, populated with numerous
processors and applications. A bridge over other such data
formatsâJSON, for a high-profile exampleâcould provide that
format with the capabilities of the entire suite of XML tools (with the
reservation that there is apt to be an impedance mismatch of some degree, that
the bridge will attempt to minimize). This is most interesting when gXML is
used with the immutable paradigm; modifying these alternative structured
hierarchical data formats as well as analyzing them is a more difficult
problem and likely to have a higher degree of impedance mismatch.</textual></para><para class="po-block e472 e472"><textual class="po-textual">Again particularly with respect to immutable processing, gXML offers an
opportunity to pass XML across the virtual machine/Java Native Interface
boundary. The XQuery Data Model defines the operations and properties that are
possible with (g)XML; there is no impediment to producing a
specification-compliant API in other languages, whether they are hosted in the
VM (Scala, Jython) or outside it (C++, Perl, Lua). This in turn suggests
possibilities for enabling most-efficient processing, for enabling scripting
in domain-specific languages, and so on.</textual></para><para class="po-block e473 e473"><textual class="po-textual">Perhaps most significantly, from the point of view of the gXML
development team: in recent years a number of new specifications have appeared
that offer exciting opportunities for advancing the state of the art of XML
processing. In Java, adoption of these technologiesâXQuery, XSLT2, XML
databasesâhas been slowed by the lack of support in dominant models,
and the limited extensibility possible. Even XML Schema has seen relatively
little adoption/development outside the enterprise; gXML includes a schema
model to address that issue. More importantly, the XQuery Data Model seems to
offer a well-thought foundation for the next ten years of development in
XML-related technologies. gXML proposes to embody that model for Java, while
providing compatibility with the existing tree models, enabling a unification
of processing while promoting differentiation, specialization, and
customization of models.</textual></para></section><section class="po-hcontainer e474 e474" xml:id="conclusion"><title class="po-block e475 e475"><textual class="po-textual">gXML Solution(s)</textual></title><para class="po-block e476 e476"><textual class="po-textual">We submit that gXML addresses the problems that its design set out to
address, and that have plagued a large population of developers. It resolves
the problem of multiple, competing tree models in Java, leverages the network
effect of the dominant Java tree model for XML (and in fact shares that
network effect with any other tree model over which a gXML bridge is
available), and permits comparison of and late (even runtime) selection of a
model best suited to the task. In the process, it begins to resolve the
problems of interoperability. It is based on a well-defined, rigorous
specification (the XQuery Data Model), which appears to be the best foundation
for the next generation of XML technologies. It introduces and promotes the
immutable paradigm for XML processing, and permits or encourages the
development of models able to fulfill the promise of that paradigm.</textual></para><para class="po-block e477 e477"><textual class="po-textual">gXML represents about five man-years of development, in its current
state. Its corporate sponsor has contributed it to open source because its
value can be directly correlated with its adoption. More bridges: more value
(to the contributing corporation and to everyone using gXML). More processors:
more value. For more code, though, we need help. Get involved! Try the code.
Our experience has been that it has immediate benefits, even for isolated
applications and processors. See a bug? Contribute a patch! Intrigued by the
promise gXML offers? Become a committer!</textual></para><para class="po-block e478 e478"><textual class="po-textual">Based on the previous ten years, introduction of so significant a shift
in APIs and paradigms in the Java world will need to last at least ten years.
The APIs developed ten years ago, viewed in hindsight, show what seem to be
obvious lacunae or missed focus. Are there such gaps and blind spots in gXML?
Take a look; if we're missing something, tell us now, and help us to address
it.</textual></para><para class="po-block e479 e479"><textual class="po-textual">Interested in the opportunities, but not in refining the core APIs? Want
to provide an XQuery Data Model over a different, currently unsupported tree
model (even over a non-XML structured data model)? Write a bridge. Our
experience suggests that investment for a new bridge is about one
programmer-month, for complete, but unoptimized functionality. Refinements
depend upon the underlying tree model; those that are closer in concept to the
XQuery Data Model tend to be easier to improve, while those further away
(particularly if they don't conform to XML Infoset) provide more challenges.
If developers involved in JDOM, DOM4J, or XOM are reading this, we hope to
have intrigued you enough that you'll contribute (or provide independently) a
bridge implementation for those models. What about a bridge for JSON? CSV?
Could the new, XQuery-conformant crop of XML databases expose programming
interfaces as bridges or as processors?</textual></para><para class="po-block e480 e480"><textual class="po-textual">Interested in a particular application of XML? Can it be conceived as an
XML processor? Development investment for a gXML processor varies pretty
widely, depending upon the complexity of the processing to be done. For
instance, the schema validation module included in the gXML source represents
perhaps six months of work; the conversion processor (because it really does
nothing more than embody an idiom already supported in the gXML core APIs)
required no more than a week. XQuery or XSLT 2.0 processors would represent
significant time investments. The field is vast, though, so it is impossible
to characterize (either in time or complexity) everything in it.</textual></para><para class="po-block e481 e481"><textual class="po-textual">Are we missing an obvious opportunity? Tell us about it. Or ... do it,
and show us up. Our primary hope, in releasing the code and this paper, is to
generate some excitement about the possibilities we believe to be inherent in
the gXML refactoring of XML in Java. Get excited; this could change the
game.</textual></para></section><appendix class="po-hcontainer e482 e482" xml:id="gxml-code"><title class="po-block e483 e483"><textual class="po-textual">gXML: Source</textual></title><para class="po-block e484 e484"><textual class="po-textual">As previously noted, the core of the gXML paradigm is an abstraction
called </textual><code class="po-atom e485 e485"><textual class="po-textual">Model</textual></code><textual class="po-textual">.  Because this is an example of the </textual><emphasis class="po-inline e486 e486"><textual class="po-textual">Handle/Body</textual></emphasis><textual class="po-textual">
design pattern (and is stateless), only one instance of </textual><code class="po-atom e487 e487"><textual class="po-textual">Model</textual></code><textual class="po-textual"> is
needed for navigation and investigation for any and all instances of the
XML tree model for which the particular </textual><code class="po-atom e488 e488"><textual class="po-textual">Model</textual></code><textual class="po-textual"> is specialized.
Consequently, it seems worthwhile to show the content of the </textual><code class="po-atom e489 e489"><textual class="po-textual">Model</textual></code><textual class="po-textual">
abstraction.  Comments have been removed.</textual></para><para class="po-block e490 e490"><code class="po-atom e491 e491"><textual class="po-textual">Model</textual></code><textual class="po-textual"> is composed from three interfaces, reflecting three different
forms of information that might be obtained from an XQuery Data Model: </textual><code class="po-atom e492 e492"><textual class="po-textual">NodeInformer</textual></code><textual class="po-textual">
reports information about the content/state of a particular node in context; </textual><code class="po-atom e493 e493"><textual class="po-textual">NodeNavigator</textual></code><textual class="po-textual">
permits one to obtain a different node given a particular starting node; </textual><code class="po-atom e494 e494"><textual class="po-textual">AxisNavigator</textual></code><textual class="po-textual">
supplies iteration over the standard XPath/XQuery axes, starting from a particular origin node.</textual></para><programlisting class="po-block e495 e495" xml:id="Model" xml:space="preserve" xreflabel="Model"><textual class="po-textual">
public interface Model&lt;N&gt;
    extends Comparator&lt;N&gt;, NodeInformer&lt;N&gt;, NodeNavigator&lt;N&gt;, AxisNavigator&lt;N&gt; {
    void stream(N node, boolean copyNamespaces, ContentHandler handler) throws GxmlException;
}

public interface NodeInformer&lt;N&gt; {
    Iterable&lt;QName&gt; getAttributeNames(N node, boolean orderCanonical);

    String getAttributeStringValue(N parent, String namespaceURI, String localName);

    URI getBaseURI(N node);

    URI getDocumentURI(N node);

    String getLocalName(N node);

    Iterable&lt;NamespaceBinding&gt; getNamespaceBindings(N node);

    String getNamespaceForPrefix(N node, String prefix);
    
    Iterable&lt;String&gt; getNamespaceNames(N node, boolean orderCanonical);

    String getNamespaceURI(N node);

    Object getNodeId(N node);

    NodeKind getNodeKind(N node);

    String getPrefix(N node);

    String getStringValue(N node);

    boolean hasAttributes(N node);

    boolean hasChildren(N node);

    boolean hasNamespaces(N node);

    boolean hasNextSibling(N node);

    boolean hasParent(N node);

    boolean hasPreviousSibling(N node);

    boolean isAttribute(N node);

    boolean isElement(N node);

    boolean isId(N node);

    boolean isIdRefs(N node);

    boolean isNamespace(N node);

    boolean isText(N node);

    boolean matches(N node, NodeKind nodeKind, String namespaceURI, String localName);

    boolean matches(N node, String namespaceURI, String localName);
}

public interface NodeNavigator&lt;N&gt; {
    N getAttribute(N node, String namespaceURI, String localName);

    N getElementById(N context, String id);

    N getFirstChild(N origin);

    N getFirstChildElement(N node);

    N getFirstChildElementByName(N node, String namespaceURI, String localName);

    N getLastChild(N node);

    N getNextSibling(N node);

    N getNextSiblingElement(N node);

    N getNextSiblingElementByName(N node, String namespaceURI, String localName);

    N getParent(N origin);

    N getPreviousSibling(N node);

    N getRoot(N node);
}

public interface AxisNavigator&lt;N&gt; {
    Iterable&lt;N&gt; getAncestorAxis(N node);

    Iterable&lt;N&gt; getAncestorOrSelfAxis(N node);

    Iterable&lt;N&gt; getAttributeAxis(N node, boolean inherit);

    Iterable&lt;N&gt; getChildAxis(N node);

    Iterable&lt;N&gt; getChildElements(N node);

    Iterable&lt;N&gt; getChildElementsByName(N node, String namespaceURI, String localName);

    Iterable&lt;N&gt; getDescendantAxis(N node);

    Iterable&lt;N&gt; getDescendantOrSelfAxis(N node);

    Iterable&lt;N&gt; getFollowingAxis(N node);

    Iterable&lt;N&gt; getFollowingSiblingAxis(N node);

    Iterable&lt;N&gt; getNamespaceAxis(N node, boolean inherit);

    Iterable&lt;N&gt; getPrecedingAxis(N node);

    Iterable&lt;N&gt; getPrecedingSiblingAxis(N node);
}
</textual></programlisting></appendix><bibliography class="po-hcontainer e496 e496"><title class="po-block e497 e497"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e498 e498" xml:id="AxiOM"><emphasis class="po-inline e499 e499"><textual class="po-textual">Axiom 1.2.8 API</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e500 e500" xlink:actuate="onRequest" xlink:href="http://ws.apache.org/commons/axiom/apidocs/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://ws.apache.org/commons/axiom/apidocs/index.html</textual></link></bibliomixed><bibliomixed class="po-block e501 e501" xml:id="LavaFlow"><textual class="po-textual">Brown W., R. Malveau, H. McCormick, T. Mowbray, and S. W. Thomas.
  </textual><emphasis class="po-inline e502 e502"><textual class="po-textual">Lava Flow anti-pattern</textual></emphasis><textual class="po-textual"> (Dec. 1999)
    </textual><link class="po-inline e503 e503" xlink:actuate="onRequest" xlink:href="http://www.antipatterns.com/lavaflow.htm" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.antipatterns.com/lavaflow.htm</textual></link></bibliomixed><bibliomixed class="po-block e504 e504" xml:id="DOM"><emphasis class="po-inline e505 e505"><textual class="po-textual">Document Object Model Technical Reports</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e506 e506" xlink:actuate="onRequest" xlink:href="http://www.w3.org/DOM/DOMTR" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/DOM/DOMTR</textual></link></bibliomixed><bibliomixed class="po-block e507 e507" xml:id="DOM4J"><emphasis class="po-inline e508 e508"><textual class="po-textual">DOM4J Introduction</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e509 e509" xlink:actuate="onRequest" xlink:href="http://dom4j.sourceforge.net/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dom4j.sourceforge.net/</textual></link></bibliomixed><bibliomixed class="po-block e510 e510" xml:id="XML"><textual class="po-textual">
    </textual><emphasis class="po-inline e511 e511"><textual class="po-textual">Extensible Markup Language (XML) 1.0 (Fifth Edition)</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e512 e512" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml/</textual></link></bibliomixed><bibliomixed class="po-block e513 e513" xml:id="GOF"><textual class="po-textual">Gamma, E., R. Helm, R. Johnson, and J. Vlissides.
    </textual><emphasis class="po-inline e514 e514"><textual class="po-textual">Design Patterns: Elements of Reusable Object-Oriented Software</textual></emphasis><textual class="po-textual">
    Addison-Wesley, 1995.</textual></bibliomixed><bibliomixed class="po-block e515 e515" xml:id="XMLInJava"><textual class="po-textual">Harold, E. </textual><emphasis class="po-inline e516 e516"><textual class="po-textual">Processing XML with Java</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e517 e517" xlink:actuate="onRequest" xlink:href="http://www.cafeconleche.org/books/xmljava/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.cafeconleche.org/books/xmljava/</textual></link></bibliomixed><bibliomixed class="po-block e518 e518" xml:id="WhatsWrong"><textual class="po-textual">Harold, E.  "What's Wrong with XML APIs (and how to fix them)"
    </textual><link class="po-inline e519 e519" xlink:actuate="onRequest" xlink:href="http://www.xom.nu/whatswrong/whatswrong.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xom.nu/whatswrong/whatswrong.html</textual></link></bibliomixed><bibliomixed class="po-block e520 e520" xml:id="Jaxen"><emphasis class="po-inline e521 e521"><textual class="po-textual">Jaxen</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e522 e522" xlink:actuate="onRequest" xlink:href="http://jaxen.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jaxen.org/</textual></link></bibliomixed><bibliomixed class="po-block e523 e523" xml:id="JDOM"><emphasis class="po-inline e524 e524"><textual class="po-textual">JDOM v1.1.1 API Specification</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e525 e525" xlink:actuate="onRequest" xlink:href="http://www.jdom.org/docs/apidocs/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.jdom.org/docs/apidocs/</textual></link></bibliomixed><bibliomixed class="po-block e526 e526" xml:id="XMLNS"><emphasis class="po-inline e527 e527"><textual class="po-textual">Namespaces in XML 1.0 (Second Edition)</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e528 e528" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml-names" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml-names</textual></link></bibliomixed><bibliomixed class="po-block e529 e529" xml:id="DMPerf"><textual class="po-textual">Sosnoski, D. "XML and Java technologies: Document models, Part 1: Performance"
    </textual><link class="po-inline e530 e530" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/xml/library/x-injava/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ibm.com/developerworks/xml/library/x-injava/index.html</textual></link></bibliomixed><bibliomixed class="po-block e531 e531" xml:id="DMUse"><textual class="po-textual">Sosnoski, D.  "XML and Java technologies: Java document model usage"
    </textual><link class="po-inline e532 e532" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/xml/library/x-injava2/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ibm.com/developerworks/xml/library/x-injava2/</textual></link></bibliomixed><bibliomixed class="po-block e533 e533" xml:id="Woden"><emphasis class="po-inline e534 e534"><textual class="po-textual">Welcome to Woden</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e535 e535" xlink:actuate="onRequest" xlink:href="http://ws.apache.org/woden/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://ws.apache.org/woden/</textual></link></bibliomixed><bibliomixed class="po-block e536 e536" xml:id="Xalan"><emphasis class="po-inline e537 e537"><textual class="po-textual">Xalan-Java</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e538 e538" xlink:actuate="onRequest" xlink:href="http://xml.apache.org/xalan-j/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://xml.apache.org/xalan-j/index.html</textual></link></bibliomixed><bibliomixed class="po-block e539 e539" xml:id="XalanDTM"><emphasis class="po-inline e540 e540"><textual class="po-textual">XalanDTM</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e541 e541" xlink:actuate="onRequest" xlink:href="http://xml.apache.org/xalan-j/dtm.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://xml.apache.org/xalan-j/dtm.html</textual></link></bibliomixed><bibliomixed class="po-block e542 e542" xml:id="Infoset"><emphasis class="po-inline e543 e543"><textual class="po-textual">XML Information Set (Second Edition)</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e544 e544" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml-infoset" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml-infoset</textual></link></bibliomixed><bibliomixed class="po-block e545 e545" xml:id="XPath1"><emphasis class="po-inline e546 e546"><textual class="po-textual">XML Path Language (XPath), Version 1.0</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e547 e547" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath/</textual></link></bibliomixed><bibliomixed class="po-block e548 e548" xml:id="WXS1"><emphasis class="po-inline e549 e549"><textual class="po-textual">XML Schema Part 1: Structures Second Edition</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e550 e550" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-1/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-1/</textual></link></bibliomixed><bibliomixed class="po-block e551 e551" xml:id="WXS2"><emphasis class="po-inline e552 e552"><textual class="po-textual">XML Schema Part 2: Datatypes Second Edition</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e553 e553" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-2/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-2/</textual></link></bibliomixed><bibliomixed class="po-block e554 e554" xml:id="XOM"><emphasis class="po-inline e555 e555"><textual class="po-textual">XOM 1.2.5</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e556 e556" xlink:actuate="onRequest" xlink:href="http://www.xom.nu/apidocs/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xom.nu/apidocs/</textual></link></bibliomixed><bibliomixed class="po-block e557 e557" xml:id="XDM"><emphasis class="po-inline e558 e558"><textual class="po-textual">XQuery 1.0 and XPath 2.0 Data Model (XDM)</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e559 e559" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel/</textual></link></bibliomixed><bibliomixed class="po-block e560 e560" xml:id="XSLT1"><emphasis class="po-inline e561 e561"><textual class="po-textual">XSL Transformations (XSLT), Version 1.0</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e562 e562" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt</textual></link></bibliomixed><bibliomixed class="po-block e563 e563" xml:id="XT"><emphasis class="po-inline e564 e564"><textual class="po-textual">XT</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e565 e565" xlink:actuate="onRequest" xlink:href="http://www.blnz.com/xt/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.blnz.com/xt/index.html</textual></link></bibliomixed></bibliography></article></classedDocument>