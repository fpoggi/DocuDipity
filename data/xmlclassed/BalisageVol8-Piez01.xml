<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Luminescent: parsing LMNL by XSLT upconversion</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">Among attempts to deal with the overlap problem, LMNL (Layered Markup and Annotation
        Language) has attracted its share of attention but has also never grown much past its
        origins as a thought experiment. LMNL’s conceptual model differs from XML’s, and by design
        its notation also differs from XML’s. Nonetheless, a pipeline of XSLT transformations can
        parse LMNL input and construct an XML representation of LMNL, with the resulting benefit
        that further XML tools can be used to analyze and process documents originating from the
        alien notation. The key is to regard the task as an upconversion: structural induction
        performed over plain text. </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Wendell</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Piez</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Wendell Piez has been attending Balisage and its antecedent conferences since the
          early days of XML; among his contributions has been, with Jeni Tennison, the original LMNL
          proposal (2002).</textual></para></personblurb><affiliation class="po-record e14 e14"><orgname class="po-block e15 e15"><textual class="po-textual">Mulberry Technologies, Inc.</textual></orgname></affiliation><email class="po-field e16 e16"><textual class="po-textual">wapiez@mulberrytech.com</textual></email></author><legalnotice class="po-container e17 e17"><para class="po-block e18 e18"><textual class="po-textual">Copyright © 2012 by the author. Used with permission.</textual></para></legalnotice></info><para class="po-block e19 e19"><emphasis class="po-inline e20 e20" role="bold"><textual class="po-textual">Luminescent</textual></emphasis><textual class="po-textual"> is a prototype parser and compiler for LMNL
    syntax, converting LMNL documents into </textual><emphasis class="po-inline e21 e21" role="bold"><textual class="po-textual">xLMNL</textual></emphasis><textual class="po-textual">, an XML-based
    representation of the LMNL model suitable for further processing. It consists of a series of
    XSLT 2.0 stylesheets, currently running in a web server (using Cocoon) or in batch mode (using
    an XProc pipeline). A second XProc pipeline can apply Schematron validation to the intermediate
    formats generated in Luminescent to detect and locate syntax errors in the input
    document.</textual></para><section class="po-hcontainer e22 e22"><title class="po-block e23 e23"><textual class="po-textual">LMNL: the Layered Markup and Annotation Language</textual></title><para class="po-block e24 e24"><textual class="po-textual">LMNL (Layered Markup and Annotation Language) is an approach to markup first proposed by
      Jeni Tennison and myself in 2002 [</textual><xref class="po-milestone e25 e25" linkend="tennison2002"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. It emulates XML in some
      respects, but also differs from it in several fundamental ways, suggesting some very different
      approaches to modeling text-based information using markup, with some very different
      applications. For this reason, even if an alternative processing stack could never be built on
      LMNL (which presumably it could, given enough time, effort and resources), and even if LMNL is
      never regarded as a replacement for XML (which it was never intended to be), it turns out to
      be fertile laboratory for solutions to modeling problems - including XML-based solutions for
      XML platforms.</textual></para><para class="po-block e26 e26"><textual class="po-textual">XML is defined [</textual><xref class="po-milestone e27 e27" linkend="xmlrec"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] as a syntax, but implies a model, which was
      described by the (non-normative) </textual><emphasis class="po-inline e28 e28" role="ital"><textual class="po-textual">XML Information Set</textual></emphasis><textual class="po-textual"> [</textual><xref class="po-milestone e29 e29" linkend="xmlinfoset"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], expressed in any number of code libraries and APIs (both official
      and unofficial), and finally standardized (at least in one variant) in the </textual><emphasis class="po-inline e30 e30" role="ital"><textual class="po-textual">XPath 2.0/XQuery Data Model</textual></emphasis><textual class="po-textual"> (XDM) [</textual><xref class="po-milestone e31 e31" linkend="xdm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] . LMNL
      inverts this, being defined first as an abstract model, whose syntax is proposed incidentally,
      as a form of representation (and as such, one among many conceivable). Nevertheless, the idea
      is the same: a formal model stabilizes a set of capabilities for tools performing useful
      operations over text-based information sets, and provides a basis for interoperability, while
      a syntax provides a serialization format and an interface for developers and users. Like XML,
      LMNL is conceived in order to support </textual><emphasis class="po-inline e32 e32" role="ital"><textual class="po-textual">markup</textual></emphasis><textual class="po-textual">, a means of
      assigning labels and attributing properties and relationships to data points or fields in
      text, by means of text; and like XML, LMNL expects to provide a basis for </textual><emphasis class="po-inline e33 e33" role="ital"><textual class="po-textual">descriptive</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e34 e34" role="ital"><textual class="po-textual">declarative</textual></emphasis><textual class="po-textual"> markup
      applications (although, again like XML, not only those), which support document and data
      processing within layered systems that can thus benefit from separation of concerns (between
      authoring, editorial, data management, and production tasks, for example), and that are not
      locked into single applications. Again like XML, LMNL does this by leaving it to applications
      to define their own sets of names, labels or keywords, to which they can assign whatever
      semantics they see fit. In this respect, LMNL syntax (like XML) is a meta-language while LMNL
      itself (like the XDM) is a meta-model: a model (with a design and hence a particular set of
      affordances in application) that we use to make models, of documents, families of documents,
      and assorted information sets of whatever description.</textual></para><para class="po-block e35 e35"><textual class="po-textual">This much is similar; the differences from XML are (primarily) in the design of the model
      itself, and (secondarily) in the syntax proposed to represent it. The syntax is designed to
      look as little like XML as possible, for two reasons: first, so that LMNL syntax may be
      embedded directly into XML syntax, or the reverse; and secondly, to reduce cognitive overload
      when thinking about LMNL and XML together, or when thinking about LMNL with the burden of
      expectations formed by XML. (At the level of the model, we have similarly tried to avoid using
      XML terminology for LMNL concepts except where the connections are strong.) In the interests
      of brevity, rather than explicate the model fully and offer rationales for it here, I offer a
      simple summary description of the model, and of LMNL syntax, together.</textual><note class="po-container e36 e36"><para class="po-block e37 e37"><textual class="po-textual">Readers may wish to review some of the historical LMNL specifications, which can now
          be found at </textual><xref class="po-milestone e38 e38" linkend="lmnl-markup"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></note></para><section class="po-hcontainer e39 e39"><title class="po-block e40 e40"><textual class="po-textual">Ranges</textual></title><para class="po-block e41 e41"><textual class="po-textual">Where XML has elements, LMNL has </textual><emphasis class="po-inline e42 e42" role="bold"><textual class="po-textual">ranges</textual></emphasis><textual class="po-textual">. Unlike XML
        elements, ranges in LMNL have no necessary relation with one another: they are neither
        parents, nor children of each other, nor in any hierarchy at all. Ranges may be named (names
        in LMNL are qualified by namespaces in much the way they are in XML), or anonymous. The
        assumption is that they will ordinarily have generic names indicating their type, like XML
        elements. Ranges are properties of an </textual><emphasis class="po-inline e43 e43" role="bold"><textual class="po-textual">owner limen</textual></emphasis><textual class="po-textual"> (using
        the Latin word for </textual><quote class="po-inline e44 e44"><textual class="po-textual">doorstep</textual></quote><textual class="po-textual"> to designate this important data object type),
        which belongs either to the document as a whole or an annotation, and which has a </textual><emphasis class="po-inline e45 e45" role="bold"><textual class="po-textual">value</textual></emphasis><textual class="po-textual"> comprising a single string (a sequence of contiguous
        characters). The value of the range will be a substring of the value of the limen, while its
        position will be the character offset within its limen where its starts.</textual></para><para class="po-block e46 e46"><textual class="po-textual">In order to avoid confusion with XML, LMNL syntax uses a different set of delimiters to
        identify starts and ends of ranges. This example shows a chunk of LMNL syntax with two types
        of ranges, </textual><emphasis class="po-inline e47 e47" role="bold"><textual class="po-textual">s</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e48 e48" role="bold"><textual class="po-textual">l</textual></emphasis><textual class="po-textual">, marked
        over the stream of text. </textual><emphasis class="po-inline e49 e49" role="bold"><textual class="po-textual">s</textual></emphasis><textual class="po-textual"> ranges do not overlap with other
          </textual><emphasis class="po-inline e50 e50" role="bold"><textual class="po-textual">s</textual></emphasis><textual class="po-textual"> ranges, and </textual><emphasis class="po-inline e51 e51" role="bold"><textual class="po-textual">l</textual></emphasis><textual class="po-textual"> never
        overlaps with </textual><emphasis class="po-inline e52 e52" role="bold"><textual class="po-textual">l</textual></emphasis><textual class="po-textual">, but the two types overlap each
        other:</textual><programlisting class="po-block e53 e53" xml:space="preserve"><textual class="po-textual">[s}[l}He manages to keep the upper hand{l]
[l}On his own farm.{s] [s}He's boss.{s] [s}But as to hens:{l]
[l}We fence our flowers in and the hens range.{l]{s]</textual></programlisting></para><para class="po-block e54 e54"><textual class="po-textual">In the way that XML has a concise empty-element syntax, empty ranges may also be marked
        with single tags, as in </textual><code class="po-atom e55 e55"><textual class="po-textual">[br]</textual></code><textual class="po-textual">. Empty ranges have no value (or their value is an
        empty string), although they do have a position within their owner layer.</textual></para><para class="po-block e56 e56"><textual class="po-textual">It is sometimes convenient (although LMNL syntax does not require it) to designate a
        single range covering the entire
        document:</textual><programlisting class="po-block e57 e57" xml:space="preserve"><textual class="po-textual">[excerpt}
[s}[l}He manages to keep the upper hand{l]
[l}On his own farm.{s] [s}He's boss.{s] [s}But as to hens:{l]
[l}We fence our flowers in and the hens range.{l]{s]
{excerpt]</textual></programlisting></para></section><section class="po-hcontainer e58 e58"><title class="po-block e59 e59"><textual class="po-textual">Arbitrary overlap</textual></title><para class="po-block e60 e60"><textual class="po-textual">LMNL supports arbitrary overlap, which is to say overlapping ranges of the same type.
        This is important for certain potential applications such as annotation frameworks and range
        indexing, where ranges of text need to be identified that may overlap, while still being of
        the same type.</textual></para><para class="po-block e61 e61"><textual class="po-textual">In LMNL syntax, this example shows two ranges named </textual><emphasis class="po-inline e62 e62" role="bold"><textual class="po-textual">r</textual></emphasis><textual class="po-textual">,
        overlapping each
        other:</textual><programlisting class="po-block e63 e63" xml:space="preserve"><textual class="po-textual">[r=r1}A case [r=r2}of{r=r1] arbitrary overlap{r=r2]</textual></programlisting><textual class="po-textual">While
        the range identifier (given after the </textual><code class="po-atom e64 e64"><textual class="po-textual">=</textual></code><textual class="po-textual">) is optional, when it is not given, a
        close tag is presumed to match the most recent open tag with the same combination of name
        and identifier; thus to express overlap of this kind (rather than one </textual><emphasis class="po-inline e65 e65" role="bold"><textual class="po-textual">r</textual></emphasis><textual class="po-textual"> range simply being enclosed in the other), the identifier is necessary on
        the tags marking at least one of the ranges involved. But the identifier is not formally
        part of the name.</textual></para></section><section class="po-hcontainer e66 e66"><title class="po-block e67 e67"><textual class="po-textual">Annotations</textual></title><para class="po-block e68 e68"><textual class="po-textual">While XML elements may have attributes, LMNL ranges may have </textual><emphasis class="po-inline e69 e69" role="bold"><textual class="po-textual">annotations</textual></emphasis><textual class="po-textual">. Unlike XML attributes, there is no restriction against assigning
        more than one annotation with the same name to a given range; likewise, the order of
        annotations on a range is supported in the model.</textual></para><para class="po-block e70 e70"><textual class="po-textual">In the syntax, annotations are represented by using tagging inside
        tagging:</textual><programlisting class="po-block e71 e71" xml:space="preserve"><textual class="po-textual">[excerpt [source}The Housekeeper{source] [author}Robert Frost{author]}
[s}[l [n}144{n]}He manages to keep the upper hand{l]
[l [n}145{n]}On his own farm.{s] [s}He's boss.{s] [s}But as to hens:{l]
[l [n}146{n]}We fence our flowers in and the hens range.{l]{s]
{excerpt]</textual></programlisting><textual class="po-textual">In
        order to reduce tagging overhead, when annotations contain only simple string values, their
        close tags may be presented in abbreviated notation (resembling anonymous end
        tags):</textual><programlisting class="po-block e72 e72" xml:space="preserve"><textual class="po-textual">...[l [n}145{]}On his own farm.{s [id}s1{]]...</textual></programlisting><textual class="po-textual">In
        addition (as this example also shows), the syntax permits placing annotations on end tags,
        not only on start tags.</textual></para><para class="po-block e73 e73"><textual class="po-textual">Finally, while attributes in XML assign properties to elements as name-value pairs, LMNL
        annotations may be structured. In the LMNL model, annotations are isomorphic to LMNL
        documents: like a document, an annotation has a limen with content and optionally ranges
        over that content. Likewise, like ranges (including ranges over annotation content),
        annotations may be annotated.</textual></para><para class="po-block e74 e74"><textual class="po-textual">Given this flexibility it is sometimes convenient for annotations, like ranges, to be
        empty, having no content but only annotations, which it groups, orders and names.</textual></para><para class="po-block e75 e75"><textual class="po-textual">So this is legal syntax and represents a coherent LMNL document
        object:</textual><programlisting class="po-block e76 e76" xml:space="preserve"><textual class="po-textual">[excerpt
  [source [date}1915{][title}The Housekeeper{]]
  [author
    [name}Robert Frost{]
    [dates}1874-1963{]] }
[s}[l [n}144{n]}He manages to keep the upper hand{l]
[l [n}145{n]}On his own farm.{s] [s}He's boss.{s] [s}But as to hens:{l]
[l [n}146{n]}We fence our flowers in and the hens range.{l]{s]
{excerpt]</textual></programlisting></para><para class="po-block e77 e77"><textual class="po-textual">In this example, the </textual><code class="po-atom e78 e78"><textual class="po-textual">excerpt</textual></code><textual class="po-textual"> range carries two empty annotations,
          </textual><code class="po-atom e79 e79"><textual class="po-textual">source</textual></code><textual class="po-textual"> and </textual><code class="po-atom e80 e80"><textual class="po-textual">author</textual></code><textual class="po-textual">, each of which has annotations of its
        own.</textual></para><para class="po-block e81 e81"><textual class="po-textual">This is an especially powerful feature of LMNL, not only because it provides a very
        useful capability in modeling (as it presents annotations in a directed graph structure
        – as if XML attributes could have their own attributes), but also because of its
        implications for the way documentary information is organized and linked. For example, a
        LMNL system might well support attaching a document dynamically as an annotation to a range
        in another document.</textual></para></section><section class="po-hcontainer e82 e82"><title class="po-block e83 e83"><textual class="po-textual">Atoms</textual></title><para class="po-block e84 e84"><textual class="po-textual">At its base, a LMNL document is defined as a sequence of </textual><emphasis class="po-inline e85 e85" role="bold"><textual class="po-textual">atoms</textual></emphasis><textual class="po-textual">: the most common type of atom will ordinarily be a </textual><quote class="po-inline e86 e86"><textual class="po-textual">character
          atom</textual></quote><textual class="po-textual">, represented by a single Unicode character in the syntax. Yet while every
        character in Unicode maps to a corresponding atom, atoms in LMNL are also capable of
        representing other information of whatever kind an application may find it useful to
        represent in this way.</textual></para><para class="po-block e87 e87"><textual class="po-textual">An atom has string length of 1. Consequently, and unlike empty ranges, atoms not only
        have location, but they </textual><quote class="po-inline e88 e88"><textual class="po-textual">occupy space</textual></quote><textual class="po-textual">, are included in the value of ranges in
        which they participate, and can be marked up. Atoms are identified with their own notation,
          </textual><code class="po-atom e89 e89"><textual class="po-textual">{{ }}</textual></code><textual class="po-textual">, in the syntax.</textual><footnote class="po-popup e90 e90"><para class="po-block e91 e91"><textual class="po-textual">This raises the question whether characters can be represented with atom syntax,
            whether they can be annotated, and so forth.</textual></para><para class="po-block e92 e92"><textual class="po-textual">The character </textual><quote class="po-inline e93 e93"><textual class="po-textual">A</textual></quote><textual class="po-textual"> may indeed be represented as </textual><code class="po-atom e94 e94"><textual class="po-textual">{{#x41}}</textual></code><textual class="po-textual">
            (using a shorthand reference) or </textual><code class="po-atom e95 e95"><textual class="po-textual">{{lmnl:char [codepoint}41{]}}</textual></code><textual class="po-textual"> using a
            reserved name for the atom with an annotation to identify it. But add another annotation
            to the latter form and it will not map back again. (It would be an </textual><quote class="po-inline e96 e96"><textual class="po-textual">annotated
              character</textual></quote><textual class="po-textual">, and as such could not be represented in a Unicode serialization by
            itself.)</textual></para></footnote><textual class="po-textual"> In this example, an atom named </textual><emphasis class="po-inline e97 e97" role="bold"><textual class="po-textual">logo</textual></emphasis><textual class="po-textual"> is marked
        up with a range named </textual><emphasis class="po-inline e98 e98" role="bold"><textual class="po-textual">link</textual></emphasis><textual class="po-textual">:</textual><programlisting class="po-block e99 e99" xml:space="preserve"><textual class="po-textual">[link [href}lmnl-markup.org{]}{{logo [src}lmnl-markup.org/hat.png{]}}{link]</textual></programlisting></para></section></section><section class="po-hcontainer e100 e100"><title class="po-block e101 e101"><textual class="po-textual">xLMNL: an XML-based representation of the LMNL data model</textual></title><para class="po-block e102 e102"><textual class="po-textual">One way LMNL builds on the conceptual foundation of XML is by differentiating between
      operations on the syntax, which imply parsing, and operations on optimized representations of
      documents held in memory: </textual><quote class="po-inline e103 e103"><textual class="po-textual">the model</textual></quote><textual class="po-textual">. This differentiation gives us leverage in
      development, since we have the opportunity to identify either syntax or model as the
      appropriate place for design and implementation, whether that be of the tag set itself
      (considered as a set of labels and constraints over their use), user interfaces,
      transformations or anything else.</textual></para><para class="po-block e104 e104"><textual class="po-textual">Paradoxically, while the LMNL model is designed in deliberate contrast to XML, it is
      nevertheless useful to specify an XML-based representation of it, for several reasons. First,
      it exposes instances conveniently by giving us the opportunity to serialize LMNL documents in
      XML syntax. Second, it makes it possible to use XML-based tools (such as XSLT, schema
      technologies, XQuery, XML servers, CMS and database technology) to query and manipulate LMNL
      – an advantage for those of us who are well-practiced in these technologies for data
      processing, but not in Java or Python. And thirdly, it clarifies some of the resemblances and
      differences between LMNL and other approaches (especially XML-based approaches) to the problem
      set.</textual></para><para class="po-block e105 e105"><textual class="po-textual">Since 2002, I have experimented with adapting XML to LMNL in several different ways. Not
      only can XML elements be construed as LMNL ranges and XML attributes as LMNL annotations (this
      is the essence of the CLIX and ECLIX approaches, cf </textual><xref class="po-milestone e106 e106" linkend="piez2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">); also,
      XML-based notations for representing overlap, such as milestone-based notations or segmented
      and aligned XML elements, can be mapped into LMNL. This provides a framework, at least, for
      thinking systematically about how to implement and maintain processes to manage these awkward
      and difficult forms of XML.</textual></para><para class="po-block e107 e107"><textual class="po-textual">Yet the real power of the LMNL model as such cannot be exploited without a more direct
      representation. </textual><emphasis class="po-inline e108 e108" role="bold"><textual class="po-textual">xLMNL</textual></emphasis><textual class="po-textual"> is an XML-based representation of the
      model itself: that is to say, it leaves behind the concept of a document as an information set
      represented in embedded markup (literal tags applied directly to literal text), and simply
      uses XML as a kind of </textual><quote class="po-inline e109 e109"><textual class="po-textual">poor man's (hierarchical) database</textual></quote><textual class="po-textual">. This gives us many of
      the advantages of an XML platform described above, while making downstream applications more
      tractable, inasmuch as they can work directly with LMNL as conceptualized, rather than at a
      remove. At the price of being somewhat heavyweight and memory intensive, xLMNL is thus a
      useful interim format for testing ideas and demonstrating concepts.</textual></para><para class="po-block e110 e110"><textual class="po-textual">Again, the most concise way of presenting this design is by way of an example: the xLMNL
      equivalent of the document given above is presented in </textual><xref class="po-milestone e111 e111" linkend="xlmnl-example"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual><note class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">Note however that the notation itself is not at all concise! In fact there are many
          redundancies built into xLMNL, as compared to a bare LMNL range model, in order to
          streamline downstream processes. For example, text layer content is broken up into spans
          which are indexed to the ranges in which they participate. While a LMNL processor might
          wish to calculate this on the fly, when working on a static document it makes sense to
          index them only once, so this is done in xLMNL. It should go without saying that this does
          not preclude a more lightweight standoff-based XML representation of LMNL.</textual></para><para class="po-block e114 e114"><textual class="po-textual">xLMNL has undergone several iterations since I first starting modeling LMNL directly
          with XML in 2004 [</textual><xref class="po-milestone e115 e115" linkend="piez2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, and see also </textual><xref class="po-milestone e116 e116" linkend="piez2010"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]</textual></para></note></para><para class="po-block e117 e117"><textual class="po-textual">Developers who work on the overlap problem in XML will recognize this as a standoff
      representation of ranges. As such, it might be generated and maintained in any number of ways
      – even (if rather onerously) by hand.</textual></para><para class="po-block e118 e118"><textual class="po-textual">Nevertheless, no claim should be inferred that I suppose xLMNL to be at all an optimal
      approach to working with LMNL on an XML platform. The best argument for doing this is that
      fairly dramatic demonstrations of the interest of overlapping markup are not all that hard to
      come by if one only has a means by which to create them, and xLMNL is a step along the
      way.</textual></para><para class="po-block e119 e119"><textual class="po-textual">A schema for xLMNL, using Relax NG (compact syntax)
      appears in </textual><xref class="po-milestone e120 e120" linkend="xlmnl-schema"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e121 e121"><title class="po-block e122 e122"><textual class="po-textual">Compiling LMNL syntax into xLMNL via XSLT upconversion</textual></title><para class="po-block e123 e123"><textual class="po-textual">In its current form, the complete Luminescent pipeline has thirteen steps, each of which
      is implemented in an XSLT 2.0 transformation. These can be chained together using any
      available means; I have used both XProc and Cocoon (which is convenient for hooking
      Luminescent together with further transformations processing xLMNL into various targets).
      Several of the steps could be combined for greater efficiency; the reason to have so many
      presently is to maximize transparency for development and debugging.</textual></para><para class="po-block e124 e124"><textual class="po-textual">The steps proceed as follows:</textual><orderedlist class="po-table e125 e125"><listitem class="po-container e126 e126"><para class="po-block e127 e127"><textual class="po-textual">Comments are extracted using a regular expression matching on open and close comment
            delimiters (</textual><code class="po-atom e128 e128"><textual class="po-textual">[!--</textual></code><textual class="po-textual"> and </textual><code class="po-atom e129 e129"><textual class="po-textual">--]</textual></code><textual class="po-textual">). This has to be done first so that
            markup inside comments will not be processed in subsequent steps. The result is a single
            element (representing the root of the tag tree) containing a sequence of strings and
            elements representing comments.</textual></para></listitem><listitem class="po-container e130 e130"><para class="po-block e131 e131"><textual class="po-textual">Tokenization: all open and close tag delimiters, </textual><code class="po-atom e132 e132"><textual class="po-textual">[</textual></code><textual class="po-textual">, </textual><code class="po-atom e133 e133"><textual class="po-textual">{</textual></code><textual class="po-textual">,
              </textual><code class="po-atom e134 e134"><textual class="po-textual">]</textual></code><textual class="po-textual"> and </textual><code class="po-atom e135 e135"><textual class="po-textual">}</textual></code><textual class="po-textual"> in document content (i.e., not inside comments) are
            matched and wrapped as XML </textual><emphasis class="po-inline e136 e136" role="bold"><textual class="po-textual">t</textual></emphasis><textual class="po-textual"> elements (for </textual><emphasis class="po-inline e137 e137" role="bold"><textual class="po-textual">token</textual></emphasis><textual class="po-textual">). The result is a sequence of strings interspersed with
            comments and these elements, representing tag delimiters.</textual></para></listitem><listitem class="po-container e138 e138"><para class="po-block e139 e139"><textual class="po-textual">The token (</textual><emphasis class="po-inline e140 e140" role="bold"><textual class="po-textual">t</textual></emphasis><textual class="po-textual">) elements are marked with line and
            character offsets, to be carried forward for purposes of any error reporting that has to
            be performed later.</textual></para></listitem><listitem class="po-container e141 e141"><para class="po-block e142 e142"><textual class="po-textual">A sibling recursion is applied to infer tagging from the tokens. A </textual><emphasis class="po-inline e143 e143" role="bold"><textual class="po-textual">tag</textual></emphasis><textual class="po-textual"> element is initiated with each open delimiter
              (</textual><code class="po-atom e144 e144"><textual class="po-textual">[</textual></code><textual class="po-textual"> or </textual><code class="po-atom e145 e145"><textual class="po-textual">{</textual></code><textual class="po-textual">); each close delimiter (</textual><code class="po-atom e146 e146"><textual class="po-textual">]</textual></code><textual class="po-textual"> or
              </textual><code class="po-atom e147 e147"><textual class="po-textual">}</textual></code><textual class="po-textual">) ends the </textual><emphasis class="po-inline e148 e148" role="bold"><textual class="po-textual">tag</textual></emphasis><textual class="po-textual"> element most recently
            started. The result is a rudimentary tag tree of the document. Delimiters and comments
            are retained.</textual></para></listitem><listitem class="po-container e149 e149"><para class="po-block e150 e150"><textual class="po-textual">Types are assigned to the tags, which are mapped to </textual><emphasis class="po-inline e151 e151" role="bold"><textual class="po-textual">start</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e152 e152" role="bold"><textual class="po-textual">end</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e153 e153" role="bold"><textual class="po-textual">empty</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e154 e154" role="bold"><textual class="po-textual">atom</textual></emphasis><textual class="po-textual"> elements. This works by
            inferring each type of tag from its open and close delimiters: </textual><code class="po-atom e155 e155"><textual class="po-textual">[r}</textual></code><textual class="po-textual"> for
            start, </textual><code class="po-atom e156 e156"><textual class="po-textual">{r]</textual></code><textual class="po-textual"> for end, </textual><code class="po-atom e157 e157"><textual class="po-textual">[e]</textual></code><textual class="po-textual"> for empty, and </textual><code class="po-atom e158 e158"><textual class="po-textual">{{a}}</textual></code><textual class="po-textual"> for
            atom. The extra level of delimiters required for atoms is respected; tags with
              </textual><quote class="po-inline e159 e159"><textual class="po-textual">outer shells</textual></quote><textual class="po-textual"> but no </textual><quote class="po-inline e160 e160"><textual class="po-textual">inner shells</textual></quote><textual class="po-textual"> (that is, that fail to
            respect the double-brace syntax of atoms, as in </textual><code class="po-atom e161 e161"><textual class="po-textual">{{atom}}</textual></code><textual class="po-textual">) are marked as
            errors.</textual></para><para class="po-block e162 e162"><textual class="po-textual">Simultaneously, tag names (generic identifiers) are extracted from their values. Any
            tags that have range identifiers with the generic identifier keeps its range identifier
            as part of its GI. (So a tag </textual><code class="po-atom e163 e163"><textual class="po-textual">[range=r1}</textual></code><textual class="po-textual"> is represented as </textual><code class="po-atom e164 e164"><textual class="po-textual">&lt;range
              gi="range=r1"/&gt;</textual></code><textual class="po-textual">.)</textual></para></listitem><listitem class="po-container e165 e165"><para class="po-block e166 e166"><textual class="po-textual">Start tags are marked with unique identifiers (distinct from any range identifiers
            already given).</textual></para></listitem><listitem class="po-container e167 e167"><para class="po-block e168 e168"><textual class="po-textual">By means of another sibling recursion, end tags are marked with the identifier of
            the most recent start tag with the same GI.</textual></para><para class="po-block e169 e169"><textual class="po-textual">Since range identifiers are still, at this stage, considered part of the GI, the
            sibling recursion in this process matches end tags to start tags correctly.</textual></para></listitem><listitem class="po-container e170 e170"><para class="po-block e171 e171"><textual class="po-textual">Matching start and end-tag pairs appearing inside tags are promoted into
            annotations.</textual></para><para class="po-block e172 e172"><textual class="po-textual">This is the trickiest step, for two reasons. First, abbreviated syntax permitted for
            simple annotations means that anonymous end tags (</textual><code class="po-atom e173 e173"><textual class="po-textual">{]</textual></code><textual class="po-textual">) may be matched with
            named start tags. Secondly, annotations may contain markup, and so not just any tag
            directly inside a tag is actually an annotation delimiter (it could mark up a range over
            content inside the annotation). This process must work, again, via sibling recursion
            (the third one performed in the pipeline). Where tagging is not correct, </textual><emphasis class="po-inline e174 e174" role="bold"><textual class="po-textual">error</textual></emphasis><textual class="po-textual"> elements may be generated.</textual></para></listitem><listitem class="po-container e175 e175"><para class="po-block e176 e176"><textual class="po-textual">Character offsets are marked on </textual><emphasis class="po-inline e177 e177" role="bold"><textual class="po-textual">start</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e178 e178" role="bold"><textual class="po-textual">end</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e179 e179" role="bold"><textual class="po-textual">empty</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e180 e180" role="bold"><textual class="po-textual">atom</textual></emphasis><textual class="po-textual"> tag elements, and text spans are wrapped (with </textual><emphasis class="po-inline e181 e181" role="bold"><textual class="po-textual">span</textual></emphasis><textual class="po-textual"> elements) and marked with character offsets within their
            owner layer (or </textual><emphasis class="po-inline e182 e182" role="bold"><textual class="po-textual">limen</textual></emphasis><textual class="po-textual"> in LMNL terminology: the
            annotation or document within which they appear). The offsets are determined from the
            lengths of string content (text nodes in the XML), with any atoms appearing being given
            length 1, while comments and range markers have length 0.</textual></para></listitem><listitem class="po-container e183 e183"><para class="po-block e184 e184"><textual class="po-textual">Proper generic identifiers (range names) are derived from combinations of ranges
            with their identifiers. (The identifiers are saved as </textual><emphasis class="po-inline e185 e185" role="bold"><textual class="po-textual">label</textual></emphasis><textual class="po-textual"> attributes in case they may be wanted.)</textual></para></listitem><listitem class="po-container e186 e186"><para class="po-block e187 e187"><textual class="po-textual">Unique identifiers are assigned to ranges; range </textual><emphasis class="po-inline e188 e188" role="bold"><textual class="po-textual">start</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e189 e189" role="bold"><textual class="po-textual">end</textual></emphasis><textual class="po-textual"> tags have the same
            identifier, while </textual><emphasis class="po-inline e190 e190" role="bold"><textual class="po-textual">empty</textual></emphasis><textual class="po-textual"> range tags have their own.
            Similarly, annotations are marked with unique identifiers, as is the document as a
            whole.</textual></para></listitem><listitem class="po-container e191 e191"><para class="po-block e192 e192"><textual class="po-textual">Layer identifiers are assigned to spans, corresponding to the limen (annotation or
            document) in which the span appears. Strictly speaking these identifiers are redundant,
            since the same information is given by the xLMNL document structure; but they are useful
            for optimizing subsequent (downstream) processes or (potentially) for processing or
            aggregating LMNL documents described in multiple xLMNL instances.</textual></para><para class="po-block e193 e193"><textual class="po-textual">The result of this step is a comprehensive </textual><quote class="po-inline e194 e194"><textual class="po-textual">tag tree</textual></quote><textual class="po-textual"> of the marked up
            LMNL syntax instance.</textual></para><para class="po-block e195 e195"><textual class="po-textual">(A later project goal will be to codify this format for interchange; it maps to the
            earlier CLIX format. This may also prove to be more robust than xLMNL for maintenance of
            LMNL data sets in XML, since ranges are still represented by tags within the text stream
            rather than standoff markup.)</textual></para></listitem><listitem class="po-container e196 e196"><para class="po-block e197 e197"><textual class="po-textual">The tag tree is converted into xLMNL by reading range elements from start/end tag
            pairs, or from empty range markers as the case may be. Ranges are marked with the start
            and end offsets, read from their tags. Spans are marked with pointers to the ranges in
            which they participate. (A fourth sibling recursion accomplishes this. Again, the
            information here is redundant but useful.)</textual></para></listitem></orderedlist></para><section class="po-hcontainer e198 e198"><title class="po-block e199 e199"><textual class="po-textual">Checking LMNL syntax for well-formedness</textual></title><para class="po-block e200 e200"><textual class="po-textual">Rather than stop processing, the pipeline currently emits </textual><emphasis class="po-inline e201 e201" role="bold"><textual class="po-textual">error</textual></emphasis><textual class="po-textual"> elements when it encounters problems, with codes identifying the issue.
        This appears to work well.</textual></para><para class="po-block e202 e202"><textual class="po-textual">In addition, more precise diagnostics are performed by applying Schematron validation to
        particular steps in the pipeline. (This is implemented with a second XProc pipeline
        specification that imports the main one, applies Schematron schemas to the results of two of
        Luminescent's intermediate formats, aggregates their results together and formats them.) For
        example, using Schematron it is easy to check whether all start tags have matching end tags
        or vice-versa, or that range or annotation names follow their rules. Because the
        intermediate formats carry forward information on the location of tagging in the original
        LMNL syntax instance, Schematron can report the locations of tagging found to be
        problematic.</textual></para><para class="po-block e203 e203"><textual class="po-textual">This is especially important since LMNL syntax becomes hard to read as the markup
        becomes more complex.</textual><footnote class="po-popup e204 e204"><para class="po-block e205 e205"><textual class="po-textual">This is a problem for which embedded markup, of course, has no built-in solution (as
            Desmond Schmidt has pointed out, </textual><xref class="po-milestone e206 e206" linkend="schmidt2010"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) other than using only
            tag sets that do not permit complexity – a high price to pay (a baby for less bath
            water), and not the idea at all. Of course, the syntax is not ultimately the point of
            the LMNL model (which might be supported in all kinds of different interfaces) but only
            a means to an end.</textual></para></footnote><textual class="po-textual"> For example, here is a malformed
        instance:</textual><programlisting class="po-block e207 e207" xml:space="preserve"><textual class="po-textual">[excerpt [source}The Housekeeper{source] [author}Robert Frost{author]]}
[s}[l [n}144{n]}He manages to keep the upper hand{l]
[l [n}145{n]}On his own farm.{s] [s}He's boss.{s] [s}But as to hens:{l]
[l [n}146{n]}We fence our flowers in and the hens range.{l]{s]
{excerpt]</textual></programlisting><textual class="po-textual">(The
        error occurs at the end of the first line, where an extra </textual><code class="po-atom e208 e208"><textual class="po-textual">]</textual></code><textual class="po-textual"> appears before the
          </textual><code class="po-atom e209 e209"><textual class="po-textual">}</textual></code><textual class="po-textual"> ending the start tag.)</textual></para><para class="po-block e210 e210"><textual class="po-textual">Schematron reports
        this:</textual><programlisting class="po-block e211 e211" xml:space="preserve"><textual class="po-textual">Error UNEXPECTED-TAGGING reported for } at 1:71,
  C:\Projects\LMNL\Luminescent\lmnl\frost-quote.lmnl
No start tag matches end tag {excerpt] at 5:1,
  C:\Projects\LMNL\Luminescent\lmnl\frost-quote.lmnl</textual></programlisting><textual class="po-textual">The
        processor has taken the mistaken </textual><code class="po-atom e212 e212"><textual class="po-textual">]</textual></code><textual class="po-textual">, as it must, as the end of the tag; and
        since it therefore makes an empty range marker, the end tag that is supposed to match it is
        found to have no start tag.</textual></para><para class="po-block e213 e213"><textual class="po-textual">The two errors are detected differently. The first error is reported for any tag
        delimiter that can't be matched with a corresponding delimiter of the opposite kind (start
        or end). The second is reported for the failure to follow the constraint that all start tags
        must have end tags and vice versa.</textual></para><para class="po-block e214 e214"><textual class="po-textual">The line numbers and offsets reported (1:71 and 5:1) correctly locate the problems;
        character 71 of line 1 is the location of the orphaned tag close delimiter </textual><code class="po-atom e215 e215"><textual class="po-textual">}</textual></code><textual class="po-textual">
        (which would have closed a start tag had the </textual><code class="po-atom e216 e216"><textual class="po-textual">]</textual></code><textual class="po-textual"> character not intervened), while
        line 5 character 1 is where the orphaned end tag is located.</textual></para></section></section><section class="po-hcontainer e217 e217"><title class="po-block e218 e218"><textual class="po-textual">Working with the model: prototype LMNL applications</textual></title><para class="po-block e219 e219"><textual class="po-textual">Currently I have several processes running with xLMNL as source. Some of these are tuned
      to particular tag sets, while others are generic. A selection is offered in place of
      presentation slides for this paper (the zipped package contains a mix of HTML, XML and SVG and
      can be reviewed starting from </textual><code class="po-atom e220 e220"><textual class="po-textual">index.html</textual></code><textual class="po-textual"> using any current web browser).</textual><itemizedlist class="po-table e221 e221"><listitem class="po-container e222 e222"><para class="po-block e223 e223"><textual class="po-textual">A generic diagnostic stylesheet can report which range types overlap with which
            other range types. (This is most useful to know for process customization.)</textual></para></listitem><listitem class="po-container e224 e224"><para class="po-block e225 e225"><textual class="po-textual">XML can be extracted from xLMNL dynamically, using a parameterized listing of range
            types to be reflected as a hierarchy of XML elements. Ranges of these types are promoted
            into XML elements; their annotations become, when they have simple values, XML
            attributes. Ranges not among these types, and annotations that are not cast to
            attributes, become XML elements representing range delimiters (tags) or annotation
            structures. Spans of text are kept with pointers to the ranges in which they
            participate, when these have not been cast to ancestor elements.</textual></para><para class="po-block e226 e226"><textual class="po-textual">This process can be run independently, but its functionality is also available
            dynamically as a function call in XSLT, operating on any xLMNL document or annotation
            (or a subset of spans from within a document or annotation, perhaps those associated
            with a given range) and casting it into XML.</textual></para><para class="po-block e227 e227"><textual class="po-textual">This is also a generic process, although the particular ranges to be converted into
            XML elements is passed in at run time.</textual></para></listitem><listitem class="po-container e228 e228"><para class="po-block e229 e229"><textual class="po-textual">SVG graphs and HTML renditions can be generated to display and depict LMNL
            documents. These transformations, to be sure, are not always trivial; but their
            difficulties are greatly mitigated by the XML extraction process just mentioned, used to
            cast LMNL into intermediate XML formats (hierarchical </textual><quote class="po-inline e230 e230"><textual class="po-textual">views</textual></quote><textual class="po-textual"> of the
            LMNL).</textual></para><para class="po-block e231 e231"><textual class="po-textual">These are not generic processes, since of course particular displays are optimized
            for particular tagging semantics, but some of them do rely on imported functionalities
            implemented generically (such as the logic that generates SVG </textual><quote class="po-inline e232 e232"><textual class="po-textual">bubble
              graphs</textual></quote><textual class="po-textual">), so it can be shared.</textual></para></listitem></itemizedlist></para><para class="po-block e233 e233"><textual class="po-textual">Links to demonstrations are provided in </textual><xref class="po-milestone e234 e234" linkend="demonstrations"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e235 e235"><title class="po-block e236 e236"><textual class="po-textual">Reflections</textual></title><para class="po-block e237 e237"><textual class="po-textual">I can make no pretense as to the efficiency or scalability of this approach. So far, it
      has only worked well enough for my purposes: to demonstrate its feasibility in principle, and
      to test the specifications. While it has performed adequately well on documents up to several
      hundred Kb in size, and experience suggests that processing bottlenecks for Luminescent are
      actually more likely coming out of xLMNL rather than into it, I have no data to confirm my
      intuitions here. There does appear to be a rich and interesting set of problems at
      hand.</textual></para><para class="po-block e238 e238"><textual class="po-textual">Nevertheless, if nothing else, this exercise has suggested some very interesting things
      about markup technologies beyond XML. One of the keys appears to be the separation of the
      parsing of the syntax from the construction of the model; so the parse tree is a tree only of
      the tags, from which the document model is derived by a different process. (The parse itself
      works like a parse of S-expressions, in which open and close delimiters are recursively parsed
      into tags.</textual><footnote class="po-popup e239 e239"><para class="po-block e240 e240"><textual class="po-textual">In fact the initial insight that led to the development of this pipeline was that if
          one were to perform simple string substitutions as follows, the result would be S-expression-like:</textual><itemizedlist class="po-table e241 e241"><listitem class="po-container e242 e242"><para class="po-block e243 e243"><code class="po-atom e244 e244"><textual class="po-textual">[</textual></code><textual class="po-textual"> and </textual><code class="po-atom e245 e245"><textual class="po-textual">{</textual></code><textual class="po-textual"> (open tag delimiters) become </textual><code class="po-atom e246 e246"><textual class="po-textual">([</textual></code><textual class="po-textual">
                and </textual><code class="po-atom e247 e247"><textual class="po-textual">({</textual></code></para></listitem><listitem class="po-container e248 e248"><para class="po-block e249 e249"><code class="po-atom e250 e250"><textual class="po-textual">]</textual></code><textual class="po-textual"> and </textual><code class="po-atom e251 e251"><textual class="po-textual">}</textual></code><textual class="po-textual"> become </textual><code class="po-atom e252 e252"><textual class="po-textual">])</textual></code><textual class="po-textual"> and
                </textual><code class="po-atom e253 e253"><textual class="po-textual">})</textual></code></para></listitem></itemizedlist><textual class="po-textual">Performing this substition on this
          text:</textual><programlisting class="po-block e254 e254" xml:space="preserve"><textual class="po-textual">[poem [by}Apollinaire{]}Et [red}l'unique [gold}cordeau{red]
  des [green}trompettes{gold] marines{green]{poem]</textual></programlisting><textual class="po-textual">we
          get:</textual><programlisting class="po-block e255 e255" xml:space="preserve"><textual class="po-textual">([poem ([by})Apollinaire({])})Et ([red})l'unique ([gold})cordeau({red])
  des ([green})trompettes({gold]) marines({green])({poem])</textual></programlisting><textual class="po-textual">Here,
          each parenthetical expression represents a tag.</textual></para></footnote><textual class="po-textual">) In this view of things, machine-automated text processing can support a very
      different form of document description than that provided by the operational semantics of XML,
      which in order to build a document model from the markup in a single pass, must limit itself
      to a syntax in which not just tags but the element structure itself can be described by a
      context-free grammar.</textual><footnote class="po-popup e256 e256"><para class="po-block e257 e257"><textual class="po-textual">Thus the XML Recommendation has a well-formedness constraint
            (</textual><link class="po-inline e258 e258" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/REC-xml/#GIMatch</textual></link><textual class="po-textual"> in </textual><xref class="po-milestone e259 e259" linkend="xmlrec"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) on an
          XML document that is not, in itself, a definition of syntax, but only a restriction on the
          way it may be used: end tags must have the same name as the most recent unclosed start tag
          (the </textual><quote class="po-inline e260 e260"><textual class="po-textual">GI matching constraint</textual></quote><textual class="po-textual">). (The reason this is not a definition of
          syntax is because syntactically, an end tag is an end tag irrespective of whether it
          matches the most recent start tag; so this rule is not for the integrity of the syntax
            </textual><emphasis class="po-inline e261 e261" role="ital"><textual class="po-textual">qua</textual></emphasis><textual class="po-textual"> syntax, but rather in order that a second tree may
          be built out of the syntax parse tree.) In connection with the production for </textual><emphasis class="po-inline e262 e262" role="bold"><textual class="po-textual">element</textual></emphasis><textual class="po-textual"> (</textual><link class="po-inline e263 e263" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/REC-xml/#NT-element</textual></link><textual class="po-textual">),
          this is how XML is able to bridge from well-formedness to its set of validity constraints
          – something still undefined for LMNL. To be sure, formally speaking validation is
          optional in XML, and systems that validate XML not in the sense of the Recommendation
          (which entails a DTD) but using other models for validation have been implemented several
          times (and in several different ways) since the Recommendation was published in
          1998.</textual></para><para class="po-block e264 e264"><textual class="po-textual">While the GI matching constraint is suspended for LMNL, the question remains how a
          validation technology can be developed for a range model rather than a graph, such as this
          constraint enables. But XML and LMNL itself also demonstrate that processing can occur
          with only implicit validation in the application of a markup language.</textual></para></footnote><textual class="po-textual"> Thus its document models are limited to trees and to graphs projected over that
      tree [</textual><xref class="po-milestone e265 e265" linkend="bos2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. While not, formally, more expressive than XML markup (since
      graphs projected over a tree can express the same relations as LMNL markup, as indeed they do
      in xLMNL or other XML-based representations of LMNL), LMNL markup is practically so; it can
      get </textual><quote class="po-inline e266 e266"><textual class="po-textual">closer to the text</textual></quote><textual class="po-textual"> than XML does, inasmuch as in order to fit within its
      own rules, XML's representation of a document (or at any rate, of a document in which
      overlapping structures or features, or structured annotations, are represented) is always
      getting in its own way.</textual></para><para class="po-block e267 e267"><textual class="po-textual">Related to this is another aspect of this work: this parsing or compiling process does not
      assume a single depth-first traversal of structures implicit in the syntax, and so does not
      perform a single pass over the data. Instead, it considers that the entire text is available
      to the parser at once, and works by applying several distinct heuristic operations in
      sequence: first tags are inferred from delimiting tokens; then different types of tags (open,
      close, empty or atom) are recognized; then open/close pairs are matched, etc. Whether this
      technique is very novel or interesting, or how it relates to (or evades, or complicates)
      classic problems in text processing, I am not highly qualified to say. Yet it might be
      interesting for the sole reason that it serves as a proof of concept for generalized plain
      text processing in XSLT.</textual></para><para class="po-block e268 e268"><textual class="po-textual">What I as a markup user find most remarkable, however, is what happens once a tool chain
      like this is in place. XML practitioners, I think, or at least those of us who work with
      structurally complex texts, are familiar with a conflict between the wish to describe our
      information accurately, capably and gracefully, and the need to force everything into a single
      hierarchy of elements – for reasons having nothing to do with the purposes of the
      markup, but only because the processing infrastructure insists on it, behind the scenes,
      before work has even begun. This conflict is apparent every time we work with (or must
      develop) a schema that has to make design compromises in order to address a requirement to
      represent things that overlap, introducing one or more of the well-worn but cumbersome
      workarounds for doing so. Sometimes we are faced with truly vexing problems in tagging, and
      even in the best case, having to use workarounds generates a certain amount of mental
      background noise. When working with LMNL markup, all this clamor is silenced. Even in small
      demonstrations, I am finding it liberating to be able to mark exactly what I wish to describe,
      with concern only for its clearest denotation in tags and its fidelity to what I want to
      represent in the text. If this is possible at all (and it evidently is), XML's early
      commitment to a single tree representation of something as complex as a text (meaning that
      word in the sense that literary scholars do, with everything it entails) appears to be a
      premature optimization – in other words, not always an optimization at all. When tags in
      plain text can be used to represent whatever structures in and features of text we care to
      discover, irrespective of whether they fit easily into a single tree-shaped model, then the
      potentials of markup are magnified immensely. We have only just started to explore the
      possibilities.</textual></para></section><appendix class="po-hcontainer e269 e269" xml:id="xlmnl-example"><title class="po-block e270 e270"><textual class="po-textual">xLMNL example</textual></title><section class="po-hcontainer e271 e271"><title class="po-block e272 e272"><textual class="po-textual">LMNL syntax:</textual></title><programlisting class="po-block e273 e273" xml:space="preserve"><textual class="po-textual">[excerpt}
[s}[l [n}144{n]}He manages to keep the upper hand{l]
[l [n}145{n]}On his own farm.{s] [s}He's boss.{s] [s}But as to hens:{l]
[l [n}146{n]}We fence our flowers in and the hens range.{l]{s]
{excerpt   
  [source [date}1915{][title}The Housekeeper{]]
  [author
    [name}Robert Frost{]
    [dates}1874-1963{]] ]</textual></programlisting></section><section class="po-hcontainer e274 e274"><title class="po-block e275 e275"><textual class="po-textual">Compiled into xLMNL</textual></title><para class="po-block e276 e276"><textual class="po-textual">White space is added for legibility, and LF characters in the data indicated with
          </textual><code class="po-atom e277 e277"><textual class="po-textual">&amp;#xA;</textual></code><textual class="po-textual">.</textual></para><programlisting class="po-block e278 e278" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;x:document xmlns:x="http://lmnl-markup.org/ns/xLMNL" ID="N.d1e1"
  base-uri="file:/c:/Projects/LMNL/Luminescent/lmnl/frost-example.lmnl"&gt;
  &lt;x:content&gt;
    &lt;x:span start="0" end="1" layer="N.d1e1" ranges="R.d1e2"&gt;&amp;#xA;&lt;/x:span&gt;
    &lt;x:span start="1" end="34" layer="N.d1e1" ranges="R.d1e2 R.d1e5 R.d1e6"&gt;He manages to keep the upper hand&lt;/x:span&gt;
    &lt;x:span start="34" end="35" layer="N.d1e1" ranges="R.d1e2 R.d1e5"&gt;&amp;#xA;&lt;/x:span&gt;
    &lt;x:span start="35" end="51" layer="N.d1e1" ranges="R.d1e2 R.d1e5 R.d1e15"&gt;On his own farm.&lt;/x:span&gt;
    &lt;x:span start="51" end="52" layer="N.d1e1" ranges="R.d1e2 R.d1e15"&gt; &lt;/x:span&gt;
    &lt;x:span start="52" end="62" layer="N.d1e1" ranges="R.d1e2 R.d1e15 R.d1e25"&gt;He's boss.&lt;/x:span&gt;
    &lt;x:span start="62" end="63" layer="N.d1e1" ranges="R.d1e2 R.d1e15"&gt; &lt;/x:span&gt;
    &lt;x:span start="63" end="78" layer="N.d1e1" ranges="R.d1e2 R.d1e15 R.d1e31"&gt;But as to hens:&lt;/x:span&gt;
    &lt;x:span start="78" end="79" layer="N.d1e1" ranges="R.d1e2 R.d1e31"&gt;&amp;#xA;&lt;/x:span&gt;
    &lt;x:span start="79" end="122" layer="N.d1e1" ranges="R.d1e2 R.d1e31 R.d1e37"&gt;We fence our flowers in and the hens range.&lt;/x:span&gt;
    &lt;x:span start="122" end="123" layer="N.d1e1" ranges="R.d1e2"&gt; &lt;/x:span&gt;
  &lt;/x:content&gt;
  &lt;x:range start="0" end="123" ID="R.d1e2" sl="1" so="1" name="excerpt" el="9" eo="25"&gt;
    &lt;x:annotation ID="N.d1e49" sl="6" so="3" el="6" eo="47" name="source"&gt;
      &lt;x:annotation ID="N.d1e50" sl="6" so="11" el="6" eo="22" name="date"&gt;
        &lt;x:content&gt;
          &lt;x:span start="0" end="4" layer="N.d1e50"&gt;1915&lt;/x:span&gt;
        &lt;/x:content&gt;
      &lt;/x:annotation&gt;
      &lt;x:annotation ID="N.d1e53" sl="6" so="23" el="6" eo="46" name="title"&gt;
        &lt;x:content&gt;
          &lt;x:span start="0" end="15" layer="N.d1e53"&gt;The Housekeeper&lt;/x:span&gt;
        &lt;/x:content&gt;
      &lt;/x:annotation&gt;
      &lt;x:content/&gt;
    &lt;/x:annotation&gt;
    &lt;x:annotation ID="N.d1e56" sl="7" so="3" el="9" eo="23" name="author"&gt;
      &lt;x:annotation ID="N.d1e57" sl="8" so="5" el="8" eo="24" name="name"&gt;
        &lt;x:content&gt;
          &lt;x:span start="0" end="12" layer="N.d1e57"&gt;Robert Frost&lt;/x:span&gt;
        &lt;/x:content&gt;
      &lt;/x:annotation&gt;
      &lt;x:annotation ID="N.d1e60" sl="9" so="5" el="9" eo="22" name="dates"&gt;
        &lt;x:content&gt;
          &lt;x:span start="0" end="9" layer="N.d1e60"&gt;1874-1963&lt;/x:span&gt;
        &lt;/x:content&gt;
      &lt;/x:annotation&gt;
      &lt;x:content/&gt;
    &lt;/x:annotation&gt;
  &lt;/x:range&gt;
  &lt;x:range start="1" end="51" ID="R.d1e5" sl="2" so="1" name="s" el="3" eo="32"/&gt;
  &lt;x:range start="1" end="34" ID="R.d1e6" sl="2" so="4" name="l" el="2" eo="52"&gt;
    &lt;x:annotation ID="N.d1e7" sl="2" so="7" el="2" eo="15" name="n"&gt;
      &lt;x:content&gt;
        &lt;x:span start="0" end="3" layer="N.d1e7"&gt;144&lt;/x:span&gt;
      &lt;/x:content&gt;
    &lt;/x:annotation&gt;
  &lt;/x:range&gt;
  &lt;x:range start="35" end="78" ID="R.d1e15" sl="3" so="1" name="l" el="3" eo="71"&gt;
    &lt;x:annotation ID="N.d1e16" sl="3" so="4" el="3" eo="12" name="n"&gt;
      &lt;x:content&gt;
        &lt;x:span start="0" end="3" layer="N.d1e16"&gt;145&lt;/x:span&gt;
      &lt;/x:content&gt;
    &lt;/x:annotation&gt;
  &lt;/x:range&gt;
  &lt;x:range start="52" end="62" ID="R.d1e25" sl="3" so="34" name="s" el="3" eo="49"/&gt;
  &lt;x:range start="63" end="122" ID="R.d1e31" sl="3" so="51" name="s" el="4" eo="62"/&gt;
  &lt;x:range start="79" end="122" ID="R.d1e37" sl="4" so="1" name="l" el="4" eo="59"&gt;
    &lt;x:annotation ID="N.d1e38" sl="4" so="4" el="4" eo="12" name="n"&gt;
      &lt;x:content&gt;
        &lt;x:span start="0" end="3" layer="N.d1e38"&gt;146&lt;/x:span&gt;
      &lt;/x:content&gt;
    &lt;/x:annotation&gt;
  &lt;/x:range&gt;
&lt;/x:document&gt;</textual></programlisting></section></appendix><appendix class="po-hcontainer e279 e279" xml:id="xlmnl-schema"><title class="po-block e280 e280"><textual class="po-textual">RNC schema for xLMNL</textual></title><programlisting class="po-block e281 e281" xml:space="preserve"><textual class="po-textual">namespace x = "http://lmnl-markup.org/ns/xLMNL"

start =
  element x:document {
    document-model }

document-model =
    attribute base-uri { xsd:anyURI }?,
    attribute ID { xsd:ID },
    attribute name { xsd:QName }?,
    debug-support?,
    (annotation | comment)*,
    ( content,
      range*,
      (annotation | comment)*)?
    
annotation =
  element x:annotation {
    document-model }

content =
  element x:content {
    element x:span {
      attribute layer { xsd:IDREF },
      attribute ranges { xsd:IDREFS }?,
      attribute start { xsd:integer },
      attribute end { xsd:integer },
      (text
       | element x:atom {
           attribute name { xsd:NCName },
           debug-support?,
           annotation*
         }
       | comment )+
    }*
  }
range =
  element x:range {
    attribute ID { xsd:ID },
    attribute name { xsd:NCName }?,
    attribute start { xsd:integer },
    attribute end { xsd:integer },
    debug-support?,
    (annotation | comment)*
  }

comment =
  element x:comment { 
    debug-support?,
    text }
    
    
debug-support =
    attribute sl { xsd:integer },
    attribute so { xsd:integer },
    attribute el { xsd:integer },
    attribute eo { xsd:integer }</textual></programlisting><para class="po-block e282 e282"><textual class="po-textual">A full specification for xLMNL would include constraints not captured by this RNG, such as
      that offsets (</textual><emphasis class="po-inline e283 e283" role="bold"><textual class="po-textual">start</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e284 e284" role="bold"><textual class="po-textual">end</textual></emphasis><textual class="po-textual">
      attributes) must be whole numbers (positive integers or 0); values of </textual><emphasis class="po-inline e285 e285" role="bold"><textual class="po-textual">end</textual></emphasis><textual class="po-textual"> must be greater than or equal to values of </textual><emphasis class="po-inline e286 e286" role="bold"><textual class="po-textual">start</textual></emphasis><textual class="po-textual"> on the same </textual><emphasis class="po-inline e287 e287" role="bold"><textual class="po-textual">range</textual></emphasis><textual class="po-textual">; the difference between
      the </textual><emphasis class="po-inline e288 e288" role="bold"><textual class="po-textual">start</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e289 e289" role="bold"><textual class="po-textual">end</textual></emphasis><textual class="po-textual"> of a
        </textual><emphasis class="po-inline e290 e290" role="bold"><textual class="po-textual">span</textual></emphasis><textual class="po-textual"> (its length) must be equal to its string length plus
      the count of its </textual><emphasis class="po-inline e291 e291" role="bold"><textual class="po-textual">atom</textual></emphasis><textual class="po-textual"> children; referential integrity must be
      maintained between spans, ranges and layers (limina), and so forth.</textual></para></appendix><appendix class="po-hcontainer e292 e292" xml:id="demonstrations"><title class="po-block e293 e293"><textual class="po-textual">Demonstrations and source code</textual></title><para class="po-block e294 e294"><textual class="po-textual">A demonstration showsing results of the Luminescent pipeline accompany this paper, in the
        </textual><link class="po-inline e295 e295" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol8/author-pkg/Piez01/BalisageVol8-Piez01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">Slides and Materials</textual></link><textual class="po-textual">
      linked in the Proceedings. Unzip the package and open </textual><code class="po-atom e296 e296"><textual class="po-textual">index.html</textual></code><textual class="po-textual">, which will
      describe the examples and present links for examining them.</textual></para><para class="po-block e297 e297"><textual class="po-textual">Many browsers will now attempt and may do a reasonable job rendering the SVG examples. But
      best results will be obtained from a fully conformant SVG viewer implementation with panning
      and zooming to arbitrary levels of scale. (Most browsers will not zoom in as far as you may
      want to go.) Apache Squiggle (distributed with Batik) is recommended.</textual></para><para class="po-block e298 e298"><textual class="po-textual">Source code for Luminescent is available on github, at
        </textual><link class="po-inline e299 e299" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://github.com/wendellpiez/Luminescent</textual></link><textual class="po-textual">.</textual></para></appendix><bibliography class="po-hcontainer e300 e300"><title class="po-block e301 e301"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e302 e302" xml:id="bos2005" xreflabel="Bos 2005"><textual class="po-textual">Bos, Bert. </textual><quote class="po-inline e303 e303"><textual class="po-textual">The XML data model</textual></quote><textual class="po-textual">.
      2005. See </textual><link class="po-inline e304 e304" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/XML/Datamodel.html</textual></link></bibliomixed><bibliomixed class="po-block e305 e305" xml:id="cayless2010" xreflabel="Cayless and Soroka 2010"><textual class="po-textual">Cayless, Hugh A., and Adam
      Soroka. </textual><quote class="po-inline e306 e306"><textual class="po-textual">On Implementing </textual><code class="po-atom e307 e307"><textual class="po-textual">string-range()</textual></code><textual class="po-textual"> for TEI</textual></quote><textual class="po-textual">. Presented at
      Balisage: The Markup Conference 2010 (Montréal, Canada, August 3 - 6, 2010). In </textual><emphasis class="po-inline e308 e308" role="ital"><textual class="po-textual">Proceedings of Balisage: The Markup Conference 2010</textual></emphasis><textual class="po-textual">. Balisage Series
      on Markup Technologies, vol. 5 (2010). doi:</textual><biblioid class="po-atom e309 doi e309"><textual class="po-textual">10.4242/BalisageVol5.Cayless01</textual></biblioid><textual class="po-textual">. </textual></bibliomixed><bibliomixed class="po-block e310 e310" xml:id="derose2004" xreflabel="DeRose 2004"><textual class="po-textual">DeRose, Steven. </textual><quote class="po-inline e311 e311"><textual class="po-textual">Markup Overlap:
        A Review and a Horse</textual></quote><textual class="po-textual">. Presented at Extreme Markup Languages 2004 (Montréal,
      Canada).</textual></bibliomixed><bibliomixed class="po-block e312 e312" xml:id="durusau-jitts" xreflabel="Durusau and O'Donnell n.d."><textual class="po-textual">Durusau, Patrick, and
      Matthew Brook O'Donnell. </textual><quote class="po-inline e313 e313"><textual class="po-textual">JITTs (Just-in-time Trees)</textual></quote><textual class="po-textual">.
      http://www.durusau.net/publications/NY_xml_sig.pdf.</textual></bibliomixed><bibliomixed class="po-block e314 e314" xml:id="lmnl-markup" xreflabel="lmnl-markup.org"><textual class="po-textual">LMNL-markup.org. See
      </textual><link class="po-inline e315 e315" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.lmnl-markup.org</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e316 e316" xml:id="piez2004" xreflabel="Piez 2004"><textual class="po-textual">Piez, Wendell. </textual><quote class="po-inline e317 e317"><textual class="po-textual">Half-steps toward
        LMNL</textual></quote><textual class="po-textual">. Presented at Extreme Markup Languages 2004 (Montréal, Canada). See
        </textual><link class="po-inline e318 e318" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.piez.org/wendell/papers/LMNL-halfsteps.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e319 e319" xml:id="piez2010" xreflabel="Piez 2010"><textual class="po-textual">Piez, Wendell. </textual><quote class="po-inline e320 e320"><textual class="po-textual">Towards Hermeneutic
        Markup: An architetural outline</textual></quote><textual class="po-textual">. Presented at Digital Humanities 2010 (London,
      England). See </textual><link class="po-inline e321 e321" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.piez.org/wendell/papers/dh2010/index.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e322 e322" xml:id="portier2009" xreflabel="Portier and Calabretto 2009"><textual class="po-textual">Portier, Pierre-Édouard, and Sylvie Calabretto. “Methodology for the construction
      of multi-structured documents.” Presented at Balisage: The Markup Conference 2009 (Montréal,
      Canada, August 11 - 14, 2009). In </textual><emphasis class="po-inline e323 e323" role="ital"><textual class="po-textual">Proceedings of Balisage: The Markup
        Conference 2009</textual></emphasis><textual class="po-textual">. Balisage Series on Markup Technologies, vol. 3 (2009).
        doi:</textual><biblioid class="po-atom e324 doi e324"><textual class="po-textual">10.4242/BalisageVol3.Portier01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e325 e325" xml:id="portier2010" xreflabel="Portier and Calabretto 2010"><textual class="po-textual">Portier, Pierre-Édouard, and Sylvie Calabretto. “Multi-structured documents and the
      emergence of annotations vocabularies.” Presented at Balisage: The Markup Conference 2010,
      Montréal, Canada, August 3 - 6, 2010. In </textual><emphasis class="po-inline e326 e326" role="ital"><textual class="po-textual">Proceedings of Balisage: The
        Markup Conference 2010</textual></emphasis><textual class="po-textual">. Balisage Series on Markup Technologies, vol. 5 (2010).
        doi:</textual><biblioid class="po-atom e327 doi e327"><textual class="po-textual">10.4242/BalisageVol5.Portier01</textual></biblioid><textual class="po-textual">. </textual></bibliomixed><bibliomixed class="po-block e328 e328" xml:id="pondorf2010" xreflabel="Pondorf and Witt 2010"><textual class="po-textual"> Pondorf, Denis, and Andreas
      Witt. </textual><quote class="po-inline e329 e329"><textual class="po-textual">Freestyle Markup Language: Specification of an intuitive, powerful,
        polyhierarchical new extensible markup language</textual></quote><textual class="po-textual">. Presented at Balisage: The Markup
      Conference 2010 (Montréal, Canada, August 3 - 6, 2010). In </textual><emphasis class="po-inline e330 e330" role="ital"><textual class="po-textual">Proceedings
        of Balisage: The Markup Conference 2010</textual></emphasis><textual class="po-textual">. Balisage Series on Markup Technologies,
      vol. 5 (2010). doi:</textual><biblioid class="po-atom e331 doi e331"><textual class="po-textual">10.4242/BalisageVol5.Pondorf01</textual></biblioid><textual class="po-textual">. </textual></bibliomixed><bibliomixed class="po-block e332 e332" xml:id="schmidt2010" xreflabel="Schmidt 2010"><textual class="po-textual">Schmidt, Desmond. </textual><quote class="po-inline e333 e333"><textual class="po-textual">The
        inadequacy of embedded markup for cultural heritage texts.</textual></quote><textual class="po-textual"> In </textual><emphasis class="po-inline e334 e334" role="ital"><textual class="po-textual">Literary and Linguistic Computing</textual></emphasis><textual class="po-textual"> (2010) 25 (3): 337-356. doi: </textual><biblioid class="po-atom e335 doi e335"><textual class="po-textual">10.1093/llc/fqq007</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e336 e336" xml:id="cmsmcq1999" xreflabel="Sperberg-McQueen and Huitfeldt 1999"><textual class="po-textual">Sperberg-McQueen, Michael, and Claus Huitfeldt: "Concurrent Document Hierarchies in MECS and
      SGML". In </textual><emphasis class="po-inline e337 e337" role="ital"><textual class="po-textual">Literary and Linguistic Computing</textual></emphasis><textual class="po-textual"> (1999) 14, pp
      29-42. </textual></bibliomixed><bibliomixed class="po-block e338 e338" xml:id="stegmann2009" xreflabel="Stegmann and Witt 2009"><textual class="po-textual">Stegmann, Jens, and
      Andreas Witt. </textual><quote class="po-inline e339 e339"><textual class="po-textual">TEI Feature Structures as a Representation Format for Multiple Annotation
        and Generic XML Documents</textual></quote><textual class="po-textual">. Presented at Balisage: The Markup Conference 2009,
      Montréal, Canada, August 11 - 14, 2009. In </textual><emphasis class="po-inline e340 e340" role="ital"><textual class="po-textual">Proceedings of Balisage: The
        Markup Conference 2009</textual></emphasis><textual class="po-textual">. Balisage Series on Markup Technologies, vol. 3 (2009).
        doi:</textual><biblioid class="po-atom e341 doi e341"><textual class="po-textual">10.4242/BalisageVol3.Stegmann01</textual></biblioid><textual class="po-textual">. </textual></bibliomixed><bibliomixed class="po-block e342 e342" xml:id="stuehrenberg2009" xreflabel="Stührenberg and Jettka 2009"><textual class="po-textual">Stührenberg,
      Maik, and Daniel Jettka. </textual><quote class="po-inline e343 e343"><textual class="po-textual">A toolkit for multi-dimensional markup: The development of SGF
        to XStandoff</textual></quote><textual class="po-textual">. Presented at Balisage: The Markup Conference 2009 (Montréal, Canada,
      August 11 - 14, 2009). In </textual><emphasis class="po-inline e344 e344" role="ital"><textual class="po-textual">Proceedings of Balisage: The Markup Conference
        2009</textual></emphasis><textual class="po-textual">. Balisage Series on Markup Technologies, vol. 3 (2009). doi:</textual><biblioid class="po-atom e345 doi e345"><textual class="po-textual">10.4242/BalisageVol3.Stuhrenberg01</textual></biblioid><textual class="po-textual">. </textual></bibliomixed><bibliomixed class="po-block e346 e346" xml:id="tennison2002" xreflabel="Tennison and Piez 2002"><textual class="po-textual">Tennison, Jeni, and
      Wendell Piez. </textual><quote class="po-inline e347 e347"><textual class="po-textual">The Layered Markup and Annotation Language (LMNL)</textual></quote><textual class="po-textual">. Presented at
      Extreme Markup Languages 2002 (Montréal, Canada).</textual></bibliomixed><bibliomixed class="po-block e348 e348" xml:id="xdm" xreflabel="XDM"><textual class="po-textual">Berglund, Anders, Mary Fernández, Ashok Malhotra,
      Jonathan Marsh, Marton Nagy, and Norman Walsh, eds. </textual><emphasis class="po-inline e349 e349" role="ital"><textual class="po-textual">XQuery 1.0 and XPath
        2.0 Data Model (XDM) (Second Edition)</textual></emphasis><textual class="po-textual"> W3C Recommendation 14 December 2010.
        </textual><link class="po-inline e350 e350" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e351 e351" xml:id="xmlinfoset" xreflabel="XML Infoset"><textual class="po-textual">Cowan, John, and Richard Tobin, eds.
        </textual><emphasis class="po-inline e352 e352" role="ital"><textual class="po-textual">XML Information Set (Second Edition)</textual></emphasis><textual class="po-textual">. W3C Recommendation 4
      February 2004. </textual><link class="po-inline e353 e353" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml-infoset/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e354 e354" xml:id="xmlrec" xreflabel="XML Recommendation"><textual class="po-textual">Tim Bray, Tim, Jean Paoli, C. M.
      Sperberg-McQueen, Eve Maler, and François Yergeau, eds. </textual><emphasis class="po-inline e355 e355" role="ital"><textual class="po-textual"> Extensible
        Markup Language (XML) 1.0 (Fifth Edition)</textual></emphasis><textual class="po-textual"> W3C Recommendation 26 November 2008.
        </textual><link class="po-inline e356 e356" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/REC-xml/</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>