<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Programming in XPath 3.0</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">While XPath is universally considered the critical intersection of XSLT and
                XQuery, until recently it lacked some essential capabilities of a full-pledged
                programming language. </textual></para><para class="po-block e8 e8"><textual class="po-textual">Although not obvious from the W3C specifications, this paper demonstrates some of
                the new, crucial features of XPath 3.0 that make it a truly complete, standalone,
                modern XML programming language. </textual></para><para class="po-block e9 e9"><textual class="po-textual">
                Among others, the benefits of host-language-independent XPath 3.0 programming include 
                the elimination of the need for redundant “per host language” programming and the ability 
                to specify XPath callable units with true copy and paste portability between different 
                host languages, such as XSLT and XQuery.
            </textual></para></abstract><author class="po-record e10 e10"><personname class="po-record e11 e11"><firstname class="po-field e12 e12"><textual class="po-textual">Dimitre</textual></firstname><surname class="po-field e13 e13"><textual class="po-textual">Novatchev</textual></surname></personname><personblurb class="po-container e14 e14"><para class="po-block e15 e15"><textual class="po-textual">
									Dimitre Novatchev developed FXSL – the functional programming library
									for XSLT (1.0 and 2.0). He thrives at discovering and employing
									unexpected capabilities of XSLT and XPath that even their W3C creators
									hadn’t imagined.
									</textual></para><para class="po-block e16 e16"><textual class="po-textual">
									Suggested the argument placeholder feature that is now part of XPath 3.0.
									</textual></para><para class="po-block e17 e17"><textual class="po-textual">
									Member in the W3C XSLT working group in 2011 – 2013, where he contributed
									to the design and specification of XSLT 3.0.
									</textual></para><para class="po-block e18 e18"><textual class="po-textual">
									Dimitre has answered around 5000 XSLT/XML/XPath questions on StackOverflow
									and many questions on the XSL-List.
									</textual></para></personblurb><email class="po-field e19 e19"><textual class="po-textual">DNovatchev@gmail.com</textual></email><affiliation class="po-record e20 e20"><orgname class="po-block e21 e21"><textual class="po-textual">IMS Health / Appature</textual></orgname></affiliation><link class="po-inline e22 e22" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dnovatchev.wordpress.com</textual></link></author><legalnotice class="po-container e23 e23"><para class="po-block e24 e24"><textual class="po-textual">Copyright © 2013 Dimitre Novatchev</textual></para></legalnotice></info><section class="po-hcontainer e25 e25"><title class="po-block e26 e26"><textual class="po-textual">1. Is XPath  1.0 a full programming language?</textual></title><para class="po-block e27 e27"><textual class="po-textual"> Does XPath 1.0[</textual><citation class="po-atom e28 e28" linkend="XPath1.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]  have all necessary features to be
            used as a complete, self-sustained programming language? </textual></para><para class="po-block e29 e29"><textual class="po-textual">
            The facts summarized in this table show that XPath 1.0  lacks many important features 
            of a programming language.
        </textual></para><table class="po-container e30 e30"><thead class="po-container e31 e31"><tr class="po-table e32 e32"><th class="po-field e33 e33"><textual class="po-textual">Capability</textual></th><th class="po-field e34 e34"><textual class="po-textual">Presence</textual></th><th class="po-field e35 e35"><textual class="po-textual">Remarks</textual></th></tr></thead><tbody class="po-table e36 e36"><tr class="po-table e37 e37"><td class="po-block e38 e38"><textual class="po-textual">Define </textual><emphasis class="po-inline e39 e39"><textual class="po-textual">variables</textual></emphasis></td><td class="po-block e40 e40"><textual class="po-textual">No.</textual></td><td class="po-block e41 e41"><textual class="po-textual">Variables references can be part of XPath 1.0  expressions, 
                        but such variables must be defined by the host language 
                        (various PLs, DOM, or XSLT[</textual><citation class="po-atom e42 e42" linkend="XSLT1.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]).
                    </textual></td></tr><tr class="po-table e43 e43"><td class="po-block e44 e44"><textual class="po-textual">Define and use </textual><emphasis class="po-inline e45 e45"><textual class="po-textual">range/outer-context variables</textual></emphasis><textual class="po-textual">.</textual></td><td class="po-block e46 e46"><textual class="po-textual">No.</textual></td><td class="po-block e47 e47"><textual class="po-textual">In an XSLT context the function </textual><code class="po-atom e48 e48"><textual class="po-textual">current()</textual></code><textual class="po-textual"> provides a limited capability 
                        of an outer-context variable.
                    </textual></td></tr><tr class="po-table e49 e49"><td class="po-block e50 e50"><textual class="po-textual">Define its </textual><emphasis class="po-inline e51 e51"><textual class="po-textual">own</textual></emphasis><textual class="po-textual"> functions.</textual></td><td class="po-block e52 e52"><textual class="po-textual">No.</textual></td><td class="po-block e53 e53"><textual class="po-textual">Only XPath system functions or functions defined in the host-provided context 
                        (such as </textual><code class="po-atom e54 e54"><textual class="po-textual">generate-id()</textual></code><textual class="po-textual"> ) can be referenced.
                    </textual></td></tr><tr class="po-table e55 e55"><td class="po-block e56 e56"><textual class="po-textual">Work with </textual><emphasis class="po-inline e57 e57"><textual class="po-textual">sequences</textual></emphasis><textual class="po-textual"> of items.</textual></td><td class="po-block e58 e58"><textual class="po-textual">No.</textual></td><td class="po-block e59 e59"><textual class="po-textual">Only the notion of a </textual><emphasis class="po-inline e60 e60"><textual class="po-textual">nodeset</textual></emphasis><textual class="po-textual"> is defined. No support 
                        for sequences containing a non-node, or of nodes that can occur 
                        more than once and/or in any order.
                    </textual></td></tr><tr class="po-table e61 e61"><td class="po-block e62 e62"><textual class="po-textual">Define own </textual><emphasis class="po-inline e63 e63"><textual class="po-textual">callable units</textual></emphasis><textual class="po-textual">.</textual></td><td class="po-block e64 e64"><textual class="po-textual">No.</textual></td><td class="po-block e65 e65"><textual class="po-textual"> </textual></td></tr><tr class="po-table e66 e66"><td class="po-block e67 e67"><textual class="po-textual">Specify that a function should be executed on every selected node.</textual></td><td class="po-block e68 e68"><textual class="po-textual">No.</textual></td><td class="po-block e69 e69"><textual class="po-textual"> </textual></td></tr><tr class="po-table e70 e70"><td class="po-block e71 e71"><textual class="po-textual">Strong typing.</textual></td><td class="po-block e72 e72"><textual class="po-textual">No.</textual></td><td class="po-block e73 e73"><textual class="po-textual">XPath 1.0 is a weakly-typed language.</textual></td></tr></tbody></table><para class="po-block e74 e74"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></section><section class="po-hcontainer e75 e75"><title class="po-block e76 e76"><textual class="po-textual">2.	Is XPath  2.0 a full programming language?</textual></title><para class="po-block e77 e77"><textual class="po-textual"> Does XPath 2.0[</textual><citation class="po-atom e78 e78" linkend="XPath2.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] have all necessary features to be used as a complete,
            self-sustained programming language? </textual></para><para class="po-block e79 e79"><textual class="po-textual">
            The facts summarized in this table show that XPath 2.0, while having strong typing, 
            the capability to define its own variables and operations on sequences, 
            still lacks some important features of a programming language, 
            such as its own callable units of execution.
        </textual></para><table class="po-container e80 e80"><thead class="po-container e81 e81"><tr class="po-table e82 e82"><th class="po-field e83 e83"><textual class="po-textual">Capability</textual></th><th class="po-field e84 e84"><textual class="po-textual">Presence</textual></th><th class="po-field e85 e85"><textual class="po-textual">Remarks</textual></th></tr></thead><tbody class="po-table e86 e86"><tr class="po-table e87 e87"><td class="po-block e88 e88"><textual class="po-textual">Define </textual><emphasis class="po-inline e89 e89"><textual class="po-textual">variables</textual></emphasis><textual class="po-textual">.</textual></td><td class="po-block e90 e90"><textual class="po-textual">Yes, but limited.</textual></td><td class="po-block e91 e91"><textual class="po-textual">Variables can be defined within an XPath 2.0 expression. 
                        It is impossible to define a variable whose value is a sequence.</textual></td></tr><tr class="po-table e92 e92"><td class="po-block e93 e93"><textual class="po-textual">Define and use </textual><emphasis class="po-inline e94 e94"><textual class="po-textual">range/outer-context variables</textual></emphasis><textual class="po-textual">.</textual></td><td class="po-block e95 e95"><textual class="po-textual">Yes.</textual></td><td class="po-block e96 e96"><textual class="po-textual"> </textual></td></tr><tr class="po-table e97 e97"><td class="po-block e98 e98"><textual class="po-textual">Define its </textual><emphasis class="po-inline e99 e99"><textual class="po-textual">own</textual></emphasis><textual class="po-textual"> functions.</textual></td><td class="po-block e100 e100"><textual class="po-textual">No.</textual></td><td class="po-block e101 e101"><textual class="po-textual">Only XPath system functions or functions defined in the host-provided context 
                        (such as functions defined in XSLT[</textual><citation class="po-atom e102 e102" linkend="XSLT2.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] or in XQuery[</textual><citation class="po-atom e103 e103" linkend="XQuery1.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]) can be referenced.</textual></td></tr><tr class="po-table e104 e104"><td class="po-block e105 e105"><textual class="po-textual">Work with </textual><emphasis class="po-inline e106 e106"><textual class="po-textual">sequences</textual></emphasis><textual class="po-textual"> of items.</textual></td><td class="po-block e107 e107"><textual class="po-textual">Yes.</textual></td><td class="po-block e108 e108"><textual class="po-textual">XPath 2.0 supports sequences whose items can be non-nodes, 
                        or  nodes that can occur more than once and/or in any order.</textual></td></tr><tr class="po-table e109 e109"><td class="po-block e110 e110"><textual class="po-textual">Define own </textual><emphasis class="po-inline e111 e111"><textual class="po-textual">callable units</textual></emphasis><textual class="po-textual">.</textual></td><td class="po-block e112 e112"><textual class="po-textual">No.</textual></td><td class="po-block e113 e113"><textual class="po-textual"> </textual></td></tr><tr class="po-table e114 e114"><td class="po-block e115 e115"><textual class="po-textual">Specify that a function should be executed on every selected node.</textual></td><td class="po-block e116 e116"><textual class="po-textual">Yes.</textual></td><td class="po-block e117 e117"><code class="po-atom e118 e118"><textual class="po-textual">/a/b/c/string-length()</textual></code><textual class="po-textual">    is legal</textual></td></tr><tr class="po-table e119 e119"><td class="po-block e120 e120"><textual class="po-textual">Specify that a function should be executed on every item in a sequence.</textual></td><td class="po-block e121 e121"><textual class="po-textual">No.</textual></td><td class="po-block e122 e122"><textual class="po-textual">While </textual><code class="po-atom e123 e123"><textual class="po-textual">/a/b/c/string-length()</textual></code><textual class="po-textual"> is legal, it isn’t allowed to use: 
                        </textual><code class="po-atom e124 e124"><textual class="po-textual">('London', 'New York', 'Paris')/string-length()</textual></code><textual class="po-textual">
                    </textual></td></tr><tr class="po-table e125 e125"><td class="po-block e126 e126"><textual class="po-textual">Strong typing.</textual></td><td class="po-block e127 e127"><textual class="po-textual">Yes.</textual></td><td class="po-block e128 e128"><textual class="po-textual">XSD type constructors, </textual><code class="po-atom e129 e129"><textual class="po-textual">cast as</textual></code><textual class="po-textual">,  </textual><code class="po-atom e130 e130"><textual class="po-textual">castable as</textual></code><textual class="po-textual">,  </textual><code class="po-atom e131 e131"><textual class="po-textual">instance of</textual></code><textual class="po-textual">
                    </textual></td></tr></tbody></table><para class="po-block e132 e132"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></section><section class="po-hcontainer e133 e133"><title class="po-block e134 e134"><textual class="po-textual">3. The Function Library Author’s Dilemma</textual></title><para class="po-block e135 e135"><textual class="po-textual"> There are examples of useful function libraries that have a separate version for
                XSLT2.0[</textual><citation class="po-atom e136 e136" linkend="XSLT2.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] and a separate version for XQuery[</textual><citation class="po-atom e137 e137" linkend="XQuery1.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]. There are other function libraries, written only for use in
            one of these two languages. A real-world example of a function library with both XSLT
            and XQuery versions is the </textual><emphasis class="po-inline e138 e138"><textual class="po-textual">FunctX library
                by Priscilla Walmsley</textual></emphasis><textual class="po-textual">[</textual><citation class="po-atom e139 e139" linkend="Walmsley"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]. </textual></para><para class="po-block e140 e140"><textual class="po-textual">
            While a function library author has the goal to produce his library for the widest possible audience, 
            writing one separate version of the library for XSLT 
            and another separate version for XQuery is problematic:
        </textual></para><itemizedlist class="po-table e141 e141"><listitem class="po-container e142 e142"><para class="po-block e143 e143"><textual class="po-textual">
                    The time required to produce two versions of the library – for use from two different languages, 
                    may be significantly (up to twice) bigger than the time for producing a single version.
                </textual></para></listitem><listitem class="po-container e144 e144"><para class="po-block e145 e145"><textual class="po-textual">
                    If the time necessary to produce two different versions of the library 
                    could be used for producing only one version, then more functions 
                    could be written and included in this library.
                </textual></para></listitem><listitem class="po-container e146 e146"><para class="po-block e147 e147"><textual class="po-textual">
                    Having two versions for the same set of functions is redundant 
                    and results in all anomalies of redundancy.
                </textual></para></listitem><listitem class="po-container e148 e148"><para class="po-block e149 e149"><textual class="po-textual">
                    Maintaining two different versions of the same set of functions 
                    is challenging – it is difficult to maintain the two versions in synch, 
                    and the required time to do so is significantly greater than maintaining a single library.
                </textual></para></listitem></itemizedlist><para class="po-block e150 e150"><textual class="po-textual">
            Due to these problems, some libraries would only have one single version. The libraries
            that have two versions
            could have included more useful functions, or could have become available sooner,
            if they had been written in a single version only.
        </textual></para><para class="po-block e151 e151"><textual class="po-textual">
            “Copy and paste portability” has never been achieved with XPath 2.0 to the extent to be really useful, 
            because the language lacks the ability to define its own callable units 
            and because it cannot define its own variables that contain a sequence, and it isn’t possible to produce 
            a new XML document / node by an XPath 2.0 expression.
        </textual></para><para class="po-block e152 e152"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></section><section class="po-hcontainer e153 e153"><title class="po-block e154 e154"><textual class="po-textual">4. New capabilities in XPath 3.0</textual></title><para class="po-block e155 e155"><textual class="po-textual">
            The next table shows some of the significant new features of XPath 3.0[</textual><citation class="po-atom e156 e156" linkend="XPath3.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]:
        </textual></para><table class="po-container e157 e157"><thead class="po-container e158 e158"><tr class="po-table e159 e159"><th class="po-field e160 e160"><textual class="po-textual">Capability</textual></th><th class="po-field e161 e161"><textual class="po-textual">Presence</textual></th><th class="po-field e162 e162"><textual class="po-textual">Remarks</textual></th></tr></thead><tbody class="po-table e163 e163"><tr class="po-table e164 e164"><td class="po-block e165 e165"><textual class="po-textual">Define </textual><emphasis class="po-inline e166 e166"><textual class="po-textual">variables</textual></emphasis></td><td class="po-block e167 e167"><textual class="po-textual">Yes.</textual></td><td class="po-block e168 e168"><textual class="po-textual">In addition to the variable definition available in XPath 2.0, 
                        XPath 3.0 makes it possible to define in a “let clause” 
                        a variable whose value is a sequence.
                    </textual></td></tr><tr class="po-table e169 e169"><td class="po-block e170 e170"><textual class="po-textual">Define and use </textual><emphasis class="po-inline e171 e171"><textual class="po-textual">range/outer-context variables</textual></emphasis><textual class="po-textual">.</textual></td><td class="po-block e172 e172"><textual class="po-textual">Yes.</textual></td><td class="po-block e173 e173"><textual class="po-textual">As in XPath 2.0.</textual></td></tr><tr class="po-table e174 e174"><td class="po-block e175 e175"><textual class="po-textual">Work with </textual><emphasis class="po-inline e176 e176"><textual class="po-textual">sequences of items</textual></emphasis><textual class="po-textual">.</textual></td><td class="po-block e177 e177"><textual class="po-textual">Yes.</textual></td><td class="po-block e178 e178"><textual class="po-textual">As in XPath 2.0.</textual></td></tr><tr class="po-table e179 e179"><td class="po-block e180 e180"><textual class="po-textual">Define own </textual><emphasis class="po-inline e181 e181"><textual class="po-textual">callable units</textual></emphasis><textual class="po-textual">.</textual></td><td class="po-block e182 e182"><textual class="po-textual">Yes.</textual></td><td class="po-block e183 e183"><textual class="po-textual">Inline function items.</textual></td></tr><tr class="po-table e184 e184"><td class="po-block e185 e185"><textual class="po-textual">Specify that a function should be executed on every selected node.</textual></td><td class="po-block e186 e186"><textual class="po-textual">Yes.</textual></td><td class="po-block e187 e187"><textual class="po-textual">As in XPath 2.0.</textual></td></tr><tr class="po-table e188 e188"><td class="po-block e189 e189"><textual class="po-textual">Specify that a function should be executed on every item in a sequence.</textual></td><td class="po-block e190 e190"><textual class="po-textual">Yes.</textual></td><td class="po-block e191 e191"><textual class="po-textual">The   </textual><code class="po-atom e192 e192"><textual class="po-textual">!</textual></code><textual class="po-textual">   (simple mapping) operator.</textual></td></tr><tr class="po-table e193 e193"><td class="po-block e194 e194"><textual class="po-textual">Strong typing.</textual></td><td class="po-block e195 e195"><textual class="po-textual">Yes.</textual></td><td class="po-block e196 e196"><textual class="po-textual">As in XPath 2.0.</textual></td></tr><tr class="po-table e197 e197"><td class="po-block e198 e198"><textual class="po-textual">Define its </textual><emphasis class="po-inline e199 e199"><textual class="po-textual">own</textual></emphasis><textual class="po-textual"> functions.</textual></td><td class="po-block e200 e200"><textual class="po-textual">Yes.</textual></td><td class="po-block e201 e201"><textual class="po-textual">This is one of the most significant new features of XPath 3.0, 
                        based on the “function item” type as defined in the XDM[</textual><citation class="po-atom e202 e202" linkend="XDM3.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">].  
                        Only “inline function items” (anonymous functions) can be defined. 
                        Typically, these are defined as the content of a variable, 
                        which then can be used as a function.
                    </textual></td></tr><tr class="po-table e203 e203"><td class="po-block e204 e204"><textual class="po-textual">Higher Order Functions (HOFs).</textual></td><td class="po-block e205 e205"><textual class="po-textual">Yes.</textual></td><td class="po-block e206 e206"><textual class="po-textual">A function item is a first class object. It can be passed as a parameter 
                        or returned as a result of calling a function. It is possible to express 
                        such well-known FP techniques as functional composition, partial function application, 
                        creation of closures.
                    </textual></td></tr><tr class="po-table e207 e207"><td class="po-block e208 e208"><textual class="po-textual">Can recursive anonymous functions be specified within an XPath expression?</textual></td><td class="po-block e209 e209"><textual class="po-textual">Yes.</textual></td><td class="po-block e210 e210"><textual class="po-textual">Shown later in this paper.</textual></td></tr><tr class="po-table e211 e211"><td class="po-block e212 e212"><textual class="po-textual">Can robust recursion of anonymous functions be implemented?</textual></td><td class="po-block e213 e213"><textual class="po-textual">Yes.</textual></td><td class="po-block e214 e214"><textual class="po-textual">Shown later in this paper.</textual></td></tr><tr class="po-table e215 e215"><td class="po-block e216 e216"><textual class="po-textual">Can a new XML document or node be created within an XPath expression?</textual></td><td class="po-block e217 e217"><textual class="po-textual">Yes.</textual></td><td class="po-block e218 e218"><textual class="po-textual">Shown later in this paper.</textual></td></tr><tr class="po-table e219 e219"><td class="po-block e220 e220"><textual class="po-textual">Can new data types be created in an XPath expression?</textual></td><td class="po-block e221 e221"><textual class="po-textual">Yes.</textual></td><td class="po-block e222 e222"><textual class="po-textual">Shown later in this paper.</textual></td></tr></tbody></table><para class="po-block e223 e223"><textual class="po-textual">
            In the next sections we give examples of using XPath 3.0 to specify functional composition, 
            partial application, closures, anonymous function recursion and robust recursion. 
            Then we provide an example of specifying a new data type – the Binary Search Tree. 
            We show how a new XML document can be created with an XPath 3.0 expression. 
            Finally, we provide an example of a complete XML processing application written entirely in XPath.
        </textual></para><para class="po-block e224 e224"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para><section class="po-hcontainer e225 e225"><title class="po-block e226 e226"><textual class="po-textual">4.1 Creating and using an anonymous function in an XPath
                    expression. HOFs.</textual></title><para class="po-block e227 e227"><textual class="po-textual"> In XPath 3.0 one can define inline (anonymous) functions and then provide
                arguments for their execution in a function call simply like this:
                </textual><programlisting class="po-block e228 e228" xml:space="preserve"><textual class="po-textual">
let $incr := 
       function($n) {$n+1}
 
  return $incr(2)
                </textual></programlisting><textual class="po-textual">
                Or, as recommended alternative, define the same function in a strongly typed way:
                </textual><programlisting class="po-block e229 e229" xml:space="preserve"><textual class="po-textual">
    let $incr :=
          function($n as xs:integer) as xs:integer
            {
              $n +1
            }
      return
        $incr(2)
                </textual></programlisting><textual class="po-textual">
                When either of these two expressions is evaluated, the result is: </textual><code class="po-atom e230 e230"><textual class="po-textual">3</textual></code><textual class="po-textual">. </textual></para><para class="po-block e231 e231"><textual class="po-textual">
                </textual><emphasis class="po-inline e232 e232" role="bold"><textual class="po-textual">The remaining examples in this paper use strong
                    typing</textual></emphasis><textual class="po-textual">. </textual></para><para class="po-block e233 e233"><textual class="po-textual"> The ability to define a function as a pure XPath 3.0 expression is one of the
                most important additions to the XPath Data Model (XDM)[</textual><citation class="po-atom e234 e234" linkend="XDM3.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">].</textual></para><para class="po-block e235 e235"><textual class="po-textual">The function has no name and is the value of the </textual><code class="po-atom e236 e236"><textual class="po-textual">$incr</textual></code><textual class="po-textual"> variable. The
                function definition has a strongly typed argument and a strongly typed result – in
                this case both the argument and the result must be of type </textual><code class="po-atom e237 e237"><textual class="po-textual">xs:integer</textual></code><textual class="po-textual">.  </textual></para><para class="po-block e238 e238"><textual class="po-textual">The body of the function is an XPath expression of type
                </textual><code class="po-atom e239 e239"><textual class="po-textual">xs:integer</textual></code></para><para class="po-block e240 e240"><textual class="po-textual">The scope of the function is the let clause where it is defined and the
                corresponding </textual><code class="po-atom e241 e241"><textual class="po-textual">return</textual></code><textual class="po-textual"> clause. </textual></para><para class="po-block e242 e242"><textual class="po-textual">Most importantly, in XPath 3.0 one can define Higher-Order Functions (HOFs)[</textual><citation class="po-atom e243 e243" linkend="HOF"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">].
                By definition, a higher order function has an argument which itself is a function,
                or produces a function as its result.  </textual></para><para class="po-block e244 e244"><textual class="po-textual"> Here is a complete example of defining and calling a HOF within an XPath
                expression: </textual></para><programlisting class="po-block e245 e245" xml:space="preserve"><textual class="po-textual">
   let $process :=
             function($s as xs:string, $fun as function(xs:string) as xs:string)
                 as xs:string
            {
              $fun($s)
            },

        $lower :=
          function($s as xs:string) as xs:string
            {
              lower-case($s)
            }
         ,
         $reverse :=
          function($s as xs:string) as xs:string
            {
              codepoints-to-string(reverse(string-to-codepoints($s)))
            }
      return
         ('lower: ', $process('HELLO', $lower),
          ', reverse: ', $process('HELLO', $reverse))
            </textual></programlisting><para class="po-block e246 e246"><textual class="po-textual"> The function </textual><code class="po-atom e247 e247"><textual class="po-textual">$process()</textual></code><textual class="po-textual">takes two arguments: a string, and a function
                that takes a string and produces a string. The result returned by
                    </textual><code class="po-atom e248 e248"><textual class="po-textual">$process()</textual></code><textual class="po-textual">is a string. </textual></para><para class="po-block e249 e249"><textual class="po-textual"> Then, in the same </textual><code class="po-atom e250 e250"><textual class="po-textual">let</textual></code><textual class="po-textual"> clause two functions are defined, each taking
                a string and producing a string: </textual><code class="po-atom e251 e251"><textual class="po-textual">$lower()</textual></code><textual class="po-textual"> and </textual><code class="po-atom e252 e252"><textual class="po-textual">$reverse()</textual></code><textual class="po-textual">. </textual></para><para class="po-block e253 e253"><textual class="po-textual"> In the return clause </textual><code class="po-atom e254 e254"><textual class="po-textual">$process()</textual></code><textual class="po-textual"> is called twice, with “HELLO” as the
                same first argument, and with the </textual><code class="po-atom e255 e255"><textual class="po-textual">$lower()</textual></code><textual class="po-textual"> function as the second
                argument in the first call to </textual><code class="po-atom e256 e256"><textual class="po-textual">$process()</textual></code><textual class="po-textual"> and </textual><code class="po-atom e257 e257"><textual class="po-textual">$reverse()</textual></code><textual class="po-textual">
                function as the second argument in the second call to </textual><code class="po-atom e258 e258"><textual class="po-textual">$process()</textual></code><textual class="po-textual">. </textual></para><para class="po-block e259 e259"><textual class="po-textual"> When the above expression is evaluated, the result is:
                </textual><programlisting class="po-block e260 e260" xml:space="preserve"><textual class="po-textual">lower:  hello , reverse:  OLLEH</textual></programlisting></para></section><section class="po-hcontainer e261 e261"><title class="po-block e262 e262"><textual class="po-textual">4.2 Function composition</textual></title><para class="po-block e263 e263"><textual class="po-textual">
                By definition, the functional composition[</textual><citation class="po-atom e264 e264" linkend="FuncComp"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] of two functions </textual><code class="po-atom e265 e265"><textual class="po-textual">g(x)</textual></code><textual class="po-textual"> and </textual><code class="po-atom e266 e266"><textual class="po-textual">h(y)</textual></code><textual class="po-textual">
                is a third function   </textual><code class="po-atom e267 e267"><textual class="po-textual">f(x)</textual></code><textual class="po-textual">  such that   </textual><code class="po-atom e268 e268"><textual class="po-textual">f(x) = h(g(x))</textual></code><textual class="po-textual">
            </textual></para><para class="po-block e269 e269"><textual class="po-textual">
                We can specify a function, which takes as its parameters two other functions, 
                and produces as its result the functional composition of its two arguments:
                </textual><programlisting class="po-block e270 e270" xml:space="preserve"><textual class="po-textual">
        $compose :=
             function($f as function(), $g as function())
                 as function()
            {
              function($x as item()*)
              {
                $g($f($x))
              }
            }
                </textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e271 e271"><textual class="po-textual">
                And we can use the so defined function in the following expression:
                </textual><programlisting class="po-block e272 e272" xml:space="preserve"><textual class="po-textual">
    let $compose :=
             function($f as function(), $g as function())
                 as function()
            {
              function($x as item()*)
              {
                $g($f($x))
              }
            },

        $lower :=
          function($s as xs:string) as xs:string
            {
              lower-case($s)
            }
         ,

         $reverse :=
          function($s as xs:string) as xs:string
            {
              codepoints-to-string(reverse(string-to-codepoints($s)))
            }

      return
               $compose($reverse, $lower)('HELLO')
                </textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e273 e273"><textual class="po-textual">
                The result of evaluating this expression is:
                </textual><programlisting class="po-block e274 e274" xml:space="preserve"><textual class="po-textual">olleh</textual></programlisting><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e275 e275"><title class="po-block e276 e276"><textual class="po-textual">4.3 Partial application of a function</textual></title><para class="po-block e277 e277"><textual class="po-textual">
                One definition of </textual><emphasis class="po-inline e278 e278" role="bital"><textual class="po-textual">partial application</textual></emphasis><textual class="po-textual">[</textual><citation class="po-atom e279 e279" linkend="PartApp"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] is the following:</textual></para><blockquote class="po-container e280 e280"><para class="po-block e281 e281"><emphasis class="po-inline e282 e282"><textual class="po-textual">“</textual><link class="po-inline e283 e283" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Partial_application" xlink:show="new" xlink:type="simple"><emphasis class="po-inline e284 e284" role="bold"><textual class="po-textual">Partial function application</textual></emphasis></link><textual class="po-textual"> is the ability to take a function of many parameters 
and apply arguments to some of the parameters to create a new function that 
needs only the application of the remaining arguments to produce the equivalent 
of applying all arguments to the original function.”</textual></emphasis></para></blockquote><para class="po-block e285 e285"><textual class="po-textual">
                XPath 3.0 has a natural way of specifying partial application.
                </textual><programlisting class="po-block e286 e286" xml:space="preserve"><textual class="po-textual">f(3, ?)</textual></programlisting><textual class="po-textual"> 
                is a new function </textual><code class="po-atom e287 e287"><textual class="po-textual">g(x)</textual></code><textual class="po-textual">, such that for all allowed values of </textual><code class="po-atom e288 e288"><textual class="po-textual">x</textual></code><textual class="po-textual"> 
                the following holds:
                </textual><programlisting class="po-block e289 e289" xml:space="preserve"><textual class="po-textual">g(x) = f(3, x)</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e290 e290"><textual class="po-textual"> Using partial application, we can re-define the </textual><code class="po-atom e291 e291"><textual class="po-textual">increment()</textual></code><textual class="po-textual"> function
                in the following way:
                </textual><programlisting class="po-block e292 e292" xml:space="preserve"><textual class="po-textual">
    let $plus :=
          function($m as xs:integer, $n as xs:integer) as xs:integer
          {
            $m + $n
          },
          
        $incr :=
          function($n as xs:integer) as xs:integer
          {
            $plus(1, ?)($n)
          }
        return 
            $incr(2)
                </textual></programlisting><textual class="po-textual">
                When this XPath 3.0 expression is evaluated, the result is </textual><code class="po-atom e293 e293"><textual class="po-textual">3</textual></code><textual class="po-textual">. 
            </textual></para><para class="po-block e294 e294"><textual class="po-textual"> In the above expression the partial application of </textual><code class="po-atom e295 e295"><textual class="po-textual">$plus()</textual></code><textual class="po-textual"> on
                binding its first argument to </textual><code class="po-atom e296 e296"><textual class="po-textual">1</textual></code><textual class="po-textual"> is defined simply as:
                </textual><programlisting class="po-block e297 e297" xml:space="preserve"><textual class="po-textual">$plus(1, ?) </textual></programlisting><textual class="po-textual"> 
                The ‘</textual><code class="po-atom e298 e298"><textual class="po-textual">?</textual></code><textual class="po-textual">’ character is
                called </textual><emphasis class="po-inline e299 e299"><textual class="po-textual">argument placeholder</textual></emphasis><textual class="po-textual"> and is used to denote
                free (still not bound) arguments. </textual></para></section><section class="po-hcontainer e300 e300"><title class="po-block e301 e301"><textual class="po-textual">4.4 Closures</textual></title><para class="po-block e302 e302"><textual class="po-textual">By definition “</textual><emphasis class="po-inline e303 e303"><textual class="po-textual">a closure[</textual><citation class="po-atom e304 e304" linkend="Closure"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] is a function produced by
                    another function and the produced function contains data from the producing
                    function</textual></emphasis><textual class="po-textual">.” 
            </textual></para><para class="po-block e305 e305"><textual class="po-textual"> Here is a complete example:
                </textual><programlisting class="po-block e306 e306" xml:space="preserve"><textual class="po-textual">
    let $greet :=
           function($greeting as xs:string)
               as function(xs:string) as xs:string
                  {
                    function($name as xs:string) as xs:string
                          {
                             $greeting || $name || '! '
                          }
                  },
         $hello := $greet('Hello: ')
                  
          return
            ($hello ('John'), $hello ('Peter') )
              </textual></programlisting><textual class="po-textual">
                Note that the outer function </textual><code class="po-atom e307 e307"><textual class="po-textual"> $greet()</textual></code><textual class="po-textual"> returns as its result the inner
                function and injects into the body of the inner function some of its own (outer
                function’s) data –  the value of its </textual><code class="po-atom e308 e308"><textual class="po-textual"> $greeting</textual></code><textual class="po-textual">  argument. 
            </textual></para><para class="po-block e309 e309"><textual class="po-textual"> When the above expression is evaluated, the result is:
                </textual><programlisting class="po-block e310 e310" xml:space="preserve"><textual class="po-textual">Hello: John! Hello: Peter! </textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e311 e311"><textual class="po-textual"> Here is another example. Let’s have this XML document: </textual><programlisting class="po-block e312 e312" xml:space="preserve"><textual class="po-textual">                    
&lt;Books&gt;
	&lt;Book&gt;
		&lt;Title&gt;Six Great Ideas&lt;/Title&gt;
		&lt;Author&gt;Mortimer J. Adler&lt;/Author&gt;
	&lt;/Book&gt;
	&lt;Book&gt;
		&lt;Title&gt;The Society of Mind&lt;/Title&gt;
		&lt;Author&gt;Marvin Minsky&lt;/Author&gt;
	&lt;/Book&gt;
&lt;/Books&gt;
                </textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e313 e313"><textual class="po-textual"> We want to have a function that has only one argument – a book’s title and
                returns the author of the book with this title. Somehow this function should have
                the above XML document already injected in its definition:
                </textual><programlisting class="po-block e314 e314" xml:space="preserve"><textual class="po-textual">
   let $lookup :=
          function($books as element())
             as function(xs:string) as xs:string?
           {
            function($bookTitle as xs:string) as xs:string?
            {
              $books/Book[Title eq $bookTitle]/Author
            }
           },
           
      $author := $lookup(/Books)
      
       return
          $author('The Society of Mind')
                </textual></programlisting><textual class="po-textual">
                The wanted function (</textual><code class="po-atom e315 e315"><textual class="po-textual">$author()</textual></code><textual class="po-textual">) is created by the function
                    </textual><code class="po-atom e316 e316"><textual class="po-textual">$lookup()</textual></code><textual class="po-textual"> by injecting into it some of its own content – the top
                element of the XML document to be searched. The result is:
                </textual><programlisting class="po-block e317 e317" xml:space="preserve"><textual class="po-textual">Marvin Minsky</textual></programlisting><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e318 e318"><title class="po-block e319 e319"><textual class="po-textual">4.5 Can Anonymous functions be
                recursive?</textual></title><para class="po-block e320 e320"><textual class="po-textual"> Such a question seems odd – if a recursive function[</textual><citation class="po-atom e321 e321" linkend="Recurs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] is one that calls itself by
                name, then how can an anonymous function be recursive, having no name? </textual></para><para class="po-block e322 e322"><textual class="po-textual"> This seems to be a stopping problem when trying to write XPath 3.0 inline
                function items that process long sequences or other, recursive data structures. So
                serious a problem, that some people[</textual><citation class="po-atom e323 e323" linkend="Snelson"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">][</textual><citation class="po-atom e324 e324" linkend="Snelson2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] even raised the question of amending
                the XPath Data Model and altering the XPath 3.0 syntax in order to allow an
                anonymous function to call itself. </textual></para><para class="po-block e325 e325"><emphasis class="po-inline e326 e326" role="bold"><textual class="po-textual">As it turns out, a natural solution exists, without the
                    need to change anything[</textual><citation class="po-atom e327 e327" linkend="Nova"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]</textual></emphasis><textual class="po-textual">. </textual></para><para class="po-block e328 e328"><textual class="po-textual"> Let us take a concrete problem: Write an XPath 3.0 inline function, that given a
                positive integer </textual><code class="po-atom e329 e329"><textual class="po-textual">n</textual></code><textual class="po-textual">, produces the value of </textual><code class="po-atom e330 e330"><textual class="po-textual">n!</textual></code><textual class="po-textual"> (The
                factorial of </textual><code class="po-atom e331 e331"><textual class="po-textual">n</textual></code><textual class="po-textual">). 
            </textual></para><para class="po-block e332 e332"><textual class="po-textual"> As a first attempt, let us analyze this code:
                </textual><programlisting class="po-block e333 e333" xml:space="preserve"><textual class="po-textual">          let $f := function($n as xs:integer,
              $f1 as function(xs:integer) as xs:integer
              ) as xs:integer

              {
                 if($n eq 0)
                    then 1
                    else $n * $f1($n -1, $f1)
              }
              return
                $f(5, $f)             
              </textual></programlisting><textual class="po-textual">
                What happens here?
            </textual></para><para class="po-block e334 e334"><textual class="po-textual">
                An inline function cannot call itself by name, because it doesn’t have a name.
                What we still can do, though, is to pass the function as an argument to itself.
            </textual></para><para class="po-block e335 e335"><textual class="po-textual"> The only special thing to notice here is how the processing is initiated:
                </textual><programlisting class="po-block e336 e336" xml:space="preserve"><textual class="po-textual">$f(5, $f)</textual></programlisting><textual class="po-textual"> calling the function and passing it to
                itself. 
            </textual></para><para class="po-block e337 e337"><textual class="po-textual"> Such initiation may seem weird to a caller and is also error-prone. This is why
                we need to further improve the solution so that no weirdness remains on the surface:
                </textual><programlisting class="po-block e338 e338" xml:space="preserve"><textual class="po-textual">let $f := function($n as xs:integer,
                   $f1 as function(xs:integer,
                                   function()) as xs:integer
                   ) as xs:integer
             {
               if($n eq 0)
                 then 1
                 else $n * $f1($n -1, $f1)

              },

    $F := function($n as xs:integer) as xs:integer
            {
               $f($n, $f)
            }
   return
           $F(5)</textual></programlisting><textual class="po-textual">
                Thus we produced an inline, anonymous function </textual><code class="po-atom e339 e339"><textual class="po-textual">$F</textual></code><textual class="po-textual">, which given an
                argument </textual><code class="po-atom e340 e340"><textual class="po-textual">$n</textual></code><textual class="po-textual">, produces</textual><code class="po-atom e341 e341"><textual class="po-textual"> $n!</textual></code><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e342 e342"><title class="po-block e343 e343"><textual class="po-textual">4.6 Robust Recursion</textual></title><para class="po-block e344 e344"><textual class="po-textual"> While the described recursion technique works well with relatively small values
                    for</textual><code class="po-atom e345 e345"><textual class="po-textual"> n</textual></code><textual class="po-textual">, we run into problems when </textual><code class="po-atom e346 e346"><textual class="po-textual">n</textual></code><textual class="po-textual"> becomes bigger. </textual></para><para class="po-block e347 e347"><textual class="po-textual">
                </textual><emphasis class="po-inline e348 e348" role="bold"><textual class="po-textual">Let’s see this based on another example – calculating the sum
                    of a sequence of numbers:</textual></emphasis><textual class="po-textual">
                </textual><programlisting class="po-block e349 e349" xml:space="preserve"><textual class="po-textual">  let $f := function($nums as xs:double*,
                     $f1 as  function(xs:double*, function()) 
                               as xs:double
                   ) as xs:double
             {
              if(not($nums[1]))
                 then 0
                 else $nums[1] + $f1(subsequence($nums,2), $f1)
              },

    $F := function($nums as xs:double*) as xs:double
            {
                $f($nums, $f)
            }
   return
           $F(1 to 10)</textual></programlisting><textual class="po-textual">
                This calculates correctly the sum of the numbers </textual><code class="po-atom e350 e350"><textual class="po-textual">1</textual></code><textual class="po-textual"> to </textual><code class="po-atom e351 e351"><textual class="po-textual">10</textual></code><textual class="po-textual"> –
                the result is: </textual><programlisting class="po-block e352 e352" xml:space="preserve"><textual class="po-textual">55</textual></programlisting><textual class="po-textual"> However, if we try:
                </textual><programlisting class="po-block e353 e353" xml:space="preserve"><textual class="po-textual">$F(1 to 100)</textual></programlisting><textual class="po-textual">
                the result is the following Saxon 9.4.6EE exception:
                        </textual><programlisting class="po-block e354 e354" xml:space="preserve"><emphasis class="po-inline e355 e355" role="bold"><textual class="po-textual">Error on line 22
Too many nested function calls. May be due to infinite recursion.
Transformation failed: Run-time errors were reported</textual></emphasis></programlisting><textual class="po-textual">
             </textual></para><para class="po-block e356 e356"><textual class="po-textual"> So, what happens here? Most readers would have guessed by now — our old </textual><emphasis class="po-inline e357 e357"><textual class="po-textual">Stack Overflow</textual></emphasis><textual class="po-textual"> (not the site) exception. </textual></para><para class="po-block e358 e358"><textual class="po-textual"> Is there </textual><emphasis class="po-inline e359 e359"><textual class="po-textual">any</textual></emphasis><textual class="po-textual"> way to avoid this exception? </textual></para><para class="po-block e360 e360"><textual class="po-textual"> One could rely on the smartness of the XSLT processor to do this. A slight
                fraction of XSLT processors recognize a limited kind of </textual><emphasis class="po-inline e361 e361"><textual class="po-textual">tail
                    recursion</textual></emphasis><textual class="po-textual"> and implement it using iteration, thus avoiding recursion. 
            </textual></para><para class="po-block e362 e362"><textual class="po-textual">
                </textual><emphasis class="po-inline e363 e363" role="bold"><textual class="po-textual">Let us refactor the above code into a tail-recursive
                    one</textual></emphasis><textual class="po-textual"> (the last thing the function does is invoke a function):
                </textual><programlisting class="po-block e364 e364" xml:space="preserve"><textual class="po-textual"> let $f := function($nums as xs:double*,
                    $accum as xs:double,
                    $f1 as  
                           function(xs:double*, xs:double, function())
                               as xs:double
                    ) as xs:double
             {
              if(not($nums[1]))
                 then $accum
                 else $f1(subsequence($nums,2), $accum+$nums[1], $f1)
              },
    $F := function($nums as xs:double*) as xs:double
          {
             $f($nums, 0, $f)
          }
  return
     $F(1 to 100)</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e365 e365"><textual class="po-textual">
                Saxon[Saxon] is well-known for carrying out tail-recursion optimization, 
                however it still raises the stack-overflow exception for the above, tail-recursive code. 
                Why?
            </textual></para><para class="po-block e366 e366"><textual class="po-textual"> Here is the Wikipedia definition[</textual><citation class="po-atom e367 e367" linkend="TailCall"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] of tail recursion: </textual></para><blockquote class="po-container e368 e368"><para class="po-block e369 e369"><emphasis class="po-inline e370 e370"><textual class="po-textual">“In </textual><link class="po-inline e371 e371" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Computer_science" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        </textual><emphasis class="po-inline e372 e372" role="bold"><textual class="po-textual">computer science</textual></emphasis></link><textual class="po-textual">, a </textual><emphasis class="po-inline e373 e373" role="bold"><textual class="po-textual">tail call</textual></emphasis><textual class="po-textual"> is a </textual><emphasis class="po-inline e374 e374" role="bold"><link class="po-inline e375 e375" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Subroutine" xlink:show="new" xlink:type="simple"><textual class="po-textual">subroutine</textual></link><textual class="po-textual">
                    </textual></emphasis><textual class="po-textual"> call that happens inside another procedure as its final action; it
                    may produce a return value which is then immediately </textual><emphasis class="po-inline e376 e376" role="bold"><link class="po-inline e377 e377" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Return_statement" xlink:show="new" xlink:type="simple"><textual class="po-textual">returned</textual></link><textual class="po-textual">
                    </textual></emphasis><textual class="po-textual"> by the calling procedure. The </textual><emphasis class="po-inline e378 e378" role="bold"><textual class="po-textual">
                        </textual><link class="po-inline e379 e379" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Call_site" xlink:show="new" xlink:type="simple"><textual class="po-textual">call
                            site</textual></link></emphasis><textual class="po-textual"> is then said to be in </textual><emphasis class="po-inline e380 e380" role="bold"><textual class="po-textual">tail
                        position</textual></emphasis><textual class="po-textual">, i.e. at the end of the calling procedure. If any call
                    that a subroutine performs, such that it might eventually lead to this same
                    subroutine being called again down the call chain, is in tail position, such a
                    subroutine is said to be </textual><emphasis class="po-inline e381 e381" role="bold"><textual class="po-textual">tail-recursive</textual></emphasis><textual class="po-textual">”</textual></emphasis><textual class="po-textual">
            </textual></para></blockquote><para class="po-block e382 e382"><textual class="po-textual"> At present, the XSLT/XPath processors that do recognize some kind of tail
                recursion typically do so if a function/template calls </textual><emphasis class="po-inline e383 e383" role="bold"><textual class="po-textual">itself</textual></emphasis><textual class="po-textual"> by
                    name. </textual></para><para class="po-block e384 e384"><textual class="po-textual">
                There is no record that any of them handles the case when the tail call is to another function
                (Michael Kay, author of Saxon[</textual><citation class="po-atom e385 e385" linkend="Saxon"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">], shared on the Saxon mailing list that Saxon correctly 
                handles any type of tail calls (not only calls to the same named template) for templates, 
                but doesn’t do so in the case of functions).
            </textual></para><para class="po-block e386 e386"><textual class="po-textual">
                So, what can we do in this situation? One decision is to wait until some processor starts 
                handling any type of tail call inside functions.
            </textual></para><para class="po-block e387 e387"><textual class="po-textual"> Fortunately, there is another option: </textual><emphasis class="po-inline e388 e388" role="bold"><textual class="po-textual">use the DVC (Divide
                    and Conquer) technique</textual></emphasis><textual class="po-textual">[</textual><citation class="po-atom e389 e389" linkend="DivConq"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] for minimizing the maximum depth of nested
                recursion calls. </textual></para><para class="po-block e390 e390"><textual class="po-textual">
                The idea is to split the sequence into subsequences (usually two) of roughly the same length, 
                recursively process each subsequence, and then combine the results of processing 
                each individual subsequence.
            </textual></para><para class="po-block e391 e391"><textual class="po-textual">
                </textual><emphasis class="po-inline e392 e392" role="bold"><textual class="po-textual">Here is the above code, re-written [</textual><citation class="po-atom e393 e393" linkend="Nova2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] to use DVC</textual></emphasis><textual class="po-textual">:
                </textual><programlisting class="po-block e394 e394" xml:space="preserve"><textual class="po-textual">let $f := function($nums as xs:double*,
                   $f1 as function(xs:double*, function())
                             as xs:double
                   ) as xs:double
             {if(not($nums[1]))
                 then 0
                 else if(not($nums[2]))
                        then $nums[1]
                        else
                         let $half := count($nums) idiv 2
                          return
                            $f1(subsequence($nums,1, $half), $f1)
		             +
		               $f1(subsequence($nums, $half+1), $f1)
              },

    $F := function($nums as xs:double*) as xs:double
            {
                $f($nums, $f)
            }
  return
    $F(1 to 10000)                </textual></programlisting><textual class="po-textual">
                
            </textual></para><para class="po-block e395 e395"><textual class="po-textual"> Sure enough, this time we get the result without any exception being thrown:
                </textual><programlisting class="po-block e396 e396" xml:space="preserve"><textual class="po-textual">5.0005E7</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e397 e397"><textual class="po-textual"> Using this technique, the maximum recursion depth is </textual><code class="po-atom e398 e398"><textual class="po-textual">Log2(N)</textual></code><textual class="po-textual"> — thus
                for processing a sequence with </textual><code class="po-atom e399 e399"><textual class="po-textual">1M</textual></code><textual class="po-textual"> (one million elements) the maximum
                recursion depth is just </textual><code class="po-atom e400 e400"><textual class="po-textual">19</textual></code><textual class="po-textual">. </textual></para><para class="po-block e401 e401"><textual class="po-textual">
                </textual><emphasis class="po-inline e402 e402" role="bold"><textual class="po-textual">Thus, the DVC technique is a tool that can be immediately used
                    to circumvent the lack of intelligence of current XPath 3.0 processors when
                    dealing with tail-call optimization</textual></emphasis><textual class="po-textual">. </textual></para><para class="po-block e403 e403"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></section><section class="po-hcontainer e404 e404"><title class="po-block e405 e405"><textual class="po-textual">4.7 Producing a new XML document or
                element</textual></title><para class="po-block e406 e406"><textual class="po-textual"> Can an XPath expression produce a new XML document? Say, from the Books XML
                document used before, can an XPath expression produce this XML document:
                </textual><programlisting class="po-block e407 e407" xml:space="preserve"><textual class="po-textual">&lt;Person&gt;Marvin Minsky&lt;/Person&gt;                </textual></programlisting><textual class="po-textual">
                    “</textual><emphasis class="po-inline e408 e408" role="bold"><textual class="po-textual">No way!</textual></emphasis><textual class="po-textual">” will tell you any XPath specialist.
                And they would be right for XPath 1.0 or 2.0. </textual></para><para class="po-block e409 e409"><textual class="po-textual">
                </textual><emphasis class="po-inline e410 e410" role="bold"><textual class="po-textual">Remarkably, we can produce the above new XML document with the
                    following XPath 3.0 expression</textual></emphasis><textual class="po-textual">:
                </textual><programlisting class="po-block e411 e411" xml:space="preserve"><textual class="po-textual">parse-xml(concat('&lt;Person&gt;', (//Author)[last()], '&lt;/Person&gt;')) </textual></programlisting></para><para class="po-block e412 e412"><textual class="po-textual"> When this XPath 3.0 expression is evaluated, the result is:
                </textual><programlisting class="po-block e413 e413" xml:space="preserve"><textual class="po-textual"> &lt;Person&gt;Marvin Minsky&lt;/Person&gt;</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e414 e414"><textual class="po-textual"> To see that we have really produced a new document we evaluate this expression:
                </textual><programlisting class="po-block e415 e415" xml:space="preserve"><textual class="po-textual">parse-xml(concat('&lt;Person&gt;', (//Author)[last()], '&lt;/Person&gt;'))/*/text()</textual></programlisting><textual class="po-textual">
                and sure enough, the result is: </textual><programlisting class="po-block e416 e416" xml:space="preserve"><textual class="po-textual">Marvin Minsky</textual></programlisting><textual class="po-textual">
            </textual></para></section></section><section class="po-hcontainer e417 e417"><title class="po-block e418 e418"><textual class="po-textual">5.	Complete XPath 3.0 modules and applications</textual></title><para class="po-block e419 e419"><textual class="po-textual">
            We now have the necessary knowledge to produce a complete module or XML processing 
            application within a single XPath 3.0 expression.
        </textual></para><para class="po-block e420 e420"><textual class="po-textual">
            The problem we are solving in this chapter is to define a new data-type – 
            the Binary Search Tree (BST). The code is implemented entirely in XPath. 
            An advantage of an “XPath-only” definition is that it can be used (hosted) in 
            many programs—it can be hosted in XSLT programs, in XQuery programs, 
            and in any other programming language that hosts XPath. Thus “XPath-only” 
            data-type definitions or, more generally, libraries of XPath functions, 
            are highly portable and reusable.
        </textual></para><para class="po-block e421 e421"><textual class="po-textual"> A BST[</textual><citation class="po-atom e422 e422" linkend="BST"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] as defined here can process an XML document and represent its data as a
            binary search tree. A BST can implement “find/insert/delete a node” operations much more
            efficiently (with logarithmic time complexity) than in the case when the nodes are
            processed in a linear fashion. </textual></para><table class="po-container e423 e423"><caption class="po-container e424 e424"><para class="po-block e425 e425"><emphasis class="po-inline e426 e426" role="bold"><textual class="po-textual">Brief efficiency analysis</textual></emphasis></para></caption><tr class="po-table e427 e427"><td class="po-block e428 e428"><textual class="po-textual">
                    </textual><para class="po-block e429 e429"><textual class="po-textual"> It is a well-known, proven fact that find/insert/delete operations in a
                        balanced binary tree can be implemented with time complexity of
                            </textual><code class="po-atom e430 e430"><textual class="po-textual">O(log2N)</textual></code><textual class="po-textual">. </textual></para><textual class="po-textual">
                    </textual><para class="po-block e431 e431"><textual class="po-textual"> When processing in a linear fashion two sequences of data items:
                            </textual><code class="po-atom e432 e432"><textual class="po-textual">seq1</textual></code><textual class="po-textual"> and </textual><code class="po-atom e433 e433"><textual class="po-textual">seq2</textual></code><textual class="po-textual"> and if </textual><code class="po-atom e434 e434"><textual class="po-textual">seq2</textual></code><textual class="po-textual"> is
                            </textual><code class="po-atom e435 e435"><textual class="po-textual">1000000</textual></code><textual class="po-textual">(1M) times longer than </textual><code class="po-atom e436 e436"><textual class="po-textual">seq1</textual></code><textual class="po-textual">, the time
                        for processing </textual><code class="po-atom e437 e437"><textual class="po-textual">seq2</textual></code><textual class="po-textual"> is around one million times bigger, than
                        the time for processing </textual><code class="po-atom e438 e438"><textual class="po-textual">seq1</textual></code><textual class="po-textual">. </textual></para><textual class="po-textual">
                    </textual><para class="po-block e439 e439"><textual class="po-textual"> Compare this to having two balanced binary search trees </textual><code class="po-atom e440 e440"><textual class="po-textual">bst1</textual></code><textual class="po-textual">
                        and </textual><code class="po-atom e441 e441"><textual class="po-textual">bst2</textual></code><textual class="po-textual">, where </textual><code class="po-atom e442 e442"><textual class="po-textual">bst2</textual></code><textual class="po-textual"> has </textual><code class="po-atom e443 e443"><textual class="po-textual">1000000</textual></code><textual class="po-textual"> (1M)
                        times more data items (nodes) than </textual><code class="po-atom e444 e444"><textual class="po-textual">bst1</textual></code><textual class="po-textual"> – in this case the time
                        to process </textual><code class="po-atom e445 e445"><textual class="po-textual">bst2</textual></code><textual class="po-textual"> is only </textual><code class="po-atom e446 e446"><textual class="po-textual">19</textual></code><textual class="po-textual"> times bigger than the
                        time for processing </textual><code class="po-atom e447 e447"><textual class="po-textual">bst1</textual></code><textual class="po-textual">. </textual></para><textual class="po-textual">
                </textual></td></tr></table><para class="po-block e448 e448"><textual class="po-textual"> In the rest of this paper we are solving this real-world problem: </textual><emphasis class="po-inline e449 e449" role="bold"><textual class="po-textual">Find all bank transactions within a given range of dates</textual></emphasis><textual class="po-textual">. </textual></para><para class="po-block e450 e450"><textual class="po-textual">
            </textual><emphasis class="po-inline e451 e451" role="bold"><textual class="po-textual">Example</textual></emphasis><textual class="po-textual">: the following XML document contains a list of
            bank transactions (withdrawals and deposits). Each transaction is stamped with a date.
            The transactions are in no particular chronological order: </textual><programlisting class="po-block e452 e452" xml:space="preserve"><textual class="po-textual"> &lt;Transactions&gt;
        &lt;transaction date="2012-03-01"&gt;
                &lt;withdrawal&gt;100&lt;/withdrawal&gt;
        &lt;/transaction&gt;
        &lt;transaction date="2012-01-15"&gt;
                &lt;deposit&gt;200&lt;/deposit&gt;
        &lt;/transaction&gt;
        &lt;transaction date="2012-05-01"&gt;
                &lt;deposit&gt;100&lt;/deposit&gt;
        &lt;/transaction&gt;
        &lt;transaction date="2012-02-01"&gt;
                &lt;withdrawal&gt;50&lt;/withdrawal&gt;
        &lt;/transaction&gt;
        &lt;transaction date="2012-06-01"&gt;
                &lt;deposit&gt;100&lt;/deposit&gt;
        &lt;/transaction&gt;
        &lt;transaction date="2012-04-01"&gt;
                &lt;deposit&gt;100&lt;/deposit&gt;
        &lt;/transaction&gt;
        &lt;transaction date="2012-01-01"&gt;
                &lt;deposit&gt;25&lt;/deposit&gt;
        &lt;/transaction&gt;
&lt;/Transactions&gt;            </textual></programlisting><textual class="po-textual"> If we could represent the above XML document as a
            binary search tree where for each node (transaction), the date of its left child
            (transaction) node is less than the (parent) node’s date and the date of its right child
            (transaction) node is greater than the (parent) node’s date. Then such a binary search
            tree be graphically represented as below: </textual><inlinemediaobject class="po-null e453 e453"><imageobject class="po-container e454 e454"><imagedata class="po-meta e455 e455" fileref="../../../vol10/graphics/Novatchev01/Novatchev01-001.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual">
        </textual></para><para class="po-block e456 e456"><textual class="po-textual">
            </textual><emphasis class="po-inline e457 e457" role="bold"><textual class="po-textual">Problem</textual></emphasis><textual class="po-textual">: Find all the transactions in the range
            2012-03-15 to 2012-05-15. </textual></para><para class="po-block e458 e458"><textual class="po-textual">
            This problem can be solved efficiently now that the transactions are stored in a binary tree. 
            (The more balanced the binary search tree is, the more efficient is a BST-based solution.)
        </textual></para><para class="po-block e459 e459"><textual class="po-textual">
            The following pseudo-code (an initial version of which and the code below was first produced by 
            Roger Costello [</textual><citation class="po-atom e460 e460" linkend="Costello"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]) that shows how to find the wanted transactions 
            (</textual><code class="po-atom e461 e461"><textual class="po-textual">start date &gt;= 2012-03-15</textual></code><textual class="po-textual">, </textual><code class="po-atom e462 e462"><textual class="po-textual">end date &lt;= 2012-05-15</textual></code><textual class="po-textual">):
        </textual></para><para class="po-block e463 e463"><textual class="po-textual">
          </textual><emphasis class="po-inline e464 e464" role="bold"><textual class="po-textual">Return a sequence of the following nodes</textual></emphasis><textual class="po-textual">:
        </textual></para><para class="po-block e465 e465"><textual class="po-textual">
            If the value of the root node equals the start date, then:
            </textual><orderedlist class="po-table e466 e466"><listitem class="po-container e467 e467"><para class="po-block e468 e468"><textual class="po-textual">
                        The root node.
                    </textual></para></listitem><listitem class="po-container e469 e469"><para class="po-block e470 e470"><textual class="po-textual">
                        The result of recursing on the right subtree.
                    </textual></para></listitem></orderedlist><textual class="po-textual">
        </textual></para><para class="po-block e471 e471"><textual class="po-textual">
            If the value of the root node equals the end date, then:
            </textual><orderedlist class="po-table e472 e472"><listitem class="po-container e473 e473"><para class="po-block e474 e474"><textual class="po-textual">
                        The result of recursing on the left subtree.
                    </textual></para></listitem><listitem class="po-container e475 e475"><para class="po-block e476 e476"><textual class="po-textual">
                        The root node.
                    </textual></para></listitem></orderedlist><textual class="po-textual">
        </textual></para><para class="po-block e477 e477"><textual class="po-textual">
            If the value of the root node is between the start and end date, then:
            </textual><orderedlist class="po-table e478 e478"><listitem class="po-container e479 e479"><para class="po-block e480 e480"><textual class="po-textual">
                        The result of recursing on the left subtree.
                    </textual></para></listitem><listitem class="po-container e481 e481"><para class="po-block e482 e482"><textual class="po-textual">
                        The root node.
                    </textual></para></listitem><listitem class="po-container e483 e483"><para class="po-block e484 e484"><textual class="po-textual">
                        The result of recursing on the right subtree.
                    </textual></para></listitem></orderedlist><textual class="po-textual">
        </textual></para><para class="po-block e485 e485"><textual class="po-textual">
            If the value of the root node is less than the start date, then:
            </textual><orderedlist class="po-table e486 e486"><listitem class="po-container e487 e487"><para class="po-block e488 e488"><textual class="po-textual">
                        The result of recursing on the right subtree,
                    </textual></para></listitem></orderedlist><textual class="po-textual">
        </textual></para><para class="po-block e489 e489"><textual class="po-textual">
            If the value of the root node is greater than the end date, then:
            </textual><orderedlist class="po-table e490 e490"><listitem class="po-container e491 e491"><para class="po-block e492 e492"><textual class="po-textual">
                        The result of recursing on the left subtree.
                    </textual></para></listitem></orderedlist><textual class="po-textual">
        </textual></para><table class="po-container e493 e493"><caption class="po-container e494 e494"><para class="po-block e495 e495"><emphasis class="po-inline e496 e496" role="bold"><textual class="po-textual">XSLT/XQuery or XPath?</textual></emphasis></para></caption><tr class="po-table e497 e497"><td class="po-block e498 e498"><textual class="po-textual">
                    </textual><para class="po-block e499 e499"><textual class="po-textual"> The code in this chapter can be implemented using XSLT or XQuery -defined
                        functions. One would favor an XPath-only solution because: </textual><itemizedlist class="po-table e500 e500"><listitem class="po-container e501 e501"><para class="po-block e502 e502"><textual class="po-textual">Implementation in more than one language (e.g. in both XSLT
                                    and XQuery) is often required.</textual></para></listitem><listitem class="po-container e503 e503"><para class="po-block e504 e504"><textual class="po-textual">The XPath code can be shorter and easier to understand.</textual></para></listitem><listitem class="po-container e505 e505"><para class="po-block e506 e506"><textual class="po-textual">The XPath solution can be injected into XSLT and/or XQuery
                                    code, with simple copy and paste.</textual></para></listitem></itemizedlist><textual class="po-textual">
                        </textual><emphasis class="po-inline e507 e507" role="bold"><textual class="po-textual">Recommendation</textual></emphasis><textual class="po-textual">: Consider producing an
                        XPath-only solution or a library of functions, especially if there is even a
                        remote possibility that the functionality would be needed in more than one
                        XML processing language.</textual></para><textual class="po-textual">
                </textual></td></tr></table><para class="po-block e508 e508"><textual class="po-textual">
            </textual><programlisting class="po-block e509 e509" xml:space="preserve"><textual class="po-textual">$find-range-of-transactions :=
	         function( $tree as function()*,
	                   $start-date as xs:date,
	                   $end-date as xs:date
	                  )
	         {
	             $find-range-of-transactions-helper
	         				( $tree,
	               	 	   $start-date,
	                       	$end-date,
	                       	$find-range-of-transactions-helper)
	         }</textual></programlisting><textual class="po-textual">
            The function’s name is </textual><code class="po-atom e510 e510"><textual class="po-textual">find-range-of-transactions</textual></code><textual class="po-textual">. This is a recursive
            function. As shown previously, implementing recursion using anonymous functions requires
            a “helper” function. Here is the helper function
                </textual><code class="po-atom e511 e511"><textual class="po-textual">find-range-of-transactions-helper()</textual></code><textual class="po-textual">:
            </textual><programlisting class="po-block e512 e512" xml:space="preserve"><textual class="po-textual">$find-range-of-transactions-helper :=
	        function( $tree as function()*,
	                  $start-date as xs:date,
	                  $end-date as xs:date,
	                  $find-range-of-transactions-helper
	                  )
	                   as element(transaction)*
	        {
	            if (empty($tree)) then ()
	            else
	                if (xs:date($root($tree)/@date)  eq  $start-date) 
                       then
	                     (
	                        $root($tree),
	                        $find-range-of-transactions-helper
	                        	  ( $right($tree),
	                                $start-date,
	                                $end-date,
	                                $find-range-of-transactions-helper)
	                     )
	                    else  if (xs:date($root($tree)/@date)  eq  $end-date) 
                           then
	                          (
	                             $find-range-of-transactions-helper
	                             	  ( $left($tree),
	                                     $start-date,
	                                     $end-date,
	                                     $find-range-of-transactions-helper),
	                             $root($tree)
	                          )
	                        else
	                            if ((xs:date($root($tree)/@date)  gt  $start-date)
	                              and
	                                (xs:date($root($tree)/@date)  lt  $end-date)) then
	                              (
	                                  $find-range-of-transactions-helper
	                                   	 ( $left($tree),
	                                      	$start-date,
	                                      	$end-date,
	                                      	$find-range-of-transactions-helper),
	                                  $root($tree),
	                                  $find-range-of-transactions-helper
	                                 	   ( $right($tree),
	                                   	   $start-date,
	                                   	   $end-date,
	                                   	   $find-range-of-transactions-helper)
	                              )
	                            else
	                                if (xs:date($root($tree)/@date)  lt  $start-date) then
	                                  (
	                                      $find-range-of-transactions-helper
	                                      	  ( $right($tree),
	                                       	   $start-date,
	                                       	   $end-date,
	                                       	   $find-range-of-transactions-helper)
	                                  )
	                                else
	                                    if (xs:date($root($tree)/@date)  gt  $end-date) then
	                                      (
	                                           $find-range-of-transactions-helper
	                                          	   ( $left($tree),
	                                           	    $start-date,
	                                           	    $end-date,
	                                           	    $find-range-of-transactions-helper)
	                                      )
	                                    else ()
	         }</textual></programlisting><textual class="po-textual">
        </textual></para><para class="po-block e513 e513"><textual class="po-textual"> As tree-nodes are inserted into the binary tree, a comparison is made between the
            tree-node being inserted and the tree’s root node. How should the comparison be done?
            That depends on the data-type of the items stored in a tree. Consequently, the “insert
            function” must be provided an appropriate “comparator function.” For our bank
            transactions example, the comparison is done based on the date attribute. Here is an
            appropriate comparator function:
            </textual><programlisting class="po-block e514 e514" xml:space="preserve"><textual class="po-textual">$transaction-less-than-comparator :=
	 function($arg1 as element(transaction),
	          $arg2 as element(transaction)
	          ) as xs:boolean
	   {
	      xs:date($arg1/@date)  lt   xs:date($arg2/@date)
	   }    </textual></programlisting><textual class="po-textual">
        </textual></para><para class="po-block e515 e515"><textual class="po-textual">
            The value of the variable is an anonymous function. The function takes two arguments – 
            both transaction  elements – and returns true if the date of  the first transaction is less 
            than the date of  the second transaction.
        </textual></para><para class="po-block e516 e516"><textual class="po-textual">
            In this paper we define a binary search tree is a set of these functions:
            </textual><orderedlist class="po-table e517 e517"><listitem class="po-container e518 e518"><para class="po-block e519 e519"><textual class="po-textual">
                        </textual><emphasis class="po-inline e520 e520" role="bold"><textual class="po-textual">create</textual></emphasis><textual class="po-textual">: create an empty tree.</textual></para></listitem><listitem class="po-container e521 e521"><para class="po-block e522 e522"><textual class="po-textual">
                        </textual><emphasis class="po-inline e523 e523" role="bold"><textual class="po-textual">root</textual></emphasis><textual class="po-textual">: return the value of the root
                        node.</textual></para></listitem><listitem class="po-container e524 e524"><para class="po-block e525 e525"><textual class="po-textual">
                        </textual><emphasis class="po-inline e526 e526" role="bold"><textual class="po-textual">left</textual></emphasis><textual class="po-textual">: return the left subtree.</textual></para></listitem><listitem class="po-container e527 e527"><para class="po-block e528 e528"><textual class="po-textual">
                        </textual><emphasis class="po-inline e529 e529" role="bold"><textual class="po-textual">right</textual></emphasis><textual class="po-textual">: return the right subtree.</textual></para></listitem><listitem class="po-container e530 e530"><para class="po-block e531 e531"><textual class="po-textual">
                        </textual><emphasis class="po-inline e532 e532" role="bold"><textual class="po-textual">empty</textual></emphasis><textual class="po-textual">: return true if the tree is empty,
                        false otherwise.</textual></para></listitem><listitem class="po-container e533 e533"><para class="po-block e534 e534"><textual class="po-textual">
                        </textual><emphasis class="po-inline e535 e535" role="bold"><textual class="po-textual">insert</textual></emphasis><textual class="po-textual">: insert an item into the tree, with
                        comparison done using a comparator (see above).</textual></para></listitem><listitem class="po-container e536 e536"><para class="po-block e537 e537"><textual class="po-textual">
                        </textual><emphasis class="po-inline e538 e538" role="bold"><textual class="po-textual">print</textual></emphasis><textual class="po-textual">: serialize the tree as XML
                        document.</textual></para></listitem><listitem class="po-container e539 e539"><para class="po-block e540 e540"><textual class="po-textual">
                        </textual><emphasis class="po-inline e541 e541" role="bold"><textual class="po-textual">populate</textual></emphasis><textual class="po-textual">: create a BST from a sequence of
                        items.</textual></para></listitem></orderedlist><textual class="po-textual">
           Additionaly, one can define other useful functions on a BST, such as node deletion[</textual><citation class="po-atom e542 e542" linkend="Nova3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">].
        </textual></para><para class="po-block e543 e543"><textual class="po-textual"> Below is the complete XPath code for both the BST type definition and the functions
            that use this data-type to actually solve the problem of finding all the bank
            transactions between a given start date and a given end date.
            </textual><programlisting class="po-block e544 e544" xml:space="preserve"><textual class="po-textual">let
         (:
             The purpose of create is to return an empty tree.
         
             It returns a sequence of functions, 
                - the first function represents the root of a tree, 
                - the second function represents the left subtree, 
                - and the third function represents the right subtree. 
             The value of each function is an empty sequence.
         :) 
         $create := (
                     function() { () }      (: root :),
                     function() { () }      (: left :),
                     function() { () }      (: right :) 
                     ),
                     
                     
         (:
             empty() returns a boolean value,
             indicating whether $tree is empty.
         
             $tree is empty in either of these two cases:
             1. $tree is the empty sequence (it doesn't contain any functions). 
             2. $tree contains a sequence of three functions, but the first 
                  function - representing the root - is empty (i.e., if you invoke the 
                  first function it returns the empty sequence). 
         :)
         $empty := function($tree as function()*)
                   {
                        empty($tree) or empty($tree[1]())
                   },
                   
                   
         (:
             root()returns the value of the root node. 
         
             This function takes one argument, $tree. Since $tree 
             is represented by a sequence of functions, returning the 
             value of the root node actually means returning the value of   
             the function that corresponds to the root node.
         
             If $tree is empty then the empty sequence is returned. Otherwise 
             the *value* of executing the first function in $tree  is returned (recall 
             that a tree is represented by a sequence of functions, the first 
             function representing the root of the tree).
         
             Note: $tree[1] is the first function whereas
                        $tree[1]() is the *value* of executing the first function.
         :)
         $root := function($tree as function()*)
                  {
                      if ($empty($tree)) 
                         then ()
                         else $tree[1]()
                  },
                  
                  
         (:
             left()returns the left subtree. 
         
             This function takes one argument, $tree. Since $tree is represented 
             by a sequence of functions, returning the left subtree  
             actually means returning the value of executing the function that corresponds 
             to the left subtree.
         
             If $tree is empty then the empty sequence is returned. Otherwise 
             the *value* of executing the second function in $tree is returned (recall 
             that a tree is represented by a sequence of functions, the second 
             function representing the left subtree).
             
             Note: $tree[2] is the second function whereas
                        $tree[2]() is the *value* of executing the second function.
         :)
         $left := function($tree as function()*)
                  {
                      if ($empty($tree)) then ()
                         else 
                           if ($empty($tree[2])) then ()
                              else $tree[2]()
                  },
                  
                  
         (:
             right() returns the right subtree. 
         
             This function takes one argument, $tree. Since $tree is represented 
             by a sequence of functions, returning the right subtree actually 
             means returning the value of executing the function that corresponds to the
             right subtree.
         
             If $tree is empty then the empty sequence is returned. Otherwise 
             the *value* of executing the third function in $tree is returned (recall 
             that a tree is represented by a sequence of functions, the third 
             function representing the right subtree).
         :)
         $right := function($tree as function()*)
                   {
                        if ($empty($tree)) then ()
                        else 
                          if ($empty($tree[3])) then ()
                          else $tree[3]()
                   },
                   
                   
        (:
            As tree-nodes are inserted into a BST, a comparison is made between 
            the value being inserted and the value in the tree's root node. How should 
            the comparison be done? That depends on the type of the data contained in a tree-node.
            Comparing two integers is different than comparing two tree fragments.
            So, the insert function must be provided with an appropriate comparator. For 
            the case of bank transactions, a date comparison is needed.
            Here is an appropriate comparator function:
        :)
        $transaction-less-than-comparator :=
	        function( $arg1  as element(transaction),
	                  $arg2  as element(transaction)
	                 ) as xs:boolean
	        {
	              xs:date($arg1/@date) lt xs:date($arg2/@date)
	        },
                                                  
                                                  
         $numeric-less-than-comparator :=
	         function( $arg1 as xs:decimal,
	                   $arg2 as xs:decimal
	                  ) as xs:boolean
	         {
	               $arg1  lt   $arg2
	         },
                                           
                                           
         (:
             insert() takes a $tree (BST) and a $item and produces a new BST that is the result 
             of inserting $item as a tree-node in $tree.  A BST is a persistent (functional) data-type.
             Insertions or deletions are never done “in place” – instead a new BST is produced.       

             The new node is inserted at:
             - if $tree is empty then as root node.
             - if the value of $item is less than the value of  the root node then
               the new tree-node is inserted into the left subtree (note the recursive definition)
             - else the new tree-node is inserted into the right subtree (again note the recursive
               definition)
         
             Here are the steps taken if $tree is empty:
             - $item specified to be the result of  the  root function. That is, the root function, 
               if invoked, it returns $item. 
             - A left function is created such that, if invoked, will return an empty subtree.
             - A right function is created such that, if invoked, will return an empty subtree.
             
             The insert function is recursive. Recursion with anonymous functions requires
             a helper function as discussed before.
         :)
         $insert-helper :=
	         function( $tree as function()*,
	                   $item as item(),
	                   $less-than-comparator as function(item(), item()) as xs:boolean,
	                   $insert-helper
	                   )
	         {
	         if ($empty($tree)) then
	               (
	                     function() {$item}     (: root :),
	                     function() {()}        (: left :),
	                     function() {()}        (: right :)
	               )
	          else if ($less-than-comparator($item, $root($tree))) then
	               (
	                     function() {$root($tree)}                           	(: root :),

	                     function() {$insert-helper( $left($tree),
	                                                 $item,
	                                                 $less-than-comparator,
	                                                 $insert-helper)
	                                }   				                         (: left :),

	                     function() {$right($tree)}                          	(: right :)
	                )
	          else
	               (
	                     function() {$root($tree)}                          	 (: root :),
	                     function() {$left($tree)}                           	(: left :),

	                     function() {$insert-helper( $right($tree),
	                                                 $item,
	                                                 $less-than-comparator,
	                                                 $insert-helper)
	                                }      				                      (: right :)
	                )
	         },
                           
                           
         $insert :=
	         function ( $tree as function()*,
	                    $item as item(),
	                    $less-than-comparator as function(item(), item()) as xs:boolean
	                    )
	         {
	               $insert-helper($tree, $item, $less-than-comparator, $insert-helper)
	         },
                    
                    
         (:
             print() produces an XML document that represents the BST $tree. 
         
             The XML document produced by  print()  consists of:
             1. A root element that represents the value of executing the root function.
             2. A left element that represents the value of print() on the left subtree
                (note the recursive definition).
             3. A right element that represents the value of print() on the right subtree
                (note the recursive definition).

            The $print-helper function produces the markup
             as a string and then the $printer function converts
             this string into an XML document by calling the  parse-xml() function.
         :)
         $print-helper :=
	         function ( $tree as function()*,
	                    $print-helper
	                    ) 
	                     as xs:string?
	         {
	              if (not($empty($tree))) then
	              concat('&lt;tree&gt;',
	                       '&lt;root&gt;',
	                          $root($tree),
	                       '&lt;/root&gt;',
	                        '&lt;left&gt;',
	                          $print-helper($left($tree),$print-helper),
	                        '&lt;/left&gt;',
	                        '&lt;right&gt;',
	                          $print-helper($right($tree),$print-helper),
	                        '&lt;/right&gt;',
	                     '&lt;/tree&gt;'
	                      )
	             else ()
	          },
                          
                          
         $print := function ($tree as function()*)
                   {parse-xml($print-helper($tree, $print-helper))/*},
                   
                   
         (:
             populate() produces a new tree from its BST argument $tree by inserting
             the value of the head() of the sequence $items onto $tree and then inserting 
             the tail() of the sequence $items onto the result. 
         :)
         $populate-helper :=
	         function ( $tree as function()*,
	                    $items as item()*,
	                    $less-than-comparator as function(item(), item()) as xs:boolean,
	                    $populate-helper
	                    )
	         {
	             if (empty($items)) then $tree
	             else
	                  $populate-helper( $insert($tree, $items[1], $less-than-comparator),
	                                    $items[position() gt 1],
	                                    $less-than-comparator,
	                                    $populate-helper
	                                    )
	         },
                             
                             
         $populate :=
	         function( $tree as function()*,
	                   $items as item()*,
	                   $less-than-comparator as function(item(), item()) as xs:boolean
	                   )
	         {$populate-helper($tree, $items, $less-than-comparator, $populate-helper)},
                      
                      
        (:
           Finally, the solution of the original problem. 
           Task: find all the bank transactions in the range 2012-03-15 to 2012-05-15. 
         :)
        $find-range-of-transactions-helper :=
	        function( $tree as function()*,
	                  $start-date as xs:date,
	                  $end-date as xs:date,
	                  $find-range-of-transactions-helper
	                )
	                as element(transaction)*
	        {
	            if (empty($tree)) then ()
	            else
	                if (xs:date($root($tree)/@date) eq $start-date) then
	                     (
	                            $root($tree),
	                            $find-range-of-transactions-helper
	                        		        ( $right($tree),
	                                   	   $start-date,
	                                      	$end-date,
	                                     	 $find-range-of-transactions-helper)
	                     )
	                    else
	                        if (xs:date($root($tree)/@date) eq $end-date) then
	                          (
	                                 $find-range-of-transactions-helper
	                             	            ( $left($tree),
	                                       	    $start-date,
	                                      	     $end-date,
	                                       	    $find-range-of-transactions-helper),
	                                 $root($tree)
	                          )
	                        else
	                            if ((xs:date($root($tree)/@date) gt $start-date)
	                               and
	                                (xs:date($root($tree)/@date) lt $end-date)) then
	                             (
	                                   $find-range-of-transactions-helper
	                                   		( $left($tree),
	                                      	   $start-date,
	                                      	   $end-date,
	                                      	   $find-range-of-transactions-helper),
	                                   $root($tree),
	                                   $find-range-of-transactions-helper
	                                 		( $right($tree),
	                                   	    $start-date,
	                                   	    $end-date,
	                                   	    $find-range-of-transactions-helper)
	                             )
	                            else
	                                if (xs:date($root($tree)/@date) lt $start-date) then
	                                 (
	                                    $find-range-of-transactions-helper
	                                      ( $right($tree),
	                                        $start-date,
	                                        $end-date,
	                                        $find-range-of-transactions-helper)
	                                 )
	                                else
	                                    if (xs:date($root($tree)/@date) gt $end-date) then
	                                     (
	                                        $find-range-of-transactions-helper
	                                          ( $left($tree),
	                                            $start-date,
	                                            $end-date,
	                                            $find-range-of-transactions-helper)
	                                     )
	                                    else ()
	         },
                                        
                                        
         $find-range-of-transactions :=
	         function($tree as function()*,
	                  $start-date as xs:date,
	                  $end-date as xs:date
	                  )
	         {
	             $find-range-of-transactions-helper
	         	  ( $tree,
	                 $start-date,
	                 $end-date,
	                 $find-range-of-transactions-helper)
	         }

                                                               
    (:  At last, we finalize this big, outermost *let* clause with a *return* clause 
        that expresses the intent of the users of the BST data-type.
        We want to get all transactions in the period:
        15th March 2012 to 15th May 2012.
    :)

  return (
              $find-range-of-transactions
                ( $populate((), //transaction, $transaction-less-than-comparator),
                  xs:date('2012-03-15'), 
                  xs:date('2012-05-15')
                 )
             )</textual></programlisting><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e545 e545"><title class="po-block e546 e546"><textual class="po-textual">6.	Analysis</textual></title><para class="po-block e547 e547"><textual class="po-textual">
            </textual><emphasis class="po-inline e548 e548" role="bold"><textual class="po-textual">This example shows how a new data-type, or generally a library of
                functions can be defined in an XPath 3.0 expression and then used by a client in the
                same XPath expression</textual></emphasis><textual class="po-textual">: </textual><itemizedlist class="po-table e549 e549"><listitem class="po-container e550 e550"><para class="po-block e551 e551"><textual class="po-textual">The definitions of the library functions are in the “let clause”.</textual></para></listitem><listitem class="po-container e552 e552"><para class="po-block e553 e553"><textual class="po-textual">The expressions that use these library functions are in the “return
                        clause”.</textual></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para><para class="po-block e554 e554"><textual class="po-textual">
            </textual><emphasis class="po-inline e555 e555" role="bold"><textual class="po-textual">We also experienced some inconvenience and that helped us specify
                a wish-list for a future version of XPath</textual></emphasis><textual class="po-textual">: </textual><orderedlist class="po-table e556 e556"><listitem class="po-container e557 e557"><para class="po-block e558 e558"><textual class="po-textual"> Our example contains one huge let-return expression. For better
                        modularity it would have been nice to place all the binary search tree
                        functions (create, left, right, insert, etc.) into their own “module” which
                        could then be “imported” by the bank transaction functions. Unfortunately,
                        XPath does not support this. </textual><emphasis class="po-inline e559 e559" role="bold"><textual class="po-textual">Recommendation for a
                            future XPath version</textual></emphasis><textual class="po-textual">: </textual><emphasis class="po-inline e560 e560"><textual class="po-textual">Support XPath
                            expression files and an import clause to collect such expressions from
                            files in a desired new, client XPath program</textual></emphasis><textual class="po-textual">. </textual></para></listitem><listitem class="po-container e561 e561"><para class="po-block e562 e562"><textual class="po-textual"> Our example implemented binary search trees as a sequence of functions.
                        While this works okay, it would be much more precise and elegant if XPath
                        had a “tuple type” so that a tree could be simply defined as a tuple: tree
                        is a tuple (root, left, right). </textual><emphasis class="po-inline e563 e563" role="bold"><textual class="po-textual">Recommendation for a
                            future XPath version</textual></emphasis><textual class="po-textual">: </textual><emphasis class="po-inline e564 e564"><textual class="po-textual">Support a tuple
                            type, so that the result type of various functions (such as the creation
                            of a tree) can be more precisely specified than just a sequence of
                            function items</textual></emphasis><textual class="po-textual">. </textual></para></listitem><listitem class="po-container e565 e565"><para class="po-block e566 e566"><textual class="po-textual">
                        The Map data-type could further boost the expressiveness of XPath, 
                        making the language even more convenient. The Map data-type is already 
                        part of the latest published working draft of XSLT 3.0 [</textual><citation class="po-atom e567 e567" linkend="XSLT3.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] and has been warmly 
                        accepted by the XML developers community.
                    </textual></para></listitem><listitem class="po-container e568 e568"><para class="po-block e569 e569"><textual class="po-textual">
                        Introducing generics would further strengthen the expressive power and preciseness of XPath. 
                    </textual></para></listitem></orderedlist><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e570 e570"><title class="po-block e571 e571"><textual class="po-textual">7. Consuming an XPath function library from XSLT 3.0 and XQuery 3.1</textual></title><para class="po-block e572 e572"><textual class="po-textual">
         It is possible in XSLT 3.0 to conveniently consume an XPath function library
         directly from a text file.
       </textual></para><para class="po-block e573 e573"><textual class="po-textual">
         </textual><emphasis class="po-inline e574 e574" role="bold"><textual class="po-textual">Here is an example:</textual></emphasis><textual class="po-textual">
       </textual></para><para class="po-block e575 e575"><textual class="po-textual">
         </textual><emphasis class="po-inline e576 e576" role="bold"><textual class="po-textual">A simple function library</textual></emphasis><textual class="po-textual"> (file SimpleLibraryAsMap.xpath):
       </textual></para><para class="po-block e577 e577"><textual class="po-textual">
         </textual><programlisting class="po-block e578 e578" xml:space="preserve"><textual class="po-textual">
 let
         $incr := function($n as xs:integer)
                   {$n +1},
         $mult := function($m as xs:integer, $n as xs:integer)
                   {$m * $n},
         $decr := function($n as xs:integer)
                   {$n -1},
         $idiv := function($m as xs:integer, $n as xs:integer)
                   {$m idiv $n}

	  (: Provide the function libary  as a map:)
 return
      map {
           'incr'     := $incr,
           'mult'     := $mult,
           'decr'     := $decr,
           'idiv'     := $idiv
          }  </textual></programlisting><textual class="po-textual">
       </textual></para><para class="po-block e579 e579"><textual class="po-textual">
         </textual><emphasis class="po-inline e580 e580" role="bold"><textual class="po-textual">XSLT transformation that uses this function library</textual></emphasis><textual class="po-textual">:
       </textual></para><para class="po-block e581 e581"><textual class="po-textual">
         </textual><programlisting class="po-block e582 e582" xml:space="preserve"><textual class="po-textual">
&lt;xsl:stylesheet version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
 &lt;xsl:output omit-xml-declaration="yes" indent="yes"/&gt;

 &lt;xsl:template match="/"&gt;

  &lt;!-- The Function Library --&gt;
  &lt;xsl:variable name="vMath" as="map(*)"&gt;
    &lt;xsl:evaluate xpath="unparsed-text('SimpleLibraryAsMap.xpath')"/&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:sequence select="'incr(3) = ', $vMath('incr')(3)"/&gt;
 &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;         </textual></programlisting><textual class="po-textual">
       </textual></para><para class="po-block e583 e583"><emphasis class="po-inline e584 e584" role="bold"><textual class="po-textual">The result is:</textual></emphasis><textual class="po-textual"> "incr(3) =  4"</textual></para><para class="po-block e585 e585"><textual class="po-textual">The "importing" of the library is done via the simple and powerful combination
             of the standard XPath 3.0 function </textual><emphasis class="po-inline e586 e586"><textual class="po-textual">unparsed-text()</textual></emphasis><textual class="po-textual"> and the new XSLT 3.0 instruction
             </textual><emphasis class="po-inline e587 e587"><textual class="po-textual">&lt;xsl:evaluate&gt;</textual></emphasis><textual class="po-textual">
       </textual></para><para class="po-block e588 e588"><textual class="po-textual">
       </textual><emphasis class="po-inline e589 e589" role="bold"><textual class="po-textual">Consuming the function library from a map-cognizant XQuery processor is even simpler</textual></emphasis><textual class="po-textual">
        -- we just need to
       wrap the library as/into an XQuery module and then import this module in the consuming XQuery.
       </textual></para><para class="po-block e590 e590"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></section><section class="po-hcontainer e591 e591"><title class="po-block e592 e592"><textual class="po-textual">Conclusion</textual></title><para class="po-block e593 e593"><textual class="po-textual">
            The powerful new capabilities in XPath 3.0 such as HOFs,  inline functions, functional composition, 
            partial application and closures, indirect and robust anonymous function recursion, 
            own sequence-type variables and the ability to create new XML documents / nodes, turn XPath 
            into a full-pledged, complete, modern XML programming language: the first to truly implement 
            useful copy-paste code portability between XSLT and XQuery. 
        </textual></para><para class="po-block e594 e594"><textual class="po-textual">
            This gives the XML programmer the ability to write an application once and reuse it many times
            – standalone or included into code written in many other languages. 
        </textual></para><para class="po-block e595 e595"><textual class="po-textual">
            Function library author’s productivity is significantly increased, redundancy is eliminated,
            maintenance of dual sets of functions is no longer a problem.
        </textual></para><para class="po-block e596 e596"><textual class="po-textual">
            A few finishing touches are needed such as adding tuples, generics 
            and modularity support – either by the W3C or by proactive programmers.
        </textual></para><para class="po-block e597 e597"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></section><section class="po-hcontainer e598 e598"><title class="po-block e599 e599"><textual class="po-textual">Acknowledgement</textual></title><para class="po-block e600 e600"><textual class="po-textual">Many thanks to Roger Costello, without whose work this paper would hardly be possible.</textual></para><para class="po-block e601 e601"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></section><section class="po-hcontainer e602 e602"><title class="po-block e603 e603"><textual class="po-textual">Appendix: The BST data type defined and consumed as a map </textual></title><para class="po-block e604 e604"><textual class="po-textual">Here we show an easy way to consume from both XSLT and XQuery
            the BST function library residing at its own file</textual></para><para class="po-block e605 e605"><emphasis class="po-inline e606 e606" role="bold"><textual class="po-textual">The BST XPath code</textual></emphasis><textual class="po-textual"> (XPathFunctionLibrary.xpath)
            -- see how a </textual><emphasis class="po-inline e607 e607"><textual class="po-textual">map</textual></emphasis><textual class="po-textual"> is created in the return clause:</textual></para><para class="po-block e608 e608"><textual class="po-textual">
        </textual><programlisting class="po-block e609 e609" xml:space="preserve"><textual class="po-textual">
 let
         (:
             The purpose of create is to return an empty tree.

             It returns a sequence of functions,
                - the first function represents the root of a tree,
                - the second function represents the left subtree,
                - and the third function represents the right subtree.
             The value of each function is an empty sequence.
         :)
         $create := (
                                function() { () }      (: root :),
                                function() { () }      (: left :),
                                function() { () }      (: right :)
                            ),


         (:
             empty() returns a boolean value,
             indicating whether $tree is empty.

             $tree is empty in either of these two cases:
             1. $tree is the empty sequence (it doesn't contain any functions).
             2. $tree contains a sequence of three functions, but the first
                  function - representing the root - is empty (i.e., if you invoke the
                  first function it returns the empty sequence).
         :)
         $empty := function($tree as function(*)*)
                           {
                                empty($tree) or empty($tree[1]())
                           },


         (:
             root()returns the value of the root node.

             This function takes one argument, $tree. Since $tree
             is represented by a sequence of functions, returning the
             value of the root node actually means returning the value of
             the function that corresponds to the root node.

             If $tree is empty then the empty sequence is returned. Otherwise
             the *value* of executing the first function in $tree  is returned (recall
             that a tree is represented by a sequence of functions, the first
             function representing the root of the tree).

             Note: $tree[1] is the first function whereas
                        $tree[1]() is the *value* of executing the first function.
         :)
         $root := function($tree as function(*)*)
                        {
                              if ($empty($tree))
                                  then ()
                                  else $tree[1]()
                        },


         (:
             left()returns the left subtree.

             This function takes one argument, $tree. Since $tree is represented
             by a sequence of functions, returning the left subtree
             actually means returning the value of executing the function that corresponds
             to the left subtree.

             If $tree is empty then the empty sequence is returned. Otherwise
             the *value* of executing the second function in $tree is returned (recall
             that a tree is represented by a sequence of functions, the second
             function representing the left subtree).

             Note: $tree[2] is the second function whereas
                        $tree[2]() is the *value* of executing the second function.
         :)
         $left := function($tree as function(*)*)
                      {
                            if ($empty($tree)) then ()
                            else
                                  if ($empty($tree[2])) then ()
                                  else $tree[2]()
                      },


         (:
             right() returns the right subtree.

             This function takes one argument, $tree. Since $tree is represented
             by a sequence of functions, returning the right subtree actually
             means returning the value of executing the function that corresponds to the
             right subtree.

             If $tree is empty then the empty sequence is returned. Otherwise
             the *value* of executing the third function in $tree is returned (recall
             that a tree is represented by a sequence of functions, the third
             function representing the right subtree).
         :)
         $right := function($tree as function(*)*)
                        {
                              if ($empty($tree)) then ()
                             else
                                   if ($empty($tree[3])) then ()
                                   else $tree[3]()
                        },


         $numeric-less-than-comparator :=
	         function( $arg1 as xs:decimal,
	                           $arg2 as xs:decimal
	                         ) as xs:boolean
	         {
	               $arg1  lt   $arg2
	         },


         (:
             insert() takes a $tree (BST) and a $item and produces a new BST that is the result
             of inserting $item as a tree-node in $tree.  A BST is a persistent (functional) data-type.
             Insertions or deletions are never done “in place” – instead a new BST is produced.

             The new node is inserted at:
             - if $tree is empty then as root node.
             - if the value of $item is less than the value of  the root node then
               the new tree-node is inserted into the left subtree (note the recursive definition)
             - else the new tree-node is inserted into the right subtree (again note the recursive
               definition)

             Here are the steps taken if $tree is empty:
             - $item specified to be the result of  the  root function. That is, the root function,
               if invoked, it returns $item.
             - A left function is created such that, if invoked, will return an empty subtree.
             - A right function is created such that, if invoked, will return an empty subtree.

             The insert function is recursive. Recursion with anonymous functions requires
             a helper function as discussed before.
         :)
         $insert-helper :=
	         function( $tree as function(*)*,
	                          $item as item(),
	                          $less-than-comparator as function(item(), item()) as xs:boolean,
	                          $insert-helper
	                         )
	         {
	         if ($empty($tree)) then
	               (
	                     function() {$item}     (: root :),
	                     function() {()}            (: left :),
	                     function() {()}            (: right :)
	               )
	          else if ($less-than-comparator($item, $root($tree))) then
	               (
	                     function() {$root($tree)}                           	(: root :),

	                     function() {$insert-helper( $left($tree),
	                                                                     $item,
	                                                                     $less-than-comparator,
	                                                                     $insert-helper)
	                                        }   				(: left :),

	                     function() {$right($tree)}                          	(: right :)
	                )
	          else
	               (
	                     function() {$root($tree)}                          	(: root :),
	                     function() {$left($tree)}                           	(: left :),

	                     function() {$insert-helper( $right($tree),
	                                                                     $item,
	                                                                     $less-than-comparator,
	                                                                     $insert-helper)
	                                          }      				  (: right :)
	                )
	         },


         $insert :=
	         function ( $tree as function(*)*,
	                           $item as item(),
	                           $less-than-comparator as function(item(), item()) as xs:boolean
	                         )
	         {
	               $insert-helper($tree, $item, $less-than-comparator, $insert-helper)
	         },


         (:
             print() produces an XML document that represents the BST $tree.

             The XML document produced by  print()  consists of:
             1. A root element that represents the value of executing the root function.
             2. A left element that represents the value of print() on the left subtree
                (note the recursive definition).
             3. A right element that represents the value of print() on the right subtree
                (note the recursive definition).

            The $print-helper function produces the markup
             as a string and then the $printer function converts
             this string into an XML document by calling the  parse-xml() function.
         :)
         $print-helper :=
	         function ( $tree as function(*)*,
	                           $print-helper
	                          )
	                          as xs:string?
	         {
	         if (not($empty($tree))) then
	                 concat('&lt;tree&gt;',
	                                    '&lt;root&gt;',
	                                          $root($tree),
	                                    '&lt;/root&gt;',
	                                    '&lt;left&gt;',
	                                          $print-helper($left($tree),$print-helper),
	                                    '&lt;/left&gt;',
	                                    '&lt;right&gt;',
	                                          $print-helper($right($tree),$print-helper),
	                                    '&lt;/right&gt;',
	                            '&lt;/tree&gt;'
	                           )
	          else ()
	          },


         $print := function ($tree as function(*)*)
                         {parse-xml($print-helper($tree, $print-helper))/*},


         (:
             populate() produces a new tree from its BST argument $tree by inserting
             the value of the head() of the sequence $items onto $tree and then inserting
             the tail() of the sequence $items onto the result.
         :)
         $populate-helper :=
	         function ( $tree as function(*)*,
	                           $items as item()*,
	                           $less-than-comparator as function(item(), item()) as xs:boolean,
	                           $populate-helper
	                         )
	         {
	             if (empty($items)) then $tree
	             else
	                  $populate-helper( $insert($tree, $items[1], $less-than-comparator),
	                                                    $items[position() gt 1],
	                                                    $less-than-comparator,
	                                                    $populate-helper
	                                                  )
	         },


         $populate :=
	         function( $tree as function(*)*,
	                           $items as item()*,
	                           $less-than-comparator as function(item(), item()) as xs:boolean
	                         )
	         {$populate-helper($tree, $items, $less-than-comparator, $populate-helper)}

	  (: Finally, make the function libary :)
	 return
      map {'create'   := $create,
           'empty'    := $empty,

           'root'     := $root,
           'left'     := $left,
           'right'    := $right,

           'insert'   := $insert,

           'populate' := $populate,
           'print'    := $print,

           'numeric-less-than-comparator'     := $numeric-less-than-comparator
          }        </textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e610 e610"><emphasis class="po-inline e611 e611" role="bold"><textual class="po-textual">Here is the XSLT consuming code, that solves the bank
            transactions problem</textual></emphasis><textual class="po-textual">: </textual></para><para class="po-block e612 e612"><textual class="po-textual">
        </textual><programlisting class="po-block e613 e613" xml:space="preserve"><textual class="po-textual">
&lt;xsl:stylesheet version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
 &lt;xsl:output omit-xml-declaration="yes" indent="yes"/&gt;


 &lt;xsl:template match="node()|@*"&gt;

  &lt;!-- The Tree Function Library --&gt;
  &lt;xsl:variable name="vTree" as="map(*)"&gt;
    &lt;xsl:evaluate xpath="unparsed-text('XPathFunctionLibrary.xpath')"/&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:sequence select=
   "
        (:
           Finally, the solution of the original problem.
           Task: find all the bank transactions in the range 2012-03-15 to 2012-05-15.
         :)
    let $find-range-of-transactions-helper :=
	        function( $tree as function(*)*,
	                          $start-date as xs:date,
	                          $end-date as xs:date,
	                          $find-range-of-transactions-helper
	                )
	                as element(transaction)*
	        {
	            if (empty($tree)) then ()
	            else
	                if (xs:date($vTree('root')($tree)/@date) eq $start-date) then
	                     (
	                            $vTree('root')($tree),
	                            $find-range-of-transactions-helper
	                        		        ($vTree('right')($tree),
	                                   	 $start-date,
	                                     $end-date,
	                                     $find-range-of-transactions-helper)
	                     )
	                    else
	                        if (xs:date($vTree('root')($tree)/@date) eq $end-date) then
	                          (
	                                 $find-range-of-transactions-helper
	                             	            ($vTree('left')($tree),
	                                       	   $start-date,
	                                      	   $end-date,
	                                       	   $find-range-of-transactions-helper),
	                                 $vTree('root')($tree)
	                          )
	                        else
	                            if (
	                                (xs:date($vTree('root')($tree)/@date) gt $start-date)
	                                 and
	                                (xs:date($vTree('root')($tree)/@date) lt $end-date)) then
	                             (
	                                   $find-range-of-transactions-helper
	                                   		($vTree('left')($tree),
	                                       $start-date,
	                                       $end-date,
	                                       $find-range-of-transactions-helper),
	                                   $vTree('root')($tree),
	                                   $find-range-of-transactions-helper
	                                 		($vTree('right')($tree),
	                                   	 $start-date,
	                                   	 $end-date,
	                                   	 $find-range-of-transactions-helper)
	                             )
	                            else
	                                if (xs:date($vTree('root')($tree)/@date) lt $start-date) then
	                                 (
	                                    $find-range-of-transactions-helper
	                                      	               ($vTree('right')($tree),
	                                       	                $start-date,
	                                       	                $end-date,
	                                       	                $find-range-of-transactions-helper)
	                                 )
	                                else
	                                    if (xs:date($vTree('root')($tree)/@date) gt $end-date) then
	                                     (
	                                        $find-range-of-transactions-helper
                                          	            ($vTree('left')($tree),
                                           	             $start-date,
                                           	             $end-date,
                                           	             $find-range-of-transactions-helper)
	                                     )
	                                    else ()
	         },


         $find-range-of-transactions :=
	         function($tree as function(*)*,
	                          $start-date as xs:date,
	                          $end-date as xs:date
	                         )
	         {
	             $find-range-of-transactions-helper
	         		       ( $tree,
	               	         $start-date,
	                       	         $end-date,
	                       	         $find-range-of-transactions-helper)
	         },

        (:
            As tree-nodes are inserted into a BST, a comparison is made between
            the value being inserted and the value in the tree's root node. How should
            the comparison be done? That depends on the type of the data contained in a tree-node.
            Comparing two integers is different than comparing two tree fragments.
            So, the insert function must be provided with an appropriate comparator. For
            the case of bank transactions, a date comparison is needed.
            Here is an appropriate comparator function:
        :)
        $transaction-less-than-comparator :=
	        function( $arg1  as element(transaction),
	                          $arg2  as element(transaction)
	                        ) as xs:boolean
	        {
	              xs:date($arg1/@date) lt xs:date($arg2/@date)
	        }



    (:  At last, we finalize this big, outermost *let* clause with a *return* clause
        that expresses the intent of the users of the BST data-type.
        We want to get all transactions in the period:
        15th March 2012 to 15th May 2012.
    :)

      return (
              $find-range-of-transactions
                      ($vTree('populate')
                         ((), //transaction, $transaction-less-than-comparator),
                       xs:date('2012-03-15'),
                       xs:date('2012-05-15')
                      )
             )   "/&gt;
 &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;        </textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e614 e614"><emphasis class="po-inline e615 e615" role="bold"><textual class="po-textual">The BST XPath code -- as an XQuery module</textual></emphasis><textual class="po-textual"> (XPathFunctionLibrary.xpath)
            -- see how a </textual><emphasis class="po-inline e616 e616"><textual class="po-textual">map</textual></emphasis><textual class="po-textual"> is created in the return clause:</textual></para><para class="po-block e617 e617"><textual class="po-textual">
        </textual><programlisting class="po-block e618 e618" xml:space="preserve"><textual class="po-textual">
module namespace BST = "BST";

declare variable $BST:vTree :=

 let
         (:
             The purpose of create is to return an empty tree.

             It returns a sequence of functions,
                - the first function represents the root of a tree,
                - the second function represents the left subtree,
                - and the third function represents the right subtree.
             The value of each function is an empty sequence.
         :)
         $create := (
                                function() { () }      (: root :),
                                function() { () }      (: left :),
                                function() { () }      (: right :)
                            ),


         (:
             empty() returns a boolean value,
             indicating whether $tree is empty.

             $tree is empty in either of these two cases:
             1. $tree is the empty sequence (it doesn't contain any functions).
             2. $tree contains a sequence of three functions, but the first
                  function - representing the root - is empty (i.e., if you invoke the
                  first function it returns the empty sequence).
         :)
         $empty := function($tree as function(*)*)
                           {
                                empty($tree) or empty($tree[1]())
                           },


         (:
             root()returns the value of the root node.

             This function takes one argument, $tree. Since $tree
             is represented by a sequence of functions, returning the
             value of the root node actually means returning the value of
             the function that corresponds to the root node.

             If $tree is empty then the empty sequence is returned. Otherwise
             the *value* of executing the first function in $tree  is returned (recall
             that a tree is represented by a sequence of functions, the first
             function representing the root of the tree).

             Note: $tree[1] is the first function whereas
                        $tree[1]() is the *value* of executing the first function.
         :)
         $root := function($tree as function(*)*)
                        {
                              if ($empty($tree))
                                  then ()
                                  else $tree[1]()
                        },


         (:
             left()returns the left subtree.

             This function takes one argument, $tree. Since $tree is represented
             by a sequence of functions, returning the left subtree
             actually means returning the value of executing the function that corresponds
             to the left subtree.

             If $tree is empty then the empty sequence is returned. Otherwise
             the *value* of executing the second function in $tree is returned (recall
             that a tree is represented by a sequence of functions, the second
             function representing the left subtree).

             Note: $tree[2] is the second function whereas
                        $tree[2]() is the *value* of executing the second function.
         :)
         $left := function($tree as function(*)*)
                      {
                            if ($empty($tree)) then ()
                            else
                                  if ($empty($tree[2])) then ()
                                  else $tree[2]()
                      },


         (:
             right() returns the right subtree.

             This function takes one argument, $tree. Since $tree is represented
             by a sequence of functions, returning the right subtree actually
             means returning the value of executing the function that corresponds to the
             right subtree.

             If $tree is empty then the empty sequence is returned. Otherwise
             the *value* of executing the third function in $tree is returned (recall
             that a tree is represented by a sequence of functions, the third
             function representing the right subtree).
         :)
         $right := function($tree as function(*)*)
                        {
                              if ($empty($tree)) then ()
                             else
                                   if ($empty($tree[3])) then ()
                                   else $tree[3]()
                        },


         $numeric-less-than-comparator :=
	         function( $arg1 as xs:decimal,
	                           $arg2 as xs:decimal
	                         ) as xs:boolean
	         {
	               $arg1  lt   $arg2
	         },


         (:
             insert() takes a $tree (BST) and a $item and produces a new BST that is the result
             of inserting $item as a tree-node in $tree.  A BST is a persistent (functional) data-type.
             Insertions or deletions are never done “in place” – instead a new BST is produced.

             The new node is inserted at:
             - if $tree is empty then as root node.
             - if the value of $item is less than the value of  the root node then
               the new tree-node is inserted into the left subtree (note the recursive definition)
             - else the new tree-node is inserted into the right subtree (again note the recursive
               definition)

             Here are the steps taken if $tree is empty:
             - $item specified to be the result of  the  root function. That is, the root function,
               if invoked, it returns $item.
             - A left function is created such that, if invoked, will return an empty subtree.
             - A right function is created such that, if invoked, will return an empty subtree.

             The insert function is recursive. Recursion with anonymous functions requires
             a helper function as discussed before.
         :)
         $insert-helper :=
	         function( $tree as function(*)*,
	                          $item as item(),
	                          $less-than-comparator as function(item(), item()) as xs:boolean,
	                          $insert-helper
	                         )
	         {
	         if ($empty($tree)) then
	               (
	                     function() {$item}     (: root :),
	                     function() {()}            (: left :),
	                     function() {()}            (: right :)
	               )
	          else if ($less-than-comparator($item, $root($tree))) then
	               (
	                     function() {$root($tree)}                           	(: root :),

	                     function() {$insert-helper( $left($tree),
	                                                                     $item,
	                                                                     $less-than-comparator,
	                                                                     $insert-helper)
	                                        }   				(: left :),

	                     function() {$right($tree)}                          	(: right :)
	                )
	          else
	               (
	                     function() {$root($tree)}                          	(: root :),
	                     function() {$left($tree)}                           	(: left :),

	                     function() {$insert-helper( $right($tree),
	                                                                     $item,
	                                                                     $less-than-comparator,
	                                                                     $insert-helper)
	                                          }      				  (: right :)
	                )
	         },


         $insert :=
	         function ( $tree as function(*)*,
	                           $item as item(),
	                           $less-than-comparator as function(item(), item()) as xs:boolean
	                         )
	         {
	               $insert-helper($tree, $item, $less-than-comparator, $insert-helper)
	         },


         (:
             print() produces an XML document that represents the BST $tree.

             The XML document produced by  print()  consists of:
             1. A root element that represents the value of executing the root function.
             2. A left element that represents the value of print() on the left subtree
                (note the recursive definition).
             3. A right element that represents the value of print() on the right subtree
                (note the recursive definition).

            The $print-helper function produces the markup
             as a string and then the $printer function converts
             this string into an XML document by calling the  parse-xml() function.
         :)
         $print-helper :=
	         function ( $tree as function(*)*,
	                           $print-helper
	                          )
	                          as xs:string?
	         {
	         if (not($empty($tree))) then
	                 concat('&lt;tree&gt;',
	                                    '&lt;root&gt;',
	                                          $root($tree),
	                                    '&lt;/root&gt;',
	                                    '&lt;left&gt;',
	                                          $print-helper($left($tree),$print-helper),
	                                    '&lt;/left&gt;',
	                                    '&lt;right&gt;',
	                                          $print-helper($right($tree),$print-helper),
	                                    '&lt;/right&gt;',
	                            '&lt;/tree&gt;'
	                           )
	          else ()
	          },


         $print := function ($tree as function(*)*)
                         {parse-xml($print-helper($tree, $print-helper))/*},


         (:
             populate() produces a new tree from its BST argument $tree by inserting
             the value of the head() of the sequence $items onto $tree and then inserting
             the tail() of the sequence $items onto the result.
         :)
         $populate-helper :=
	         function ( $tree as function(*)*,
	                           $items as item()*,
	                           $less-than-comparator as function(item(), item()) as xs:boolean,
	                           $populate-helper
	                         )
	         {
	             if (empty($items)) then $tree
	             else
	                  $populate-helper( $insert($tree, $items[1], $less-than-comparator),
	                                                    $items[position() gt 1],
	                                                    $less-than-comparator,
	                                                    $populate-helper
	                                                  )
	         },


         $populate :=
	         function( $tree as function(*)*,
	                           $items as item()*,
	                           $less-than-comparator as function(item(), item()) as xs:boolean
	                         )
	         {$populate-helper($tree, $items, $less-than-comparator, $populate-helper)}

	  (: Finally, make the function libary :)
	 return
      map {'create'   := $create,
           'empty'    := $empty,

           'root'     := $root,
           'left'     := $left,
           'right'    := $right,

           'insert'   := $insert,

           'populate' := $populate,
           'print'    := $print,

           'numeric-less-than-comparator'     := $numeric-less-than-comparator
          }
;        </textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e619 e619"><emphasis class="po-inline e620 e620" role="bold"><textual class="po-textual">Here is the XQuery consuming code, that solves the bank
            transactions problem</textual></emphasis><textual class="po-textual">: </textual></para><para class="po-block e621 e621"><textual class="po-textual">
        </textual><programlisting class="po-block e622 e622" xml:space="preserve"><textual class="po-textual">
import module namespace bst="BST" at "XPathFunctionLibrary.xpath";

declare variable $vDoc := doc('transactions.xml');


  (: The Tree Function Library :)
        (:
           Finally, the solution of the original problem.
           Task: find all the bank transactions in the range 2012-03-15 to 2012-05-15.
         :)
    let $find-range-of-transactions-helper :=
	        function( $tree as function(*)*,
	                          $start-date as xs:date,
	                          $end-date as xs:date,
	                          $find-range-of-transactions-helper
	                )
	                as element(transaction)*
	        {
	            if (empty($tree)) then ()
	            else
	                if (xs:date($bst:vTree('root')($tree)/@date) eq $start-date) then
	                     (
	                            $bst:vTree('root')($tree),
	                            $find-range-of-transactions-helper
	                        		        ($bst:vTree('right')($tree),
	                                   	 $start-date,
	                                     $end-date,
	                                     $find-range-of-transactions-helper)
	                     )
	                    else
	                        if (xs:date($bst:vTree('root')($tree)/@date) eq $end-date) then
	                          (
	                                 $find-range-of-transactions-helper
	                             	            ($bst:vTree('left')($tree),
	                                       	   $start-date,
	                                      	   $end-date,
	                                       	   $find-range-of-transactions-helper),
	                                 $bst:vTree('root')($tree)
	                          )
	                        else
	                            if (
	                                (xs:date($bst:vTree('root')($tree)/@date) gt $start-date)
	                                 and
	                                (xs:date($bst:vTree('root')($tree)/@date) lt $end-date)) then
	                             (
	                                   $find-range-of-transactions-helper
	                                   		($bst:vTree('left')($tree),
	                                       $start-date,
	                                       $end-date,
	                                       $find-range-of-transactions-helper),
	                                   $bst:vTree('root')($tree),
	                                   $find-range-of-transactions-helper
	                                 		($bst:vTree('right')($tree),
	                                   	 $start-date,
	                                   	 $end-date,
	                                   	 $find-range-of-transactions-helper)
	                             )
	                            else
	                                if (xs:date($bst:vTree('root')($tree)/@date) lt $start-date) then
	                                 (
	                                    $find-range-of-transactions-helper
	                                      	               ($bst:vTree('right')($tree),
	                                       	                $start-date,
	                                       	                $end-date,
	                                       	                $find-range-of-transactions-helper)
	                                 )
	                                else
	                                    if (xs:date($bst:vTree('root')($tree)/@date) gt $end-date) then
	                                     (
	                                        $find-range-of-transactions-helper
                                          	            ($bst:vTree('left')($tree),
                                           	             $start-date,
                                           	             $end-date,
                                           	             $find-range-of-transactions-helper)
	                                     )
	                                    else ()
	         },


         $find-range-of-transactions :=
	         function($tree as function(*)*,
	                          $start-date as xs:date,
	                          $end-date as xs:date
	                         )
	         {
	             $find-range-of-transactions-helper
	         		       ( $tree,
	               	         $start-date,
	                       	         $end-date,
	                       	         $find-range-of-transactions-helper)
	         },

        (:
            As tree-nodes are inserted into a BST, a comparison is made between
            the value being inserted and the value in the tree's root node. How should
            the comparison be done? That depends on the type of the data contained in a tree-node.
            Comparing two integers is different than comparing two tree fragments.
            So, the insert function must be provided with an appropriate comparator. For
            the case of bank transactions, a date comparison is needed.
            Here is an appropriate comparator function:
        :)
        $transaction-less-than-comparator :=
	        function( $arg1  as element(transaction),
	                          $arg2  as element(transaction)
	                        ) as xs:boolean
	        {
	              xs:date($arg1/@date) lt xs:date($arg2/@date)
	        }



    (:  At last, we finalize this big, outermost *let* clause with a *return* clause
        that expresses the intent of the users of the BST data-type.
        We want to get all transactions in the period:
        15th March 2012 to 15th May 2012.
    :)

      return (
              $find-range-of-transactions
                      ($bst:vTree('populate')
                         ((), $vDoc//transaction, $transaction-less-than-comparator),
                       xs:date('2012-03-15'),
                       xs:date('2012-05-15')
                      )
             )        </textual></programlisting><textual class="po-textual">
      </textual></para></section><bibliography class="po-hcontainer e623 e623"><title class="po-block e624 e624"><textual class="po-textual">References:</textual></title><bibliomixed class="po-block e625 e625" xml:id="BST"><textual class="po-textual">
                    </textual><emphasis class="po-inline e626 e626"><textual class="po-textual">Binary Search Tree as defined by Wikipedia</textual></emphasis><textual class="po-textual">, 
                    at: </textual><link class="po-inline e627 e627" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Binary_search_tree" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        http://en.wikipedia.org/wiki/Binary_search_tree</textual></link><textual class="po-textual">
                </textual></bibliomixed><bibliomixed class="po-block e628 e628" xml:id="Closure"><textual class="po-textual">
                    </textual><emphasis class="po-inline e629 e629"><textual class="po-textual">Closure (computer science) -- Wikipedia</textual></emphasis><textual class="po-textual">, 
                    at: </textual><link class="po-inline e630 e630" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Binary_search_tree" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        http://en.wikipedia.org/wiki/Binary_search_tree</textual></link><textual class="po-textual">
                </textual></bibliomixed><bibliomixed class="po-block e631 e631" xml:id="Costello"><textual class="po-textual">
                    </textual><emphasis class="po-inline e632 e632"><textual class="po-textual">Pearls of XSLT and XPath 3.0 Design</textual></emphasis><textual class="po-textual">, 
                    at: </textual><link class="po-inline e633 e633" xlink:actuate="onRequest" xlink:href="http://www.xfront.com/Pearls-of-XSLT-and-XPath-3-0-Design.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        http://www.xfront.com/Pearls-of-XSLT-and-XPath-3-0-Design.pdf</textual></link><textual class="po-textual">
                </textual></bibliomixed><bibliomixed class="po-block e634 e634" xml:id="DivConq"><textual class="po-textual">
                    </textual><emphasis class="po-inline e635 e635"><textual class="po-textual">Divide and conquer algorithm -- Wikipedia</textual></emphasis><textual class="po-textual">, 
                    at: </textual><link class="po-inline e636 e636" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm</textual></link><textual class="po-textual">
                </textual></bibliomixed><bibliomixed class="po-block e637 e637" xml:id="FuncComp"><textual class="po-textual">
                    </textual><emphasis class="po-inline e638 e638"><textual class="po-textual">Function composition -- Wikipedia</textual></emphasis><textual class="po-textual">, 
                    at: </textual><link class="po-inline e639 e639" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Function_composition" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        http://en.wikipedia.org/wiki/Function_composition</textual></link><textual class="po-textual">
                </textual></bibliomixed><bibliomixed class="po-block e640 e640" xml:id="Nova"><textual class="po-textual">
                    </textual><emphasis class="po-inline e641 e641"><textual class="po-textual">Recursion with anonymous (inline) functions in XPath 3.0</textual></emphasis><textual class="po-textual">, 
                    at: </textual><link class="po-inline e642 e642" xlink:actuate="onRequest" xlink:href="http://dnovatchev.wordpress.com/2012/10/15/recursion-with-anonymous-inline-functions-in-xpath-3-0-2/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        http://dnovatchev.wordpress.com/2012/10/15/recursion-with-anonymous-inline-functions-in-xpath-3-0-2/</textual></link><textual class="po-textual">
                </textual></bibliomixed><bibliomixed class="po-block e643 e643" xml:id="HOF"><textual class="po-textual">
                    </textual><emphasis class="po-inline e644 e644"><textual class="po-textual">Higher-order function -- Wikipedia</textual></emphasis><textual class="po-textual">, 
                    at: </textual><link class="po-inline e645 e645" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Higher-order_function" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                        http://en.wikipedia.org/wiki/Higher-order_function</textual></link><textual class="po-textual">
                </textual></bibliomixed><bibliomixed class="po-block e646 e646" xml:id="Nova2"><textual class="po-textual">
                     </textual><emphasis class="po-inline e647 e647"><textual class="po-textual">Recursion with anonymous (inline) functions in XPath 3.0 — Part II</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e648 e648" xlink:actuate="onRequest" xlink:href="http://dnovatchev.wordpress.com/2013/04/08/recursion-with-anonymous-inline-functions-in-xpath-3-0-part-ii/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://dnovatchev.wordpress.com/2013/04/08/recursion-with-anonymous-inline-functions-in-xpath-3-0-part-ii/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e649 e649" xml:id="Nova3"><textual class="po-textual">
                     </textual><emphasis class="po-inline e650 e650"><textual class="po-textual">The Binary Search Tree Data Structure–having fun with XPath 3.0</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e651 e651" xlink:actuate="onRequest" xlink:href="http://dnovatchev.wordpress.com/2012/01/09/the-binary-search-tree-data-structurehaving-fun-with-xpath-3-0/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://dnovatchev.wordpress.com/2012/01/09/the-binary-search-tree-data-structurehaving-fun-with-xpath-3-0/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e652 e652" xml:id="PartApp"><textual class="po-textual">
                     </textual><emphasis class="po-inline e653 e653"><textual class="po-textual">Partial function application -- Wikipedia</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e654 e654" xlink:actuate="onRequest" xlink:href="http://rosettacode.org/wiki/Partial_function_application" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://rosettacode.org/wiki/Partial_function_application</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e655 e655" xml:id="Recurs"><textual class="po-textual">
                     </textual><emphasis class="po-inline e656 e656"><textual class="po-textual">Recursion (computer science) -- Wikipedia</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e657 e657" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_functions_and_algorithms" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_functions_and_algorithms</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e658 e658" xml:id="Saxon"><textual class="po-textual">
                     </textual><emphasis class="po-inline e659 e659"><textual class="po-textual">The Saxon XSLT/XQuery/XPath Processor</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e660 e660" xlink:actuate="onRequest" xlink:href="http://www.saxonica.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.saxonica.com</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e661 e661" xml:id="Snelson"><textual class="po-textual">
                     </textual><emphasis class="po-inline e662 e662"><textual class="po-textual">Adding Recursive Inline Functions to XQuery 1.1 and XPath 2.1</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e663 e663" xlink:actuate="onRequest" xlink:href="http://john.snelson.org.uk/adding-recursive-inline-function-to-xquery-11" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://john.snelson.org.uk/adding-recursive-inline-function-to-xquery-11</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e664 e664" xml:id="Snelson2"><textual class="po-textual">
                     </textual><emphasis class="po-inline e665 e665"><textual class="po-textual">W3C Bugzilla: Bug 8662 - [XQ31ReqUC] Requirement: Recursive inline functions </textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e666 e666" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=8662" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         https://www.w3.org/Bugs/Public/show_bug.cgi?id=8662</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e667 e667" xml:id="TailCall"><textual class="po-textual">
                     </textual><emphasis class="po-inline e668 e668"><textual class="po-textual">Tail call -- Wikipedia</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e669 e669" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Tail_call" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://en.wikipedia.org/wiki/Tail_call</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e670 e670" xml:id="Walmsley"><textual class="po-textual">
                     </textual><emphasis class="po-inline e671 e671"><textual class="po-textual">FunctX XSLT 2.0 and XQuery 1.0 Function Libraries</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e672 e672" xlink:actuate="onRequest" xlink:href="http://www.functx.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.functx.com/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e673 e673" xml:id="XDM3.0"><textual class="po-textual">
                     </textual><emphasis class="po-inline e674 e674"><textual class="po-textual">XQuery and XPath Data Model 3.0</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e675 e675" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.w3.org/TR/xpath-datamodel-30/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e676 e676" xml:id="XPath1.0"><textual class="po-textual">
                     </textual><emphasis class="po-inline e677 e677"><textual class="po-textual">XML Path Language (XPath) Version 1.0</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e678 e678" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.w3.org/TR/xpath/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e679 e679" xml:id="XPath2.0"><textual class="po-textual">
                     </textual><emphasis class="po-inline e680 e680"><textual class="po-textual">XML Path Language (XPath) 2.0 (Second Edition)</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e681 e681" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath20/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.w3.org/TR/xpath20/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e682 e682" xml:id="XPath3.0"><textual class="po-textual">
                     </textual><emphasis class="po-inline e683 e683"><textual class="po-textual">XML Path Language (XPath) 3.0</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e684 e684" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.w3.org/TR/xpath-30/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e685 e685" xml:id="XSLT1.0"><textual class="po-textual">
                     </textual><emphasis class="po-inline e686 e686"><textual class="po-textual">XSL Transformations (XSLT) Version 1.0</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e687 e687" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.w3.org/TR/xslt</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e688 e688" xml:id="XSLT2.0"><textual class="po-textual">
                     </textual><emphasis class="po-inline e689 e689"><textual class="po-textual">XSL Transformations (XSLT) Version 2.0</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e690 e690" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt20/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.w3.org/TR/xslt20/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e691 e691" xml:id="XSLT3.0"><textual class="po-textual">
                     </textual><emphasis class="po-inline e692 e692"><textual class="po-textual">XSL Transformations (XSLT) Version 3.0</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e693 e693" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.w3.org/TR/xslt-30/</textual></link><textual class="po-textual">
                 </textual></bibliomixed><bibliomixed class="po-block e694 e694" xml:id="XQuery1.0"><textual class="po-textual">
                     </textual><emphasis class="po-inline e695 e695"><textual class="po-textual">XQuery 1.0: An XML Query Language (Second Edition)</textual></emphasis><textual class="po-textual">, 
                     at: </textual><link class="po-inline e696 e696" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery/" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                         http://www.w3.org/TR/xquery/</textual></link><textual class="po-textual">
                 </textual></bibliomixed></bibliography></article></classedDocument>