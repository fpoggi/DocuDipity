<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">A practical introduction to EXPath</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Collaboratively Defining Open Standards for Portable XPath Extensions</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2009</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 11 - 14, 2009</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">For some time now the demand for standardized extensions within the core XML
            technologies, especially XSLT and XQuery, has been increasing. A closer look at the
            EXSLT and EXQuery projects shows that their goals align to address the issue of
            extensions, but also that they overlap, predominantly because of their common ancestor:
            XPath. It is thus reasonable to assume that both projects should collaborate together on
            common areas influenced by the underlying XPath specification. In addition, by jointly
            working at the lower level, any XPath based language or processor could also benefit
            from this work, like XProc, XForms or plain XPath engines.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Florent</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Georges</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Florent Georges is a freelance IT consultant in Brussels who has been involved in
               the XML world for 10 years, especially within the XSLT and XQuery communities. His
               main interests are in the field of XSLT and XQuery extensions and libraries,
               packaging, unit and functional testing, and portability between several processors.
               Since the beginning of 2009, he has worked on EXPath, to define "standard" extension
               function libraries that can be used in XPath (so in XSLT, XQuery and XProc as
               well).</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">XML Architect</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">fgeorges.org</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">fgeorges@fgeorges.org</textual></email></author><legalnotice class="po-container e19 e19"><para class="po-block e20 e20"><textual class="po-textual">Copyright Â© 2009 Florent Georges. Used by permission.</textual></para></legalnotice><keywordset class="po-table e21 e21" role="author"><keyword class="po-field e22 e22"><textual class="po-textual">EXPath</textual></keyword><keyword class="po-field e23 e23"><textual class="po-textual">extension</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">XPath</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">XSLT</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">XQuery</textual></keyword></keywordset></info><section class="po-hcontainer e27 e27"><title class="po-block e28 e28"><textual class="po-textual">Introduction</textual></title><para class="po-block e29 e29"><textual class="po-textual">XPath is a textual language to query XML content. Besides a very convenient way to
         navigate within an XML document through a path system, it provides the ability to make
         various kinds of computation, for example string manipulations or date and time processing.
         Such features are provided as functions, defined in a separate recommendation detailing a
         standard library. It is also possible to use additional defined functions; XSLT and XQuery
         allow one to define new functions directly in the stylesheet or query module. An XPath
         processor also usually provides implementation specific libraries of additional functions,
         as well as a way to augment the set of available functions, these are typically written
         using an API in the same language as the processor.</textual></para><para class="po-block e30 e30"><textual class="po-textual">This leads to the concept of an extension function. Such a function is not defined by
         XPath, but inspired by XSLT this is defined as any function available in an expression
         although not defined in any recommendation. There are two major kinds of extension
         functions: those provided by the processor itself, and those written by the user. A
         processor can provide extensions to deal with database management for instance, and the
         user can implement any processing he could not write in XPath directly (for instance using
         a complex mathematical library available in Java.) Examples of possible useful extensions
         could provide support for performing HTTP requests, using WebDAV, reading and writing ZIP
         files (like EPUB eBook, Open XML and OpenDocument files,) parsing and serializing XML and
         HTML documents, executing XSLT transforms and XQuery queries, etc.</textual></para><para class="po-block e31 e31"><textual class="po-textual">Extension functions are very powerful ways to extend XPath functionality. Many
         extensions have been written over the years and by many different people. Reflecting on
         this, it appears almost impossible to create and then share an extension function among
         several processors and to maintain interoperability with them all over time. Extension
         functions provided by processors themselves are not compatible, so that an expression that
         uses them is not portable between processors. It is that situation which has led to the
         creation of a project that would define libraries of extension functions unrelated to any
         single processor, allowing existing processors to choose to implement them natively, or
         allowing a user to install an existing implementation as an external package in their
         processor. In this way it becomes possible to use extension functions already defined and
         implemented, and if not more importantly, to write expressions that become portable across
         every processor that supports the extension or that an implementation was pre-provided
         for.</textual></para><para class="po-block e32 e32"><textual class="po-textual">This project is </textual><link class="po-inline e33 e33" xlink:actuate="onRequest" xlink:href="http://www.expath.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">EXPath</textual></link><textual class="po-textual">!</textual></para></section><section class="po-hcontainer e34 e34"><title class="po-block e35 e35"><textual class="po-textual">The project</textual></title><para class="po-block e36 e36"><textual class="po-textual">EXPath was launched four months ago in April 2009. It is divided into several modules,
         quite independent from each other. The module is the delivery unit of EXPath. It is a
         consistent set of functions providing support for a particular domain, and can be viewed as
         a specific library of functions. Besides the specification of the functions itself,
         implementations can also be provided for various processors. The first module that has been
         defined is the HTTP Client. It provides support to send HTTP requests and to handle the
         responses. This module defines one single function, how it represents a HTTP request and
         response as XML elements and how it can be used to perform requests. Implementations are
         provided as open source packages via the website for a number of processors - Saxon, eXist
         and MarkLogic.</textual></para><para class="po-block e37 e37"><textual class="po-textual">If there is a need for new extension functions to address missing functionality, a new
         module may be proposed by anyone with the help of other people interested in supporting the
         same features. The first step in this process is to identify precise use cases for the
         desired features, and describe examples of use; this sets the scope of the module and sets
         us on the road to defining specifications. Of course the scope can evolve over time, as
         well as the use case examples, but this gives a formal basis for further discussion.</textual></para><para class="po-block e38 e38"><textual class="po-textual">Once the use cases have been identified, function signatures and definitions of
         behaviour for the module must be proposed. That proposal is discussed among the community
         through the mailing list, and people interested in this module help to solve issues and
         improve its design. Extensions addressing the same problem might already exist, either as
         part of a known processor, or developed as independent individual projects; this is
         valuable material to learn from during this stage. In parallel with this definition, it is
         encouraged to develop at least one implementation to validate the feasibility of what is
         being specified. Before being officially endorsed as a module, at least two implementations
         should have been provided, to ensure that the specification is not too tightly linked to a
         particular processor.</textual></para><para class="po-block e39 e39"><textual class="po-textual">Each module has its own maintainer who is responsible for editing the specification,
         leading the discussions and making design choices in according to those discussions.
         Similarly, every implementation of a module for a particular processor has its own
         maintainer. If someone needs the module to be implemented for another processor, they may
         volunteer for that work, and propose an implementation. A test suite for the module should
         be provided and carefully designed to ensure every implementation provides the same
         functionality. The vendor of a processor might also propose a native implementation of a
         module, in which case responsibility for the implementation and ensuring it meets the
         specification and tests lies with the vendor.</textual></para><para class="po-block e40 e40"><textual class="po-textual">An interesting point about implementing a module is when a processor already provides a
         similar feature through processor-specific extension functions. It may then be sometimes
         possible to reuse the existing extensions through a lightweight wrapper exposing the EXPath
         interface to the user. For instance, the HTTP Client has been implemented for MarkLogic
         Server with an XQuery module using MarkLogic's own HTTP Client set of extension functions.
         This example also shows the limitations of this approach: the implementation is only
         partial, as the MarkLogic's extensions do not provide exactly all the possibilities
         required by the EXPath HTTP Client module. It is thus not always possible to use this
         technique to provide full conformance, but this is a convenient way to quickly provide a
         (possibly partial) implementation.</textual></para><para class="po-block e41 e41"><textual class="po-textual">Needless to say, lots of work needs to be done, and everyone is welcome to help, at
         every level: writing specifications, writing documentation and tutorials, peer review,
         discussion, coding, testing or simply using the extensions and providing feedback.</textual></para><para class="po-block e42 e42"><textual class="po-textual">But let's call it a day on the theory, and let's examine some real examples using two
         modules: the HTTP Client and ZIP modules.</textual></para></section><section class="po-hcontainer e43 e43"><title class="po-block e44 e44"><textual class="po-textual">Two example modules</textual></title><para class="po-block e45 e45"><textual class="po-textual">Before going through the examples, here is a simple introduction to the modules. The
         HTTP Client module, without any surprise, provides the ability to send HTTP requests and
         handle the responses. The ZIP module provides ZIP files support, either to extract entries
         from them, add new entries, or update entries in existing ZIP files.</textual></para><para class="po-block e46 e46"><textual class="po-textual">The HTTP Client provides one single function: </textual><code class="po-atom e47 e47"><textual class="po-textual">http:send-request</textual></code><textual class="po-textual"> (actually
         it defines four different arities for this function, but this is mainly a convenient way to
         pass some values as separate parameters.) This function has been inspired by the
         corresponding XProc step, </textual><code class="po-atom e48 e48"><textual class="po-textual">p:http-request</textual></code><textual class="po-textual">. This function makes it possible to
         query REST services, Google services, Web services through SOAP, or simply to retrieve
         resources on the Web. The signature of this function (the one-parameter version) is:</textual></para><programlisting class="po-block e49 e49" xml:space="preserve"><textual class="po-textual">http:send-request($request as element(http:request)) as item()+</textual></programlisting><para class="po-block e50 e50"><textual class="po-textual">Its parameter is an element representing the request. It is structured as in the
         following sample:</textual></para><programlisting class="po-block e51 e51" xml:space="preserve"><textual class="po-textual">&lt;http:request href="http://www.example.com/..." method="post"&gt;
   &lt;http:header name="X-Header" value="some value"/&gt;
   &lt;http:header name="X-Other"  value="other value"/&gt;
   &lt;http:body content-type="application/xml"&gt;
      &lt;hello&gt;World!&lt;/hello&gt;
   &lt;/http:body&gt;
&lt;/http:request&gt;</textual></programlisting><para class="po-block e52 e52"><textual class="po-textual">The request will result in a HTTP POST, with Content-Type </textual><code class="po-atom e53 e53"><textual class="po-textual">application/xml</textual></code><textual class="po-textual">,
         sent to the specified URI and with a header explicitly set by the user (</textual><code class="po-atom e54 e54"><textual class="po-textual">X-Header:
            some value</textual></code><textual class="po-textual">.) The result is described with another element,
            </textual><code class="po-atom e55 e55"><textual class="po-textual">http:response</textual></code><textual class="po-textual">, that describes the response returned by the server:</textual></para><programlisting class="po-block e56 e56" xml:space="preserve"><textual class="po-textual">&lt;http:response status="200" message="OK"&gt;
   &lt;http:header name="..." value="..."/&gt;
   ...
   &lt;http:body content-type="application/xml"/&gt;
&lt;/http:request&gt;</textual></programlisting><para class="po-block e57 e57"><textual class="po-textual">The structure of this element is not dissimilar to the request element, instead of the
         URI and HTTP method, it contains the status code and the message returned by the server.
         One significant difference as opposed to the request, lies in the way in which the response
         body is returned: the response body element (if any) is only a description of the body. The
         body content itself is returned as a subsequent item in the result sequence (or several
         items in case of a multipart response.) Let's analyse an example in XQuery:</textual></para><programlisting class="po-block e58 e58" xml:space="preserve"><textual class="po-textual">http:send-request(
   &lt;http:request href="http://www.balisage.net/" method="get"/&gt;)</textual></programlisting><para class="po-block e59 e59"><textual class="po-textual">This simply sends a GET request to the web server of Balisage. The result of this
         function call is a sequence of two items: the </textual><code class="po-atom e60 e60"><textual class="po-textual">http:result</textual></code><textual class="po-textual"> element and the body
         content as a document node (holding an XHTML document):</textual></para><programlisting class="po-block e61 e61" xml:space="preserve"><textual class="po-textual">&lt;http:response status="200" message="OK"&gt;
   &lt;http:header name="Server" value="Apache/1.3.41 (Unix)"/&gt;
   ...
   &lt;http:body content-type="text/html"/&gt;
&lt;/http:response&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
   &lt;head&gt;
      &lt;title&gt;Balisage: The Markup Conference&lt;/title&gt;
      ...</textual></programlisting><para class="po-block e62 e62"><textual class="po-textual">It may sound strange to have a sequence as the result of the function, but this is the
         only way to provide the response description alongside the payload expressed as a full
         document node. This design choice prevents mixing different layers in the same document.
         The body content is analysed based on the content-type returned by the server. If the
         content type is of an XML type it is parsed and returned as a document node, if it is an
         HTML type it is tidied up, parsed and returned as a document node, if it is a textual type
         it is returned as a string, in any other case it is returned as a
            </textual><code class="po-atom e63 e63"><textual class="po-textual">xs:base64Binary</textual></code><textual class="po-textual"> item. In the case of a multipart response this rule is
         applied to each part which is then returned as subsequent items after the
            </textual><code class="po-atom e64 e64"><textual class="po-textual">http:response</textual></code><textual class="po-textual"> element.</textual></para><para class="po-block e65 e65"><textual class="po-textual">The ZIP module defines the following functions to read the structure of a ZIP file, to
         create a completely new ZIP file from scratch, and to create a new ZIP file, based on an
         existing file by changing only some entries:</textual></para><programlisting class="po-block e66 e66" xml:space="preserve"><textual class="po-textual">zip:entries($href) as element(zip:file)
zip:zip-file($zip as element(zip:file)) as empty-sequence()
zip:update-entries($zip, $output) as empty-sequence()</textual></programlisting><para class="po-block e67 e67"><textual class="po-textual">The first function takes a ZIP file's URI as parameter, and returns a description of its
         structure (its entries) as a </textual><code class="po-atom e68 e68"><textual class="po-textual">zip:file</textual></code><textual class="po-textual"> element. This element looks like the
         following:</textual></para><programlisting class="po-block e69 e69" xml:space="preserve"><textual class="po-textual">&lt;zip:file href="some.zip"&gt;
   &lt;zip:entry name="file.xml"/&gt;
   &lt;zip:entry name="index.html"/&gt;
   &lt;zip:dir name="dir"&gt;
      &lt;zip:entry name="file.txt"/&gt;
   &lt;/zip:dir&gt;
&lt;/zip:file&gt;</textual></programlisting><para class="po-block e70 e70"><textual class="po-textual">Only the structure is returned, not the whole content of each file entry. The function
            </textual><code class="po-atom e71 e71"><textual class="po-textual">zip:zip-file()</textual></code><textual class="po-textual"> takes a similar element as parameter, and create a new ZIP
         file based on that content. The element is similar, but in addition it contains the content
         of each file entry, so that the function has all the needed information to actually create
         the whole file. For each </textual><code class="po-atom e72 e72"><textual class="po-textual">zip:entry</textual></code><textual class="po-textual">, the content of the element can be an XML
         document, a string, or binary encoded as a base 64 string (an attribute tells if the
         content has to be serialized as XML, HTML, text or binary.) An existing file can also be
         copied verbatim to the entry, by giving its URI instead of the actual content. An example
         of a </textual><code class="po-atom e73 e73"><textual class="po-textual">zip:file</textual></code><textual class="po-textual"> element to pass to this function is:</textual></para><programlisting class="po-block e74 e74" xml:space="preserve"><textual class="po-textual">&lt;zip:file href="some.zip"&gt;
   &lt;zip:entry name="file.xml" output="xml"&gt;
      &lt;hello&gt;World!&lt;/hello&gt;
   &lt;/zip:entry&gt;
   &lt;zip:entry name="index.html" href="/some/file.html"/&gt;
   &lt;zip:dir name="dir"&gt;
      &lt;zip:entry name="file.txt" output="text"&gt;
         Hello, world!
      &lt;/zip:entry&gt;
   &lt;/zip:dir&gt;
&lt;/zip:file&gt;</textual></programlisting><para class="po-block e75 e75"><textual class="po-textual">The third function, </textual><code class="po-atom e76 e76"><textual class="po-textual">zip:update-entries()</textual></code><textual class="po-textual"> looks a lot like
            </textual><code class="po-atom e77 e77"><textual class="po-textual">zip:zip-file()</textual></code><textual class="po-textual">, but it uses an existing ZIP file to create a new one,
         replacing the entries in the </textual><code class="po-atom e78 e78"><textual class="po-textual">zip:file</textual></code><textual class="po-textual"> element in parameter. It then becomes
         possible to use a pattern file, replacing only a few entries, with content computed in this
         expression. To be complete, the module also provides 4 functions to read one specific entry
         from an existing ZIP file, for instance depending on the result of
            </textual><code class="po-atom e79 e79"><textual class="po-textual">zip:entries()</textual></code><textual class="po-textual">. They return either a document node, a string or a
            </textual><code class="po-atom e80 e80"><textual class="po-textual">xs:base64Binary</textual></code><textual class="po-textual"> item, following the same rules as
            </textual><code class="po-atom e81 e81"><textual class="po-textual">http:send-request()</textual></code><textual class="po-textual">:</textual></para><programlisting class="po-block e82 e82" xml:space="preserve"><textual class="po-textual">zip:xml-entry($href, $entry) as document-node()
zip:html-entry($href, $entry) as document-node()
zip:text-entry($href, $entry) as xs:string
zip:binary-entry($href, $entry) as xs:base64Binary</textual></programlisting></section><section class="po-hcontainer e83 e83"><title class="po-block e84 e84"><textual class="po-textual">SOAP Web service client</textual></title><para class="po-block e85 e85"><textual class="po-textual">EXPath works at the XPath level. But XPath is never used standalone, it is always used
         from within a host language. Among the various languages providing support for XPath, XSLT
         and XQuery have a place of choice, by their close integration with XPath. We will thus use
         XQuery and XSLT to demonstrate complete examples of the functions introduced earlier.
         XQuery's ability to create elements directly within expressions allows for very concise
         examples that are easier to understand. However, where transforming XML trees is fully part
         of the example, XSLT is used instead.</textual></para><para class="po-block e86 e86"><textual class="po-textual">The first sample consumes a SOAP Web service. The Web service takes as input an element
         with a country code and a city name. It returns an element with a corresponding place name
         and the local short term weather forecast. The format of the request and response elements
         is as follows:</textual></para><programlisting class="po-block e87 e87" xml:space="preserve"><textual class="po-textual">&lt;tns:weather-by-city-request&gt;
   &lt;tns:city&gt;Montreal&lt;/tns:city&gt;
   &lt;tns:country&gt;CA&lt;/tns:country&gt;
&lt;/tns:weather-by-city-request&gt;

&lt;tns:weather-by-city-response&gt;
   &lt;tns:place&gt;Montreal, CA&lt;/tns:place&gt;
   &lt;tns:detail&gt;
      &lt;tns:day&gt;2009-08-13&lt;/tns:day&gt;
      &lt;tns:min-temp&gt;16&lt;/tns:min-temp&gt;
      &lt;tns:max-temp&gt;26&lt;/tns:max-temp&gt;
      &lt;tns:desc&gt;Ideal temperature for a conference.&lt;/tns:desc&gt;
   &lt;/tns:detail&gt;
   &lt;tns:detail&gt;
   ...
&lt;/tns:weather-by-city-response&gt;</textual></programlisting><para class="po-block e88 e88"><textual class="po-textual">Thus, the XQuery module has to send a SOAP request to the Web service HTTP endpoint,
         check any error conditions and then if everything went well, process the result content.
         These steps fit naturally into three different functions defined within the XQuery module.
         After a few declarations (importing the HTTP Client module, declaring namespaces and
         variables,) the three functions are defined and then composed together:</textual></para><programlisting class="po-block e89 e89" xml:space="preserve"><textual class="po-textual">xquery version "1.0";

import module namespace http = "http://www.expath.org/mod/http-client";

declare namespace soap = "http://schemas.xmlsoap.org/soap/envelope/";
declare namespace tns  = "http://www.webservicex.net";

declare variable $endpoint as xs:string
   := "http://www.webservicex.net/WeatherForecast.asmx";
declare variable $soap-action as xs:string
   := "http://www.webservicex.net/GetWeatherByPlaceName";

(: Send the message to the Web service.
 :)
declare function local:send-message()
      as item()+
{
   http:send-request(
      &lt;http:request method="post" href="{ $endpoint }"&gt;
         &lt;http:header name="SOAPAction" value="{ $soap-action }"/&gt;
         &lt;http:body content-type="text/xml"&gt;
            &lt;soap:Envelope&gt;
               &lt;soap:Header/&gt;
               &lt;soap:Body&gt;
                  &lt;tns:weather-by-city-request&gt;
                     &lt;tns:city&gt;Montreal&lt;/tns:city&gt;
                     &lt;tns:country&gt;CA&lt;/tns:country&gt;
                  &lt;/tns:weather-by-city-request&gt;
               &lt;/soap:Body&gt;
            &lt;/soap:Envelope&gt;
         &lt;/http:body&gt;
      &lt;/http:request&gt;
   )
};

(: Extract the SOAP payload from the HTTP response.
 : Perform some sanity checks.
 :)
declare function local:extract-payload($res as item()+)
      as element(tns:weather-by-city-response)
{
   let $status := xs:integer($res[1]/@status)
   let $weather := $res[2]/soap:Envelope/soap:Body/*
      return
         if ( $status ne 200 ) then
            error(xs:QName('ERRSOAP001'),
                  concat('HTTP error: ', $status, '-', $res[1]/@message))
         else if ( empty($weather) ) then
            error(xs:QName('ERRSOAP002'), "SOAP payload is empty?")
         else
            $weather
};

(: Format the Web service response to a textual list.
 :)
declare function local:format-result(
            $weather as element(tns:weather-by-city-response))
      as xs:string
{
   string-join((
      'Place: ', $weather/tns:place, '&amp;#10;',
      for $d in $weather/tns:detail return $d/concat(
         '  - ', tns:day, ':&amp;#09;', tns:min-temp, ' - ',
         tns:max-temp, ':&amp;#09;', tns:desc, '&amp;#10;'
      )
    ),
   '')
};

(: The main query, orchestrating the request, extracting and
 : formating the response.
 :)
let $http-res := local:send-message()
let $payload  := local:extract-payload($http-res)
   return
      local:format-result($payload)</textual></programlisting><para class="po-block e90 e90"><textual class="po-textual">If everything goes well, the result should look like the following:</textual></para><programlisting class="po-block e91 e91" xml:space="preserve"><textual class="po-textual">Place: Montreal, CA
  - 2009-08-13:  16 - 26:  Ideal temperature for a conference
  - 2009-08-14:  24 - 32:  Enjoy holidays
  ...</textual></programlisting><para class="po-block e92 e92"><textual class="po-textual">This simple example shows a client call to a SOAP Web service. Given that such Web
         services are usually described by a WSDL service description, it is actually possible to
         automatically generate something like the previous example, but once for all operations
         described in the WSDL. This has been implemented in the WSDL Compiler, an XSLT stylesheet
         that transforms a WSDL file into an XSLT stylesheet or an XQuery module which can then be
         used as a library module. As each WSDL operation becomes a function, the XPath processor
         actually checks at compile time that the namespace URI, function name and parameters are
         correct. Here is the same example but using the module generated by this WSDL
         compiler:</textual></para><programlisting class="po-block e93 e93" xml:space="preserve"><textual class="po-textual">(: The module generated by the WSDL compiler.
:)
import module namespace tns = "http://www.webservicex.net" at "weather.xq";

(: The main query call the Web service like a function, passing
 : directly its parameters and using its result.
 :)
local:format-result(
   tns:weather-by-city(
      &lt;tns:weather-by-city-request&gt;
         &lt;tns:city&gt;Montreal&lt;/tns:city&gt;
         &lt;tns:country&gt;CA&lt;/tns:country&gt;
      &lt;/tns:weather-by-city-request&gt;
   )
)</textual></programlisting><para class="po-block e94 e94"><textual class="po-textual">All the HTTP and SOAP details have been hidden, and calling the Web service looks
         exactly like using a library module. Technically speaking, this is the case: only that
         module uses the HTTP extension and has been generated from the WSDL file, so that it knows
         how to communicate with the Web service.</textual></para></section><section class="po-hcontainer e95 e95"><title class="po-block e96 e96"><textual class="po-textual">Compound Document Template pattern</textual></title><para class="po-block e97 e97"><textual class="po-textual">This section introduces a new design pattern to generate compound documents based on the
         ZIP format, such as OpenDocument or Open XML, by using a template file. It is particularly
         well-suited to file generation based on transformations from data-oriented document to ODF
         for presentation purpose. Let us take a concrete example, transforming a simple contact
         list to an OpenDocument (ODF) text file (I use ODF as an example here, but the pattern
         could equally applied to other similar formats.) A typical transform of an input
         data-oriented document to an OpenDocument </textual><code class="po-atom e98 e98"><textual class="po-textual">content.xml</textual></code><textual class="po-textual"> file can be represented
         by the following workflow (by which a contact list is transformed to ODF using XPath
         technologies, for instance an XSLT stylesheet):</textual></para><para class="po-block e99 e99"><textual class="po-textual">
         </textual><mediaobject class="po-container e100 e100"><imageobject class="po-container e101 e101"><imagedata class="po-meta e102 e102" fileref="../../../vol3/graphics/Georges01/Georges01-001.png" format="png" width="99%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><textual class="po-textual">
      </textual></para><para class="po-block e103 e103"><textual class="po-textual">The </textual><code class="po-atom e104 e104"><textual class="po-textual">content.xml</textual></code><textual class="po-textual"> file is just one file in a whole ODF document. Such a
         document is actually a ZIP file, containing several XML files (the structure of the ZIP
         file in a manifest, the several styles used in other parts, the content...) among other
         files (for instance pictures in an OpenDocument Text file.) For instance, a typical ODF
         text document could have a structure like the following (if you open it as a ZIP
         file):</textual></para><programlisting class="po-block e105 e105" xml:space="preserve"><textual class="po-textual">mimetype
content.xml
styles.xml
meta.xml
settings.xml
Thumbnails/
META-INF/
   manifest.xml
Pictures/
   d9e69.map.gif
   d9e80.map.gif
   d9e82.photo.png</textual></programlisting><para class="po-block e106 e106"><textual class="po-textual">So the above transformation requires some post-processing to create the ZIP file that
         bundles all those files into a proper ODF document. In addition, some files depend on the
         way </textual><code class="po-atom e107 e107"><textual class="po-textual">content.xml</textual></code><textual class="po-textual"> is generated (for instance the style names it uses) even if
         they could be seen as static files. ODF is a comprehensive and quite complex specification,
         and it could rapidly become complicated to deal with all of its aspects while generating a
         simple text document. This pattern simplifies this by allowing one to create a template
         document using an application like Open Office. In this specific example, this is as simple
         as creating a table, with several columns, where each line is a contact. By using Open
         Office, we can set up all the layout visually, and create one single contact in the table.
         The transform will then extract </textual><code class="po-atom e108 e108"><textual class="po-textual">content.xml</textual></code><textual class="po-textual"> from the template file, copy it
         identically except for the fake contact line that will be used as a template for each
         contact in the input contact list. Then the result is used to create a new ZIP file, based
         on the template file, where all entries are copied except </textual><code class="po-atom e109 e109"><textual class="po-textual">content.xml</textual></code><textual class="po-textual">, which
         is replaced by the result of the transform. The general diagram for this pattern is:</textual></para><para class="po-block e110 e110"><textual class="po-textual">
         </textual><mediaobject class="po-container e111 e111"><imageobject class="po-container e112 e112"><imagedata class="po-meta e113 e113" fileref="../../../vol3/graphics/Georges01/Georges01-002.png" format="png" width="99%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><textual class="po-textual">
      </textual></para><para class="po-block e114 e114"><textual class="po-textual">There are several possible variants: the transform could read some entries from the
         template file, or not; it can generate several different entries or just the main content
         file... But the important point is to be able to create and maintain the overall structure
         and the layout details from within end-user applications for one ZIP-and-XML based format,
         and then to be able to use this template and just fill in the blanks with actual data. Here
         is how the last step (creating a new ZIP file based on the template file by updating some
         entries) can be implemented in XSLT:</textual></para><programlisting class="po-block e115 e115" xml:space="preserve"><textual class="po-textual">&lt;xsl:param name="content" as="element(office:document-content)"/&gt;

&lt;xsl:variable name="desc" as="element(zip:file)"&gt;
   &lt;zip:file href="template.odt"&gt;
      &lt;zip:entry name="content.xml" output="xml"&gt;
         &lt;xsl:sequence select="$content"/&gt;
      &lt;/zip:entry&gt;
   &lt;/zip:file&gt;
&lt;/xsl:variable&gt;

&lt;xsl:sequence select="zip:update-entries($desc, 'result.odt')"/&gt;</textual></programlisting><para class="po-block e116 e116"><textual class="po-textual">This ability to manipulate ZIP files opens up several possibilities with ODF.
         Spreadsheets or text documents could for instance be used directly from within XSLT
         stylesheets or XQuery modules as a natural human front-end for data input. But let us
         examine a simpler transformation from a contact list to a text document.</textual></para></section><section class="po-hcontainer e117 e117"><title class="po-block e118 e118"><textual class="po-textual">Google Contacts to ODF</textual></title><para class="po-block e119 e119"><textual class="po-textual">Using the </textual><code class="po-atom e120 e120"><textual class="po-textual">http:send-request()</textual></code><textual class="po-textual"> extension (introduced above) it is possible
         to access Google's Data REST Web services. It is even possible to write a library to
         encapsulate those API calls into our own reuseable functions. I have written such a library
         for XSLT 2.0, supporting the underlying Data Service, as well as various dedicated
         services, such as contacts and calendar (unfortunately, it is not published yet, but feel
         free to contact me in private, or through the EXPath mailing list if you are interested in
         obtaining a draft version.) Let's take for instance the </textual><link class="po-inline e121 e121" xlink:actuate="onRequest" xlink:href="http://code.google.com/apis/contacts/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Google Contacts API</textual></link><textual class="po-textual">, and use
         the contact information it provides to create a contact book in ODF Text format. The
         contact book is a simple table with three columns: a picture of the contact if any, then
         its textual information (name, email, address, etc.) and finally a last column with a
         thumbnail of a Google Map of its neighbourhood:</textual></para><para class="po-block e122 e122"><textual class="po-textual">
         </textual><mediaobject class="po-container e123 e123"><imageobject class="po-container e124 e124"><imagedata class="po-meta e125 e125" fileref="../../../vol3/graphics/Georges01/Georges01-003.png" format="png" width="99%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><textual class="po-textual">
      </textual></para><para class="po-block e126 e126"><textual class="po-textual">By using the Compound Document Template pattern, it is possible to create this table
         directly in Open Office, by just creating one single row with a picture, a name in bold, an
         email address as a link, other textual info, and a map. Let's save the file in, for
         instance, </textual><code class="po-atom e127 e127"><textual class="po-textual">template.odt</textual></code><textual class="po-textual">. The transform contains three rather independent parts:
         retrieve info from Google, format them into a new </textual><code class="po-atom e128 e128"><textual class="po-textual">content.xml</textual></code><textual class="po-textual"> document, then
         create a new </textual><code class="po-atom e129 e129"><textual class="po-textual">result.odt</textual></code><textual class="po-textual"> file by updating </textual><code class="po-atom e130 e130"><textual class="po-textual">content.xml</textual></code><textual class="po-textual"> and adding
         the picture files:</textual></para><para class="po-block e131 e131"><textual class="po-textual">
         </textual><mediaobject class="po-container e132 e132"><imageobject class="po-container e133 e133"><imagedata class="po-meta e134 e134" fileref="../../../vol3/graphics/Georges01/Georges01-004.png" format="png" width="99%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><textual class="po-textual">
      </textual></para><para class="po-block e135 e135"><textual class="po-textual">By using an intermediate document type for the contacts, we apply the
            </textual><emphasis class="po-inline e136 e136"><textual class="po-textual">separation of concerns</textual></emphasis><textual class="po-textual"> principle to isolate the formatting itself,
         making it independent of the specific Google Contacts format. The </textual><emphasis class="po-inline e137 e137"><textual class="po-textual">get
            contacts</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e138 e138"><textual class="po-textual">update zip</textual></emphasis><textual class="po-textual"> modules use the same kind of
         code shown in previous sections to ask the Google servers on the one hand, and to read and
         update ZIP files on the other hand. The orchestration of those three modules is controlled
         by the main driver: </textual><emphasis class="po-inline e139 e139"><textual class="po-textual">google contacts</textual></emphasis><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e140 e140"><title class="po-block e141 e141"><textual class="po-textual">Packaging</textual></title><para class="po-block e142 e142"><textual class="po-textual">XPath and XSLT 1.0 recommendations are ten years old, and still there are very few
         libraries and applications distributed in XSLT. You can find looking around very valuable
         pieces of work written in XSLT like </textual><link class="po-inline e143 e143" xlink:actuate="onRequest" xlink:href="http://www.functx.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">FunctX</textual></link><textual class="po-textual">, </textual><link class="po-inline e144 e144" xlink:actuate="onRequest" xlink:href="http://www.cranesoftwrights.com/resources/xslstyle/" xlink:show="new" xlink:type="simple"><textual class="po-textual">XSLStyle</textual></link><textual class="po-textual">, </textual><link class="po-inline e145 e145" xlink:actuate="onRequest" xlink:href="http://www.schematron.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Schematron</textual></link><textual class="po-textual"> or of
         course </textual><link class="po-inline e146 e146" xlink:actuate="onRequest" xlink:href="http://www.docbook.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">DocBook</textual></link><textual class="po-textual">, but the absence of a
         standardized way to install them tends to slow down their adoption. However, each time one
         has to go through the same process: figuring out the exposed URIs, creating a catalog
         mapping those URIs to the install location, checking whether there are dependencies to
         install, plug the catalog to the cataloging system of her processor or IDE (for each ot
         them,) etc. But there is no homogeneity in the way each project packages its resources and
         it documents the install process.</textual></para><para class="po-block e147 e147"><textual class="po-textual">It would be nice though to be able to download a single file, to give that file to a
         processor to install it automatically, and to rely only on the public URIs associated to
         XSLT stylesheets, XQuery modules and XProc pipelines. Or with any library of functions,
         including extension functions. Where other languages define packages, core XML technologies
         use URIs. But the concept is the same, and we should only care about those URIs when
         developing, instead of constantly keeping trace of physical files, and installing them
         again and again on each machine we have to work on. Everything else than those public URIs
         should be hidden deep in the internals of a simple packaging system supported by most
         processors, IDEs and server environments.</textual></para><para class="po-block e148 e148"><textual class="po-textual">There is not already a formal proposal for such a system, but the idea is quite
         well-defined, and there is even an implementation of a prototype for Saxon, supporting
         standard XSLT stylesheets and XQuery modules, as well as extension functions written in
         Java. I have successfully packaged projects like the DocBook XSLT stylesheets, the DITA
         Open Toolkit XSLT stylesheets, the XSLStyle stylesheets, or the FunctX library (for XSLT as
         for XQuery.) The principle is very simple: a graphical application helps you to manage a
         central repository where it installs the libraries, as well as generated XML Catalogs, and
         a shell script wrapper or Java helper class configure correctly Saxon, so you can still use
         Saxon from the command line or from within a Java program. You can then use the public
         import URI of the installed stylesheet to import the components it provides. This is also
         possible with extension functions, even though Saxon does not provide any (simple) way to
         link a URI to an extension function. The trick is to provide a wrapper stylesheet that uses
         the Saxon-specific URI to access extension functions in Java, while providing a wrapper
         function defined in the correct namespace for each exported function from Java:</textual></para><programlisting class="po-block e149 e149" xml:space="preserve"><textual class="po-textual">&lt;xsl:stylesheet xmlns:http="http://www.expath.org/mod/http-client"
                xmlns:http-java="java:org.expath.saxon.HttpClient"
                ...&gt;

   &lt;xsl:function name="http:send-request" as="item()+"&gt;
      &lt;xsl:param name="request" as="element(http:request)?"/&gt;
      &lt;xsl:sequence select="http-java:send-request($request)"/&gt;
   &lt;/xsl:function&gt;

   ...</textual></programlisting><para class="po-block e150 e150"><textual class="po-textual">On the other hand, the stylesheet using the extension function does not rely on any
         detail of its implementation. It uses a public absolute URI to import the library and the
         namespace defined in the specification instead of the Java-bound namespace:</textual></para><programlisting class="po-block e151 e151" xml:space="preserve"><textual class="po-textual">&lt;xsl:stylesheet xmlns:http="http://www.expath.org/mod/http-client" ...&gt;

   &lt;xsl:import href="http://www.expath.org/mod/http-client.xsl"/&gt;

   &lt;xsl:template match="/"&gt;
      &lt;xsl:sequence select="http:send-request(...)"/&gt;
      ...</textual></programlisting><para class="po-block e152 e152"><textual class="po-textual">Here is how the different pieces fit together:</textual></para><para class="po-block e153 e153"><textual class="po-textual">
         </textual><mediaobject class="po-container e154 e154"><imageobject class="po-container e155 e155"><imagedata class="po-meta e156 e156" fileref="../../../vol3/graphics/Georges01/Georges01-005.png" format="png" width="99%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><textual class="po-textual">
      </textual></para><para class="po-block e157 e157"><textual class="po-textual">The admin GUI is used to manage the repository (you can use it from the command line
         too.) It can install, remove and rename packages. Once installed, everything needed by a
         module resides in that repository (you can have several repositories, for different
         purposes or projects,) like stylesheets and queries, XML catalogs and JAR files for
         extension functions. The shell script is used to execute Saxon from the command line, while
         the Java helper class is used from within Java programs, for instance in a web application.
         Both do configure Saxon with the appropriate resolvers to locate properly the modules in
         the repository. For instance, you can add the following line to your project's Makefile in
         order to generate the documentation with XSLStyle:</textual></para><programlisting class="po-block e158 e158" xml:space="preserve"><textual class="po-textual">&gt; saxon -xsl:urn:isbn:978-1-894049:xslstyle:xslstyle-dita.xsl -s:my.xsl</textual></programlisting><para class="po-block e159 e159"><textual class="po-textual">This is an interesting example as XSLStyle relies on DocBook or DITA (or both.) Let us
         examine how I packaged XSLStyle. The original distribution includes a private copy of both
         DocBook and DITA. This is a bad practice in software engineering, but one has no other
         choice as long as there is no packaging system out there. The first step is thus to remove
         those external libraries, and package them separately. Then we have to define a public URI
         to allow other stylesheets to import the stylesheets provided by this package. This URI
         does not have to point to an actual resource; this is a logical identifier. Following Ken's
         advice, I chose </textual><code class="po-atom e160 e160"><textual class="po-textual">urn:isbn:978-1-894049:xslstyle:xslstyle-dita.xsl</textual></code><textual class="po-textual">, and a
         similar one for the DocBook version. The same way, because we removed the private copies of
         DocBook and DITA, we have to change the XSLStyle stylesheet accordingly, to use public URIs
         in their import instructions. As long as the package for DocBook or for DITA are installed,
         Saxon will find them through the packaging system, by their public URIs.</textual></para><para class="po-block e161 e161"><textual class="po-textual">Furthermore, because Saxon is a standalone processor and can be invoked from the command
         line directly by humans, the shell script allows you to use symbolic names in addition to
         URIs. URIs are convenient from within program pieces like stylesheets and queries, but are
         not well-suited to human beings. Depending on how exactly you installed and configured the
         package, the above example can be rewritten as:</textual></para><programlisting class="po-block e162 e162" xml:space="preserve"><textual class="po-textual">&gt; saxon --xsl=xslstyle-dita -s:my.xsl</textual></programlisting><para class="po-block e163 e163"><textual class="po-textual">This prototype has been implemented only for Saxon so far, but the concept of a central
         repository is particularly well-suited for XML databases as well, like eXist or MarkLogic,
         as they already own a private space on the filesystem to save and organize their components
         and user data. And because the resolving mechanism is built on top of XML Catalogs, any
         serious XML tool or environment (like oXygen) can be configured to share the same
         repository. If this packaging system becomes widely used to deliver libraries and
         applications, we can even think about a central website listing all existing packages,
         allowing for automatic package management over the Internet. Like the APT system for
         Debian, CTAN for TeX or CPAN for Perl. The later inspired in fact the concept and the name
         of CXAN for such a system, thanks to Jim Fuller and Mohamed Zergaoui, which stands for
         Comprehensive X* Archive Network (replace X* with your preferred core XML
         technology.)</textual></para></section><section class="po-hcontainer e164 e164"><title class="po-block e165 e165"><textual class="po-textual">Conclusion</textual></title><para class="po-block e166 e166"><textual class="po-textual">EXPath has just been launched, right after XML Prague 2009, and yet there are very
         valuable modules. The most exiting of them being maybe the packaging system. Besides other
         modules defined as function libraries, this system is a good example of a module that is
         not a library, but rather a tool or a framework which various core XML technologies could
         benefit from. Other ideas include nested sequences, useful to define and manipulate complex
         data structures, first-class function items, to define higher-order functions, XML and HTML
         parsers, or filesystem access. Another module under investigation aims to define an
         abstract web container and the way a piece of X* code can plug itself into this container
         to be evaluated when it receives requests from clients, as well as the communication means
         between the container and the user code. Something similar to Java EE's servlets. For now,
         there is no abstract description of the services provided by an X* server environment, like
         an XML database. Given such a description of an abstract container, third-party frameworks
         could be written in an implementation-independent way, like web MVC frameworks and
         frameworks for XRX applications.</textual></para><para class="po-block e167 e167"><textual class="po-textual">That gives me the opportunity to introduce three sibling extension projects: EXQuery,
         EXSLT 2.0 and EXProc. Without any surprise, their goal is to define extensions to
         respectively XQuery, XSLT 2.0 and XProc. Each of those projects is complementary with
         EXPath, which has been created in the first place to avoid having to specify several times
         the same features, in an non-compatible way.</textual></para><para class="po-block e168 e168"><textual class="po-textual">There is a bunch of work to define new extensions, to write their specifications, to
         implement and test them, to document them. Everyone is welcome to help on the project (and
         I am sure on the other EX* projects.) Just use the extensions and give us feedback on the
         mailing list: </textual><link class="po-inline e169 e169" xlink:actuate="onRequest" xlink:href="http://www.expath.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.expath.org/</textual></link><textual class="po-textual">.</textual></para><para class="po-block e170 e170"><textual class="po-textual">See you soon!</textual></para></section></article></classedDocument>