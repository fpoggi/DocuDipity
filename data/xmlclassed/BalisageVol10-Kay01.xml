<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">The FtanML Markup Language</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">This paper presents a new markup language called FtanML, together with an
                associated schema language called FtanGram, and a query/transformation language
                called FtanSkrit. FtanML was originally designed by a group of students taught by
                the author, together with Stephanie Haupt, at a summer school held in the Swiss
                village of Ftan in August 2012. It has since been taken forward by the author with
                some further involvement by the students. The idea of FtanML is to rethink markup
                from the ground up: to imagine what the world could be like if we didn't have to
                carry forward the mistakes of the past; to take what works well in current
                languages, and discard the features that do little more than add complexity. More
                mundanely, FtanML can be seen as a blend of ideas from XML and JSON: neither the
                union nor the intersection of the two, but a new language that combines the best
                features of both.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Michael</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Kay</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Michael Kay has been developing the Saxon product since 1998, initially as
                        a spare-time activity at ICL and then Software AG, but since 2004 within the
                        Saxonica company which he founded. He holds a Ph.D from the University of
                        Cambridge where he studied databases under the late Maurice Wilkes, and
                        spent 24 years with ICL, mainly working on the development of database
                        software. He is the editor of the W3C XSLT specification. The FtanML project
                        is totally separate from any W3C or Saxonica activities.</textual></para></personblurb><affiliation class="po-record e14 e14"><orgname class="po-block e15 e15"><textual class="po-textual">Saxonica</textual></orgname></affiliation><email class="po-field e16 e16"><textual class="po-textual">mike@saxonica.com</textual></email></author><keywordset class="po-table e17 e17" role="author"><keyword class="po-field e18 e18"><textual class="po-textual">Markup Languages</textual></keyword><keyword class="po-field e19 e19"><textual class="po-textual">Schema Languages</textual></keyword><keyword class="po-field e20 e20"><textual class="po-textual">Document Processing Languages</textual></keyword></keywordset></info><section class="po-hcontainer e21 e21"><title class="po-block e22 e22"><textual class="po-textual">Introduction</textual></title><para class="po-block e23 e23"><textual class="po-textual">Whereas the computing community invents a new programming language almost every week,
            and the best ideas from these many experiments find their way into perhaps one
            programming language a year that sees the light of day outside the project that
            conceived it, new markup languages are rather rare, and most attempts to create them
            (such as the MicroXML project</textual><xref class="po-milestone e24 e24" linkend="ref1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) have self-imposed constraints of compatibility that
            limit the freedom of the designers to find new ways of doing things, even in areas where
            existing designs are universally acknowledged to be problematic.</textual></para><para class="po-block e25 e25"><textual class="po-textual">Invited to run a course at a summer school in August 2012 for a high-achieving group
            of German undergraduates, I decided to take the opportunity to remedy this. While
            enjoying the thin air of the Swiss Alps in the Romansch-speaking village of Ftan at
            1700m above sea level, the students spent the first week learning the technologies in
            the XML stack, and the second week designing a replacement. The result was FtanML. </textual><footnote class="po-popup e26 e26"><para class="po-block e27 e27"><textual class="po-textual">Ftan is a place name, not an acronym, and while words beginning "Ft" are
                    uncommon in English, the pronunciation comes easily with practice.</textual></para></footnote></para><section class="po-hcontainer e28 e28"><title class="po-block e29 e29"><textual class="po-textual">FtanML Goals</textual></title><para class="po-block e30 e30"><textual class="po-textual">Some of the design goals the students set themselves at the end of the first week
            were:</textual></para><para class="po-block e31 e31"><textual class="po-textual">
            </textual><itemizedlist class="po-table e32 e32"><listitem class="po-container e33 e33"><para class="po-block e34 e34"><textual class="po-textual">The language would be as good as JSON</textual><xref class="po-milestone e35 e35" linkend="ref3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> in handling typed data, and as good
                        as XML in handling documents.</textual></para></listitem><listitem class="po-container e36 e36"><para class="po-block e37 e37"><textual class="po-textual">The language would be more concise than XML, while still being
                        human-readable.</textual></para></listitem><listitem class="po-container e38 e38"><para class="po-block e39 e39"><textual class="po-textual">Both a syntax and a data model would be defined; the data model must map
                        readily to data structures available in most modern programming
                        languages.</textual></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para><para class="po-block e40 e40"><textual class="po-textual">Perhaps as important was a non-goal of which we had to remind ourselves frequently:
            compatibility with the past was not an objective. We did not want to repeat other
            people's mistakes for the sake of compatibility, whether at the level of documents,
            parsers, APIs, editing tools, or simply user expectations. Associated with this goal was
            the implicit decision that we would not compromise technical quality in the interests of
            market acceptance. The aim was to do it right, and we would not measure success by the
            level of adoption. Having said that, there was no point in being needlessly different
            when there was nothing wrong with existing designs.</textual></para><para class="po-block e41 e41"><textual class="po-textual">During the second week of the course we defined the FtanML markup language and object
            model, and implemented a parser using JavaCC. In the weeks after the course, some of the
            students rewrote the parser in Scala, and together we worked on extending the system
            with a type/constraint language. Inevitably, with the students dispersed to their
            various institutions, momentum was lost, but I decided that there were enough good ideas
            that it was worth bringing the design to some kind of completion. This paper provides an
            overview of the language rather than a complete specification (which remains as work to
            be done). A Scala implementation covering a significant subset is available at
            [2].</textual></para></section><section class="po-hcontainer e42 e42"><title class="po-block e43 e43"><textual class="po-textual">Requirements Background</textual></title><para class="po-block e44 e44"><textual class="po-textual">XML has been remarkably successful and is widely used. It meets a wide variety of needs,
                achieves a high level of interoperability, and is not expensive to implement. </textual></para><para class="po-block e45 e45"><textual class="po-textual">Nevertheless, over a period of 15 years' use, the drawbacks and limitations of XML
            have become well known, and are acknowledged by XML's critics and enthusiasts alike. Perhaps
            the most notable limitations and frustrations are:</textual></para><itemizedlist class="po-table e46 e46"><listitem class="po-container e47 e47"><para class="po-block e48 e48"><textual class="po-textual">XML has been widely adopted as a serialization format for structured data, but
                    its data model has a poor fit to the type systems of most popular programming languages.
                    Hence alternatives such as JSON and YAML</textual><xref class="po-milestone e49 e49" linkend="ref4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e50 e50"><para class="po-block e51 e51"><textual class="po-textual">XML is over-complex. Many of its features are rarely used, or used only in very
                        simple ways, but still make everything more complicated. Hence MicroXML.</textual></para></listitem><listitem class="po-container e52 e52"><para class="po-block e53 e53"><textual class="po-textual">XML cannot handle overlap or graph structures. Hence LMNL</textual><xref class="po-milestone e54 e54" linkend="ref5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and GODDAG</textual><xref class="po-milestone e55 e55" linkend="ref6"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e56 e56"><para class="po-block e57 e57"><textual class="po-textual">XML is verbose and inefficient. Hence the various Binary XML contenders,
                        including Fast Infoset</textual><xref class="po-milestone e58 e58" linkend="ref7"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and EXI</textual><xref class="po-milestone e59 e59" linkend="ref8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, as well as the adoption of custom non-XML syntax
                    for various applications such as RelaxNG and RDF in direct competition with an
                    XML syntax for the same information.</textual></para></listitem><listitem class="po-container e60 e60"><para class="po-block e61 e61"><textual class="po-textual">XML is syntax without an agreed data model. No-one knows, for example, whether
                    CDATA sections should be treated as information-bearing or not. Similarly for comments.
                    Hence the myriad XML data models such as DOM and XDM, all of them different.</textual></para></listitem></itemizedlist><para class="po-block e62 e62"><textual class="po-textual">So there's clearly room for improvement. A standard, once entrenched, rarely gives way 
                to a technically superior alternative: the
                QWERTY keyboard is an oft-cited example, and XML will probably be no exception. However,
                there's room for diversity, and the aim of this exercise is to explore
            what is possible. It doesn't tackle all the problems noted above (for example, there's nothing
            on overlap or graph structures); but it tries to address most of them.</textual></para></section></section><section class="po-hcontainer e63 e63"><title class="po-block e64 e64"><textual class="po-textual">FtanML: The Markup Language</textual></title><para class="po-block e65 e65"><textual class="po-textual">This section presents the syntax of FtanML. We'll present the "data-only" core of the
            language at this stage, but with some forwards references to how the language is
            subsequently extended to enable active scripting of documents.</textual></para><para class="po-block e66 e66"><textual class="po-textual">A document (the unit of input to the parser) is a sequence of Unicode characters
            conforming to the grammar defined in this section. The encoding of characters as octets
            (or as scratches on clay tablets) is out of scope — it belongs in a different layer of
            the protocol stack. But if in doubt, UTF-8 is recommended.</textual></para><para class="po-block e67 e67"><textual class="po-textual">The document must match the </textual><code class="po-atom e68 e68"><textual class="po-textual">value</textual></code><textual class="po-textual"> production.</textual></para><programlisting class="po-block e69 e69" xml:space="preserve"><textual class="po-textual">
value ::= null | boolean | number | string | list | element | richText
        </textual></programlisting><para class="po-block e70 e70"><textual class="po-textual">As this production shows, there are seven kinds of value, which we will present in
            turn, starting with the simplest. The term "rich text" means text with interspersed
            markup: what the markup community traditionally calls "mixed content".</textual></para><para class="po-block e71 e71"><textual class="po-textual">Later we will introduce an eighth kind of value, namely functions. But first, let's
            start with an example.</textual></para><section class="po-hcontainer e72 e72"><title class="po-block e73 e73"><textual class="po-textual">FtanML Example: the Purchase Order</textual></title><para class="po-block e74 e74"><textual class="po-textual">This is what the purchase order from the XML Schema Primer</textual><xref class="po-milestone e75 e75" linkend="ref2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> might look like in FtanML.</textual></para><programlisting class="po-block e76 e76" xml:space="preserve"><textual class="po-textual">&lt;purchaseOrder 
   orderDate="1999-10-20" 
   shipTo = &lt;country="US" [
      &lt;name "Alice Smith"&gt;
      &lt;street "123 Maple Street"&gt;
      &lt;city "Mill Valley"&gt;
      &lt;state "CA"&gt;
      &lt;zip 90952&gt;
   ]&gt;
   billTo = &lt;country="US" [
      &lt;name "Robert Smith"&gt;
      &lt;street "8 Oak Avenue"&gt;
      &lt;city "Old Town"&gt;
      &lt;state "PA"&gt;
      &lt;zip 95819&gt;
   ]&gt;
   comment = |&lt;emph |Hurry|&gt;, my lawn is going wild|
   items = [
      &lt;  partNum="872-AA"
         productName="Lawnmower"
         quantity=1
         USPrice=148.95
         comment=|Confirm this is &lt;strong |electric|&gt;|
      &gt;
      &lt;  partNum="926-AA"
         productName="Baby Monitor"
         quantity=1
         USPrice=39.98
         shipDate="1999-05-21"
      &gt;
   ]
&gt;</textual></programlisting><para class="po-block e77 e77"><textual class="po-textual">This example follows the example given in the XML Schema Primer very closely; I've
                only made one change, which is to use rich text in the comment fields. Let's compare
                it with the XML version:</textual></para><itemizedlist class="po-table e78 e78"><listitem class="po-container e79 e79"><para class="po-block e80 e80"><textual class="po-textual">End tags reduce to a simple "&gt;".</textual></para></listitem><listitem class="po-container e81 e81"><para class="po-block e82 e82"><textual class="po-textual">The content of an element, and the content of an attribute, can be either
                        a string (in single or double quotes), a number, a boolean (not used in this
                        example), rich text (delimited with vertical bars), an element, or a list of
                        elements (inter alia). When elements have element content, the child
                        elements are enclosed in a list marked by square brackets.</textual></para></listitem><listitem class="po-container e83 e83"><para class="po-block e84 e84"><textual class="po-textual">Since an attribute
                        can contain anything an element can contain, it's possible to use structured attributes, and I have
                        taken advantage of this. 
                        I have chosen to use attributes rather than child elements in cases where ordering does not
                    matter, and where there is only one child of the parent element with a given name: specifically
                    for the top-level properties of a purchase order, and for the properties of each item. Where
                    there is some significance in the ordering, as with the components of an address, I chose
                    to use child elements.</textual></para></listitem><listitem class="po-container e85 e85"><para class="po-block e86 e86"><textual class="po-textual">In the list of items, the original XML has an element named
                            </textual><code class="po-atom e87 e87"><textual class="po-textual">items</textual></code><textual class="po-textual">, whose children are all elements named
                            </textual><code class="po-atom e88 e88"><textual class="po-textual">item</textual></code><textual class="po-textual">. Since the name of the child element is always the
                        same, it is redundant, so I chose to leave it out: the content of the
                            </textual><code class="po-atom e89 e89"><textual class="po-textual">items</textual></code><textual class="po-textual"> attribute is now a list of anonymous elements.</textual></para></listitem><listitem class="po-container e90 e90"><para class="po-block e91 e91"><textual class="po-textual">There's a difference between a singleton and a list of length one. Lists
                        are always explicitly marked with square brackets. That might be a little
                        inconvenient for authors, but it makes life a lot easier for the programmer
                        at the receiving end. (You could choose to allow the </textual><code class="po-atom e92 e92"><textual class="po-textual">items</textual></code><textual class="po-textual">
                        attribute to contain a single item rather than a list if only one item has
                        been ordered, but the program reading the data would then have to cater for
                        both possibilities.)</textual></para></listitem><listitem class="po-container e93 e93"><para class="po-block e94 e94"><textual class="po-textual">For the purpose of the example I have followed the XML Schema Primer in
                        defining the ZIP code as a number, though in reality it should be a string
                        of digits, which is not the same thing.</textual></para></listitem><listitem class="po-container e95 e95"><para class="po-block e96 e96"><textual class="po-textual">There's no ambiguity about where whitespace is and is not significant. It's only significant if it
                    appears in a string, or in rich text.</textual></para></listitem></itemizedlist><para class="po-block e97 e97"><textual class="po-textual">If we compare this with how it might have been done in JSON, there are two main
                differences. Firstly, JSON provides no satisfactory way to handle the mixed content
                comments. Secondly, with JSON we would have to make a choice how to represent the
                addresses: either use an object (i.e. a map), in which case ordering information is
                lost, or use an array in which case the components have no names. A minor difference
                with JSON, or at least with official JSON, is that we don't need quotes around the
                element and attribute names.</textual></para><para class="po-block e98 e98"><textual class="po-textual">Now let's look at the individual constructs of FtanML.</textual></para></section><section class="po-hcontainer e99 e99"><title class="po-block e100 e100"><textual class="po-textual">The null value</textual></title><programlisting class="po-block e101 e101" xml:space="preserve"><textual class="po-textual">
null ::= "null"
            </textual></programlisting><para class="po-block e102 e102"><textual class="po-textual">There is a single value in this class, denoted by the keyword "null". It is
                borrowed directly from JSON, but plays a wider part in the data model.</textual></para></section><section class="po-hcontainer e103 e103"><title class="po-block e104 e104"><textual class="po-textual">Boolean values</textual></title><programlisting class="po-block e105 e105" xml:space="preserve"><textual class="po-textual">
boolean ::= "true" | "false"
            </textual></programlisting><para class="po-block e106 e106"><textual class="po-textual">There are two boolean values, denoted by the keywords "true" and "false".</textual></para></section><section class="po-hcontainer e107 e107"><title class="po-block e108 e108"><textual class="po-textual">Numeric values</textual></title><programlisting class="po-block e109 e109" xml:space="preserve"><textual class="po-textual">
number ::= "-"? digits ("." digits)? ([eE] [+-]? digits)?
digits ::= [0-9]+
            </textual></programlisting><para class="po-block e110 e110"><textual class="po-textual">The production rule for numbers is a little different from both the
                    </textual><code class="po-atom e111 e111"><textual class="po-textual">DoubleLiteral</textual></code><textual class="po-textual"> of XPath 2.0 (it requires digits both before and
                after the decimal point), and the equivalent in JSON (it allows leading zeros). The
                value space is not binary floating point, but decimal. Specifically, it is the set
                of values that can be represented in the form </textual><code class="po-atom e112 e112"><textual class="po-textual">N * 10^M</textual></code><textual class="po-textual"> where
                    </textual><code class="po-atom e113 e113"><textual class="po-textual">N</textual></code><textual class="po-textual"> and </textual><code class="po-atom e114 e114"><textual class="po-textual">M</textual></code><textual class="po-textual"> are integers, and </textual><code class="po-atom e115 e115"><textual class="po-textual">N</textual></code><textual class="po-textual"> is not a
                multiple of ten. Implementations may impose limits on this infinite set.</textual></para><para class="po-block e116 e116"><textual class="po-textual">Why decimals? Because that's what most human beings on the planet use in their
                everyday lives. Floating-point binary is designed for machines, not for humans.
                Also, because it survives round-trip conversion to and from text without ambiguity
                or loss of precision. However, the use of decimals gives a problem with the design
                goal that it should be easy to program using conventional programming languages. We
                take a hit here: in the case of programming languages with no decimal data type,
                numbers may be converted to whatever number system that language uses. But the
                native language for processing FtanML, namely FtanSkrit, treats the values as
                decimals.</textual></para></section><section class="po-hcontainer e117 e117"><title class="po-block e118 e118"><textual class="po-textual">Strings</textual></title><programlisting class="po-block e119 e119" xml:space="preserve"><textual class="po-textual">
string ::= ('"' (charRep - '"')* '"') | ("'" (charRep - "'")* "'")
charRep ::= (char - "\") | escape
char ::= (any Unicode character)
escape ::= (see prose)
            </textual></programlisting><para class="po-block e120 e120"><textual class="po-textual">Strings are enclosed in either double or single quotes. The value space for
                strings is the set of all sequences of Unicode characters. In the FtanML
                representation of a string, these characters are represented as themselves, except
                in the case of characters that have a special meaning, notably the string delimiter,
                and the escape character "\".</textual></para><para class="po-block e121 e121"><textual class="po-textual">Escape sequences fall into a number of categories:</textual></para><para class="po-block e122 e122"><textual class="po-textual">
                </textual><itemizedlist class="po-table e123 e123"><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">Whitespace escapes: </textual><code class="po-atom e126 e126"><textual class="po-textual">\n</textual></code><textual class="po-textual">, </textual><code class="po-atom e127 e127"><textual class="po-textual">\r</textual></code><textual class="po-textual">, </textual><code class="po-atom e128 e128"><textual class="po-textual">\t</textual></code><textual class="po-textual">,
                                </textual><code class="po-atom e129 e129"><textual class="po-textual">\s</textual></code><textual class="po-textual">, and </textual><code class="po-atom e130 e130"><textual class="po-textual">\S</textual></code><textual class="po-textual"> represent newline, carriage
                            return, tab, space, and non-breaking space respectively.</textual></para></listitem><listitem class="po-container e131 e131"><para class="po-block e132 e132"><textual class="po-textual">Formatting escapes: </textual><code class="po-atom e133 e133"><textual class="po-textual">\</textual></code><textual class="po-textual"> followed by a sequence of
                            whitespace characters represents nothing. This means that a FtanML
                            editor can reformat the text for display purposes by inserting or
                            removing escaped newlines without changing the actual content.</textual></para></listitem><listitem class="po-container e134 e134"><para class="po-block e135 e135"><textual class="po-textual">Special character escapes: </textual><code class="po-atom e136 e136"><textual class="po-textual">\\</textual></code><textual class="po-textual"> for backslash,
                                </textual><code class="po-atom e137 e137"><textual class="po-textual">\"</textual></code><textual class="po-textual"> for quotation mark, </textual><code class="po-atom e138 e138"><textual class="po-textual">\'</textual></code><textual class="po-textual"> for apostrophe,
                                </textual><code class="po-atom e139 e139"><textual class="po-textual">\|</textual></code><textual class="po-textual"> for vertical bar, </textual><code class="po-atom e140 e140"><textual class="po-textual">\`</textual></code><textual class="po-textual"> for backtick,
                                </textual><code class="po-atom e141 e141"><textual class="po-textual">\&lt;</textual></code><textual class="po-textual"> for a left angle bracket, </textual><code class="po-atom e142 e142"><textual class="po-textual">\[</textual></code><textual class="po-textual"> for a
                            left square bracket, </textual><code class="po-atom e143 e143"><textual class="po-textual">\{</textual></code><textual class="po-textual"> for a left curly brace.</textual></para></listitem><listitem class="po-container e144 e144"><para class="po-block e145 e145"><textual class="po-textual">Unicode codepoint escapes: </textual><code class="po-atom e146 e146"><textual class="po-textual">\xHHHHH;</textual></code><textual class="po-textual"> represents the
                            Unicode codepoint whose hexadecimal value is </textual><code class="po-atom e147 e147"><textual class="po-textual">HHHHH</textual></code><textual class="po-textual">. This
                            may be any number of digits, followed by a semicolon. (Unlike JSON,
                            non-BMP characters are represented by the actual codepoint, not by a
                            surrogate pair.)</textual></para></listitem><listitem class="po-container e148 e148"><para class="po-block e149 e149"><textual class="po-textual">Cells: </textual><code class="po-atom e150 e150"><textual class="po-textual">\[§....§]</textual></code><textual class="po-textual"> where </textual><code class="po-atom e151 e151"><textual class="po-textual">§</textual></code><textual class="po-textual"> is any character
                            that does not appear in the string. This is analogous to XML's CDATA
                            section, except that it can also be used in attributes: it allows a
                            literal string to appear without escaping of special characters. For
                            example a sequence of four backslashes might be written
                                </textual><code class="po-atom e152 e152"><textual class="po-textual">\[⟡\\\\⟡]</textual></code><textual class="po-textual">. Cells are handy for things such as regular
                            expressions and Windows filenames, and for authoring papers that
                            describe new markup languages.</textual><footnote class="po-popup e153 e153"><para class="po-block e154 e154"><textual class="po-textual">It's called a cell because escaping is not allowed.</textual></para></footnote></para></listitem></itemizedlist><textual class="po-textual">
            </textual></para><para class="po-block e155 e155"><textual class="po-textual">The only characters that must be escaped in strings are </textual><code class="po-atom e156 e156"><textual class="po-textual">\</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e157 e157"><textual class="po-textual">{</textual></code><textual class="po-textual"> , and the character used as the string delimiter (</textual><code class="po-atom e158 e158"><textual class="po-textual">"</textual></code><textual class="po-textual">
                or  </textual><code class="po-atom e159 e159"><textual class="po-textual">'</textual></code><textual class="po-textual">).  We'll come on to the significance of curly braces
                later.</textual></para></section><section class="po-hcontainer e160 e160"><title class="po-block e161 e161"><textual class="po-textual">Lists</textual></title><para class="po-block e162 e162"><textual class="po-textual">A list is a sequence of values. The values may be of any of the seven kinds (null,
                boolean, number, string, list, element, or rich text).</textual></para><para class="po-block e163 e163"><textual class="po-textual">The unabbreviated syntax is the same as for arrays in JSON:</textual></para><programlisting class="po-block e164 e164" xml:space="preserve"><textual class="po-textual">
list ::= "[" (value ("," value)* )? "]"
            </textual></programlisting><para class="po-block e165 e165"><textual class="po-textual">For example, </textual><code class="po-atom e166 e166"><textual class="po-textual">[1, 3, "London", null]</textual></code></para><para class="po-block e167 e167"><textual class="po-textual">Two abbreviations are allowed:</textual></para><para class="po-block e168 e168"><textual class="po-textual">
                </textual><itemizedlist class="po-table e169 e169"><listitem class="po-container e170 e170"><para class="po-block e171 e171"><textual class="po-textual"> Commas may be omitted, so </textual><code class="po-atom e172 e172"><textual class="po-textual">[1 2 3]</textual></code><textual class="po-textual"> is equivalent to
                                </textual><code class="po-atom e173 e173"><textual class="po-textual">[1,2,3]</textual></code><textual class="po-textual"> and
                                </textual><code class="po-atom e174 e174"><textual class="po-textual">[&lt;first&gt;&lt;last&gt;]</textual></code><textual class="po-textual"> is
                            equivalent to </textual><code class="po-atom e175 e175"><textual class="po-textual">[&lt;first&gt;,&lt;last&gt;]</textual></code><textual class="po-textual">.
                        </textual></para></listitem><listitem class="po-container e176 e176"><para class="po-block e177 e177"><textual class="po-textual">The value </textual><code class="po-atom e178 e178"><textual class="po-textual">null</textual></code><textual class="po-textual"> is implicit if there is nothing between
                            two commas, or before the first comma, or after the last. So
                                </textual><code class="po-atom e179 e179"><textual class="po-textual">[,,]</textual></code><textual class="po-textual"> is equivalent to
                            </textual><code class="po-atom e180 e180"><textual class="po-textual">[null,null,null]</textual></code></para></listitem></itemizedlist><textual class="po-textual">
            </textual></para><para class="po-block e181 e181"><textual class="po-textual">The effect of these two rules is that the abbreviated syntax for lists
                becomes:</textual></para><programlisting class="po-block e182 e182" xml:space="preserve"><textual class="po-textual">
lists ::= "[" ( value | ",")* "]"
            </textual></programlisting><para class="po-block e183 e183"><textual class="po-textual">Whitespace is needed between two values only where necessary to terminate a token; specifically, when
            one value ends with an alphanumeric character and the next starts with an alphanumeric character.</textual></para></section><section class="po-hcontainer e184 e184"><title class="po-block e185 e185"><textual class="po-textual">Elements</textual></title><para class="po-block e186 e186"><textual class="po-textual">Elements serve the same purpose as objects (maps) in JSON and elements in
                XML.</textual></para><programlisting class="po-block e187 e187" xml:space="preserve"><textual class="po-textual">
element ::= "&lt;" name? (name "=" value)* content? "&gt;"
content ::= value
            </textual></programlisting><para class="po-block e188 e188"><textual class="po-textual">Elements have three parts: an optional name, a set of name/value pairs called
                attributes, and an optional value referred to as the element's content.</textual></para><para class="po-block e189 e189"><textual class="po-textual">The values of attributes can be of any type: not just strings as in XML, but
                numbers, booleans, lists, elements, rich text. An attribute with the value null is
                deemed equivalent to omitting the attribute.</textual><footnote class="po-popup e190 e190"><para class="po-block e191 e191"><textual class="po-textual">This decision means that JSON is not a pure subset of FtanML, because JSON
                        distinguishes an absent entry in an object from an entry whose value is
                        null. However, the decision makes programming simpler, and makes sense
                        semantically.</textual></para></footnote></para><para class="po-block e192 e192"><textual class="po-textual">Attribute names within an element must be distinct.</textual></para><para class="po-block e193 e193"><textual class="po-textual">Like attributes, the content value can be of any type.</textual></para><para class="po-block e194 e194"><textual class="po-textual">As with lists, whitespace is needed only where necessary to terminate a
                token.</textual></para><para class="po-block e195 e195"><textual class="po-textual">We'll have more to say on element and attribute names later. For the moment,
                suffice it to say that the name can be any non-empty string. If the name contains
                special characters it can be written within backticks (a convention borrowed from
                the SQL world).</textual></para><para class="po-block e196 e196"><textual class="po-textual">Here are some examples of elements. (We haven't explained rich text yet, so we
                won't use it in any of our examples):</textual></para><para class="po-block e197 e197"><textual class="po-textual">
                </textual><table class="po-container e198 e198"><caption class="po-container e199 e199"><para class="po-block e200 e200"><textual class="po-textual">Examples of Elements</textual></para></caption><thead class="po-container e201 e201"><tr class="po-table e202 e202"><th class="po-field e203 e203"><textual class="po-textual">Example</textual></th><th class="po-field e204 e204"><textual class="po-textual">Explanation</textual></th></tr></thead><tbody class="po-table e205 e205"><tr class="po-table e206 e206"><td class="po-block e207 e207"><textual class="po-textual">&lt;&gt;</textual></td><td class="po-block e208 e208"><textual class="po-textual">An empty element (no name, attributes, or content)</textual></td></tr><tr class="po-table e209 e209"><td class="po-block e210 e210"><textual class="po-textual">&lt;br&gt;</textual></td><td class="po-block e211 e211"><textual class="po-textual">An empty element named </textual><code class="po-atom e212 e212"><textual class="po-textual">br</textual></code></td></tr><tr class="po-table e213 e213"><td class="po-block e214 e214"><textual class="po-textual">&lt;age 23&gt;</textual></td><td class="po-block e215 e215"><textual class="po-textual">An element whose name is </textual><code class="po-atom e216 e216"><textual class="po-textual">age</textual></code><textual class="po-textual"> and whose content
                                    value is the number 23</textual></td></tr><tr class="po-table e217 e217"><td class="po-block e218 e218"><textual class="po-textual">&lt;colors ["red", "green", "blue"]&gt;</textual></td><td class="po-block e219 e219"><textual class="po-textual">An element whose name is </textual><code class="po-atom e220 e220"><textual class="po-textual">colors</textual></code><textual class="po-textual"> and whose
                                    content value is a list of three strings</textual></td></tr><tr class="po-table e221 e221"><td class="po-block e222 e222"><textual class="po-textual">&lt;x=0.13 y=0.57&gt;</textual></td><td class="po-block e223 e223"><textual class="po-textual">An unnamed element containing two attributes, both
                                    numeric</textual></td></tr><tr class="po-table e224 e224"><td class="po-block e225 e225"><textual class="po-textual">&lt;polygon coords=[[1,1], [1,3], [3,2]]&gt;</textual></td><td class="po-block e226 e226"><textual class="po-textual">An element named </textual><code class="po-atom e227 e227"><textual class="po-textual">polygon</textual></code><textual class="po-textual"> with an attribute named
                                        </textual><code class="po-atom e228 e228"><textual class="po-textual">coords</textual></code><textual class="po-textual"> whose content value is a list; the list
                                    contains three sublists, and each sublist contains two
                                    numbers.</textual></td></tr><tr class="po-table e229 e229"><td class="po-block e230 e230"><textual class="po-textual">&lt;[&lt;i&gt;&lt;j&gt;&lt;k&gt;]&gt;</textual></td><td class="po-block e231 e231"><textual class="po-textual">An unnamed element whose content value is a list of three
                                    elements. Note the omission of the optional commas.</textual></td></tr><tr class="po-table e232 e232"><td class="po-block e233 e233"><textual class="po-textual">&lt;`Graduate Trainee` `date of birth`="1995-01-01"&gt;</textual></td><td class="po-block e234 e234"><textual class="po-textual">An element where both the element name and attribute name contain spaces.</textual></td></tr></tbody></table><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e235 e235"><title class="po-block e236 e236"><textual class="po-textual">Rich Text</textual></title><para class="po-block e237 e237"><textual class="po-textual">Rich Text (known in the XML world as mixed content) consists of characters and markup, 
                or more specifically a sequence whose members are either characters or elements.</textual></para><programlisting class="po-block e238 e238" xml:space="preserve"><textual class="po-textual">
richText ::= "|" (charRep | element) "|"
            </textual></programlisting><para class="po-block e239 e239"><textual class="po-textual">Rich text is written between vertical bars.</textual><footnote class="po-popup e240 e240"><para class="po-block e241 e241"><textual class="po-textual">This is a change from the original FtanML design. Originally rich text was
                        introduced by a vertical bar, and ended with the "&gt;" delimiter marking the
                        end of the element. This design prevented rich text appearing as the value
                        of an attribute, or being used as a value in the scripting language. The
                        revised design restores orthogonality by allowing rich text to appear where
                        any value can appear. </textual></para></footnote></para><para class="po-block e242 e242"><textual class="po-textual">For example: </textual><code class="po-atom e243 e243"><textual class="po-textual">|H&lt;sub|2|&gt;O|</textual></code><textual class="po-textual"> represents text consisting of the
                character "H", an element whose name is </textual><code class="po-atom e244 e244"><textual class="po-textual">sub</textual></code><textual class="po-textual"> and whose content is the
                rich text "2", and the character "O".</textual></para><para class="po-block e245 e245"><textual class="po-textual">Escapes can be used in rich text just as they can in strings. Any recognized
                escape sequence may be used; the only characters that must be escaped are "\", "|",
                "{", and "&lt;".</textual></para></section><section class="po-hcontainer e246 e246"><title class="po-block e247 e247"><textual class="po-textual">Whitespace</textual></title><para class="po-block e248 e248"><textual class="po-textual">FtanML (unlike XML) is explicit about the difference between significant and
                insignificant whitespace.</textual></para><para class="po-block e249 e249"><textual class="po-textual">Whitespace appearing directly within a string or within rich text is significant
                and is retained in the data model — except that a sequence of whitespace characters
                preceded by a backslash is ignored (this is formatting whitespace, used only to make
                the text more easily readable on screen or paper). Whitespace between tokens in a
                list or element is insignificant and is not retained. Whitespace is never required
                between tokens unless necessary for disambiguation.</textual></para><para class="po-block e250 e250"><textual class="po-textual">Note that because elements may be embedded in rich text, these rules apply
                recursively. Whitespace characters appearing between the tokens of an element that
                itself appears within rich text are not significant; it is the immediate container
                that matters. Support for rich text means that unlike JSON, this is not a two-level
                grammar where it makes sense to think of a tokenization phase followed by a syntax
                analysis phase, with whitespace being discarded during tokenization.</textual></para></section><section class="po-hcontainer e251 e251"><title class="po-block e252 e252"><textual class="po-textual">Names and Namespaces</textual></title><para class="po-block e253 e253"><textual class="po-textual">As stated earlier, the name of an element or attribute may be any string. Names without
                special characters are called simple names; those containing special characters must be
                written with enclosing backticks (grave accent, x60), and are called quoted names.</textual></para><para class="po-block e254 e254"><textual class="po-textual">The rule for a simple name is that it must begin with a letter or underscore, and
                continue with letters, digits, or underscore. The terms "letter" and "digit" are
                defined by reference to Unicode character categories.</textual></para><para class="po-block e255 e255"><textual class="po-textual">A quoted name may use escaped characters in the same way as a string literal. The only characters
            that must be escaped are the backslash and backtick.</textual></para><programlisting class="po-block e256 e256" xml:space="preserve"><textual class="po-textual">
name ::= simpleName | quotedName
simpleName ::= [\p{L}_][\p{L}\p{D}_]*
quotedName ::= "`" ((charRep - "`") | Escape)+ "`"
             </textual></programlisting><para class="po-block e257 e257"><textual class="po-textual">A name written in a FtanML document, with or without backticks, cannot be zero
                length; in the data model, however, the content value is modelled as an attribute
                with a zero-length name.</textual></para><para class="po-block e258 e258"><textual class="po-textual">There are no namespaces in FtanML.</textual></para><para class="po-block e259 e259"><textual class="po-textual">As a matter of convention, it is recommended that an element or attribute intended
                to be used in an alien context, that is, a context where the containing element is
                part of a different vocabulary defined by a different specification, 
                should be made unique by use of a "reverse-DNS" qualified name along the lines of
                </textual><code class="po-atom e260 e260"><textual class="po-textual">org_w3c_xsl_transform</textual></code><textual class="po-textual">.</textual></para><para class="po-block e261 e261"><textual class="po-textual">By contrast, in the normal case where an element or attribute 
                always has a containing element whose name is defined as part of the same vocabulary, 
                short names such as </textual><code class="po-atom e262 e262"><textual class="po-textual">status</textual></code><textual class="po-textual"> or
                    </textual><code class="po-atom e263 e263"><textual class="po-textual">name</textual></code><textual class="po-textual"> are perfectly adequate and cause no ambiguity.</textual></para><para class="po-block e264 e264"><textual class="po-textual">For interoperability with XML, there may be cases where it is desirable to
            use the same names for elements and attributes as defined in an XML vocabulary. There are two ways
            this might be done:</textual></para><para class="po-block e265 e265"><textual class="po-textual">
                </textual><itemizedlist class="po-table e266 e266"><listitem class="po-container e267 e267"><para class="po-block e268 e268"><textual class="po-textual">The XML expanded name can be used in Clark notation, enclosed in
                            backticks. For example:
                                </textual><code class="po-atom e269 e269"><textual class="po-textual">[&lt;`{http://www.w3.org/1999/XSL/Transform}stylesheet` version="2.0"...&gt;</textual></code><textual class="po-textual">
                        </textual></para></listitem><listitem class="po-container e270 e270"><para class="po-block e271 e271"><textual class="po-textual">Prefixes and namespace declaration attributes may be used, following XML conventions:
                            </textual><code class="po-atom e272 e272"><textual class="po-textual">&lt;`xsl:stylesheet` `xmlns:xsl`="http://www.w3.org/1999/XSL/Transform" version="2.0"...&gt;</textual></code><textual class="po-textual">.
                            The FtanML system will not attach any meaning to such namespace declaration
                            attributes, but it is capable of representing them if required. 
                            Note that any name containing a colon (or various other characters such as ".") needs to be
                            backtick-quoted. 
                        </textual></para></listitem></itemizedlist><textual class="po-textual">
            </textual></para></section></section><section class="po-hcontainer e273 e273"><title class="po-block e274 e274"><textual class="po-textual">Data Model</textual></title><para class="po-block e275 e275"><textual class="po-textual">The data model for FtanML corresponds closely to the syntactic structure.</textual></para><para class="po-block e276 e276"><textual class="po-textual">Null values, booleans, strings, and numbers need no further explanation.</textual></para><para class="po-block e277 e277"><textual class="po-textual">A list is an ordered sequence of values; a list of length one is not the same thing as
            its singleton member.</textual></para><para class="po-block e278 e278"><textual class="po-textual">An element comprises a name (which is a string, or absent) and a set of zero or more
            name/value pairs, the element's attributes. The content value of the element is modelled
            as an attribute whose name is the zero-length string. Attributes whose value is null are
            treated as absent.</textual></para><para class="po-block e279 e279"><textual class="po-textual">Rich text is modelled as a sequence of strings and elements, in which no string is
            zero-length, and no two strings are immediately adjacent. But note that rich text is a
            distinct data type and is distinguishable from a list of strings and elements.
        </textual><footnote class="po-popup e280 e280"><para class="po-block e281 e281"><textual class="po-textual">Modelling rich text as a list of strings and elements is convenient
        in some situations, especially because it's the only representation available using the data types of
        many programming languages. The main drawback is that it's not convenient when we want to treat
        the data as a simple string, and ignore the markup. So we make it a distinct data type,
        that can easily be converted either to a list or to a string for processing when required.</textual></para></footnote></para><para class="po-block e282 e282"><textual class="po-textual">All values in the model are immutable; modifications always involve creating new
            values rather than modifying existing values. There is no notion of identity; it is not
            meaningful to ask whether two lists both containing the values </textual><code class="po-atom e283 e283"><textual class="po-textual">[1,2,3]</textual></code><textual class="po-textual"> are
            "the same list", and this is also true for elements.</textual></para><para class="po-block e284 e284"><textual class="po-textual">These concepts have mappings to the data structures of popular programming language
            that in most cases are fairly obvious. There are a few exceptions: some languages do not
            have a natural way of representing decimal numbers; others have difficulty representing
            Unicode strings, especially strings in which the NUL character (</textual><code class="po-atom e285 e285"><textual class="po-textual">x00</textual></code><textual class="po-textual">) is
            permitted. The way in which such conflicts are resolved is outside the scope of this
            paper.</textual></para><para class="po-block e286 e286"><textual class="po-textual">A noteworthy feature of the data model is that there are no "parent pointers". It is not
            possible to navigate from a value to its container. Closely related to this, values have
            no "identity" in the sense of object-oriented data models. In this respect the data model follows JSON rather than the
            various models used to represent XML. The absence of parent references and object
            identity creates some challenges, but has many benefits in establishing a purely
            functional semantics for the processing language, and in enabling efficient
            transformation: it means, for example, that copying a subtree from one element to
            another is a very cheap operation, because the physical data can be shared.
            </textual><footnote class="po-popup e287 e287"><para class="po-block e288 e288"><textual class="po-textual">
                I have previously [x] discussed the possibility of
                writing an XSLT optimizer in XSLT; I concluded that the only thing preventing
                this was the inefficiency of the XSLT processing model in cases where it is necessary
                to make many passes over a tree, with each pass effecting a small change.
                Allowing subtrees to be shared between the source and result of the transformation could
                eliminate this problem.
            </textual></para></footnote></para></section><section class="po-hcontainer e289 e289"><title class="po-block e290 e290"><textual class="po-textual">The Schema Language: FtanGram</textual></title><para class="po-block e291 e291"><textual class="po-textual">The schema language can be used to define constraints on values, including constraints
            on entire documents. This is the only purpose of a schema; validation returns a true or
            false answer, perhaps with a stream of error messages as a side effect, but it does not
            change the data being validated in any way, except perhaps as an internal
            optimization.</textual></para><para class="po-block e292 e292"><textual class="po-textual">A type is thus a predicate; it distinguishes values that match the type from those
            that do not.</textual></para><para class="po-block e293 e293"><textual class="po-textual">A schema is a set of named types. The seven named types </textual><code class="po-atom e294 e294"><textual class="po-textual">null</textual></code><textual class="po-textual">,
                </textual><code class="po-atom e295 e295"><textual class="po-textual">boolean</textual></code><textual class="po-textual">, </textual><code class="po-atom e296 e296"><textual class="po-textual">number</textual></code><textual class="po-textual">, </textual><code class="po-atom e297 e297"><textual class="po-textual">string</textual></code><textual class="po-textual">, </textual><code class="po-atom e298 e298"><textual class="po-textual">list</textual></code><textual class="po-textual">,
                </textual><code class="po-atom e299 e299"><textual class="po-textual">element</textual></code><textual class="po-textual">, and </textual><code class="po-atom e300 e300"><textual class="po-textual">text</textual></code><textual class="po-textual"> are always available; other types are
            user-defined.</textual></para><para class="po-block e301 e301"><textual class="po-textual">Types have a representation as FtanML elements, and we will use this representation in
            discussing types. However, the element used to represent a type must not be confused
            with the type itself.</textual></para><para class="po-block e302 e302"><textual class="po-textual">The convention for type representations is to use elements such as
                </textual><code class="po-atom e303 e303"><textual class="po-textual">&lt;number gt=0 le=1000&gt;</textual></code><textual class="po-textual">, where </textual><code class="po-atom e304 e304"><textual class="po-textual">number</textual></code><textual class="po-textual"> is the
            name of a base type, and attributes such as </textual><code class="po-atom e305 e305"><textual class="po-textual">gt=0</textual></code><textual class="po-textual"> and </textual><code class="po-atom e306 e306"><textual class="po-textual">le=1000</textual></code><textual class="po-textual">
            define constraints. These attributes are referred to as </textual><emphasis class="po-inline e307 e307" role="ital"><textual class="po-textual">facets</textual></emphasis><textual class="po-textual">. If there are multiple attributes, they define multiple
            constraints, which are independent and orthogonal. In this example, the </textual><code class="po-atom e308 e308"><textual class="po-textual">gt</textual></code><textual class="po-textual">
            facet defines a minimum value (exclusive), while the </textual><code class="po-atom e309 e309"><textual class="po-textual">le</textual></code><textual class="po-textual"> facet defines a
            maximum value (inclusive). Specifying a base type is often unnecessary — in this example
            every value that can be greater than zero is necessarily a number, so every value that
            satisfies the predicate will also satisfy the base type. However, including the base
            type can still be useful to aid clarity.</textual></para><para class="po-block e310 e310"><textual class="po-textual">Although we speak of "base type" here, there is no type hierarchy. One value can
            belong to any number of types, and although it may be true that one type subsumes
            another, the language makes no use of the fact. Naming a base type in a type
            representation merely indicates that to satisfy the type, a value must satisfy all the
            constraints imposed by the base type in addition to the facets explicitly listed.</textual></para><para class="po-block e311 e311"><textual class="po-textual">Before we get into a detailed exposition, we'll again start with an example.</textual></para><section class="po-hcontainer e312 e312"><title class="po-block e313 e313"><textual class="po-textual">FtanGram Example: the Purchase Order Schema</textual></title><para class="po-block e314 e314"><textual class="po-textual">In this section we present the schema for the purchase order shown earlier.
            This is based on the example schema in the XSD primer, modified to correspond
            with the way we restructured the instance document to take advantage of FtanML.</textual></para><programlisting class="po-block e315 e315" xml:space="preserve"><textual class="po-textual">
 &lt;org_ftanml_schema [
  &lt;import "ftan_calendar.ftg"&gt;
  &lt;types
   purchaseOrderType = 
     &lt;element form=&lt;purchaseOrder 
                      shipTo=&lt;addressType&gt;
                      billTo=&lt;addressType&gt;
                      comment=&lt;nullable&lt;text elements=&lt;inlineType&gt;&gt;&gt;
                      items=&lt;occurs=[1,] &lt;itemType&gt;&gt;
     &gt;
   addressType = 
     &lt;element form=&lt;  country=&lt;eq="US"&gt;
                      &lt;seq [ &lt;element form=&lt;name &lt;string&gt;&gt;&gt;,
                             &lt;element form=&lt;street &lt;string&gt;&gt;&gt;,
                             &lt;element form=&lt;city &lt;string&gt;&gt;&gt;,
                             &lt;element form=&lt;state &lt;string&gt;&gt;&gt;,
                             &lt;element form=&lt;zip &lt;number&gt;&gt;&gt;]&gt;
     &gt;
   itemType =
     &lt;element form=&lt;  partNum=&lt;SKUType&gt;
                      productName=&lt;string&gt;
                      quantity=&lt;number ge=1 lt=100 step=1&gt;
                      USPrice=&lt;number ge=0 step=0.01&gt;
                      comment=&lt;nullable&lt;text elements=&lt;inlineType&gt;&gt;&gt;
                      shipDate=&lt;nullable&lt;org_ftanml_calendar_dateType&gt;&gt;
                   &gt;
     &gt;
   inlineType = 
     &lt;element elemName=&lt;enum=["ital", "bold"]&gt; 
              form=&lt;&lt;inlineType&gt;&gt;
     &gt; 
   SKUType = &lt;string pattern="\[#\d{3}-[A-Z]{2}#]"&gt;  
  &gt;   
]&gt;</textual></programlisting><para class="po-block e316 e316"><textual class="po-textual">Looking at this in a little detail, we see:</textual></para><para class="po-block e317 e317"><textual class="po-textual">
                </textual><itemizedlist class="po-table e318 e318"><listitem class="po-container e319 e319"><para class="po-block e320 e320"><textual class="po-textual">A schema is a set of named types. Some of these types are defined inline, some (in this case
                        </textual><code class="po-atom e321 e321"><textual class="po-textual">org_ftanml_calendar_dateType</textual></code><textual class="po-textual">) are imported from an external type library.</textual></para></listitem><listitem class="po-container e322 e322"><para class="po-block e323 e323"><textual class="po-textual">Elements are defined using the </textual><code class="po-atom e324 e324"><textual class="po-textual">form</textual></code><textual class="po-textual">
                            attribute. The value of this attribute is a proforma element. The name
                            of the proforma element matches the name of the instance element; the
                            attributes of the proforma element define the types of the attributes of
                            the instance element; and the content value of the proforma element defines
                            the type of the content value of the instance element.</textual></para></listitem><listitem class="po-container e325 e325"><para class="po-block e326 e326"><textual class="po-textual">An optional attribute is given a type such as
                                </textual><code class="po-atom e327 e327"><textual class="po-textual">&lt;nullable&lt;T&gt;&gt;</textual></code><textual class="po-textual">. This reflects the fact that
                            an absent attribute is equivalent to an attribute that has the explicit
                            value of null; so as well as the normal type of the attribute, the
                            schema must also allow it to take the value null.</textual></para></listitem><listitem class="po-container e328 e328"><para class="po-block e329 e329"><textual class="po-textual">Note the use of a "cell" for escaping the regular expression in the pattern facet
                        for </textual><code class="po-atom e330 e330"><textual class="po-textual">SKUType</textual></code><textual class="po-textual">. This helps to avoid clutter in a string that makes generous use
                        of special characters, especially backslashes.</textual></para></listitem></itemizedlist><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e331 e331"><title class="po-block e332 e332"><textual class="po-textual">Constructing Types</textual></title><para class="po-block e333 e333"><textual class="po-textual">The construct </textual><code class="po-atom e334 e334"><textual class="po-textual">&lt;value&gt;</textual></code><textual class="po-textual"> represents a type that matches
                every value.</textual></para><para class="po-block e335 e335"><textual class="po-textual">Given types </textual><code class="po-atom e336 e336"><textual class="po-textual">T</textual></code><textual class="po-textual">, </textual><code class="po-atom e337 e337"><textual class="po-textual">U</textual></code><textual class="po-textual">, </textual><code class="po-atom e338 e338"><textual class="po-textual">V</textual></code><textual class="po-textual">, the construct
                    </textual><code class="po-atom e339 e339"><textual class="po-textual">&lt;anyOf [T, U, V]&gt;</textual></code><textual class="po-textual"> represents the union of these types,
                while </textual><code class="po-atom e340 e340"><textual class="po-textual">&lt;allOf [T, U, V]&gt;</textual></code><textual class="po-textual"> represents their intersection.</textual></para><para class="po-block e341 e341"><textual class="po-textual">For example, </textual><code class="po-atom e342 e342"><textual class="po-textual">&lt;anyOf [&lt;number&gt;, &lt;string&gt;]&gt;</textual></code><textual class="po-textual"> allows numbers
                and strings, while </textual><code class="po-atom e343 e343"><textual class="po-textual">&lt;allOf [&lt;positive&gt;, &lt;even&gt;]&gt;</textual></code><textual class="po-textual"> allows
                values provided they satisfy both the (user-defined) types </textual><code class="po-atom e344 e344"><textual class="po-textual">positive</textual></code><textual class="po-textual"> and
                    </textual><code class="po-atom e345 e345"><textual class="po-textual">even</textual></code><textual class="po-textual">.</textual></para><para class="po-block e346 e346"><textual class="po-textual">For convenience, the construct </textual><code class="po-atom e347 e347"><textual class="po-textual">&lt;nullable &lt;T&gt;&gt;</textual></code><textual class="po-textual"> is equivalent
                to </textual><code class="po-atom e348 e348"><textual class="po-textual">&lt;anyOf [&lt;T&gt;, &lt;null&gt;]&gt;</textual></code><textual class="po-textual">: that is, either </textual><code class="po-atom e349 e349"><textual class="po-textual">T</textual></code><textual class="po-textual"> or
                null. Thus </textual><code class="po-atom e350 e350"><textual class="po-textual">&lt;nullable &lt;number&gt;&gt;</textual></code><textual class="po-textual"> matches either a number, or
                null.</textual></para><para class="po-block e351 e351"><textual class="po-textual">An enumeration type can be defined using the construct
                    </textual><code class="po-atom e352 e352"><textual class="po-textual">&lt;enum=[A,B,C,...]&gt;</textual></code><textual class="po-textual">. For example,
                    </textual><code class="po-atom e353 e353"><textual class="po-textual">&lt;enum=["red", "green", "blue"]&gt;</textual></code><textual class="po-textual"> matches the three
                specified strings and nothing else. A singleton enumeration can be defined with the
                    </textual><code class="po-atom e354 e354"><textual class="po-textual">eq</textual></code><textual class="po-textual"> facet: for example </textual><code class="po-atom e355 e355"><textual class="po-textual">&lt;eq=""&gt;</textual></code><textual class="po-textual"> matches the
                zero-length string only.</textual></para><para class="po-block e356 e356"><textual class="po-textual">The construct </textual><code class="po-atom e357 e357"><textual class="po-textual">&lt;not &lt;T&gt;&gt;</textual></code><textual class="po-textual"> denotes a type that matches all
                values that are not instances of </textual><code class="po-atom e358 e358"><textual class="po-textual">T</textual></code><textual class="po-textual">. This can be useful in constructing
                more complex types; for example </textual><code class="po-atom e359 e359"><textual class="po-textual">&lt;not&lt;eq=""&gt;&gt;</textual></code><textual class="po-textual"> matches all
                non-empty strings, while </textual><code class="po-atom e360 e360"><textual class="po-textual">&lt;allOf [&lt;number&gt;, &lt;not &lt;eq=0&gt;&gt;]&gt;</textual></code><textual class="po-textual">
                matches values that are numbers and that are not equal to zero.</textual></para><para class="po-block e361 e361"><textual class="po-textual">The most general way of defining a restriction is with an assertion facet, for
                example: </textual><code class="po-atom e362 e362"><textual class="po-textual">&lt;assert={$.startsWith("abc")}&gt;</textual></code><textual class="po-textual">. To understand
                assertions, however, we need to look at the scripting language, which comes later in
                the paper. (The curly braces signal that the value is a function; this represents an
                extension to the base FtanML syntax which is used only in scripts.)</textual></para></section><section class="po-hcontainer e363 e363"><title class="po-block e364 e364"><textual class="po-textual">Restricting numbers</textual></title><para class="po-block e365 e365"><textual class="po-textual">Numeric ranges may be defined using the four attributes </textual><code class="po-atom e366 e366"><textual class="po-textual">ge</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e367 e367"><textual class="po-textual">gt</textual></code><textual class="po-textual">, </textual><code class="po-atom e368 e368"><textual class="po-textual">le</textual></code><textual class="po-textual">, and </textual><code class="po-atom e369 e369"><textual class="po-textual">lt</textual></code><textual class="po-textual">, corresponding to the XML
                Schema facets </textual><code class="po-atom e370 e370"><textual class="po-textual">minInclusive</textual></code><textual class="po-textual">, </textual><code class="po-atom e371 e371"><textual class="po-textual">minExclusive</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e372 e372"><textual class="po-textual">maxInclusive</textual></code><textual class="po-textual">, and </textual><code class="po-atom e373 e373"><textual class="po-textual">maxExclusive</textual></code><textual class="po-textual">, together with the
                facets </textual><code class="po-atom e374 e374"><textual class="po-textual">eq</textual></code><textual class="po-textual"> and </textual><code class="po-atom e375 e375"><textual class="po-textual">ne</textual></code><textual class="po-textual"> which are applicable to all values. For
                example, the type consisting of numbers in the range 0 to 100 inclusive may defined
                as </textual><code class="po-atom e376 e376"><textual class="po-textual">&lt;number ge=0 le=100&gt;</textual></code><textual class="po-textual">. (As mentioned earlier, the element
                name </textual><code class="po-atom e377 e377"><textual class="po-textual">number</textual></code><textual class="po-textual"> is redundant, because only a number can satisfy the other
                constraints.) </textual></para><para class="po-block e378 e378"><textual class="po-textual">A </textual><code class="po-atom e379 e379"><textual class="po-textual">step</textual></code><textual class="po-textual"> facet constrains the number to be an integer multiple of the
                given increment. The most common values (both found in our example schema) are 1,
                which requires the value to be an integer, and 0.01, which is often suitable for
                currency amounts. Specifying </textual><code class="po-atom e380 e380"><textual class="po-textual">step=17.2</textual></code><textual class="po-textual"> would be unusual, but is
                perfectly legal. The facet does not constrain the way the value is written, for
                example an integer can be validly written as </textual><code class="po-atom e381 e381"><textual class="po-textual">1.00000</textual></code><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e382 e382"><title class="po-block e383 e383"><textual class="po-textual">Restricting strings</textual></title><para class="po-block e384 e384"><textual class="po-textual">Strings may be restricted using a regular expression, for example
                    </textual><code class="po-atom e385 e385"><textual class="po-textual">&lt;string pattern="[A-Z]*"&gt;</textual></code><textual class="po-textual">. There are no special facets
                for defining a minimum, fixed, or maximum length, since regular expressions are
                sufficient for this purpose.</textual></para></section><section class="po-hcontainer e386 e386"><title class="po-block e387 e387"><textual class="po-textual">Restricting lists</textual></title><para class="po-block e388 e388"><textual class="po-textual">A list can be constrained with a grammar. A grammar is a facet like any other:
                just another way of defining a restriction on the content, and it is defined in the
                same way: </textual><code class="po-atom e389 e389"><textual class="po-textual">&lt;list grammar=....&gt;</textual></code><textual class="po-textual">. A simple grammar might allow a list
                to consist of a sequence of zero or more numbers. This would be defined like
                this:</textual></para><programlisting class="po-block e390 e390" xml:space="preserve"><textual class="po-textual">
&lt;list grammar=&lt;number occurs=[0,]&gt;&gt;                
</textual></programlisting><para class="po-block e391 e391"><textual class="po-textual">To take another example, a grammar might require a value to be a list comprising a
                string, a number, and a boolean. Here is the definition:</textual></para><programlisting class="po-block e392 e392" xml:space="preserve"><textual class="po-textual">
&lt;list grammar=&lt;seq [&lt;string&gt;, &lt;number&gt;, &lt;boolean&gt;]&gt;&gt;                
</textual></programlisting><para class="po-block e393 e393"><textual class="po-textual">Unlike most schema languages in the XML world, grammars can constrain any
                sequence of values, not only a sequence of elements. In principle, if there are
                subtypes of string representing nouns, verbs, and so on, then a grammar could
                constrain a list to contain a sequence of words making up an English
                sentence.</textual></para><para class="po-block e394 e394"><textual class="po-textual">The "alphabet" of the grammar — the set of tokens it recognizes — is the
                set of types. The fact that a value might belong to more than one of these types does not
                matter. The grammar exists not to define an unambiguous parse tree of the input, but
                only to determine whether the input is valid against the type definition or not.</textual></para><para class="po-block e395 e395"><textual class="po-textual">A grammar can be represented as a tree of particles. Each particle consists of
                a term (what does it match?), and a repetition indicator (how often does it match?).
                For leaf particles, the term is a type. Non-leaf particles are either sequence
                particles or choice particles, and in each case the term is the set of child
                particles in the tree.</textual></para><para class="po-block e396 e396"><textual class="po-textual">The value of the </textual><code class="po-atom e397 e397"><textual class="po-textual">grammar</textual></code><textual class="po-textual"> facet is an element representing
                the root particle in this tree.</textual></para><para class="po-block e398 e398"><textual class="po-textual">The three kinds of particle are represented as follows:</textual></para><itemizedlist class="po-table e399 e399"><listitem class="po-container e400 e400"><para class="po-block e401 e401"><textual class="po-textual">A sequence particle is represented by an element named </textual><code class="po-atom e402 e402"><textual class="po-textual">seq</textual></code><textual class="po-textual">; an optional
                            </textual><code class="po-atom e403 e403"><textual class="po-textual">occurs</textual></code><textual class="po-textual"> attribute; and content which is a list containing
                        the child particles in the tree. For example:
                            </textual><code class="po-atom e404 e404"><textual class="po-textual">&lt;seq occurs=[0,] [&lt;white&gt;,&lt;black&gt;]&gt;</textual></code><textual class="po-textual">, which
                        matches an alternating sequence of values of types </textual><code class="po-atom e405 e405"><textual class="po-textual">&lt;white&gt;</textual></code><textual class="po-textual">
                        and </textual><code class="po-atom e406 e406"><textual class="po-textual">&lt;black&gt;</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e407 e407"><para class="po-block e408 e408"><textual class="po-textual">A choice particle is represented by an element named </textual><code class="po-atom e409 e409"><textual class="po-textual">choice</textual></code><textual class="po-textual">; an optional
                            </textual><code class="po-atom e410 e410"><textual class="po-textual">occurs</textual></code><textual class="po-textual"> attribute; and content which is a list containing
                        the child particles in the tree. For example:
                            </textual><code class="po-atom e411 e411"><textual class="po-textual">&lt;choice occurs=[0,] [&lt;white&gt;,&lt;black&gt;]&gt;</textual></code><textual class="po-textual">, which
                        matches sequence of values, each of which can be either of
                            </textual><code class="po-atom e412 e412"><textual class="po-textual">&lt;white&gt;</textual></code><textual class="po-textual"> or </textual><code class="po-atom e413 e413"><textual class="po-textual">&lt;black&gt;</textual></code><textual class="po-textual"> type.</textual></para></listitem><listitem class="po-container e414 e414"><para class="po-block e415 e415"><textual class="po-textual">A leaf particle is represented by the same element used to describe the type, augmented if
                        necessary with an </textual><code class="po-atom e416 e416"><textual class="po-textual">occurs</textual></code><textual class="po-textual"> attribute. For example
                            </textual><code class="po-atom e417 e417"><textual class="po-textual">&lt;number&gt;</textual></code><textual class="po-textual">, or </textual><code class="po-atom e418 e418"><textual class="po-textual">&lt;number occurs=10&gt;</textual></code><textual class="po-textual">.
                        The </textual><code class="po-atom e419 e419"><textual class="po-textual">occurs</textual></code><textual class="po-textual"> attribute defaults to 1; it appears alongside the
                        attributes defining facets of the type, though it is not really a property
                        of the type, but rather of the particle referring to the type.</textual></para></listitem></itemizedlist><para class="po-block e420 e420"><textual class="po-textual">The value of the </textual><code class="po-atom e421 e421"><textual class="po-textual">occurs</textual></code><textual class="po-textual"> attribute is either an integer (indicating a
                fixed number of occurrences), or a list of size two (indicating a range with a
                minimum and maximum). The first item must be an integer, the second can be either
                another integer, or null to indicate an unbounded range. For example
                    </textual><code class="po-atom e422 e422"><textual class="po-textual">[0,1]</textual></code><textual class="po-textual"> indicates an optional particle (zero or one occurrences),
                    </textual><code class="po-atom e423 e423"><textual class="po-textual">[0,]</textual></code><textual class="po-textual"> indicates zero or more, and </textual><code class="po-atom e424 e424"><textual class="po-textual">[1,]</textual></code><textual class="po-textual"> indicates one or
                more. The default is </textual><code class="po-atom e425 e425"><textual class="po-textual">occurs=1</textual></code><textual class="po-textual">.</textual></para><para class="po-block e426 e426"><textual class="po-textual">Some further examples of grammars are shown in the table below:</textual></para><para class="po-block e427 e427"><textual class="po-textual">
                </textual><table class="po-container e428 e428"><caption class="po-container e429 e429"><para class="po-block e430 e430"><textual class="po-textual">Examples of Grammars</textual></para></caption><thead class="po-container e431 e431"><tr class="po-table e432 e432"><th class="po-field e433 e433"><textual class="po-textual">Example</textual></th><th class="po-field e434 e434"><textual class="po-textual">Explanation</textual></th></tr></thead><tbody class="po-table e435 e435"><tr class="po-table e436 e436"><td class="po-block e437 e437"><textual class="po-textual">&lt;seq [&lt;string&gt;, &lt;number&gt;, &lt;number&gt;]&gt;</textual></td><td class="po-block e438 e438"><textual class="po-textual">A string followed by two numbers</textual></td></tr><tr class="po-table e439 e439"><td class="po-block e440 e440"><textual class="po-textual">&lt;seq [&lt;string&gt;, &lt;number occurs=2&gt;]&gt;</textual></td><td class="po-block e441 e441"><textual class="po-textual">A string followed by two numbers</textual></td></tr><tr class="po-table e442 e442"><td class="po-block e443 e443"><textual class="po-textual">&lt;occurs=[0,] &lt;seq [&lt;string&gt;, &lt;number&gt;]&gt;&gt;</textual></td><td class="po-block e444 e444"><textual class="po-textual">An alternating sequence of strings and numbers</textual></td></tr><tr class="po-table e445 e445"><td class="po-block e446 e446"><textual class="po-textual">&lt;enum=["red", "green", "blue"] occurs=[1,]&gt;</textual></td><td class="po-block e447 e447"><textual class="po-textual">A sequence of one or more strings each taken from a defined
                                    set of colour values</textual></td></tr><tr class="po-table e448 e448"><td class="po-block e449 e449"><textual class="po-textual">&lt;occurs=[0,100] &lt;choice [&lt;string&gt;, &lt;number&gt;]&gt;&gt;</textual></td><td class="po-block e450 e450"><textual class="po-textual">A list of up to 100 items, each of which may be either a
                                    string or a number. Note that when the sub-particles of a choice
                                    are leaf particles, an alternative approach is to define a union
                                    type using </textual><code class="po-atom e451 e451"><textual class="po-textual">&lt;anyOf&gt;</textual></code></td></tr></tbody></table><textual class="po-textual">
            </textual></para><para class="po-block e452 e452"><textual class="po-textual">Many of these examples serve the purpose that in XML Schema would be achieved
                using simple types of variety list or union. But of course, in the document markup
                tradition, grammars are commonly used to define sequences of elements, and we will
                see examples of this in the next section.</textual></para></section><section class="po-hcontainer e453 e453"><title class="po-block e454 e454"><textual class="po-textual">Restricting elements</textual></title><para class="po-block e455 e455"><textual class="po-textual">The simplest way to place restrictions on elements is by use of the </textual><code class="po-atom e456 e456"><textual class="po-textual">form</textual></code><textual class="po-textual"> facet. 
            Its value is an element, known as a proforma, which works as follows:</textual></para><itemizedlist class="po-table e457 e457"><listitem class="po-container e458 e458"><para class="po-block e459 e459"><textual class="po-textual">The name of the proforma element constrains the name of the target element.</textual></para></listitem><listitem class="po-container e460 e460"><para class="po-block e461 e461"><textual class="po-textual">The attributes of the proforma element constrain the attributes of the target element.</textual></para></listitem><listitem class="po-container e462 e462"><para class="po-block e463 e463"><textual class="po-textual">The content value of the proforma element constrains the content value of the target
                        element.</textual></para></listitem></itemizedlist><para class="po-block e464 e464"><textual class="po-textual">For example, the proforma:</textual></para><programlisting class="po-block e465 e465" xml:space="preserve"><textual class="po-textual">
                &lt;img height=&lt;number&gt; width=&lt;number&gt; &lt;null&gt;&gt;
            </textual></programlisting><para class="po-block e466 e466"><textual class="po-textual">represents an element whose name must be "img", whose </textual><code class="po-atom e467 e467"><textual class="po-textual">height</textual></code><textual class="po-textual"> and
                    </textual><code class="po-atom e468 e468"><textual class="po-textual">width</textual></code><textual class="po-textual"> attributes must be numbers, and whose content value must be
                absent (null).</textual></para><para class="po-block e469 e469"><textual class="po-textual">This proforma can be used to define an element type like this:</textual></para><programlisting class="po-block e470 e470" xml:space="preserve"><textual class="po-textual">
                &lt;element form=&lt;img height=&lt;number&gt; width=&lt;number&gt; &lt;null&gt;&gt;&gt;
            </textual></programlisting><para class="po-block e471 e471"><textual class="po-textual">Like all facets, a proforma can only define restrictions. If the proforma includes
                no element name, then it places no restrictions on the element name. If a particular
                attribute is not present in the proforma, then it places no restrictions on the
                presence or content of that attribute. If the proforma has no content value, then
                the content value of the target element is unconstrained.</textual></para><para class="po-block e472 e472"><textual class="po-textual">If an attribute is to be optional, this can be indicated by permitting null as the
                value: for example writing </textual><code class="po-atom e473 e473"><textual class="po-textual">height=&lt;nullable&lt;number&gt;&gt;</textual></code><textual class="po-textual">
                indicates that the </textual><code class="po-atom e474 e474"><textual class="po-textual">height</textual></code><textual class="po-textual"> attribute must either be a number, or null.
                Recall that omitting an attribute is the same as giving it a value of null.</textual></para><para class="po-block e475 e475"><textual class="po-textual">Some additional facets are available for elements for use where the proforma construct is
            insufficiently expressive:</textual></para><itemizedlist class="po-table e476 e476"><listitem class="po-container e477 e477"><para class="po-block e478 e478"><textual class="po-textual">The </textual><code class="po-atom e479 e479"><textual class="po-textual">elemName</textual></code><textual class="po-textual"> facet defines the type of the element name.</textual></para><para class="po-block e480 e480"><textual class="po-textual">For example 
                        </textual><code class="po-atom e481 e481"><textual class="po-textual">&lt;element elemName=&lt;enum=["i", "b", "u"]&gt;&gt;</textual></code><textual class="po-textual"> constrains the element
                        name to be one of the names listed.</textual></para></listitem><listitem class="po-container e482 e482"><para class="po-block e483 e483"><textual class="po-textual">The </textual><code class="po-atom e484 e484"><textual class="po-textual">attName</textual></code><textual class="po-textual"> facet defines the type that all attribute names must conform to (for
                        example, as an enumeration, or by means of a pattern). This is the easiest
                        way of prohibiting attributes from appearing (the other way is to constrain
                        the value to be null). For example, </textual><code class="po-atom e485 e485"><textual class="po-textual">attName=&lt;ne="xmlns"&gt;</textual></code><textual class="po-textual">
                        would disallow the attribute name </textual><code class="po-atom e486 e486"><textual class="po-textual">xmlns</textual></code><textual class="po-textual">; this constraint could
                        also be expressed in the proforma as </textual><code class="po-atom e487 e487"><textual class="po-textual">xmlns=&lt;null&gt;</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e488 e488"><para class="po-block e489 e489"><textual class="po-textual">For convenience, as an alternative to using a proforma, the content of the element can be
                        constrained using the </textual><code class="po-atom e490 e490"><textual class="po-textual">content</textual></code><textual class="po-textual"> facet. The value is a type. For
                        example, </textual><code class="po-atom e491 e491"><textual class="po-textual">content=&lt;boolean&gt;</textual></code><textual class="po-textual"> constrains the content to be the
                        boolean value true or false, while </textual><code class="po-atom e492 e492"><textual class="po-textual">content=&lt;null&gt;</textual></code><textual class="po-textual"> constrains
                        it to be null (which can be achieved either by omitting the content, or
                        using the FtanML keyword </textual><code class="po-atom e493 e493"><textual class="po-textual">null</textual></code><textual class="po-textual">).</textual></para></listitem></itemizedlist><para class="po-block e494 e494"><textual class="po-textual">We can now see how to define an element type that participates in the content model of another
            element type. Suppose we have an element named </textual><code class="po-atom e495 e495"><textual class="po-textual">items</textual></code><textual class="po-textual"> whose children are
            elements named </textual><code class="po-atom e496 e496"><textual class="po-textual">item</textual></code><textual class="po-textual"> with string content. We can define the type of </textual><code class="po-atom e497 e497"><textual class="po-textual">items</textual></code><textual class="po-textual">
            like this:</textual></para><programlisting class="po-block e498 e498" xml:space="preserve"><textual class="po-textual">
&lt;element form=
  &lt;items 
    grammar=&lt;element form=&lt;item &lt;string&gt;&gt; occurs=[0,]&gt;
  &gt;  
&gt;</textual></programlisting><para class="po-block e499 e499"><textual class="po-textual">(I find it useful when writing such constructs to ensure that every angle bracket is aligned
            either vertically or horizontally with its partner, and to limit the nesting of angle brackets on a single
            line to about 3.)</textual></para><para class="po-block e500 e500"><textual class="po-textual">Content models like this would quickly become unwieldy if the whole structure had
                to be defined inline. In addition, it would not be possible to reuse types in
                different parts of the model. It is therefore possible for the definition of one
                type to refer to other types by name. The above example could be expressed using named
                types in a schema, thus:</textual></para><programlisting class="po-block e501 e501" xml:space="preserve"><textual class="po-textual">
&lt;types
  itemsType = &lt;element form=&lt;items &lt;grammar=&lt;itemType occurs=[0,]&gt;&gt;&gt;&gt;
  itemType = &lt;element form=&lt;item &lt;string&gt;&gt;&gt;
&gt;</textual></programlisting></section><section class="po-hcontainer e502 e502"><title class="po-block e503 e503"><textual class="po-textual">Restricting Rich Text</textual></title><para class="po-block e504 e504"><textual class="po-textual">Most of the time, the only restriction that needs to be placed on rich
                text is to define what elements may appear within it. This is done with
                an </textual><code class="po-atom e505 e505"><textual class="po-textual">elements</textual></code><textual class="po-textual"> facet, whose value is a type. 
                All elements appearing in the text must conform to this type.</textual></para><para class="po-block e506 e506"><textual class="po-textual">We don't expect it to be used very often, but FtanML also allows rich text to
                be constrained with a grammar. The rules for defining a grammar are exactly the same
                as for lists, and they define the grammar when the text is considered as a list
                containing strings and elements. For example, a grammar might define that the first
                thing to appear is a </textual><code class="po-atom e507 e507"><textual class="po-textual">headword</textual></code><textual class="po-textual"> element, and after that there are no
                constraints.</textual></para></section><section class="po-hcontainer e508 e508"><title class="po-block e509 e509"><textual class="po-textual">Uniqueness and Referential Constraints</textual></title><para class="po-block e510 e510"><textual class="po-textual">As with XML Schema, definition of constraints takes advantage of the processing
                language, so this section contains some forward references to facilities not yet
                introduced.</textual></para><para class="po-block e511 e511"><textual class="po-textual">Uniqueness is enforced by a function-valued facet. For example:</textual></para><programlisting class="po-block e512 e512" xml:space="preserve"><textual class="po-textual">&lt;list unique={$@id}&gt;</textual></programlisting><para class="po-block e513 e513"><textual class="po-textual">expresses a contraint on a list of elements stating that among the elements in
                this list, all attributes named </textual><code class="po-atom e514 e514"><textual class="po-textual">id</textual></code><textual class="po-textual"> must have distinct values. Null
                values are excluded. This facet can be applied to lists and elements; in each case
                the supplied function is used as a mapping function, and is applied to each item in
                the list or each attribute of the element, as if by the </textual><code class="po-atom e515 e515"><textual class="po-textual">!</textual></code><textual class="po-textual"> operator; the
                value is invalid if the resulting list contains any duplicates. So a simple
                constraint that all the numbers in a list of numbers be unique can be expressed as
                    </textual><code class="po-atom e516 e516"><textual class="po-textual">unique={$}</textual></code><textual class="po-textual">; a constraint that the names of the attributes in an
                element should each start with a different letter can be written
                    </textual><code class="po-atom e517 e517"><textual class="po-textual">unique={substring($, 0, 1)}</textual></code><textual class="po-textual">, and a constraint that all the non-null
                attributes of an element should have distinct values can be expressed as
                    </textual><code class="po-atom e518 e518"><textual class="po-textual">unique={$2}</textual></code><textual class="po-textual"> (when a mapping function is applied to an element, the
                first argument </textual><code class="po-atom e519 e519"><textual class="po-textual">$</textual></code><textual class="po-textual"> is the attribute name, and the second argument
                    </textual><code class="po-atom e520 e520"><textual class="po-textual">$2</textual></code><textual class="po-textual"> is the attribute value).</textual></para><para class="po-block e521 e521"><textual class="po-textual">Referential constraints are enforced by a similar facet whose value is a pair of
                functions, one of which selects the references (foreign keys) and one the target
                identifiers (primary keys):</textual></para><para class="po-block e522 e522"><code class="po-atom e523 e523"><textual class="po-textual">&lt;ref=&lt;from={$@ref} to={$@id}&gt;&gt;</textual></code></para><para class="po-block e524 e524"><textual class="po-textual">The rule is that the set of values selected by the </textual><code class="po-atom e525 e525"><textual class="po-textual">from</textual></code><textual class="po-textual"> function
                (again excluding any nulls) must be a subset of the set of values selected by the
                    </textual><code class="po-atom e526 e526"><textual class="po-textual">to</textual></code><textual class="po-textual"> function.</textual></para></section></section><section class="po-hcontainer e527 e527"><title class="po-block e528 e528"><textual class="po-textual">Queries and Transformations: the FtanSkrit Processing Language</textual></title><para class="po-block e529 e529"><textual class="po-textual">FtanSkrit is a functional, weakly-typed, Turing-complete programming language for
                manipulating instances of the FtanML data model. It is an expression language with
                full orthogonality: any expression can be used as an operand of any other
                expression, subject only to rules on operator precedence and type
                constraints.</textual></para><para class="po-block e530 e530"><textual class="po-textual">A program in FtanSkrit is written as a function (a function which typically takes
                a source document as input and produces a result document as its result). The body
                of a function is an expression, and this exposition of the language will focus on
                the different kinds of expression that can be written.</textual></para><para class="po-block e531 e531"><textual class="po-textual">The data model that can result from parsing a FtanML document, as we saw earlier,
            can contain seven types of value: null, boolean, number, string, list, element, and
            text. We also mentioned an eighth type of value, namely a function. Functions can appear
            in the data model anywhere that the other seven types of value can appear, for example
            as the value of an attribute in an element, or as the value of an item in a list.</textual></para><para class="po-block e532 e532"><textual class="po-textual">Because expressions can be nested arbitrarily, it's not easy to define the different
            classes of expression without forward references to concepts that haven't been explained
            yet, and it's also rather difficult to know where to begin. But because functions are so
            important and central, that's where I'll start.</textual></para><section class="po-hcontainer e533 e533"><title class="po-block e534 e534"><textual class="po-textual">Functions</textual></title><para class="po-block e535 e535"><textual class="po-textual">There are two important kinds of expression associated with functions: function
                declarations and function calls.</textual></para><section class="po-hcontainer e536 e536"><title class="po-block e537 e537"><textual class="po-textual">Function Declarations</textual></title><para class="po-block e538 e538"><textual class="po-textual">A function is written as an expression enclosed in curly braces. Here's a
                    function that computes the sum of its two arguments: </textual><code class="po-atom e539 e539"><textual class="po-textual">{$1 +
                    $2}</textual></code></para><para class="po-block e540 e540"><textual class="po-textual">References to parameters are written </textual><code class="po-atom e541 e541"><textual class="po-textual">$1</textual></code><textual class="po-textual">, </textual><code class="po-atom e542 e542"><textual class="po-textual">$2</textual></code><textual class="po-textual"> etc, where
                        </textual><code class="po-atom e543 e543"><textual class="po-textual">$N</textual></code><textual class="po-textual"> refers to the Nth supplied argument in the function call.
                    The expression </textual><code class="po-atom e544 e544"><textual class="po-textual">$</textual></code><textual class="po-textual"> can be used in place of </textual><code class="po-atom e545 e545"><textual class="po-textual">$1</textual></code><textual class="po-textual"> to refer
                    to the first argument, and is particularly useful for functions that expect a
                    single argument. It can be used in rather the same way as </textual><code class="po-atom e546 e546"><textual class="po-textual">.</textual></code><textual class="po-textual"> (the
                    context item) in XPath, and plays a similar role to </textual><code class="po-atom e547 e547"><textual class="po-textual">_</textual></code><textual class="po-textual"> in languages
                    such as Perl or Scala.</textual></para><para class="po-block e548 e548"><textual class="po-textual">For example, a function that returns true if the supplied element has a name
                    might be written </textual><code class="po-atom e549 e549"><textual class="po-textual">{name($) != null}</textual></code><textual class="po-textual">.</textual></para><para class="po-block e550 e550"><textual class="po-textual">Functions have no name, but can be bound to named variables, in which case the
                variable name serves effectively as a function name. Functions in the system library
                are bound to predefined variables. </textual></para><para class="po-block e551 e551"><textual class="po-textual">A function does not have a fixed arity. The example function </textual><code class="po-atom e552 e552"><textual class="po-textual">{$1 +
                        $2}</textual></code><textual class="po-textual"> expects two arguments, but it can be called with more than two
                    arguments (excess arguments are ignored), or with fewer than two (unsupplied
                    arguments default to null).</textual></para><para class="po-block e553 e553"><textual class="po-textual">The expression </textual><code class="po-atom e554 e554"><textual class="po-textual">$$</textual></code><textual class="po-textual"> returns all the supplied arguments in the form
                    of a list. This makes it possible to write functions that take a variable number
                    of arguments: the actual number is accessible as </textual><code class="po-atom e555 e555"><textual class="po-textual">count($$)</textual></code><textual class="po-textual">. </textual></para><para class="po-block e556 e556"><textual class="po-textual">Functions can refer to variables defined outside the function body, which
                    become part of the closure of the function, to be used when it is
                    evaluated.</textual></para><para class="po-block e557 e557"><textual class="po-textual">Within the body of a function, the variable </textual><code class="po-atom e558 e558"><textual class="po-textual">self</textual></code><textual class="po-textual"> is bound to the
                    function itself. This makes it easy to write anonymous recursive functions: for
                    example a function to compute the sum of its arguments can be written as
                        </textual><code class="po-atom e559 e559"><textual class="po-textual">{if empty($$) then 0 else $ + self(tail($$))}</textual></code><textual class="po-textual">. We'll see later
                    how to write mutually-recursive functions.</textual></para><para class="po-block e560 e560"><textual class="po-textual">Because a function is an expression, it can be used anywhere an expression can
                appear; for example as the value of an attribute in an element. This allows an
                element to be used as a map from strings to functions, which is very like
                Javascript's notion of an object. This enables a kind of polymorphism.</textual></para><para class="po-block e561 e561"><textual class="po-textual">Sometimes it is useful to design a function so that parameters are supplied by
                    name rather than positionally. The can be achieved by writing the function to
                    accept an element as its argument. The caller might supply the arguments like
                    this: </textual><code class="po-atom e562 e562"><textual class="po-textual">f(&lt;x=2 y=3&gt;)</textual></code><textual class="po-textual">; and in the function body the supplied values
                    can then be referenced as </textual><code class="po-atom e563 e563"><textual class="po-textual">$@x</textual></code><textual class="po-textual"> or </textual><code class="po-atom e564 e564"><textual class="po-textual">$@y</textual></code><textual class="po-textual">.</textual></para><para class="po-block e565 e565"><textual class="po-textual">Functions do not declare their arguments explicitly. As a matter of convention,
                when writing a public function it is good practice to bind the supplied parameters
                to variables along with a type check. For example the following implementation
                of the </textual><code class="po-atom e566 e566"><textual class="po-textual">indexOf</textual></code><textual class="po-textual"> function starts by giving names to its arguments and checking their type,
                    which simultaneously makes the function more robust and more readable.
                </textual><footnote class="po-popup e567 e567"><para class="po-block e568 e568"><textual class="po-textual">It would be easy enough to add syntax for a more verbose function declaration with
                    an explicit signature. But at this stage, it's important (a) to keep the language small,
                    and (b) to provide a very concise syntax for functions, allowing them to be used as freely
                    and easily as predicates and steps are used in XPath.</textual></para></footnote></para><programlisting class="po-block e569 e569" xml:space="preserve"><textual class="po-textual">
let indexOf = {
  let Array = $1.as(&lt;occurs=[0,] &lt;number&gt;&gt;);
  let Search = $2.as(&lt;number&gt;);
  0..count(Array)-1?{Array[$]=Search}
  }</textual></programlisting><para class="po-block e570 e570"><textual class="po-textual">Because argument types are not declared, it's up to the implementor of a function
                what to do when the caller supplies arguments of the wrong type. There are no implicit conversions
                defined as part of the call mechanism. The preferred approach is to throw an error, which
                can be readily achieved using the coding style in the above example.</textual></para></section><section class="po-hcontainer e571 e571"><title class="po-block e572 e572"><textual class="po-textual">Function Calls</textual></title><para class="po-block e573 e573"><textual class="po-textual">If </textual><code class="po-atom e574 e574"><textual class="po-textual">F</textual></code><textual class="po-textual"> is an expression that evaluates to a function, then the
                        function may be called with arguments </textual><code class="po-atom e575 e575"><textual class="po-textual">x</textual></code><textual class="po-textual"> and </textual><code class="po-atom e576 e576"><textual class="po-textual">y</textual></code><textual class="po-textual"> using
                        the expression </textual><code class="po-atom e577 e577"><textual class="po-textual">F(x, y)</textual></code><textual class="po-textual">.</textual></para><para class="po-block e578 e578"><textual class="po-textual">If </textual><code class="po-atom e579 e579"><textual class="po-textual">f</textual></code><textual class="po-textual"> is a variable whose value is a function, and if the function
                        has at least one argument, then a function call can be written either as
                        </textual><code class="po-atom e580 e580"><textual class="po-textual">f(x,y)</textual></code><textual class="po-textual"> or as </textual><code class="po-atom e581 e581"><textual class="po-textual">x.f(y)</textual></code><textual class="po-textual">. </textual></para><para class="po-block e582 e582"><textual class="po-textual">As in XPath 3.0, partial function application (currying) is possible by
                        supplying </textual><code class="po-atom e583 e583"><textual class="po-textual">?</textual></code><textual class="po-textual"> for one of the arguments: </textual><code class="po-atom e584 e584"><textual class="po-textual">contains(?, ':')</textual></code><textual class="po-textual">
                        returns a function whose effect is to test whether its first argument is a
                        string that contains a colon.</textual></para><para class="po-block e585 e585"><textual class="po-textual">Some built-in functions can also be invoked using an infix operator. For
                        example the </textual><code class="po-atom e586 e586"><textual class="po-textual">+</textual></code><textual class="po-textual"> operator corresponds to the </textual><code class="po-atom e587 e587"><textual class="po-textual">plus</textual></code><textual class="po-textual">
                        function; </textual><code class="po-atom e588 e588"><textual class="po-textual">a + b</textual></code><textual class="po-textual"> has the same meaning as </textual><code class="po-atom e589 e589"><textual class="po-textual">plus(a, b)</textual></code><textual class="po-textual"> or
                        </textual><code class="po-atom e590 e590"><textual class="po-textual">a.plus(b)</textual></code><textual class="po-textual">. All the operators in the language, including higher-order operators, are defined
                        in terms of functions, to allow them to be passed as arguments to higher-order
                        functions.</textual></para><para class="po-block e591 e591"><textual class="po-textual">The names of built-in functions always use the ASCII alphabet; for
                        some operators we have allowed ourselves the luxury of reaching beyond ASCII,
                        but users can always avoid relying on such operators and can use the function
                        name instead.</textual></para></section></section><section class="po-hcontainer e592 e592"><title class="po-block e593 e593"><textual class="po-textual">List and Element Constructors</textual></title><para class="po-block e594 e594"><textual class="po-textual">The syntax of lists and elements is extended so that expressions may appear
                anywhere the FtanML syntax allows a value. </textual></para><para class="po-block e595 e595"><textual class="po-textual">For example, the expression </textual><code class="po-atom e596 e596"><textual class="po-textual">{[$, $+1, $+2]}(5)</textual></code><textual class="po-textual"> returns the list [5,
                6, 7].</textual></para><para class="po-block e597 e597"><textual class="po-textual">Lists in FtanML are not automatically flattened, so the expression </textual><code class="po-atom e598 e598"><textual class="po-textual">[1 to 5,
                    10]</textual></code><textual class="po-textual"> produces the length-2 list </textual><code class="po-atom e599 e599"><textual class="po-textual">[[1,2,3,4,5],10]</textual></code><textual class="po-textual"> rather than
                the length-6 list </textual><code class="po-atom e600 e600"><textual class="po-textual">[1,2,3,4,5,10]</textual></code><textual class="po-textual">. The latter result can be achieved
                either by applying the </textual><code class="po-atom e601 e601"><textual class="po-textual">flatten()</textual></code><textual class="po-textual"> function explicitly, or by using list
                concatenation/append operators: for example </textual><code class="po-atom e602 e602"><textual class="po-textual">(1..5).append(10)</textual></code><textual class="po-textual">.</textual></para><para class="po-block e603 e603"><textual class="po-textual">In an element constructor, expressions can be used to compute the values of
                attributes, but cannot be used to compute their names. The value can be expressed
                either as a parenthesized expression, or using a string or text value containing
                expressions embedded in curly braces: </textual><code class="po-atom e604 e604"><textual class="po-textual">&lt;img size=(x+1) caption="Figure
                    {n}"&gt;</textual></code><textual class="po-textual">. The same applies to the content value. Note that curly braces are
                used only for inline expansion of strings and text (and for writing functions); to
                compute general structured content, parenthesized expressions should be used. The
                expression:</textual></para><programlisting class="po-block e605 e605" xml:space="preserve"><textual class="po-textual">&lt;job-titles (distinct-values(employee@job-title))&gt;</textual></programlisting><para class="po-block e606 e606"><textual class="po-textual">might generate</textual></para><programlisting class="po-block e607 e607" xml:space="preserve"><textual class="po-textual">&lt;job-titles ["Manager", "Programmer", "Bottle-Washer"]&gt;</textual></programlisting><para class="po-block e608 e608"><textual class="po-textual">A null value for an attribute indicates the effective absence of the attribute, so
                the expression </textual><code class="po-atom e609 e609"><textual class="po-textual">&lt;size x=(a+1) y=(if a=2 then 3 else null)&gt;</textual></code><textual class="po-textual"> might
                produce the output </textual><code class="po-atom e610 e610"><textual class="po-textual">&lt;size x=3&gt;</textual></code><textual class="po-textual">.</textual></para><para class="po-block e611 e611"><textual class="po-textual">More specifically, in an element constructor, the value of an attribute, or of the
                content value, can take any of the following forms:</textual></para><itemizedlist class="po-table e612 e612"><listitem class="po-container e613 e613"><para class="po-block e614 e614"><textual class="po-textual">A literal value, for example </textual><code class="po-atom e615 e615"><textual class="po-textual">a=3</textual></code><textual class="po-textual"> or </textual><code class="po-atom e616 e616"><textual class="po-textual">a="blue"</textual></code><textual class="po-textual"> or
                        </textual><code class="po-atom e617 e617"><textual class="po-textual">a=false</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e618 e618"><para class="po-block e619 e619"><textual class="po-textual">A string or text value with embedded expressions enclosed between curly braces, for example
                            </textual><code class="po-atom e620 e620"><textual class="po-textual">a="Chapter {n}"</textual></code><textual class="po-textual"> The value of the attribute is obtained by
                        evaluating the embedded expressions as strings and inserting the resulting
                        strings into the text.</textual></para></listitem><listitem class="po-container e621 e621"><para class="po-block e622 e622"><textual class="po-textual">A list constructor, for example </textual><code class="po-atom e623 e623"><textual class="po-textual">a=[n, n+1, n+2]</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e624 e624"><para class="po-block e625 e625"><textual class="po-textual">An element constructor, for example </textual><code class="po-atom e626 e626"><textual class="po-textual">a=&lt;x=(n+1) y=(n+2)&gt;</textual></code></para></listitem><listitem class="po-container e627 e627"><para class="po-block e628 e628"><textual class="po-textual">A parenthesized expression, for example </textual><code class="po-atom e629 e629"><textual class="po-textual">a=(n+1)</textual></code></para></listitem><listitem class="po-container e630 e630"><para class="po-block e631 e631"><textual class="po-textual">A function, for example </textual><code class="po-atom e632 e632"><textual class="po-textual">a={$+1}</textual></code><textual class="po-textual">. In this case the value of
                        the attribute is the function, not the result of evaluating the
                        function.</textual></para></listitem></itemizedlist><para class="po-block e633 e633"><textual class="po-textual">Where element constructors cannot be used because the element or attribute names
                are not known statically, functions can be used to construct an element. For
                example:</textual></para><programlisting class="po-block e634 e634" xml:space="preserve"><textual class="po-textual">
element("img").add("x", 3).add("y", 5).add("", "An image")
}</textual></programlisting><para class="po-block e635 e635"><textual class="po-textual">Here the function call </textual><code class="po-atom e636 e636"><textual class="po-textual">element("img")</textual></code><textual class="po-textual"> constructs an element with a
                given name, and the </textual><code class="po-atom e637 e637"><textual class="po-textual">add()</textual></code><textual class="po-textual"> function adds an attribute with a given name
                and value (copying the element to create a new element). The last call adds the
                element content, represented as an attribute with an empty name. It should be
                remembered that although we use the term "element", FtanML elements will not only be
                used in the way that XML elements are traditionally used, but also in the way that
                maps are used in other programming languages, where the keys (attribute names) are
                highly dynamic: indeed, to satisfy the kind of use cases for which maps are being
                added to XSLT 3.0.</textual></para><para class="po-block e638 e638"><textual class="po-textual">Rich text (mixed content) is constructed as a list of strings and elements, which
                is then converted to rich text by applying the </textual><code class="po-atom e639 e639"><textual class="po-textual">toText()</textual></code><textual class="po-textual">
                function.</textual></para></section><section class="po-hcontainer e640 e640"><title class="po-block e641 e641"><textual class="po-textual">Conditional Expressions</textual></title><para class="po-block e642 e642"><textual class="po-textual">The syntax for a conditional expression is:</textual></para><programlisting class="po-block e643 e643" xml:space="preserve"><textual class="po-textual">
                "if" expression "then" expression "else" expression
            </textual></programlisting><para class="po-block e644 e644"><textual class="po-textual">There is no need for parentheses (though you can use them if you like, for old
                time's sake). The "else" branch is mandatory, partly to avoid choosing an arbitrary
                default (null?) and partly to prevent the dangling-else ambiguity when conditional
                expressions are nested. For example:</textual></para><programlisting class="po-block e645 e645" xml:space="preserve"><textual class="po-textual">
 if $ = 0 then x else y
 </textual></programlisting><para class="po-block e646 e646"><textual class="po-textual">A simple try/catch construct is provided:</textual></para><programlisting class="po-block e647 e647" xml:space="preserve"><textual class="po-textual">
                "try" expression "catch" function
            </textual></programlisting><para class="po-block e648 e648"><textual class="po-textual">which returns the result of the expression unless an error occurs during its
                    evaluation, in which case the catch function is called, supplying error
                    information as its argument, in the form of an element with attributes
                    representing the error code and error description.</textual></para><para class="po-block e649 e649"><textual class="po-textual">For example, the following catches a divide-by-zero error (we assume use of
                    the XPath error codes), and returns null if it occurs; otherwise the error is
                    re-thrown:</textual></para><programlisting class="po-block e650 e650" xml:space="preserve"><textual class="po-textual">
                try (x.div(n)) catch {if $@code="FOAR0001" then null else error($)}
            </textual></programlisting><para class="po-block e651 e651"><textual class="po-textual">A function </textual><code class="po-atom e652 e652"><textual class="po-textual">orElse</textual></code><textual class="po-textual"> allows a default to be substituted when a value
                is null. For example </textual><code class="po-atom e653 e653"><textual class="po-textual">a.orElse(0)</textual></code><textual class="po-textual"> returns the value of </textual><code class="po-atom e654 e654"><textual class="po-textual">a</textual></code><textual class="po-textual">
                unless it is null, in which case it returns zero. This function could be defined as
                    </textual><code class="po-atom e655 e655"><textual class="po-textual">{if $1=null then $2 else $1}</textual></code><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e656 e656"><title class="po-block e657 e657"><textual class="po-textual">Variables</textual></title><para class="po-block e658 e658"><textual class="po-textual">Variables have simple names (no "$" prefix, no backticks). The names
                    </textual><code class="po-atom e659 e659"><textual class="po-textual">true</textual></code><textual class="po-textual">, </textual><code class="po-atom e660 e660"><textual class="po-textual">false</textual></code><textual class="po-textual">, and </textual><code class="po-atom e661 e661"><textual class="po-textual">null</textual></code><textual class="po-textual"> are reserved: they
                are used syntactically like variables, but have fixed predefined values. Language
                keywords such as </textual><code class="po-atom e662 e662"><textual class="po-textual">if</textual></code><textual class="po-textual"> and </textual><code class="po-atom e663 e663"><textual class="po-textual">let</textual></code><textual class="po-textual"> are also reserved: unlike
                XPath, this is possible because bare names are not used to refer to elements and
                attributes in input documents.</textual></para><para class="po-block e664 e664"><textual class="po-textual">Variables may be declared using the construct:</textual></para><programlisting class="po-block e665 e665" xml:space="preserve"><textual class="po-textual">
                LetExpression ::= "let" name "=" expression; expression
            </textual></programlisting><para class="po-block e666 e666"><textual class="po-textual">which evaluates the second expression with the named variable bound to the
                value of the first expression; for example </textual><code class="po-atom e667 e667"><textual class="po-textual">let x=2; x+x</textual></code><textual class="po-textual"> returns
                4.</textual></para><para class="po-block e668 e668"><textual class="po-textual">Variables declared in this way are available only after they have been
                    declared. An alternative style of declaration allows forwards references to
                    variables, which is necessary when writing recursive functions. This style uses
                    element notation: </textual></para><programlisting class="po-block e669 e669" xml:space="preserve"><textual class="po-textual">
                let &lt;
                  even = {if $=0 then true else odd(abs($)-1)}
                  odd  = {if $=0 then false else even(abs($)-1)}
                &gt;;
                even(32)
            </textual></programlisting><para class="po-block e670 e670"><textual class="po-textual">With this approach, all the variables declared as attributes of the same
                    element are in scope within each others' declarations, failing dynamically (or
                    in the worst case, failing to finish) if this results in non-terminating
                    recursion.</textual></para></section><section class="po-hcontainer e671 e671"><title class="po-block e672 e672"><textual class="po-textual">Equality and Other Comparisons</textual></title><para class="po-block e673 e673"><textual class="po-textual">The </textual><code class="po-atom e674 e674"><textual class="po-textual">eq</textual></code><textual class="po-textual"> function (operator </textual><code class="po-atom e675 e675"><textual class="po-textual">=</textual></code><textual class="po-textual">) is defined over all
                values. To be equal, two values must have the same fundamental type (this means, for
                example, that the string </textual><code class="po-atom e676 e676"><textual class="po-textual">"John"</textual></code><textual class="po-textual"> is not equal to the rich text
                    </textual><code class="po-atom e677 e677"><textual class="po-textual">|John|</textual></code><textual class="po-textual">). Strings are compared codepoint-by-codepoint. Lists are
                equal if they have the same size and their items are pairwise equal. Elements are
                equal if they have the same name, and if there is a one-to-one correspondence of
                attributes in which both the attribute names and the corresponding values are equal
                (the content value is treated here as an attribute). Two texts are equal if the two
                sequences of strings and elements making up the texts are pairwise equal.</textual></para><para class="po-block e678 e678"><textual class="po-textual">Defining equality for functions requires further work. Some languages such as
                ML and Haskell make equality of functions undefined, but this would mean that
                equality of lists and elements containing functions also becomes undefined.
                Currently my preference is to make equality of functions implementation-defined,
                subject to the proviso that two functions can only be equal if all invocations are
                guaranteed to return equal results. It would be useful to attempt a more careful
                definition, for example one that guarantees that the result of the expression
                    </textual><code class="po-atom e679 e679"><textual class="po-textual">let a=b; a=b</textual></code><textual class="po-textual"> is always true, but formalizing this is not easy
                without introducing some notion of identity.</textual></para><para class="po-block e680 e680"><textual class="po-textual">The </textual><code class="po-atom e681 e681"><textual class="po-textual">ne</textual></code><textual class="po-textual"> function (operator </textual><code class="po-atom e682 e682"><textual class="po-textual">!=</textual></code><textual class="po-textual">) is the inverse of
                        </textual><code class="po-atom e683 e683"><textual class="po-textual">eq</textual></code><textual class="po-textual">.</textual></para><para class="po-block e684 e684"><textual class="po-textual">Ordering (specifically, the functions </textual><code class="po-atom e685 e685"><textual class="po-textual">le</textual></code><textual class="po-textual">, </textual><code class="po-atom e686 e686"><textual class="po-textual">lt</textual></code><textual class="po-textual">,
                        </textual><code class="po-atom e687 e687"><textual class="po-textual">ge</textual></code><textual class="po-textual">, </textual><code class="po-atom e688 e688"><textual class="po-textual">gt</textual></code><textual class="po-textual">, and their corresponding operators
                        </textual><code class="po-atom e689 e689"><textual class="po-textual">&lt;=</textual></code><textual class="po-textual">, </textual><code class="po-atom e690 e690"><textual class="po-textual">&lt;</textual></code><textual class="po-textual">, </textual><code class="po-atom e691 e691"><textual class="po-textual">&gt;=</textual></code><textual class="po-textual">,
                        </textual><code class="po-atom e692 e692"><textual class="po-textual">&gt;=</textual></code><textual class="po-textual">) is defined over numbers and strings only. Strings are
                    sorted in Unicode codepoint sequence.</textual></para><para class="po-block e693 e693"><textual class="po-textual">Testing whether a value </textual><code class="po-atom e694 e694"><textual class="po-textual">V</textual></code><textual class="po-textual"> is present in a list </textual><code class="po-atom e695 e695"><textual class="po-textual">A</textual></code><textual class="po-textual">
                (the equivalent of the </textual><code class="po-atom e696 e696"><textual class="po-textual">=</textual></code><textual class="po-textual"> operator in XPath) is sufficiently common that
                we provide a function, </textual><code class="po-atom e697 e697"><textual class="po-textual">in(V, A)</textual></code><textual class="po-textual"> with corresponding operator ∊ (x220A).
                The function </textual><code class="po-atom e698 e698"><textual class="po-textual">in(V, A)</textual></code><textual class="po-textual"> can be defined as </textual><code class="po-atom e699 e699"><textual class="po-textual">{let V=$1; let A=$2;
                    exists(A?{$=V})}</textual></code><textual class="po-textual">. (This uses a filter operator which we will introduce in
                due course.)</textual></para><para class="po-block e700 e700"><textual class="po-textual">A collation is modelled as a set of functions. Specifically, a collation for a
                particular language, say Swedish, is obtained using the function call
                    </textual><code class="po-atom e701 e701"><textual class="po-textual">collation(&lt;lang="se"&gt;)</textual></code><textual class="po-textual">. This returns an element, whose
                attributes are functions. One of these functions is a sort function, so to sort a
                list of strings using Swedish collation, one can write
                    </textual><code class="po-atom e702 e702"><textual class="po-textual">collation(&lt;lang="se"&gt;)@sort(input)</textual></code><textual class="po-textual">. Other functions available as
                attributes of a collation include comparison functions </textual><code class="po-atom e703 e703"><textual class="po-textual">eq</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e704 e704"><textual class="po-textual">le</textual></code><textual class="po-textual">, etc, and collation-sensitive versions of other functions that
                involve string comparison such as </textual><code class="po-atom e705 e705"><textual class="po-textual">in</textual></code><textual class="po-textual">, </textual><code class="po-atom e706 e706"><textual class="po-textual">min</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e707 e707"><textual class="po-textual">max</textual></code><textual class="po-textual">, </textual><code class="po-atom e708 e708"><textual class="po-textual">indexOf</textual></code><textual class="po-textual">, </textual><code class="po-atom e709 e709"><textual class="po-textual">contains</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e710 e710"><textual class="po-textual">startsWith</textual></code><textual class="po-textual">, </textual><code class="po-atom e711 e711"><textual class="po-textual">endsWith</textual></code><textual class="po-textual">, </textual><code class="po-atom e712 e712"><textual class="po-textual">substringAfter</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e713 e713"><textual class="po-textual">substringBefore</textual></code><textual class="po-textual">.</textual></para><para class="po-block e714 e714"><textual class="po-textual">Comparing </textual><code class="po-atom e715 e715"><textual class="po-textual">A = null</textual></code><textual class="po-textual"> returns true if </textual><code class="po-atom e716 e716"><textual class="po-textual">A</textual></code><textual class="po-textual"> is null, 
                false otherwise. (This is not as obvious as it might seem, given the semantics in some
                other languages.)</textual></para></section><section class="po-hcontainer e717 e717"><title class="po-block e718 e718"><textual class="po-textual">Operations involving Types</textual></title><para class="po-block e719 e719"><textual class="po-textual">The function </textual><code class="po-atom e720 e720"><textual class="po-textual">isA</textual></code><textual class="po-textual"> tests whether a value belongs to a given type.
                    Types are represented using the element representation introduced in an earlier
                    section. For example, </textual><code class="po-atom e721 e721"><textual class="po-textual">x.isA(&lt;number ge=0&gt;)</textual></code><textual class="po-textual"> returns true if the
                    value of </textual><code class="po-atom e722 e722"><textual class="po-textual">x</textual></code><textual class="po-textual"> is a number and satisfies the facet </textual><code class="po-atom e723 e723"><textual class="po-textual">ge=0</textual></code><textual class="po-textual">.
                    Recall that a type is a predicate, not a label associated with a value, so this
                    tests whether the value meets all the constraints defined by the type, not
                    whether the value carries any particular type label.</textual></para><para class="po-block e724 e724"><textual class="po-textual">For convenience, the functions </textual><code class="po-atom e725 e725"><textual class="po-textual">isNull</textual></code><textual class="po-textual">, </textual><code class="po-atom e726 e726"><textual class="po-textual">isBoolean</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e727 e727"><textual class="po-textual">isNumber</textual></code><textual class="po-textual">, </textual><code class="po-atom e728 e728"><textual class="po-textual">isString</textual></code><textual class="po-textual">, </textual><code class="po-atom e729 e729"><textual class="po-textual">isList</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e730 e730"><textual class="po-textual">isElement</textual></code><textual class="po-textual">, </textual><code class="po-atom e731 e731"><textual class="po-textual">isText</textual></code><textual class="po-textual">, and </textual><code class="po-atom e732 e732"><textual class="po-textual">isFunction</textual></code><textual class="po-textual"> are
                available to test for membership of the primitive types.</textual></para><para class="po-block e733 e733"><textual class="po-textual">The function </textual><code class="po-atom e734 e734"><textual class="po-textual">as</textual></code><textual class="po-textual"> is similar to </textual><code class="po-atom e735 e735"><textual class="po-textual">isA</textual></code><textual class="po-textual">, but instead of
                    returning a boolean indicating whether or not the value is a member of the type,
                    it returns the value unchanged if this is the case, and throws an error
                    otherwise. We saw this function used to check the arguments to a function call.</textual></para><para class="po-block e736 e736"><textual class="po-textual">For convenience, the functions </textual><code class="po-atom e737 e737"><textual class="po-textual">asNull</textual></code><textual class="po-textual">, </textual><code class="po-atom e738 e738"><textual class="po-textual">asBoolean</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e739 e739"><textual class="po-textual">asNumber</textual></code><textual class="po-textual">, </textual><code class="po-atom e740 e740"><textual class="po-textual">asString</textual></code><textual class="po-textual">, </textual><code class="po-atom e741 e741"><textual class="po-textual">asList</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e742 e742"><textual class="po-textual">asElement</textual></code><textual class="po-textual">, </textual><code class="po-atom e743 e743"><textual class="po-textual">asText</textual></code><textual class="po-textual">, and </textual><code class="po-atom e744 e744"><textual class="po-textual">asFunction</textual></code><textual class="po-textual"> are
                available to test for membership of the primitive types. In each case, they return
                the argument unchanged if it matches the corresponding type, or throw an error
                otherwise.</textual></para><para class="po-block e745 e745"><textual class="po-textual">Functions for conversion of values have names such as </textual><code class="po-atom e746 e746"><textual class="po-textual">toString</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e747 e747"><textual class="po-textual">toList</textual></code><textual class="po-textual">, and </textual><code class="po-atom e748 e748"><textual class="po-textual">toText</textual></code><textual class="po-textual">. There are no general rules here;
                as in other languages, the rules for what can be converted to what are inherently
                ad-hoc. </textual></para><para class="po-block e749 e749"><textual class="po-textual">The </textual><code class="po-atom e750 e750"><textual class="po-textual">parse</textual></code><textual class="po-textual"> function takes a FtanML lexical representation of a value
                and returns the corresponding value; conversely, </textual><code class="po-atom e751 e751"><textual class="po-textual">serialize</textual></code><textual class="po-textual"> takes a
                value and returns its FtanML lexical representation. </textual></para></section><section class="po-hcontainer e752 e752"><title class="po-block e753 e753"><textual class="po-textual">Boolean Functions and Operators</textual></title><para class="po-block e754 e754"><textual class="po-textual">The functions </textual><code class="po-atom e755 e755"><textual class="po-textual">and</textual></code><textual class="po-textual">, </textual><code class="po-atom e756 e756"><textual class="po-textual">or</textual></code><textual class="po-textual">, and </textual><code class="po-atom e757 e757"><textual class="po-textual">not</textual></code><textual class="po-textual"> are
                    available. The first two have equivalent operators </textual><code class="po-atom e758 e758"><textual class="po-textual">&amp;&amp;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e759 e759"><textual class="po-textual">||</textual></code><textual class="po-textual">.</textual></para><para class="po-block e760 e760"><textual class="po-textual">The argument must either be a boolean or null; there is no implicit conversion
                to boolean as in XPath. If an argument is null, the operators implement three-valued
                logic as in SQL, for example </textual><code class="po-atom e761 e761"><textual class="po-textual">(null||true)</textual></code><textual class="po-textual"> is </textual><code class="po-atom e762 e762"><textual class="po-textual">true</textual></code><textual class="po-textual">.</textual></para><para class="po-block e763 e763"><textual class="po-textual">Order of evaluation is not defined; programmers should not assume that the
                second argument will only be evaluated if it is required. (This rule might seem
                unnecessary in the absence of side-effects, but it becomes important when defining
                the terminating conditions of a recursive function. Like XPath, we choose to allow
                optimizers the freedom to re-order the terms in a predicate, which can be important
                when indexes are available on large data sets.)</textual></para></section><section class="po-hcontainer e764 e764"><title class="po-block e765 e765"><textual class="po-textual">Numeric Functions and Operators</textual></title><para class="po-block e766 e766"><textual class="po-textual">The functions </textual><code class="po-atom e767 e767"><textual class="po-textual">plus</textual></code><textual class="po-textual">, </textual><code class="po-atom e768 e768"><textual class="po-textual">minus</textual></code><textual class="po-textual">, </textual><code class="po-atom e769 e769"><textual class="po-textual">times</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e770 e770"><textual class="po-textual">div</textual></code><textual class="po-textual">, </textual><code class="po-atom e771 e771"><textual class="po-textual">idiv</textual></code><textual class="po-textual">, and </textual><code class="po-atom e772 e772"><textual class="po-textual">mod</textual></code><textual class="po-textual"> are defined; the first
                four have corresponding operators </textual><code class="po-atom e773 e773"><textual class="po-textual">+</textual></code><textual class="po-textual">, </textual><code class="po-atom e774 e774"><textual class="po-textual">-</textual></code><textual class="po-textual">, </textual><code class="po-atom e775 e775"><textual class="po-textual">*</textual></code><textual class="po-textual">,
                and </textual><code class="po-atom e776 e776"><textual class="po-textual">/</textual></code><textual class="po-textual">. Arithmetic is performed in decimal. Division by zero is an
                error; the precision of the result of division is implementation-defined, as are
                limits on the value space.</textual></para><para class="po-block e777 e777"><textual class="po-textual">Additional functions </textual><code class="po-atom e778 e778"><textual class="po-textual">abs</textual></code><textual class="po-textual">, </textual><code class="po-atom e779 e779"><textual class="po-textual">round</textual></code><textual class="po-textual">, </textual><code class="po-atom e780 e780"><textual class="po-textual">floor</textual></code><textual class="po-textual">,
                        </textual><code class="po-atom e781 e781"><textual class="po-textual">ceiling</textual></code><textual class="po-textual"> have the same effect as in XPath.</textual></para><para class="po-block e782 e782"><textual class="po-textual">The function </textual><code class="po-atom e783 e783"><textual class="po-textual">parse</textual></code><textual class="po-textual"> may be used to convert a string to a number.
                    Writing </textual><code class="po-atom e784 e784"><textual class="po-textual">parse(X).asA(&lt;number&gt;)</textual></code><textual class="po-textual"> checks that the value was
                    indeed numeric.</textual></para><para class="po-block e785 e785"><textual class="po-textual">Supplying null to an arithmetic function or operator results in the value
                    null. Supplying any other non-numeric value causes an error. There is no
                    implicit conversion of strings to numbers.</textual></para><para class="po-block e786 e786"><textual class="po-textual">Aggregation functions </textual><code class="po-atom e787 e787"><textual class="po-textual">sum</textual></code><textual class="po-textual">, </textual><code class="po-atom e788 e788"><textual class="po-textual">avg</textual></code><textual class="po-textual">, </textual><code class="po-atom e789 e789"><textual class="po-textual">min</textual></code><textual class="po-textual">,
                    </textual><code class="po-atom e790 e790"><textual class="po-textual">max</textual></code><textual class="po-textual"> work as in XPath.</textual></para><para class="po-block e791 e791"><textual class="po-textual">The function </textual><code class="po-atom e792 e792"><textual class="po-textual">to</textual></code><textual class="po-textual"> or its equivalent operator </textual><code class="po-atom e793 e793"><textual class="po-textual">..</textual></code><textual class="po-textual">
                returns a list of consecutive integers, for example </textual><code class="po-atom e794 e794"><textual class="po-textual">1..5</textual></code><textual class="po-textual"> returns the
                list </textual><code class="po-atom e795 e795"><textual class="po-textual">[1,2,3,4,5]</textual></code><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e796 e796"><title class="po-block e797 e797"><textual class="po-textual">String Functions and Operators</textual></title><para class="po-block e798 e798"><textual class="po-textual">The </textual><code class="po-atom e799 e799"><textual class="po-textual">toString</textual></code><textual class="po-textual"> function can be applied to any value without
                exception to convert it to a string. If the input is already a string, it is
                returned unchanged. If the input is a boolean, number, or null, the result is the
                same as the FtanML literal representation of the value. If the input is a list, the
                result is </textual><code class="po-atom e800 e800"><textual class="po-textual">string-join($!toString, " ")</textual></code><textual class="po-textual">, that is, the space-separated
                concatenation of the string values of the members of the array. If the input is an
                element, the result is </textual><code class="po-atom e801 e801"><textual class="po-textual">string(content($))</textual></code><textual class="po-textual">, that is, the string value of
                the element's content. If the input is rich text, the result is
                    </textual><code class="po-atom e802 e802"><textual class="po-textual">string-join($.toList()!toString)</textual></code><textual class="po-textual">, that is, the concatenation
                (without space separation) of the string-values of the strings and elements making
                up the text. If the value is a function, the resulting string begins with "{" and
                ends with "}", and is otherwise implementation-defined; it is not necessarily a
                string that can be parsed and executed as a function.</textual></para><para class="po-block e803 e803"><textual class="po-textual">String concatenation can be achieved conveniently using string templates, for
                example </textual><code class="po-atom e804 e804"><textual class="po-textual">"See section {s} in chapter {n}"</textual></code><textual class="po-textual">. This mechanism can be used
                wherever a string literal is permitted. The result of the enclosed expressions is
                converted to a string if necessary, by using the </textual><code class="po-atom e805 e805"><textual class="po-textual">toString</textual></code><textual class="po-textual">
                function.</textual></para><para class="po-block e806 e806"><textual class="po-textual">Generally FtanSkrit avoids implicit conversion. For example, if rich text is
                to be compared to a string, it must be converted to a string explicitly. When null
                is supplied to a function that expects a string, it is generally treated as a
                zero-length string (but this is a convention adopted by the functions in the
                built-in function library; it is not a feature of the language). </textual></para><para class="po-block e807 e807"><textual class="po-textual">Other functions are available as in XPath. Counting of characters in a string,
                    however, starts at zero. The basic built-in functions use codepoint collation;
                    equivalents using a different collation can be obtained as attributes of the
                    collation.</textual></para></section><section class="po-hcontainer e808 e808"><title class="po-block e809 e809"><textual class="po-textual">Functions and Operators on Lists</textual></title><para class="po-block e810 e810"><textual class="po-textual">The number of items in a list </textual><code class="po-atom e811 e811"><textual class="po-textual">A</textual></code><textual class="po-textual"> is obtained using
                    </textual><code class="po-atom e812 e812"><textual class="po-textual">count(A)</textual></code><textual class="po-textual"> (or equivalently, </textual><code class="po-atom e813 e813"><textual class="po-textual">A.count()</textual></code><textual class="po-textual">).</textual></para><para class="po-block e814 e814"><textual class="po-textual">The construct </textual><code class="po-atom e815 e815"><textual class="po-textual">A[n]</textual></code><textual class="po-textual"> selects the n'th item in list </textual><code class="po-atom e816 e816"><textual class="po-textual">A</textual></code><textual class="po-textual">.
                This construct is never used for filtering, only for subscripting. If </textual><code class="po-atom e817 e817"><textual class="po-textual">n</textual></code><textual class="po-textual">
                is out of range, the expression returns null. This operation is also available as a
                function </textual><code class="po-atom e818 e818"><textual class="po-textual">itemAt(A, n)</textual></code><textual class="po-textual">.</textual></para><para class="po-block e819 e819"><textual class="po-textual">The function </textual><code class="po-atom e820 e820"><textual class="po-textual">cat(a, a)</textual></code><textual class="po-textual"> (operator </textual><code class="po-atom e821 e821"><textual class="po-textual">++</textual></code><textual class="po-textual">) concatenates
                two lists. The function </textual><code class="po-atom e822 e822"><textual class="po-textual">append(a, i)</textual></code><textual class="po-textual"> (operator </textual><code class="po-atom e823 e823"><textual class="po-textual">+~</textual></code><textual class="po-textual">) appends
                an item to a list, while </textual><code class="po-atom e824 e824"><textual class="po-textual">prepend(i, a)</textual></code><textual class="po-textual"> (operator </textual><code class="po-atom e825 e825"><textual class="po-textual">~+</textual></code><textual class="po-textual">)
                prepends. Thus for example </textual><code class="po-atom e826 e826"><textual class="po-textual">0 ~+ [1,2,3] ++ [4,5,6] +~ 7</textual></code><textual class="po-textual"> returns the
                list </textual><code class="po-atom e827 e827"><textual class="po-textual">[0, 1, 2, 3, 4, 5, 6, 7]</textual></code><textual class="po-textual">. </textual></para><para class="po-block e828 e828"><textual class="po-textual">The function </textual><code class="po-atom e829 e829"><textual class="po-textual">head(a)</textual></code><textual class="po-textual"> is equivalent to </textual><code class="po-atom e830 e830"><textual class="po-textual">a[0]</textual></code><textual class="po-textual">, while
                        </textual><code class="po-atom e831 e831"><textual class="po-textual">tail(a)</textual></code><textual class="po-textual"> equates to </textual><code class="po-atom e832 e832"><textual class="po-textual">remove(a, 0)</textual></code><textual class="po-textual">.</textual></para><para class="po-block e833 e833"><textual class="po-textual">The function </textual><code class="po-atom e834 e834"><textual class="po-textual">flatten</textual></code><textual class="po-textual"> flattens a list: it creates a new list in
                which any non-list items in the argument list are copied to the new list, and any
                list items are processed by copying their contents. This only works one level deep.
                So </textual><code class="po-atom e835 e835"><textual class="po-textual">flatten([[1,2],[3,[4,5]]])</textual></code><textual class="po-textual"> returns
                </textual><code class="po-atom e836 e836"><textual class="po-textual">[1,2,3,[4,5]]</textual></code><textual class="po-textual">.</textual></para><para class="po-block e837 e837"><textual class="po-textual">Functions </textual><code class="po-atom e838 e838"><textual class="po-textual">index-of</textual></code><textual class="po-textual">, </textual><code class="po-atom e839 e839"><textual class="po-textual">remove</textual></code><textual class="po-textual">, </textual><code class="po-atom e840 e840"><textual class="po-textual">subsequence</textual></code><textual class="po-textual">
                work as in XPath, except that indexing starts at zero. The
                    </textual><code class="po-atom e841 e841"><textual class="po-textual">insert-before</textual></code><textual class="po-textual"> function inserts a single item at a specified
                position; if the supplied item is a list, it becomes a nested list (there is no
                flattening).</textual></para><para class="po-block e842 e842"><textual class="po-textual">The function </textual><code class="po-atom e843 e843"><textual class="po-textual">toList</textual></code><textual class="po-textual"> works as follows: if the argument is a list,
                it is returned unchanged. If the argument is rich text, it is converted to a list
                whose members are (non-zero-length) strings and elements. In other cases, the
                function creates and returns a singleton list in which the argument is the only
                item. This function is useful because it makes it easier to process different types
                of content in the same way: a single element looks the same as a list of elements of
                length one, which looks the same as mixed content comprising a single element; a
                single string looks the same as mixed content containing no elements.</textual></para><para class="po-block e844 e844"><textual class="po-textual">The function </textual><code class="po-atom e845 e845"><textual class="po-textual">forEach</textual></code><textual class="po-textual">, or the equivalent operator </textual><code class="po-atom e846 e846"><textual class="po-textual">!</textual></code><textual class="po-textual">,
                applies a function to every item in a list. So </textual><code class="po-atom e847 e847"><textual class="po-textual">forEach([1,2,3], {$+1})</textual></code><textual class="po-textual">
                returns </textual><code class="po-atom e848 e848"><textual class="po-textual">[2,3,4]</textual></code><textual class="po-textual">; this can also be written </textual><code class="po-atom e849 e849"><textual class="po-textual">[1,2,3] ! {$+1}</textual></code><textual class="po-textual">.
                Similarly, </textual><code class="po-atom e850 e850"><textual class="po-textual">[1,2,3]!toString</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e851 e851"><textual class="po-textual">["1", "2", "3"]</textual></code><textual class="po-textual">. Note
                that this is a non-flattening mapping operation; the result list will contain
                exactly the same number of items as the input.</textual></para><para class="po-block e852 e852"><textual class="po-textual">Another example: </textual><code class="po-atom e853 e853"><textual class="po-textual">(1..5)!{&lt;br&gt;}</textual></code><textual class="po-textual"> returns
                    </textual><code class="po-atom e854 e854"><textual class="po-textual">[&lt;br&gt;, &lt;br&gt;, &lt;br&gt;, &lt;br&gt;, &lt;br&gt;]</textual></code></para><para class="po-block e855 e855"><textual class="po-textual">The function </textual><code class="po-atom e856 e856"><textual class="po-textual">select</textual></code><textual class="po-textual">, or the equivalent operator </textual><code class="po-atom e857 e857"><textual class="po-textual">?</textual></code><textual class="po-textual">,
                applies a function to every item in a list and returns a list containing those items
                for which the function returns true. So </textual><code class="po-atom e858 e858"><textual class="po-textual">select([1,2,3], {$&gt;=2})</textual></code><textual class="po-textual"> returns
                    </textual><code class="po-atom e859 e859"><textual class="po-textual">[2,3]</textual></code><textual class="po-textual">; this can also be written </textual><code class="po-atom e860 e860"><textual class="po-textual">[1,2,3]?{$&gt;=2}</textual></code><textual class="po-textual">.
                Similarly, </textual><code class="po-atom e861 e861"><textual class="po-textual">[1,2,"London"]?isNumber</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e862 e862"><textual class="po-textual">[1,2]</textual></code><textual class="po-textual">.</textual></para><para class="po-block e863 e863"><textual class="po-textual">The result of the </textual><code class="po-atom e864 e864"><textual class="po-textual">select</textual></code><textual class="po-textual"> operator or function is always a list,
                even if only one item is selected. If it is known that the predicate will select
                exactly one item, it is necessary to extract that item from the result, typically by
                a call on </textual><code class="po-atom e865 e865"><textual class="po-textual">head</textual></code><textual class="po-textual">, or by using the subscript operation
                    </textual><code class="po-atom e866 e866"><textual class="po-textual">(A?P)[0]</textual></code><textual class="po-textual">. Because this is a common operation, the operator
                    </textual><code class="po-atom e867 e867"><textual class="po-textual">??</textual></code><textual class="po-textual"> is provided, equivalent to </textual><code class="po-atom e868 e868"><textual class="po-textual">?</textual></code><textual class="po-textual"> followed by
                    </textual><code class="po-atom e869 e869"><textual class="po-textual">head()</textual></code><textual class="po-textual">: it selects the first item found, or null if nothing was
                matched. A query to find a singleton can now be written, for example
                    </textual><code class="po-atom e870 e870"><textual class="po-textual">items??{$@id='xyz'}</textual></code><textual class="po-textual">. </textual></para><para class="po-block e871 e871"><textual class="po-textual">The functions </textual><code class="po-atom e872 e872"><textual class="po-textual">all</textual></code><textual class="po-textual"> and </textual><code class="po-atom e873 e873"><textual class="po-textual">some</textual></code><textual class="po-textual"> can be used in
                conjunction with the </textual><code class="po-atom e874 e874"><textual class="po-textual">forEach</textual></code><textual class="po-textual"> (</textual><code class="po-atom e875 e875"><textual class="po-textual">!</textual></code><textual class="po-textual">) operator to perform
                universal and existential quantification: they test whether a list consists entirely
                of boolean true values (all), or contains at least one true value (some). So, for
                example </textual><code class="po-atom e876 e876"><textual class="po-textual">all([1,2,3]!{$&gt;0})</textual></code><textual class="po-textual"> returns true, while
                    </textual><code class="po-atom e877 e877"><textual class="po-textual">some([1,2,3]!{$=0})</textual></code><textual class="po-textual"> returns false.</textual></para><para class="po-block e878 e878"><textual class="po-textual">Functions </textual><code class="po-atom e879 e879"><textual class="po-textual">fold-left</textual></code><textual class="po-textual"> and </textual><code class="po-atom e880 e880"><textual class="po-textual">fold-right</textual></code><textual class="po-textual"> are available as
                    in XPath 3.0.</textual></para></section><section class="po-hcontainer e881 e881"><title class="po-block e882 e882"><textual class="po-textual">Functions and Operators on Elements</textual></title><para class="po-block e883 e883"><textual class="po-textual">The function </textual><code class="po-atom e884 e884"><textual class="po-textual">name(E)</textual></code><textual class="po-textual"> returns the name of an element
                        </textual><code class="po-atom e885 e885"><textual class="po-textual">E</textual></code><textual class="po-textual">, or null if it is unnamed. The syntax </textual><code class="po-atom e886 e886"><textual class="po-textual">E.name()</textual></code><textual class="po-textual">
                    can also be used, of course.</textual></para><para class="po-block e887 e887"><textual class="po-textual">The mapping and filtering operators (</textual><code class="po-atom e888 e888"><textual class="po-textual">!</textual></code><textual class="po-textual"> and </textual><code class="po-atom e889 e889"><textual class="po-textual">?</textual></code><textual class="po-textual">) apply to
                elements as well as to lists. In this case they expect a two argument function to be
                supplied, and call this with the attribute name as the first argument and the
                attribute value as the second. The mapping operator returns a list with as many
                members as there are non-null attributes in the input; the filter operator returns
                an element with the same name as original, and with a subset of its attributes.
                These operators treat the content value as just another attribute. They provide the
                most general and powerful means of processing elements, and other operations can be
                defined in terms of these two. For example, the function content(E), which returns
                the content of an element, could be defined as E?{$1=""}!{$2}.</textual></para><para class="po-block e890 e890"><textual class="po-textual">For example </textual><code class="po-atom e891 e891"><textual class="po-textual">E?{$.in("id", "code", "status"}</textual></code><textual class="po-textual"> returns a copy of element
                E, retaining only the three specified attributes.</textual></para><para class="po-block e892 e892"><textual class="po-textual">If </textual><code class="po-atom e893 e893"><textual class="po-textual">E</textual></code><textual class="po-textual"> is an element and </textual><code class="po-atom e894 e894"><textual class="po-textual">xyz</textual></code><textual class="po-textual"> is the name of an attribute
                (known at the time the program is written), then </textual><code class="po-atom e895 e895"><textual class="po-textual">E@xyz</textual></code><textual class="po-textual"> returns the
                value of the attribute. It returns the value only, not an "attribute node" as in
                XPath; if the attribute is not present, it returns null. If the name needs to be
                dynamically computed, this can be achieved using an expression in parentheses, for
                example </textual><code class="po-atom e896 e896"><textual class="po-textual">E@(X@name)</textual></code><textual class="po-textual"> returns the attribute of </textual><code class="po-atom e897 e897"><textual class="po-textual">E</textual></code><textual class="po-textual"> whose name
                is given by the expression </textual><code class="po-atom e898 e898"><textual class="po-textual">(X@name)</textual></code><textual class="po-textual">. The construct </textual><code class="po-atom e899 e899"><textual class="po-textual">E^</textual></code><textual class="po-textual"> is
                an abbreviation for </textual><code class="po-atom e900 e900"><textual class="po-textual">E@``</textual></code><textual class="po-textual"> — it returns the value of the attribute whose
                name is the zero-length string, that is, the content value.</textual></para><para class="po-block e901 e901"><textual class="po-textual">Filtering a list of elements to select those with a given name is likely to be a
                common operation. The syntax </textual><code class="po-atom e902 e902"><textual class="po-textual">L?{name($)=N}</textual></code><textual class="po-textual"> achieves this but is a
                little cumbersome, and becomes more so if the list can also include values other
                than elements. So we provide the construct </textual><code class="po-atom e903 e903"><textual class="po-textual">:N</textual></code><textual class="po-textual">, where </textual><code class="po-atom e904 e904"><textual class="po-textual">N</textual></code><textual class="po-textual"> is
                a name, which represents a function that returns true when its first argument is an
                element with the name </textual><code class="po-atom e905 e905"><textual class="po-textual">N</textual></code><textual class="po-textual">, and false otherwise. So given a list of
                elements </textual><code class="po-atom e906 e906"><textual class="po-textual">L</textual></code><textual class="po-textual">, we can now select those having the name N by writing
                    </textual><code class="po-atom e907 e907"><textual class="po-textual">L?:N</textual></code><textual class="po-textual">. If we know there will be only one such element, we can select
                it using </textual><code class="po-atom e908 e908"><textual class="po-textual">L??:N</textual></code><textual class="po-textual">.</textual></para><para class="po-block e909 e909"><textual class="po-textual">So if </textual><code class="po-atom e910 e910"><textual class="po-textual">PO</textual></code><textual class="po-textual"> is the purchase order presented in section 2.1, then
                    </textual><code class="po-atom e911 e911"><textual class="po-textual">PO@shipTo^??:name</textual></code><textual class="po-textual"> gives the value </textual><code class="po-atom e912 e912"><textual class="po-textual">"Alice Smith"</textual></code><textual class="po-textual">, while
                    </textual><code class="po-atom e913 e913"><textual class="po-textual">PO@items[0]@partNum</textual></code><textual class="po-textual"> gives </textual><code class="po-atom e914 e914"><textual class="po-textual">"872-AA"</textual></code><textual class="po-textual">. </textual></para><para class="po-block e915 e915"><textual class="po-textual">The following example selects from a list of elements those having a particular
                attribute value: </textual><code class="po-atom e916 e916"><textual class="po-textual">PO@items?{$@USprice &gt; 20.00}</textual></code><textual class="po-textual">.</textual></para><para class="po-block e917 e917"><textual class="po-textual">The </textual><code class="po-atom e918 e918"><textual class="po-textual">@</textual></code><textual class="po-textual"> operator performs implicit mapping. Specifically: if the
                left-hand operand is a list </textual><code class="po-atom e919 e919"><textual class="po-textual">L</textual></code><textual class="po-textual">, then any lists contained in this list
                are expanded recursively. Any values in the expanded list that are not elements are
                ignored, so we end up with a list of elements; call this </textual><code class="po-atom e920 e920"><textual class="po-textual">LL</textual></code><textual class="po-textual">. The value
                of the expression </textual><code class="po-atom e921 e921"><textual class="po-textual">L@name</textual></code><textual class="po-textual"> is then defined as </textual><code class="po-atom e922 e922"><textual class="po-textual">LL!{$@name}</textual></code><textual class="po-textual">.
                Note that the result may be a list of lists; it is not flattened.</textual></para><para class="po-block e923 e923"><textual class="po-textual">Returning again to the purchase order example, this means that
                    </textual><code class="po-atom e924 e924"><textual class="po-textual">PO@items@partNum</textual></code><textual class="po-textual"> returns the list of strings </textual><code class="po-atom e925 e925"><textual class="po-textual">["872-AA",
                    "926-AA"]</textual></code><textual class="po-textual">.</textual></para><para class="po-block e926 e926"><textual class="po-textual">The postfix operator </textual><code class="po-atom e927 e927"><textual class="po-textual">//</textual></code><textual class="po-textual"> represents the</textual><code class="po-atom e928 e928"><textual class="po-textual"> deepContent()</textual></code><textual class="po-textual">
                function, which is the flattened transitive closure of the </textual><code class="po-atom e929 e929"><textual class="po-textual">content()</textual></code><textual class="po-textual">
                function. Specifically, if the result of </textual><code class="po-atom e930 e930"><textual class="po-textual">content()</textual></code><textual class="po-textual"> is a list, then any
                element in that list has its own descendants inserted immediately after it. So the
                function </textual><code class="po-atom e931 e931"><textual class="po-textual">descendants(E)</textual></code><textual class="po-textual"> can be defined as </textual><code class="po-atom e932 e932"><textual class="po-textual">content(E)!{$ ~+ (if
                    $.isA(&lt;element&gt;) then $.descendants() else [])}</textual></code><textual class="po-textual">. So if </textual><code class="po-atom e933 e933"><textual class="po-textual">E</textual></code><textual class="po-textual">
                is an element, then </textual><code class="po-atom e934 e934"><textual class="po-textual">E//?:status</textual></code><textual class="po-textual"> will select all descendant elements
                named </textual><code class="po-atom e935 e935"><textual class="po-textual">status</textual></code><textual class="po-textual">, and </textual><code class="po-atom e936 e936"><textual class="po-textual">E//?[$@id=12]</textual></code><textual class="po-textual"> will select all descendant
                elements having the </textual><code class="po-atom e937 e937"><textual class="po-textual">id</textual></code><textual class="po-textual"> attribute equal to 12.</textual></para><para class="po-block e938 e938"><textual class="po-textual">The postfix operator </textual><code class="po-atom e939 e939"><textual class="po-textual">@@</textual></code><textual class="po-textual"> similarly gives the transitive closure of
                    </textual><code class="po-atom e940 e940"><textual class="po-textual">attributes()</textual></code><textual class="po-textual">.</textual></para><para class="po-block e941 e941"><textual class="po-textual">As already mentioned, the function </textual><code class="po-atom e942 e942"><textual class="po-textual">forEach</textual></code><textual class="po-textual"> and the equivalent
                operator </textual><code class="po-atom e943 e943"><textual class="po-textual">!</textual></code><textual class="po-textual"> are overloaded for elements to process all the attributes of
                an element (including the content). The second operand is a function which is called
                with two arguments, the attribute name and the attribute value. For example, given
                an element E the expression </textual><code class="po-atom e944 e944"><textual class="po-textual">E!{$}</textual></code><textual class="po-textual"> returns the names of its
                attributes.</textual></para><para class="po-block e945 e945"><textual class="po-textual">Similarly the function </textual><code class="po-atom e946 e946"><textual class="po-textual">select</textual></code><textual class="po-textual"> and the equivalent operator
                    </textual><code class="po-atom e947 e947"><textual class="po-textual">?</textual></code><textual class="po-textual"> are overloaded to process all the attributes, and return an
                element in which only a subset of the original attributes are present. </textual></para><para class="po-block e948 e948"><textual class="po-textual">The function </textual><code class="po-atom e949 e949"><textual class="po-textual">element(name)</textual></code><textual class="po-textual"> constructs an element with a given
                name (which may be null). It can also be called with two arguments:
                    </textual><code class="po-atom e950 e950"><textual class="po-textual">element(name, attributes)</textual></code><textual class="po-textual">. The second argument is a list of
                attributes, each attribute being represented by a two-member list containing the
                name and the value.</textual></para><para class="po-block e951 e951"><textual class="po-textual">The function </textual><code class="po-atom e952 e952"><textual class="po-textual">add(element, name, value)</textual></code><textual class="po-textual"> takes an existing element,
                and adds an attribute with the given name and value, replacing any existing
                attribute with the same value. A new element is returned. Calls to this function can
                conveniently be chained: </textual><code class="po-atom e953 e953"><textual class="po-textual">element("rect").add("id", "a001").add("color",
                    "black")</textual></code><textual class="po-textual">.</textual></para><para class="po-block e954 e954"><textual class="po-textual">For convenience, the function </textual><code class="po-atom e955 e955"><textual class="po-textual">addContent</textual></code><textual class="po-textual"> is defined as
                    </textual><code class="po-atom e956 e956"><textual class="po-textual">add(?, "", ?)</textual></code><textual class="po-textual">.</textual></para><para class="po-block e957 e957"><textual class="po-textual">So, for example, we can convert attributes to a list of child elements like
                this:</textual></para><programlisting class="po-block e958 e958" xml:space="preserve"><textual class="po-textual">let elementsToAttributes = {
    let E = $.asElement();
    element(E.name()).setContent(E!{element($1).setContent($2)})    
 }
            </textual></programlisting><para class="po-block e959 e959"><textual class="po-textual">The semantics of these constructions in FtanSkrit are different from the corresponding operations in XPath, but hopefully they will have a familiar feel.</textual></para></section></section><section class="po-hcontainer e960 e960"><title class="po-block e961 e961"><textual class="po-textual">Future Features</textual></title><para class="po-block e962 e962"><textual class="po-textual">FtanML as presented in this paper packs a large amount of functionality into a small
            language. It doesn't offer everything that anyone might ask for, and nor should it:
            keeping it small is important. Nevertheless, there are things one might want to add, and
            which have not been ruled out.</textual></para><itemizedlist class="po-table e963 e963"><listitem class="po-container e964 e964"><para class="po-block e965 e965"><textual class="po-textual">An extensible mechanism for data types is needed: for example, representing
                    dates as values. Schema validation can confirm that a date is a valid string,
                    but for processing one would like to manipulate it as a date, not just as a
                    string. Similarly, support for binary data is important to some applications;
                    and it would be nice if URIs were recognizable as such. A general mechanism for
                    extending the set of types (perhaps along the lines suggested in [Jeni
                    Tennison]), would be undoubtedly useful.</textual></para></listitem><listitem class="po-container e966 e966"><para class="po-block e967 e967"><textual class="po-textual">What about pointers and links? XML has a sorry tale to tell in this area, but
                    that doesn't mean it can't be done better. Arguably links and anchors should be
                    first-class constructs marked as such in the syntax, rather than a semantic
                    overlay affecting the interpretation of strings. Both intra-document and
                    inter-document links are needed, and they should ideally be handled using a
                    single mechanism. Support for the kind of referential integrity found in
                    relational databases is as important as support for the hyperlinking traditions
                    of the markup community, and there is no good reason why the two mechanisms
                    should be distinct.</textual></para></listitem><listitem class="po-container e968 e968"><para class="po-block e969 e969"><textual class="po-textual">In the scripting language, there is an obvious need for rule-based processing
                    in the style popularised by XSLT. In this paper, I have concentrated on
                    presenting a small functional core for the scripting language, but I would like
                    to see rule-based processing superimposed, and I see no reason why this should
                    not be achievable.</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e970 e970"><title class="po-block e971 e971"><textual class="po-textual">Conclusions and Summary</textual></title><para class="po-block e972 e972"><textual class="po-textual">We have introduced three languages as replacements for the central pillars of the
            markup edifice: FtanML as the markup language, FtanGram as its schema language, and
            FtanSkrit as its query and transformation language. Let's try now to assess what we've
            achieved.</textual></para><para class="po-block e973 e973"><textual class="po-textual">Firstly, FtanML compared to XML. FtanML is considerably smaller as a specification,
            but it's also more powerful. It gets rid of the same unwanted things that MicroXML gets
            rid of (namespaces, comments, processing instructions, entities, DTDs), but by allowing
            attributes and element content to be any value, the data model is much richer, more
            orthogonal, and more expressive. It also solves the whitespace issue (which whitespace
            is significant?). By dropping end tags, the language is a lot less verbose, which is
            particularly noticeable when it is used for highly structured information, as in the
            FtanGram syntax. There's a lot of general tidying-up in little areas like escaping of
            special characters.</textual></para><para class="po-block e974 e974"><textual class="po-textual">Does verbosity matter? We think it does. The fact that XML is bulky and hard to read
            is a significant factor leading to the adoption of alternative syntaxes for languages
            such as RDF and RelaxNG, and is a big turn-off for people coming newly to XSLT. Even if
            specialist editors can reduce the burden of entering the markup, the amount of noise on
            the page affects the ability of a human reader to absorb information quickly. This is
            not to say that the most concise syntax is optimal, of course: we might have swung too
            far. XML had human
            readability as one of its goals, and we should remember that readability is not a binary
            attribute; there are degrees of readability, and readability also depends greatly on
            the familiarity of the reader with the notation.</textual></para><para class="po-block e975 e975"><textual class="po-textual">Compared to JSON, FtanML's main contribution is that it adds support for mixed
            content. And element names, which are very handy when modelling document
            structures.</textual></para><para class="po-block e976 e976"><textual class="po-textual">Compared to the XPath data model (XDM), the FtanML model has more capability and
            greater orthogonality. The core structuring constructs (elements and lists) are powerful
            enough for all computational requirements. XSLT and XQuery have found a need to extend
            the core XML-based model with other constructs such as maps and lists; the FtanML model
            does not have this awkward duality between constructs that can be directly serialized in
            the markup, and constructs used only for internal processing.</textual></para><para class="po-block e977 e977"><textual class="po-textual">FtanGram learns from RelaxNG the importance of designing a schema language to do
            validation and nothing else. Unlike RelaxNG, it's able to take advantage of the
            simplification and orthogonality of the data model. The unification of facilities for
            "simple types" and "complex types" is particularly appealing, allowing a smaller number
            of constructs to be combined in more powerful ways to create richer functionality. The
            idea that element names as well as attributes and content are something that can be
            constrained by a type is also a useful simplification. FtanGram also attempts to show
            that by making the markup language itself more powerful and less verbose, the need for a
            "compact syntax" (that is, a syntax using constructs other than those available in the
            target language) is eliminated.</textual></para><para class="po-block e978 e978"><textual class="po-textual">FtanSkrit is broadly equivalent in capability to XQuery, but with a stronger reliance
            on higher-order functions and operators in preference to custom syntax. It currently
            lacks any mechanism comparable to XSLT's template rules, but we have ideas for how that
            could be added.</textual></para><para class="po-block e979 e979"><textual class="po-textual">There will always be debates about strong versus weak typing, static versus dynamic. I
            believe that FtanML's dynamic typing approach fits better with the philosophy that with
            markup, you can have as much or as little schema machinery as you want. The XPath
            ability to mix typed and untyped data is one solution to the problem of spanning the
            worlds of structured and unstructured data, but it is something of a camel.</textual></para><para class="po-block e980 e980"><textual class="po-textual">Are there any downsides? Some may find the languages excessively terse; highly compact
            syntax is not easy on the eye. The absence of named end tags in FtanML can lead to long
            strings of closing angle-brackets which are hard to match up without the support of a
            syntax-driven editor. Generally, though, we feel that FtanML with its sister languages
            FtanGram and FtanSkrit together form a markup system that has more than the power of the
            equivalent XML stack, with much greater integrity of design, simplicity, orthogonality,
            efficiency, and usability.</textual></para></section><section class="po-hcontainer e981 e981"><title class="po-block e982 e982"><textual class="po-textual">Implementation</textual></title><para class="po-block e983 e983"><textual class="po-textual">A Scala implementation is available as open source software. It can be downloaded from here:</textual></para><para class="po-block e984 e984"><code class="po-atom e985 e985"><textual class="po-textual">https://github.com/organizations/FtanML-WG</textual></code></para><para class="po-block e986 e986"><textual class="po-textual">The implementation is not 100% complete,
            and is intended as a proof of concept rather than as production quality software. It
            includes a complete parser for FtanML which constructs a tree represenation of the
            object model; an implementation of all the FtanGram types and facets (including the
            grammar facet), but not the schema language itself; and an implementation of most of the
            FtanSkrit processing language, though with some relatively unimportant functions and
            operators omitted.</textual></para></section><section class="po-hcontainer e987 e987"><title class="po-block e988 e988"><textual class="po-textual">Acknowledgements</textual></title><para class="po-block e989 e989"><textual class="po-textual">FtanML was invented by a group of students from German universities taught by the
            author, with Stephanie Haupt as co-tutor, during a summer school in Ftan, Switzerland in
            August 2012, organised by the Max Weber Programm, Bayern. The students deserve much of
            the credit, if only for challenging things that I had assumed to be self-evident: they
            were Max Altgelt, Julien Bergner, Lukas Graf, Dominik Helm, Axel Kroschk, Uwe von Lüpke,
            My-Tien Nguyen, Sebastian Meßmer, Suhanyaa Nitkunanantharajah, Jan Landelin Pawellek,
            and Martin Schmitt. They were a most impressive team and a pleasure to work with:
            absorbing knowledge quickly, researching information thoroughly, generating ideas
            constantly, reaching consensus amicably, writing parsers correctly, making decisions
            wisely, and communicating bilingually. I am particularly indebted to Sebastian Meßmer
            for helping me climb the Scala learning curve.</textual></para></section><bibliography class="po-hcontainer e990 e990"><title class="po-block e991 e991"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e992 e992" xml:id="ref1" xreflabel="1"><emphasis class="po-inline e993 e993" role="ital"><textual class="po-textual">MicroXML</textual></emphasis><textual class="po-textual">. Ed. James Clark and John Cowan, 2012. W3C.
            </textual><link class="po-inline e994 e994" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://dvcs.w3.org/hg/microxml/raw-file/tip/spec/microxml.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e995 e995" xml:id="ref2" xreflabel="2"><emphasis class="po-inline e996 e996" role="ital"><textual class="po-textual">XML Schema Part 0 Primer</textual></emphasis><textual class="po-textual">, Second Edition. Ed. David C. Fallside and Priscilla Walmsley. 28 Oct 2004. W3C.
            </textual><link class="po-inline e997 e997" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-0/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e998 e998" xml:id="ref3" xreflabel="3"><emphasis class="po-inline e999 e999" role="ital"><textual class="po-textual">Introducing JSON</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e1000 e1000" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.json.org</textual></link></bibliomixed><bibliomixed class="po-block e1001 e1001" xml:id="ref4" xreflabel="4"><emphasis class="po-inline e1002 e1002" role="ital"><textual class="po-textual">YAML: YAML ain't markup language</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e1003 e1003" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://yaml.org</textual></link></bibliomixed><bibliomixed class="po-block e1004 e1004" xml:id="ref5" xreflabel="5"><emphasis class="po-inline e1005 e1005" role="ital"><textual class="po-textual">LMNL: Layered Markup and Annotation Language</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e1006 e1006" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.lmnl-markup.com</textual></link></bibliomixed><bibliomixed class="po-block e1007 e1007" xml:id="ref6" xreflabel="6"><emphasis class="po-inline e1008 e1008" role="ital"><textual class="po-textual">ODDAG: A Data Structure for Overlapping Hierarchies</textual></emphasis><textual class="po-textual">. 
            C. M. Sperberg-McQueen and C. Huitfeld. 2004. Springer.</textual></bibliomixed><bibliomixed class="po-block e1009 e1009" xml:id="ref7" xreflabel="7"><emphasis class="po-inline e1010 e1010" role="ital"><textual class="po-textual">Information technology -- Generic applications of ASN.1: Fast Infoset</textual></emphasis><textual class="po-textual">. 
        ISO/IEC 24824-1:2007</textual></bibliomixed><bibliomixed class="po-block e1011 e1011" xml:id="ref8" xreflabel="8"><emphasis class="po-inline e1012 e1012" role="ital"><textual class="po-textual">Efficient XML Interchange (EXI) Format 1.0</textual></emphasis><textual class="po-textual">. 
            10 Mar 2011. W3C. </textual><link class="po-inline e1013 e1013" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2011/REC-exi-20110310/</textual></link></bibliomixed></bibliography></article></classedDocument>