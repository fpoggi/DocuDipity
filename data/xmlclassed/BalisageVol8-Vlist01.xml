<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Fleshing the XDM chimera</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">The XQuery and XPath Data Model 3.0 (XDM) is the kernel of the XML ecosystem. XDM had been extended with foreign item types to embrace new data sources such as JSON, taking the risk
                to become a chimera. This talk explores some ways to move this fundamental piece of the XML stack forward.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Eric</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">van der Vlist</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Eric is an independent consultant and trainer. His domain of expertise include Web development and XML technologies.</textual></para><para class="po-block e14 e14"><textual class="po-textual">He is the creator and main editor of </textual><link class="po-inline e15 e15" xlink:actuate="onRequest" xlink:href="http://xmlfr.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">XMLfr.org</textual></link><textual class="po-textual">, the main site dedicated to XML technologies in French, the author of the O'Reilly
                    animal books XML Schema and RELAX NG and a member or the ISO DSDL (</textual><link class="po-inline e16 e16" xlink:actuate="onRequest" xlink:href="http://dsdl.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dsdl.org</textual></link><textual class="po-textual">) working group focused on XML schema languages.</textual></para><para class="po-block e17 e17"><textual class="po-textual">He is based in Paris and you can reach him by mail (</textual><link class="po-inline e18 e18" xlink:actuate="onRequest" xlink:href="mailto:vdv@dyomedea.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">vdv@dyomedea.com</textual></link><textual class="po-textual">) or meet him in one of the many conferences where he
                    presents his projects.</textual></para></personblurb><affiliation class="po-record e19 e19"><orgname class="po-block e20 e20"><textual class="po-textual">Dyomedea</textual></orgname></affiliation></author><legalnotice class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Published under the Creative Commons "cc by" license</textual></para></legalnotice></info><section class="po-hcontainer e23 e23"><title class="po-block e24 e24"><textual class="po-textual">Motivation</textual></title><blockquote class="po-container e25 e25"><para class="po-block e26 e26"><link class="po-inline e27 e27" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Chimera_%28mythology%29" xlink:show="new" xlink:type="simple"><textual class="po-textual">Chimera (mythology)</textual></link><textual class="po-textual">: The Chimera (also Chimaera or Chimæra) (Greek: Χίμαιρα, Khimaira, from χίμαρος,
                khimaros, "she-goat") was, according to Greek mythology, a monstrous fire-breathing female creature of Lycia in Asia Minor, composed of the parts of multiple animals: upon the body of
                a lioness with a tail that ended in a snake's head, the head of a goat arose on her back at the center of her spine. The Chimera was one of the offspring of Typhon and Echidna and a
                sibling of such monsters as Cerberus and the Lernaean Hydra. The term chimera has also come to describe any mythical animal with parts taken from various animals and, more generally,
                an impossible or foolish fantasy.</textual></para><attribution class="po-block e28 e28"><link class="po-inline e29 e29" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Chimera_%28mythology%29" xlink:show="new" xlink:type="simple"><textual class="po-textual">Wikipedia</textual></link></attribution></blockquote><blockquote class="po-container e30 e30"><para class="po-block e31 e31"><link class="po-inline e32 e32" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Chimera_%28genetics%29" xlink:show="new" xlink:type="simple"><textual class="po-textual">Chimera (genetics)</textual></link><textual class="po-textual">: A chimera or chimaera is a single organism (usually an animal) that is composed of
                two or more different populations of genetically distinct cells that originated from different zygotes involved in sexual reproduction. If the different cells have emerged from the
                same zygote, the organism is called a mosaic. Chimeras are formed from at least four parent cells (two fertilized eggs or early embryos fused together). Each population of cells keeps
                its own character and the resulting organism is a mixture of tissues. </textual></para><attribution class="po-block e33 e33"><link class="po-inline e34 e34" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Chimera_%28genetics%29" xlink:show="new" xlink:type="simple"><textual class="po-textual">Wikipedia</textual></link></attribution></blockquote><para class="po-block e35 e35"><textual class="po-textual">During her opening keynote at XML Prague 2012, speaking about the relation between XML, HTML, JSON and RDF, Jeni Tennison warned us against the temptation to create chimeras:
                </textual><citation class="po-atom e36 e36"><textual class="po-textual">chimera are usually ugly, foolish or impossible fantasies</textual></citation><textual class="po-textual">.</textual></para><para class="po-block e37 e37"><textual class="po-textual">The next morning, Michael Kay and Jonathan Robie came to present new features in XPath/XQuery/XSLT 3.0. A lot of these features are directly based on the XQuery and XPath Data Model 3.0
            (aka </textual><link class="po-inline e38 e38" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#other-items" xlink:show="new" xlink:type="simple"><textual class="po-textual">XDM</textual></link><textual class="po-textual">):</textual><blockquote class="po-container e39 e39"><para class="po-block e40 e40"><textual class="po-textual">The XPath Data Model is the abstraction over which XPath expressions are evaluated. Historically, all of the items in the data model could be derived directly (nodes) or
                    indirectly (typed values, sequences) from an XML document. However, as the XPath expression language has matured, new features have been added which require additional types of
                    items to appear in the data model. These items have no direct XML serialization, but they are never the less part of the data model. </textual></para></blockquote></para><para class="po-block e41 e41"><textual class="po-textual">XDM 3.0 is composed of items from a number of different technologies:</textual><itemizedlist class="po-table e42 e42"><listitem class="po-container e43 e43"><para class="po-block e44 e44"><textual class="po-textual">Items from the XML Infoset (nodes, attributes, ...)</textual></para></listitem><listitem class="po-container e45 e45"><para class="po-block e46 e46"><textual class="po-textual">Datatype information borrowed from the Post Schema Validation Infoset</textual></para></listitem><listitem class="po-container e47 e47"><para class="po-block e48 e48"><textual class="po-textual">Sequences</textual></para></listitem><listitem class="po-container e49 e49"><para class="po-block e50 e50"><textual class="po-textual">Atomic values</textual></para></listitem><listitem class="po-container e51 e51"><para class="po-block e52 e52"><textual class="po-textual">Functions that can also be used to model JSON arrays</textual></para></listitem></itemizedlist></para><note class="po-container e53 e53"><para class="po-block e54 e54"><textual class="po-textual">The feature that will be introduced to model JSON arrays is called "maps" and it will be specified as a XSLT feature in the XSLT 3.0 recommendation (not published yet). The XSLT 3.0
                editor, Michael Kay has published an </textual><link class="po-inline e55 e55" xlink:actuate="onRequest" xlink:href="http://dev.saxonica.com/blog/mike/2012/01/#000188" xlink:show="new" xlink:type="simple"><textual class="po-textual">early version</textual></link><textual class="po-textual"> of this feature in his blog. In this paper, XDM 3.0 will
                refer to the XSLT 3.0 data model (the XPath 3.0 data model augmented with maps).</textual></para></note><para class="po-block e56 e56"><textual class="po-textual">XDM 3.0 being a single data model composed of items from different data models, it is fair to say that it is a chimera!</textual></para><para class="po-block e57 e57"><textual class="po-textual">Following Jeni Tennison on stage, I have tried to </textual><link class="po-inline e58 e58" xlink:actuate="onRequest" xlink:href="http://www.xmlprague.cz/2012/sessions.html#The-eX-Markup-Language" xlink:show="new" xlink:type="simple"><textual class="po-textual">show</textual></link><textual class="po-textual"> that in a world where HTML 5 on one
            hand and JSON on the other hand are gaining traction, XML has become an ecosystem in a competitive environment and that it's data model is a major competitive advantage.</textual></para><para class="po-block e59 e59"><textual class="po-textual">Among other factors, the continued success of XML will thus come from its ability to seamlessly integrate other data models such as JSON.</textual></para><para class="po-block e60 e60"><textual class="po-textual">If we follow this conclusion, we must admit that this chimera is essential to the future of XML and do our best to make it elegant and smart.</textual></para></section><section class="po-hcontainer e61 e61"><title class="po-block e62 e62"><textual class="po-textual">XML Data Models</textual></title><para class="po-block e63 e63"><textual class="po-textual">Whether it's a bug or a feature could be debated endlessly, but a remarkable feature of the XML recommendation it's all about syntax and parsing rule and does not really define a data
            model. The big advantage is that everyone can find pretty much what he wants in XML documents but for the sake of this paper we need to choose a well known -and well defined- data model to
            work on. </textual></para><para class="po-block e64 e64"><textual class="po-textual">The most common XML data model is probably the data model defined by the trio XPath/XSLT/XQuery known as "XDM" since XPath version 2.0 and that's the one we will choose.</textual></para><para class="po-block e65 e65"><textual class="po-textual">XDM version 3.0, still work in progress, will be the third version of this data model. It's important to understand its design and evolution to use its most advanced features and we'll
            start our prospective by a short history of its versions.</textual></para><section class="po-hcontainer e66 e66"><title class="po-block e67 e67"><textual class="po-textual">XPath/XSLT 1.0</textual></title><para class="po-block e68 e68"><textual class="po-textual">The </textual><link class="po-inline e69 e69" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath/#data-model" xlink:show="new" xlink:type="simple"><textual class="po-textual">XPath 1.0 data model</textual></link><textual class="po-textual"> is described as being composed of seven types of nodes (root, elements, text, attributes,
                namespaces, processing instructions and comments).</textual></para><para class="po-block e70 e70"><textual class="po-textual">The </textual><link class="po-inline e71 e71" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt/#data-model" xlink:show="new" xlink:type="simple"><textual class="po-textual">XSLT 1.0 data model</textual></link><textual class="po-textual"> is defined as being the XPath 1.0 data model with:</textual></para><itemizedlist class="po-table e72 e72"><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">Relaxed constraints on root node children to support well-formed external general parsed entities that are not well formed XML documents</textual></para></listitem><listitem class="po-container e75 e75"><para class="po-block e76 e76"><textual class="po-textual">An additional "base URI" property on every node.</textual></para></listitem><listitem class="po-container e77 e77"><para class="po-block e78 e78"><textual class="po-textual">An additional "unparsed entities" property on the root node. </textual></para></listitem></itemizedlist><para class="po-block e79 e79"><textual class="po-textual">It's fair to say that these two -very close- data models are completely focused on XML, but is that all?</textual></para><para class="po-block e80 e80"><textual class="po-textual">Not entirely and these two specifications introduce other notions that should be considered as related to the data model even if they are not described in their sections called "Data
                Model"...</textual></para><para class="po-block e81 e81"><textual class="po-textual">XSLT 1.0 inadvertently mentions </textual><quote class="po-inline e82 e82"><textual class="po-textual">the four basic XPath data-types (string, number, boolean, node-set)</textual></quote><textual class="po-textual"> to explicitly add a fifth one: </textual><quote class="po-inline e83 e83"><textual class="po-textual">result tree
                fragments</textual></quote><textual class="po-textual">.</textual></para><para class="po-block e84 e84"><textual class="po-textual">These four basic data-types are implicitly defined in XPath 1.0 in its section about its function library but no formal description of these types is given.</textual></para></section><section class="po-hcontainer e85 e85"><title class="po-block e86 e86"><textual class="po-textual">XDML 2.0: XPath 2.0/XSLT 2.0/XQuery 1.0</textual></title><para class="po-block e87 e87"><textual class="po-textual">In version 2.0, the XDM is promoted to get its </textual><link class="po-inline e88 e88" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/" xlink:show="new" xlink:type="simple"><textual class="po-textual">own specification</textual></link><textual class="po-textual">.</textual></para><para class="po-block e89 e89"><textual class="po-textual">XDM 2.0 keeps the same seven types of nodes as XPath 1.0 and integrates the additions from the XSLT 1.0 data model. A number of properties are added to these nodes to capture
                information that had been left outside the data model by the previous version and also to support the data-type system from the PSVI (Post Schema Validation Infoset).</textual></para><para class="po-block e90 e90"><textual class="po-textual">The term "data-type" or simply "type" being now used to refer to XML Schema data-types, a new terminology is introduced where the data model is composed of "information items" (or
                items) being either XML nodes or "atomic values".</textual></para><para class="po-block e91 e91"><textual class="po-textual">The concept of "sequences" is also introduced. Sequences are not strictly considered as items but play a very important role in XDM. They are defined as </textual><quote class="po-inline e92 e92"><textual class="po-textual">an ordered collection
                    of zero or more </textual><link class="po-inline e93 e93" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/#dt-item" xlink:show="new" xlink:type="simple"><textual class="po-textual">items</textual></link></quote><textual class="po-textual">.</textual></para><para class="po-block e94 e94"><textual class="po-textual">The data model is thus now composed of three different concepts:</textual><itemizedlist class="po-table e95 e95"><listitem class="po-container e96 e96"><para class="po-block e97 e97"><textual class="po-textual">nodes</textual></para></listitem><listitem class="po-container e98 e98"><para class="po-block e99 e99"><textual class="po-textual">atomic values</textual></para></listitem><listitem class="po-container e100 e100"><para class="po-block e101 e101"><textual class="po-textual">sequences</textual></para></listitem></itemizedlist></para><para class="po-block e102 e102"><textual class="po-textual">XDM 2.0 notes that an important difference between nodes and atomic values is that only nodes have </textual><link class="po-inline e103 e103" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/#node-identity" xlink:show="new" xlink:type="simple"><textual class="po-textual">identities</textual></link><textual class="po-textual">:</textual><blockquote class="po-container e104 e104"><para class="po-block e105 e105"><textual class="po-textual">Each node has a unique identity. Every </textual><link class="po-inline e106 e106" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/#dt-node" xlink:show="new" xlink:type="simple"><textual class="po-textual">node</textual></link><textual class="po-textual"> in an instance of the data model is unique: identical to
                        itself, and not identical to any other node. (</textual><link class="po-inline e107 e107" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/#dt-atomic-value" xlink:show="new" xlink:type="simple"><textual class="po-textual">Atomic values</textual></link><textual class="po-textual"> do not have identity; every instance
                        of the value “5” as an integer is identical to every other instance of the value “5” as an integer.)</textual></para><attribution class="po-block e108 e108"><link class="po-inline e109 e109" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/#node-identity" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery 1.0 and XPath 2.0 Data Model (XDM) (Second Edition)</textual></link></attribution></blockquote></para><para class="po-block e110 e110"><textual class="po-textual">This is a crucial distinction that divides the data model into two different kind of items (those which have an identity and those which haven't one). Let's take an example: </textual></para><programlisting class="po-block e111 e111" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;foo&gt;5&lt;/foo&gt;
    &lt;foo&gt;5&lt;/foo&gt;
    &lt;bar foo="5"&gt;
        &lt;foo&gt;5&lt;/foo&gt;
    &lt;/bar&gt;
&lt;/root&gt;</textual></programlisting><para class="po-block e112 e112"><textual class="po-textual">The three </textual><code class="po-atom e113 e113"><textual class="po-textual">&lt;foo&gt;5&lt;/foo&gt;</textual></code><textual class="po-textual"> look similar and can be considered "</textual><link class="po-inline e114 e114" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-functions/#func-deep-equal" xlink:show="new" xlink:type="simple"><textual class="po-textual">deeply equal</textual></link><textual class="po-textual">" but they
                are three different elements with three different identities. This is needed because some of their properties are different: the parent of the first two is </textual><code class="po-atom e115 e115"><textual class="po-textual">&lt;root/&gt;</textual></code><textual class="po-textual">
                while the parent of the third one is </textual><code class="po-atom e116 e116"><textual class="po-textual">&lt;bar/&gt;</textual></code><textual class="po-textual">, the preceding sibling of the second one is the first one while the first one has no preceeding sibling, ...</textual></para><para class="po-block e117 e117"><textual class="po-textual">The three "5" text nodes are similar but they still are different text nodes with different identities and this is necessary because they don't have the same parent elements.</textual></para><para class="po-block e118 e118"><textual class="po-textual">By contrast, the atomic values of the three </textual><code class="po-atom e119 e119"><textual class="po-textual">&lt;foo/&gt;</textual></code><textual class="po-textual"> element (and the atomic value of the </textual><code class="po-atom e120 e120"><textual class="po-textual">@foo</textual></code><textual class="po-textual"> attribute) are the same atomic value, the "5" (assuming they
                have all been declared with the same datatype). Among many other things, this means that when you manipulate their values, you can't access back to the node that is holding the
                value).</textual></para></section><section class="po-hcontainer e121 e121"><title class="po-block e122 e122"><textual class="po-textual">XDM 3.0: XPath 3.0/XSLT 3.0/XQuery 3.0</textual></title><para class="po-block e123 e123"><note class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">These specifications are still work on progress, currently divided between </textual><link class="po-inline e126 e126" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery and XPath Data
                            Model 3.0</textual></link><textual class="po-textual"> and data model extensions described in XSL Transformations (XSLT) Version 3.0.</textual></para></note></para><para class="po-block e127 e127"><textual class="po-textual">XDM 3.0 adds functions as a third kind of items, transforming XQuery and XSLT into functional languages.</textual></para><para class="po-block e128 e128"><textual class="po-textual">Like atomic values, functions have no identity:</textual><blockquote class="po-container e129 e129"><para class="po-block e130 e130"><textual class="po-textual">Functions have no identity, cannot be compared, and have no serialization.</textual></para><attribution class="po-block e131 e131"><link class="po-inline e132 e132" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#function-items" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery and XPath Data Model 3.0 - W3C Working Draft 13 December
                        2011</textual></link></attribution></blockquote></para><para class="po-block e133 e133"><textual class="po-textual">XSLT 3.0 adds to XDM 3.0 a fourth king of items: maps, derived from functions which, among many other use cases, can be used to model JSON objects:</textual></para><para class="po-block e134 e134"><textual class="po-textual">Like atomic values and functions (from which they are derived), maps have no identity:</textual><blockquote class="po-container e135 e135"><para class="po-block e136 e136"><textual class="po-textual">Like sequences, maps have no identity. It is meaningful to compare the contents of two maps, but there is no way of asking whether they are "the same map": two maps with the
                        same content are indistinguishable.</textual></para><attribution class="po-block e137 e137"><link class="po-inline e138 e138" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#map" xlink:show="new" xlink:type="simple"><textual class="po-textual">XSL Transformations (XSLT) Version 3.0 - W3C Working Draft 10 July 2012</textual></link></attribution></blockquote><note class="po-container e139 e139"><para class="po-block e140 e140"><textual class="po-textual">In this statement, the specification does acknowledge that sequences have no identity either. This is understandable but didn't seem to be clearly specified elsewhere.</textual></para></note></para><para class="po-block e141 e141"><textual class="po-textual">Of course, XSLT 3.0 is also adding functions to create, manipulate maps and serialize/deserialize them as JSON and a syntax to define map literals. It does not any new pattern to
                select of match maps or map entries, though.</textual></para></section></section><section class="po-hcontainer e142 e142"><title class="po-block e143 e143"><textual class="po-textual">Identity Crisis</textual></title><blockquote class="po-container e144 e144"><para class="po-block e145 e145"><textual class="po-textual">Appolonius' ship is a beautiful ship. Over the years it has been repaired so many times that there is not a single piece of the original materials remaining. The question is,
                therefore, is it really still Appolonius' ship? </textual></para><attribution class="po-block e146 e146"><link class="po-inline e147 e147" xlink:actuate="onRequest" xlink:href="http://c2.com/cgi/wiki?ObjectIdentity" xlink:show="new" xlink:type="simple"><textual class="po-textual">ObjectIdentity on c2.com</textual></link></attribution></blockquote><para class="po-block e148 e148"><textual class="po-textual">Object identity is often confused with mutability. The need for objects to have identities is more obvious when they are mutable, their identities being then used to track them despite
            their changes like Appolonius' ship. However, XDM 3.0 gives us a good opportunity to explore the meaning and consequences of having (or not having) an identity for immutable object
            structures.</textual></para><para class="po-block e149 e149"><textual class="po-textual">The definition of node identity in XDM 3.0 is directly copied from XDM 2.0:</textual><blockquote class="po-container e150 e150"><para class="po-block e151 e151"><textual class="po-textual">Each node has a unique identity. Every </textual><link class="po-inline e152 e152" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#dt-node" xlink:show="new" xlink:type="simple"><textual class="po-textual">node</textual></link><textual class="po-textual"> in an instance of the data model is
                    unique: identical to itself, and not identical to any other node. (</textual><link class="po-inline e153 e153" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#dt-atomic-value" xlink:show="new" xlink:type="simple"><textual class="po-textual">Atomic values</textual></link><textual class="po-textual">
                    do not have identity; every instance of the value “5” as an integer is identical to every other instance of the value “5” as an integer.)</textual></para><attribution class="po-block e154 e154"><link class="po-inline e155 e155" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#node-identity" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery and XPath Data Model 3.0 - W3C Working Draft 13 December
                    2011</textual></link></attribution></blockquote></para><para class="po-block e156 e156"><textual class="po-textual">I find this definition confusing:</textual><itemizedlist class="po-table e157 e157"><listitem class="po-container e158 e158"><para class="po-block e159 e159"><textual class="po-textual">Why should the value “5” as an integer be instantiated and why should we care? The value “5” as an integer is... the value “5” as an integer! It's unique and being unique,
                        doesn't it have an identity?</textual></para></listitem><listitem class="po-container e160 e160"><para class="po-block e161 e161"><textual class="po-textual">A node, with all the properties defined in XDM (including its document-uri and parent accessors) would be unique if it had "previous-sibling" or "document-order" accessors.
                    </textual></para></listitem></itemizedlist><note class="po-container e162 e162"><para class="po-block e163 e163"><textual class="po-textual">To find the previous siblings of a node relying only on the accessors defined in XDM (2.0 or 3.0), you'd have to access to the node's parent and loop over it's children until you
                    find the current node that you would identify as such by checking its identity.</textual></para></note></para><para class="po-block e164 e164"><textual class="po-textual">Rather than focussing on uniqueness, which for immutable information items does not really matter, a better differentiation could be between information items which have enough context
            information to "know where they belong" in the data model and those which don't. </textual></para><para class="po-block e165 e165"><textual class="po-textual">This differentiation has the benefit of highlighting the consequences of having or not having an identity: to be able to navigate between an information item and its ancestors or sibling
            this item must know where it belongs. When that's not the case, it is still be possible to navigate between the item and its descendants but axis such as </textual><code class="po-atom e166 e166"><textual class="po-textual">ancestor::</textual></code><textual class="po-textual"> or
                </textual><code class="po-atom e167 e167"><textual class="po-textual">sibling::</textual></code><textual class="po-textual"> are not available. </textual></para><note class="po-container e168 e168"><para class="po-block e169 e169"><textual class="po-textual">Identity can be seen as the price to pay for the </textual><code class="po-atom e170 e170"><textual class="po-textual">ancestor::</textual></code><textual class="po-textual"> and </textual><code class="po-atom e171 e171"><textual class="po-textual">sibling::</textual></code><textual class="po-textual"> axis. </textual></para></note><para class="po-block e172 e172"><textual class="po-textual">Let's take back a simple example:</textual></para><para class="po-block e173 e173"><textual class="po-textual">
            </textual><programlisting class="po-block e174 e174" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;foo&gt;5&lt;/foo&gt;
    &lt;foo&gt;5&lt;/foo&gt;
    &lt;bar&gt; 
        &lt;foo&gt;5&lt;/foo&gt;
    &lt;/bar&gt;
&lt;/root&gt;</textual></programlisting><textual class="po-textual">
        </textual></para><para class="po-block e175 e175"><textual class="po-textual">In an hypothetical data model where nodes have no identity, there would be only 3 elements:</textual><itemizedlist class="po-table e176 e176"><listitem class="po-container e177 e177"><para class="po-block e178 e178"><textual class="po-textual">The root element</textual></para></listitem><listitem class="po-container e179 e179"><para class="po-block e180 e180"><textual class="po-textual">The bar element</textual></para></listitem><listitem class="po-container e181 e181"><para class="po-block e182 e182"><textual class="po-textual">The foo element (referred twice has children of root end once as child of bar)</textual></para></listitem></itemizedlist></para><para class="po-block e183 e183"><textual class="po-textual">If we add identity (or context information) properties, the foo elements become three information different items since they defer by these properties.</textual></para><para class="po-block e184 e184"><textual class="po-textual">The process of adding these properties to an information item looks familiar. Depending on your background, you can compare it to:</textual><itemizedlist class="po-table e185 e185"><listitem class="po-container e186 e186"><para class="po-block e187 e187"><textual class="po-textual">class/object instantiation in class based Object Oriented Programming</textual></para></listitem><listitem class="po-container e188 e188"><para class="po-block e189 e189"><textual class="po-textual">clones in prototype based Object Oriented Programming</textual></para></listitem><listitem class="po-container e190 e190"><para class="po-block e191 e191"><textual class="po-textual">RDF reification.</textual></para></listitem></itemizedlist></para><para class="po-block e192 e192"><textual class="po-textual">We've seen that XDM 3.0 acknowledges this difference between information items which have context information and those which don't have. I don't want to deny that both types of data
            models have their use cases: there are obviously many use cases where context information is needed and use cases where lightweight structures are a better fit.</textual></para><para class="po-block e193 e193"><textual class="po-textual">That being said, if we are serious about the support of JSON in XDM, we should offer the same features to access data whether this data is stored in maps or in XML nodes. </textual></para><para class="po-block e194 e194"><textual class="po-textual">Let's consider this JSON object borrowed from the XSLT 3.0 Working
            Draft:</textual><programlisting class="po-block e195 e195" xml:space="preserve"><textual class="po-textual">{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  </textual></programlisting></para><para class="po-block e196 e196"><textual class="po-textual">This object could be represented in XML by the following
            document:</textual><programlisting class="po-block e197 e197" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;company&gt;
    &lt;department name="sales"&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Sally&lt;/firstName&gt;
            &lt;lastName&gt;Green&lt;/lastName&gt;
            &lt;age&gt;27&lt;/age&gt;
        &lt;/employee&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Jim&lt;/firstName&gt;
            &lt;lastName&gt;Galley&lt;/lastName&gt;
            &lt;age&gt;41&lt;/age&gt;
        &lt;/employee&gt;
    &lt;/department&gt;
    &lt;department name="accounting"&gt;
        &lt;employee&gt;
            &lt;firstName&gt;John&lt;/firstName&gt;
            &lt;lastName&gt;Doe&lt;/lastName&gt;
            &lt;age&gt;23&lt;/age&gt;
        &lt;/employee&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Mary&lt;/firstName&gt;
            &lt;lastName&gt;Smith&lt;/lastName&gt;
            &lt;age&gt;32&lt;/age&gt;
        &lt;/employee&gt;
    &lt;/department&gt;
&lt;/company&gt;</textual></programlisting></para><para class="po-block e198 e198"><textual class="po-textual">The features introduced in the latest XSLT 3.0 Working Draft do allow to transform rather easily from one model to the other, but these two models do not have, bar far, the same
            features.</textual></para><para class="po-block e199 e199"><textual class="po-textual">In the XML flavor, when the context item is the employee "John Doe", you can easily find out what his department is because this is an element and element do carry context information.
            In the map flavor by contrast when the context item is an employee map, this object has no context information and you can't tell which is his department without looping within the
            containing map.  </textual></para><para class="po-block e200 e200"><textual class="po-textual">This important restriction is at a purely data model level. It is aggravated by the XPath syntax has not been extended to generalize axis so that they can work with maps. If I work with
            the XML version of this structure, it's obvious to evaluate things such as the number of employees, the average age of employees, the number of departments, the number of employees by
            department, the average age by department, obvious to find out if there is an employee called "Mary Smith" in one of the departments, the employees who are more than 40, to get a list of
            employees from all the department sorted by age, ... In the map flavor by contrast, I don't have any XPath axis available and must do all these operations using a limited number of map
            functions (map:keys(), map:contains(), map:get()). In other words, while I can use XPath expressions with the XML version, I must use DOM like operations to access the map version!</textual></para><para class="po-block e201 e201"><textual class="po-textual">To summarize, yes XDM 3.0 does support JSON but to do pretty much anything interesting with JSON objects, you'd better transform them into XML nodes first! XSLT 3.0 does give you the
            tools to do this transformation quite easily but the message to JSON users is that we don't treat their data model as a first class citizen.</textual></para><para class="po-block e202 e202"><textual class="po-textual">To make it worse, XPath is used by many other specifications, within and outside the W3C and the level of support for JSON provided by XDM and XPath will determine how these
            specifications will be able to support for JSON. Specifications that are impacted by this issue include XForms, XProc and Schematron. Supporting JSON would be really useful for these three
            specifications if and only if map items could have the same features than nodes.</textual></para><para class="po-block e203 e203"><textual class="po-textual">Furthermore, the same asymmetry exists when you went to create these two structures from other sources: to create the XML structure you can use sequence constructors but to create the
            map structure, you have to use the </textual><code class="po-atom e204 e204"><textual class="po-textual">map:new()</textual></code><textual class="po-textual"> and </textual><code class="po-atom e205 e205"><textual class="po-textual">map:item()</textual></code><textual class="po-textual"> functions.</textual></para><para class="po-block e206 e206"><textual class="po-textual">My proposal to solve this issue is:</textual><itemizedlist class="po-table e207 e207"><listitem class="po-container e208 e208"><para class="po-block e209 e209"><textual class="po-textual">To acknowledge the fact that any type of information item can be either "context independent" or include context information and explore the consequences of this
                        statement.</textual></para></listitem><listitem class="po-container e210 e210"><para class="po-block e211 e211"><textual class="po-textual">To generalize XPath axis so that they can be used with map items. </textual></para></listitem><listitem class="po-container e212 e212"><para class="po-block e213 e213"><textual class="po-textual">To create sequence constructors for maps and map entries.</textual></para></listitem></itemizedlist></para><para class="po-block e214 e214"><textual class="po-textual">You are welcome to discuss this further:</textual><itemizedlist class="po-table e215 e215"><listitem class="po-container e216 e216"><para class="po-block e217 e217"><textual class="po-textual"> W3C XSLT 3.0 </textual><link class="po-inline e218 e218" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=16118" xlink:show="new" xlink:type="simple"><textual class="po-textual">Bug 16118</textual></link><textual class="po-textual">, "Maps should be first class citizens"</textual></para></listitem><listitem class="po-container e219 e219"><para class="po-block e220 e220"><textual class="po-textual">Blog entry: </textual><link class="po-inline e221 e221" xlink:actuate="onRequest" xlink:href="http://eric.van-der-vlist.com/blog/2012/02/25/xdm-maps-should-be-first-class-citizens/" xlink:show="new" xlink:type="simple"><textual class="po-textual">XDM Maps should be first class citizens</textual></link><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e222 e222"><para class="po-block e223 e223"><textual class="po-textual">Blog entry: </textual><link class="po-inline e224 e224" xlink:actuate="onRequest" xlink:href="http://eric.van-der-vlist.com/blog/2012/02/28/more-musings-on-xdm-3-0/" xlink:show="new" xlink:type="simple"><textual class="po-textual">More musings on XDM 3.0</textual></link></para></listitem></itemizedlist></para></section><section class="po-hcontainer e225 e225"><title class="po-block e226 e226"><textual class="po-textual">Introducing χίμαιραλ (chimeral), the Chimera Language</textual></title><para class="po-block e227 e227"><textual class="po-textual">When I started to work on </textual><link class="po-inline e228 e228" xlink:actuate="onRequest" xlink:href="http://χίμαιραλ.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">χίμαιραλ</textual></link><textual class="po-textual"> a few months ago, my first motivation was to propose an XDM serialization for maps which would turn the
            rather abstract prose from the specification into concrete angle brackets that you could see and read.</textual></para><para class="po-block e229 e229"><textual class="po-textual">The exercise has been very instructive and helped me a lot to understand the spec, however a more ambitious use pattern has emerged while I was making progress. The XSLT 3.0 Working
            Draft is part of a batch of Working Drafts which are far more advanced. My proposals to solve the "map identity crisis" are probably too intrusive and too late to be taken into account and
            the batch of specifications will most probably carry on with the current proposal.</textual></para><para class="po-block e230 e230"><textual class="po-textual">If that's the case, we've seen that it makes a lot of sense to convert maps into nodes to enable to use XPath axis and χίμαιραλ provides a generic target format for these
            conversions.</textual></para><section class="po-hcontainer e231 e231"><title class="po-block e232 e232"><textual class="po-textual">Example</textual></title><para class="po-block e233 e233"><textual class="po-textual">Let's take again the JSON object borrowed from the XSLT 3.0 Working
                Draft:</textual><programlisting class="po-block e234 e234" xml:space="preserve"><textual class="po-textual">{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  </textual></programlisting></para><para class="po-block e235 e235"><textual class="po-textual">Its χίμαιραλ representation
                is:</textual><programlisting class="po-block e236 e236" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
    &lt;χ:map&gt;
        &lt;χ:entry key="sales" keyType="string"&gt;
            &lt;χ:map&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
            &lt;/χ:map&gt;
        &lt;/χ:entry&gt;
        &lt;χ:entry key="accounting" keyType="string"&gt;
            &lt;χ:map&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
            &lt;/χ:map&gt;
        &lt;/χ:entry&gt;
    &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e237 e237"><textual class="po-textual">Granted, it's much more verbose than the JSON version, but it's the exact translation of the XDM corresponding to the JSON object in XML. </textual></para></section><section class="po-hcontainer e238 e238"><title class="po-block e239 e239"><textual class="po-textual">χίμαιραλ In a Nutshell</textual></title><para class="po-block e240 e240"><textual class="po-textual">The design goals are:</textual><itemizedlist class="po-table e241 e241"><listitem class="po-container e242 e242"><para class="po-block e243 e243"><textual class="po-textual">Be as close as possible to the XDM and its terminology</textual></para></listitem><listitem class="po-container e244 e244"><para class="po-block e245 e245"><textual class="po-textual">Represent XML nodes as... XML nodes</textual></para></listitem><listitem class="po-container e246 e246"><para class="po-block e247 e247"><textual class="po-textual">Allow round-trips (an XDM model serialized as χίμαιραλ should give a XDM model identical to the original one when de-serialized)</textual></para></listitem><listitem class="po-container e248 e248"><para class="po-block e249 e249"><textual class="po-textual">Be easy to process using XPath/XQuery/XSLT</textual></para></listitem><listitem class="po-container e250 e250"><para class="po-block e251 e251"><textual class="po-textual">Support of the PSVI is not a goal</textual></para></listitem></itemizedlist></para><para class="po-block e252 e252"><textual class="po-textual">χίμαιραλ is not the only proposal to serialize XDM as XML. Two other notable ones are:</textual><itemizedlist class="po-table e253 e253"><listitem class="po-container e254 e254"><para class="po-block e255 e255"><textual class="po-textual">Zorba's </textual><link class="po-inline e256 e256" xlink:actuate="onRequest" xlink:href="http://bazaar.launchpad.net/~zorba-coders/zorba/pul-and-xdm-schemas/view/head:/schemas/xdm.xsd" xlink:show="new" xlink:type="simple"><textual class="po-textual">XDM serialization</textual></link><textual class="po-textual"> is a straight and
                            accurate XDM serialization which does support PSVI annotations. As a consequence, nodes are serialized as </textual><code class="po-atom e257 e257"><textual class="po-textual">xdm:*</textual></code><textual class="po-textual"> elements (an element is an
                                </textual><code class="po-atom e258 e258"><textual class="po-textual">xdm:element</textual></code><textual class="po-textual">, an attribute an </textual><code class="po-atom e259 e259"><textual class="po-textual">xdm:attribute</textual></code><textual class="po-textual"> element, ...). This does'n meet  by second requirement to represent nodes as themselves.</textual></para></listitem><listitem class="po-container e260 e260"><para class="po-block e261 e261"><link class="po-inline e262 e262" xlink:actuate="onRequest" xlink:href="http://balisage.net/Proceedings/vol7/html/Rennau01/BalisageVol7-Rennau01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">XDML</textual></link><textual class="po-textual">, presented by Rennau, Hans-Jürgen, and David A. Lee at
                            Balisage 2011 is more than just an XDM serialization and also includes manipulation and processing definitions. It introduces its own terminology and concepts and is too
                            far away from XDM for my design goals.</textual></para></listitem></itemizedlist></para><para class="po-block e263 e263"><textual class="po-textual">A lot of attention has been given to the first design goal: the structure of a χίμαιραλ model and the name of its elements and attributes are directly derived from the
                specifications.</textual></para><para class="po-block e264 e264"><textual class="po-textual">In XDM, map entries' values can be arrays (an array beeing nothing else than a map with integer keys) but also sequences (which is not possible in JSON). χίμαιραλ respects the fact
                that in XDM there is no difference between a sequence composed of a single element and represents sequences by a repetition of values.</textual></para><para class="po-block e265 e265"><textual class="po-textual">The map </textual><code class="po-atom e266 e266"><textual class="po-textual">map{1:= 'foo'}</textual></code><textual class="po-textual"> is serialized
                as:</textual><programlisting class="po-block e267 e267" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="1" keyType="number"&gt;
         &lt;χ:atomic-value type="string"&gt;foo&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e268 e268"><textual class="po-textual">And the map </textual><code class="po-atom e269 e269"><textual class="po-textual">map{1:= ('foo', 'bar')}</textual></code><textual class="po-textual"> is serialized
                as:</textual><programlisting class="po-block e270 e270" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="1" keyType="number"&gt;
         &lt;χ:atomic-value type="string"&gt;foo&lt;/χ:atomic-value&gt;
         &lt;χ:atomic-value type="string"&gt;bar&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e271 e271"><textual class="po-textual">We've seen that XDM makes a clear distinction between nodes which have identities and other item types (atomic values, functions and maps) which haven't. XDM allows to use nodes as
                map entry values. χίμαιραλ allows this feature too, but copying the nodes would create new nodes with different identities.</textual></para><para class="po-block e272 e272"><textual class="po-textual">To avoid that, documents to which these nodes belong are copied into χ:instance elements and references between map entries values and instances are made using XPath expressions. </textual></para><para class="po-block e273 e273"><textual class="po-textual">The following </textual><code class="po-atom e274 e274"><textual class="po-textual">$map</textual></code><textual class="po-textual">
                variable:</textual><programlisting class="po-block e275 e275" xml:space="preserve"><textual class="po-textual">&lt;xsl:variable name="a-node"&gt;
    &lt;foo/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map" select="map{'a-node':= $a-node}"/&gt;</textual></programlisting></para><para class="po-block e276 e276"><textual class="po-textual">Is serialized
                as:</textual><programlisting class="po-block e277 e277" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:instance id="d4" kind="document"&gt;
      &lt;foo/&gt;
   &lt;/χ:instance&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="a-node" keyType="string"&gt;
         &lt;χ:node kind="document" instance="d4" path="/"/&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e278 e278"><textual class="po-textual">Like XSLT variable, instances do not always contain document nodes and the following </textual><code class="po-atom e279 e279"><textual class="po-textual">$map</textual></code><textual class="po-textual">
                variable:</textual><programlisting class="po-block e280 e280" xml:space="preserve"><textual class="po-textual">&lt;xsl:variable name="a-node" as="node()"&gt;
    &lt;foo/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map" select="map{'a-node':= $a-node}"/&gt;</textual></programlisting></para><para class="po-block e281 e281"><textual class="po-textual">Is serialized
                as:</textual><programlisting class="po-block e282 e282" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:instance id="d4e0" kind="fragment"&gt;
      &lt;foo/&gt;
   &lt;/χ:instance&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="a-node" keyType="string"&gt;
         &lt;χ:node kind="element" instance="d4e0" path="root()" name="foo"/&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e283 e283"><textual class="po-textual">Nodes can belong to more than one instances, and this $map
                variable:</textual><programlisting class="po-block e284 e284" xml:space="preserve"><textual class="po-textual">&lt;xsl:variable name="a-node" as="node()*"&gt;
    &lt;foo/&gt;
    &lt;bar/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map" select="map{'a-node':= $a-node}"/&gt;</textual></programlisting></para><para class="po-block e285 e285"><textual class="po-textual">Is serialized
                as:</textual><programlisting class="po-block e286 e286" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:instance id="d4e0" kind="fragment"&gt;
      &lt;foo/&gt;
   &lt;/χ:instance&gt;
   &lt;χ:instance id="d4e3" kind="fragment"&gt;
      &lt;bar/&gt;
   &lt;/χ:instance&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="a-node" keyType="string"&gt;
         &lt;χ:node kind="element" instance="d4e0" path="root()" name="foo"/&gt;
         &lt;χ:node kind="element" instance="d4e3" path="root()" name="bar"/&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e287 e287"><textual class="po-textual">Nodes can be "deep linked", a same node can be linked several times and nodes can be mixed with atomic values at wish. The following $map
                variable:</textual><programlisting class="po-block e288 e288" xml:space="preserve"><textual class="po-textual">&lt;xsl:variable name="doc"&gt;
    &lt;department name="sales"&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Sally&lt;/firstName&gt;
            &lt;lastName&gt;Green&lt;/lastName&gt;
            &lt;age&gt;27&lt;/age&gt;
        &lt;/employee&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Jim&lt;/firstName&gt;
            &lt;lastName&gt;Galley&lt;/lastName&gt;
            &lt;age&gt;41&lt;/age&gt;
        &lt;/employee&gt;
    &lt;/department&gt;
    &lt;department name="accounting"&gt;
        &lt;employee&gt;
            &lt;firstName&gt;John&lt;/firstName&gt;
            &lt;lastName&gt;Doe&lt;/lastName&gt;
            &lt;age&gt;23&lt;/age&gt;
        &lt;/employee&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Mary&lt;/firstName&gt;
            &lt;lastName&gt;Smith&lt;/lastName&gt;
            &lt;age&gt;32&lt;/age&gt;
        &lt;/employee&gt;
    &lt;/department&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map"
    select="map{
            'sales' := $doc/department[@name='sales'],
            'Sally' := $doc//employee[firstName = 'Sally'],
            'kids'  := $doc//employee[age &amp;lt; 30],
            'dep-names-attributes' := $doc/department/@name,
            'dep-names' := for $name in $doc/department/@name return string($name)
            }"/&gt;</textual></programlisting></para><para class="po-block e289 e289"><textual class="po-textual">Is serialized
                as:</textual><programlisting class="po-block e290 e290" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:instance id="d4" kind="document"&gt;
      &lt;department name="sales"&gt;
         &lt;employee&gt;
            &lt;firstName&gt;Sally&lt;/firstName&gt;
            &lt;lastName&gt;Green&lt;/lastName&gt;
            &lt;age&gt;27&lt;/age&gt;
         &lt;/employee&gt;
         &lt;employee&gt;
            &lt;firstName&gt;Jim&lt;/firstName&gt;
            &lt;lastName&gt;Galley&lt;/lastName&gt;
            &lt;age&gt;41&lt;/age&gt;
         &lt;/employee&gt;
      &lt;/department&gt;
      &lt;department name="accounting"&gt;
         &lt;employee&gt;
            &lt;firstName&gt;John&lt;/firstName&gt;
            &lt;lastName&gt;Doe&lt;/lastName&gt;
            &lt;age&gt;23&lt;/age&gt;
         &lt;/employee&gt;
         &lt;employee&gt;
            &lt;firstName&gt;Mary&lt;/firstName&gt;
            &lt;lastName&gt;Smith&lt;/lastName&gt;
            &lt;age&gt;32&lt;/age&gt;
         &lt;/employee&gt;
      &lt;/department&gt;
   &lt;/χ:instance&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="sales" keyType="string"&gt;
         &lt;χ:node kind="element"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[1]"
                 name="department"/&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="Sally" keyType="string"&gt;
         &lt;χ:node kind="element"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[1]/&amp;#34;&amp;#34;:employee[1]"
                 name="employee"/&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="kids" keyType="string"&gt;
         &lt;χ:node kind="element"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[1]/&amp;#34;&amp;#34;:employee[1]"
                 name="employee"/&gt;
         &lt;χ:node kind="element"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[2]/&amp;#34;&amp;#34;:employee[1]"
                 name="employee"/&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="dep-names-attributes" keyType="string"&gt;
         &lt;χ:node kind="attribute"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[1]/@name"
                 name="name"&gt;sales&lt;/χ:node&gt;
         &lt;χ:node kind="attribute"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[2]/@name"
                 name="name"&gt;accounting&lt;/χ:node&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="dep-names" keyType="string"&gt;
         &lt;χ:atomic-value type="string"&gt;sales&lt;/χ:atomic-value&gt;
         &lt;χ:atomic-value type="string"&gt;accounting&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para></section><section class="po-hcontainer e291 e291"><title class="po-block e292 e292"><textual class="po-textual">Remaining Issues</textual></title><para class="po-block e293 e293"><textual class="po-textual">A collation property should be added to </textual><code class="po-atom e294 e294"><textual class="po-textual">&lt;χ:map/&gt;</textual></code><textual class="po-textual">, probably as an attribute, the transformation to serialize to χίμαιραλ should be cleaned up and the reverse
                transformation should be implemented.</textual></para><para class="po-block e295 e295"><textual class="po-textual">These are pretty trivial issues and the biggest one is probably to find a way to cleanly serialize references to nodes that are not contained within an element, such as the following
                $map
                variable:</textual><programlisting class="po-block e296 e296" xml:space="preserve"><textual class="po-textual">&lt;xsl:variable name="attribute" as="node()"&gt;
    &lt;xsl:attribute name="foo"&gt;bar&lt;/xsl:attribute&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map"
    select="map{
            'attribute' := $attribute
            }"/&gt;</textual></programlisting></para><para class="po-block e297 e297"><textual class="po-textual">Support of functions should also be considered.</textual></para></section><section class="po-hcontainer e298 e298"><title class="po-block e299 e299"><textual class="po-textual">χίμαιραλ and the identity crisis</textual></title><para class="po-block e300 e300"><textual class="po-textual">To some extend, χίμαιραλ can be considered as a solution to the XDM identity crisis: </textual><itemizedlist class="po-table e301 e301"><listitem class="po-container e302 e302"><para class="po-block e303 e303"><textual class="po-textual">Serializing an XDM model as χίμαιραλ creates elements for maps, map entries and atomic values and these elements, being nodes, have identities. The serialization is
                            therefore also an instantiation of XDM information items as defined above.</textual></para></listitem><listitem class="po-container e304 e304"><para class="po-block e305 e305"><textual class="po-textual">De-serializing a χίμαιραλ to create an XDM data model is also a de-instantiation-- except of course that the identity of XML nodes is not "removed". </textual></para></listitem></itemizedlist></para><para class="po-block e306 e306"><textual class="po-textual">However, χίμαιραλ does keep a strong difference between nodes which are kept in </textual><code class="po-atom e307 e307"><textual class="po-textual">&lt;χ:instance&gt;</textual></code><textual class="po-textual"> elements and maps and atomic values.</textual></para></section></section><section class="po-hcontainer e308 e308"><title class="po-block e309 e309"><textual class="po-textual">Moving the chimera forward</textual></title><para class="po-block e310 e310"><textual class="po-textual">χίμαιραλ is a good playground to explore the new possibilities offered by XDM 3.0. Here is a (non exhaustive) list of a few directions that seem interesting... </textual></para><note class="po-container e311 e311"><para class="po-block e312 e312"><textual class="po-textual">Don't expect to find fully baked proposals in this section which contains, on the contrary very early drafts of  ideas to follow to support XDM maps as "first class citizens"!</textual></para></note><section class="po-hcontainer e313 e313"><title class="po-block e314 e314"><textual class="po-textual">Embracing RDF</textual></title><para class="po-block e315 e315"><textual class="po-textual">If you had the opportunity to enjoy the sunny weather of Orlando in December 2001, you may remember "</textual><link class="po-inline e316 e316" xlink:actuate="onRequest" xlink:href="http://web.archive.org/web/20020115041927/http://www.idealliance.org/papers/xml2001/papers/html/03-01-04.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">The Syntactic Web</textual></link><textual class="po-textual">" a provocative talk where
                Jonathan Robie has shown how XQuery 1.0 could be used to query normalized XML/RDF documents.</textual></para><para class="po-block e317 e317"><textual class="po-textual">The gap between RDF triples and the versatility of its XML representation was a big issue, but the new features brought by this new version of the XPath/XQuery/XSLT package should
                help us.</textual></para><para class="po-block e318 e318"><textual class="po-textual">The basic data model of RDF is based on triples, a triple being a composed of a subject, a predicate and an object. In XDM, a triple can now be represented by either a sequence, an
                array or a map of three items.</textual></para><para class="po-block e319 e319"><textual class="po-textual">XDM sequences have the property that they cannot include other sequences and representing triples as sequences would mean that you couldn't define sequences of triples. For that
                reason it is probably better to define triples as maps or arrays. An array being a map indexed by integers, that doesn't make a huge difference at a conceptual level, but I find it
                cleaner to access to the subject of a triple using a QName (such as rdf:subject) rather than an index. Following this principle, we could define a triple
                as:</textual><programlisting class="po-block e320 e320" xml:space="preserve"><textual class="po-textual">map {
    xs:QName('rdf:subject')   := xs:anyURI('http://www.example.org/index.html'),
    xs:QName('rdf:predicate') := xs:anyURI('http://purl.org/dc/elements/1.1/creator'),
    xs:QName('rdf:object')    := xs:anyURI('http://www.example.org/staffid/85740')
}</textual></programlisting></para><para class="po-block e321 e321"><textual class="po-textual">The χίμαιραλ serialization of this map
                is:</textual><programlisting class="po-block e322 e322" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:χ="http://χίμαιραλ.com#"
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="rdf:object"
               keyType="xs:QName"&gt;
         &lt;χ:atomic-value type="xs:anyURI"&gt;http://www.example.org/staffid/85740&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="rdf:predicate"
               keyType="xs:QName"&gt;
         &lt;χ:atomic-value type="xs:anyURI"&gt;http://purl.org/dc/elements/1.1/creator&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="rdf:subject"
               keyType="xs:QName"&gt;
         &lt;χ:atomic-value type="xs:anyURI"&gt;http://www.example.org/index.html&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e323 e323"><textual class="po-textual">What can we do with such triples? Using higher order functions, it should not be too difficult to define triple stores with basic query features!</textual></para><para class="po-block e324 e324"><textual class="po-textual">Is this lightweight enough? Or does RDF support deserve new information item types to be supported by XDM?</textual></para></section><section class="po-hcontainer e325 e325"><title class="po-block e326 e326"><textual class="po-textual">Syntactical sugar</textual></title><para class="po-block e327 e327"><textual class="po-textual">We've seen that this JSON
                object</textual><programlisting class="po-block e328 e328" xml:space="preserve"><textual class="po-textual">{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  </textual></programlisting></para><para class="po-block e329 e329"><textual class="po-textual">Is serialized in χίμαιραλ
                as:</textual><programlisting class="po-block e330 e330" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
    &lt;χ:map&gt;
        &lt;χ:entry key="sales" keyType="string"&gt;
            &lt;χ:map&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
            &lt;/χ:map&gt;
        &lt;/χ:entry&gt;
        &lt;χ:entry key="accounting" keyType="string"&gt;
            &lt;χ:map&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
            &lt;/χ:map&gt;
        &lt;/χ:entry&gt;
    &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e331 e331"><textual class="po-textual">We can work with that, but wouldn't it be nice if we had a native syntax that does not use XML elements and attributes to represent maps?</textual></para><para class="po-block e332 e332"><textual class="po-textual">Depending on the requirements, many approaches are possible. </textual></para><para class="po-block e333 e333"><textual class="po-textual">A first option would be to define pluggable notation parsers within XML and
                write:</textual><programlisting class="po-block e334 e334" xml:space="preserve"><textual class="po-textual">&lt;χ:notation mediatype="application/json"&gt;&lt;![CDATA[
{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  
]]&gt;&lt;/χ:notation&gt;</textual></programlisting><textual class="po-textual">The
                meaning of the </textual><code class="po-atom e335 e335"><textual class="po-textual">&lt;χ:notation/&gt;</textual></code><textual class="po-textual"> element would be to trigger a parser supporting the application/json datatype. This is less verbose, more natural to JSON users, but
                doesn't allow to add XML nodes in maps or sequences.</textual></para><para class="po-block e336 e336"><textual class="po-textual">Another direction would be to extend the syntax of XML itself. To do so, again, there are many possibilities. The markup in XML is based on angle brackets and the distinction between
                the different XML productions is usually done through the character following the bracket in the opening tags.</textual></para><para class="po-block e337 e337"><textual class="po-textual">This principle leaves a lot of possibilities. For instance, maps could be identified by the tags </textual><code class="po-atom e338 e338"><textual class="po-textual">&lt;{&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e339 e339"><textual class="po-textual">&lt;/}&gt;</textual></code><textual class="po-textual"> to follow the characters used by XDM map
                literals and JSON objects
                :</textual><programlisting class="po-block e340 e340" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;χ:entry key="sales" keyType="string"&gt;
            &lt;{&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/}&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/}&gt;
                &lt;/χ:entry&gt;
            &lt;/}&gt;
        &lt;/χ:entry&gt;
        &lt;χ:entry key="accounting" keyType="string"&gt;
            &lt;{&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/}&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/}&gt;
                &lt;/χ:entry&gt;
            &lt;/}&gt;
        &lt;/χ:entry&gt;
    &lt;/}&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e341 e341"><textual class="po-textual">Map entries are not ordered and in that respect they are similar to XML attributes. We could use this similarity and use the character </textual><code class="po-atom e342 e342"><textual class="po-textual">@</textual></code><textual class="po-textual"> to identify map
                entries:</textual><programlisting class="po-block e343 e343" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;@"sales" keyType="string"&gt;
            &lt;{&gt;
                &lt;@"1" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@"lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/@"lastName"&gt;
                        &lt;@"age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/@"age"&gt;
                        &lt;@"firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/@"firstName"&gt;
                    &lt;/}&gt;
                &lt;/@"1"&gt;
                &lt;@"2" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@"lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/@"lastName"&gt;
                        &lt;@"age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/@"age"&gt;
                        &lt;@"firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/@"firstName"&gt;
                    &lt;/}&gt;
                &lt;/@"2"&gt;
            &lt;/}&gt;
        &lt;/@"sales"&gt;
        &lt;@"accounting" keyType="string"&gt;
            &lt;{&gt;
                &lt;@"1" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@"lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/@"lastName"&gt;
                        &lt;@"age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/@"age"&gt;
                        &lt;@"firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/@"firstName"&gt;
                    &lt;/}&gt;
                &lt;/@"1"&gt;
                &lt;@"2" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@"lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/@"lastName"&gt;
                        &lt;@"age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/@"age"&gt;
                        &lt;@"firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/@"firstName"&gt;
                    &lt;/}&gt;
                &lt;/@"2"&gt;
            &lt;/}&gt;
        &lt;/@"accounting"&gt;
    &lt;/}&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e344 e344"><textual class="po-textual">The key names have been enclosed between quotes because map keys can include any character including whitespaces, but they can be made optional when they are not needed. We could
                also give to the keyType a default value of
                "string":</textual><programlisting class="po-block e345 e345" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;@sales&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/@lastName
                        &lt;@age&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/@age
                        &lt;@firstName&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/@firstName
                    &lt;/}&gt;
                &lt;/@1
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/@lastName
                        &lt;@age&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/@age
                        &lt;@firstName&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/@firstName
                    &lt;/}&gt;
                &lt;/@2
            &lt;/}&gt;
        &lt;/@sales
        &lt;@accounting&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/@lastName
                        &lt;@age&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/@age
                        &lt;@firstName&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/@firstName
                    &lt;/}&gt;
                &lt;/@1
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/@lastName
                        &lt;@age&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/@age
                        &lt;@firstName&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/@firstName
                    &lt;/}&gt;
                &lt;/@2
            &lt;/}&gt;
        &lt;/@accounting
    &lt;/}&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e346 e346"><textual class="po-textual">Atomic values could be identified by </textual><code class="po-atom e347 e347"><textual class="po-textual">&lt;=&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e348 e348"><textual class="po-textual">&lt;/=&gt;</textual></code><textual class="po-textual"> and the same default value applied to its type
                attribute:</textual><programlisting class="po-block e349 e349" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;@sales&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;=&gt;Green&lt;/=&gt;
                        &lt;/@lastName&gt;
                        &lt;@age&gt;
                            &lt;= type="number"&gt;27&lt;/=&gt;
                        &lt;/@age&gt;
                        &lt;@firstName&gt;
                            &lt;=&gt;Sally&lt;/=&gt;
                        &lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@1&gt;
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;=&gt;Galley&lt;/=&gt;
                        &lt;/@lastName&gt;
                        &lt;@age&gt;
                            &lt;= type="number"&gt;41&lt;/=&gt;
                        &lt;/@age&gt;
                        &lt;@firstName&gt;
                            &lt;=&gt;Jim&lt;/=&gt;
                        &lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@2&gt;
            &lt;/}&gt;
        &lt;/@sales&gt;
        &lt;@accounting&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;=&gt;Doe&lt;/=&gt;
                        &lt;/@lastName&gt;
                        &lt;@age&gt;
                            &lt;= type="number"&gt;23&lt;/=&gt;
                        &lt;/@age&gt;
                        &lt;@firstName&gt;
                            &lt;=&gt;John&lt;/=&gt;
                        &lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@1&gt;
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;=&gt;Smith&lt;/=&gt;
                        &lt;/@lastName&gt;
                        &lt;@age&gt;
                            &lt;= type="number"&gt;32&lt;/=&gt;
                        &lt;/@age&gt;
                        &lt;@firstName&gt;
                            &lt;=&gt;Mary&lt;/=&gt;
                        &lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@2&gt;
            &lt;/}&gt;
        &lt;/@accounting&gt;
    &lt;/}&gt;
&lt;/χ:data-model&gt;</textual></programlisting></para><para class="po-block e350 e350"><textual class="po-textual">The tags that surround atomic values are useful when these values are within a sequence but look superfluous when the item has a single value. The next step could be to define that
                in that case as a shortcut the value and its type attribute could be directly included in the
                item:</textual><programlisting class="po-block e351 e351" xml:space="preserve"><textual class="po-textual">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;@sales&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;Green&lt;/@lastName&gt;
                        &lt;@age type="number"&gt;27&lt;/@age&gt;
                        &lt;@firstName&gt;Sally&lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@1&gt;
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;Galley&lt;/@lastName&gt;
                        &lt;@age type="number"&gt;41&lt;/@age&gt;
                        &lt;@firstName&gt;Jim&lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@2&gt;
            &lt;/}&gt;
        &lt;/@sales&gt;
        &lt;@accounting&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;Doe&lt;/@lastName&gt;
                        &lt;@age type="number"&gt;23&lt;/@age&gt;
                        &lt;@firstName&gt;John&lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@1&gt;
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;Smith&lt;/@lastName&gt;
                        &lt;@age type="number"&gt;32&lt;/@age&gt;
                        &lt;@firstName&gt;Mary&lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@2&gt;
            &lt;/}&gt;
        &lt;/@accounting&gt;
    &lt;/}&gt;
&lt;/χ:data-model&gt;
</textual></programlisting></para></section><section class="po-hcontainer e352 e352"><title class="po-block e353 e353"><textual class="po-textual">XPath</textual></title><para class="po-block e354 e354"><textual class="po-textual">The χίμαιραλ serialization being XML, it is possible to use XPath path expressions to query its structure. For instance, to get a list of employees which are less than 30, we can
                write:</textual><programlisting class="po-block e355 e355" xml:space="preserve"><textual class="po-textual">χ:map/χ:entry/χ:map/χ:entry/χ:map[χ:entry[@key='age'][χ:atomic-value &lt; 30]]</textual></programlisting></para><para class="po-block e356 e356"><textual class="po-textual">Or, if we're feeling lucky:</textual><programlisting class="po-block e357 e357" xml:space="preserve"><textual class="po-textual">//χ:map[χ:entry[@key='age'][χ:atomic-value &lt; 30]]</textual></programlisting></para><para class="po-block e358 e358"><textual class="po-textual">Again, that's good as long we work on a χίμαιραλ serialization but it would be good to be able to use </textual><link class="po-inline e359 e359" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2011/WD-xpath-30-20111213/#id-path-expressions" xlink:show="new" xlink:type="simple"><textual class="po-textual">path expressions</textual></link><textual class="po-textual">  directly on map data structures. To do so we would need at minima to
                define steps to match maps and entries.</textual></para><para class="po-block e360 e360"><textual class="po-textual">XSLT 3.0 introduces a new </textual><link class="po-inline e361 e361" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#map-type" xlink:show="new" xlink:type="simple"><code class="po-atom e362 e362"><textual class="po-textual">map()</textual></code><textual class="po-textual"> item type</textual></link><textual class="po-textual"> which could be used as a </textual><link class="po-inline e363 e363" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2011/WD-xpath-30-20111213/#doc-xpath30-KindTest" xlink:show="new" xlink:type="simple"><textual class="po-textual">kind test</textual></link><textual class="po-textual"> to identify maps.</textual></para><para class="po-block e364 e364"><textual class="po-textual">If we follow the idea that map entries are similar to XML attributes, we could use the </textual><code class="po-atom e365 e365"><textual class="po-textual">@</textual></code><textual class="po-textual"> notation to identify them. The XPath expression would then
                become:</textual><programlisting class="po-block e366 e366" xml:space="preserve"><textual class="po-textual">map()/@*/map()/@*/map()[@age &lt; 30]]</textual></programlisting></para><para class="po-block e367 e367"><textual class="po-textual">Or, if we're feeling lucky:</textual><programlisting class="po-block e368 e368" xml:space="preserve"><textual class="po-textual">//map()[@age &lt; 30]]</textual></programlisting></para></section><section class="po-hcontainer e369 e369"><title class="po-block e370 e370"><textual class="po-textual">Validation</textual></title><para class="po-block e371 e371"><textual class="po-textual">These data models can be complex. Wouldn't it be useful to be able to validate them with schema languages? This would give us a way to validate JSON maps!</textual></para><para class="po-block e372 e372"><textual class="po-textual">Of course we can already serialize them in χίμαιραλ and validate the serialization using any schema language, but again it would be good to be able to validate these structures
                directly.</textual></para><para class="po-block e373 e373"><textual class="po-textual">A RELAX NG schema to validate the χίμαιραλ serialization of our example would
                be:</textual><programlisting class="po-block e374 e374" xml:space="preserve"><textual class="po-textual">namespace χ = "http://χίμαιραλ.com#"

start = element χ:data-model { top-level-map }

# Top level map: departments
top-level-map =
    element χ:map {
        element χ:entry {
            attribute key { xsd:NMTOKEN },
            attribute keyType { "string" },
            emp-array
        }*
    }

# List of employees
emp-array =
    element χ:map {
        element χ:entry {
            attribute key { xsd:positiveInteger },
            attribute keyType { "number" },
            emp-map
        }*
    }

# Description of an employee
emp-map = element χ:map { (age | firstName | lastName) + }

age =
    element χ:entry {
        attribute key { "age" },
        attribute keyType { "string" },
        element χ:atomic-value {
            attribute type { "number" },
            xsd:positiveInteger
        }
    }

firstName =
    element χ:entry {
        attribute key { "firstName" },
        attribute keyType { "string" },
        element χ:atomic-value {
            attribute type { "string" },
            xsd:token
        }
    }

lastName =
    element χ:entry {
        attribute key { "lastName" },
        attribute keyType { "string" },
        element χ:atomic-value {
            attribute type { "string" },
            xsd:token
        }
    }
</textual></programlisting></para><note class="po-container e375 e375"><para class="po-block e376 e376"><textual class="po-textual">In the description of the maps used to describe employees, we cannot use </textual><code class="po-atom e377 e377"><textual class="po-textual">interleave</textual></code><textual class="po-textual"> patterns because of the </textual><link class="po-inline e378 e378" xlink:actuate="onRequest" xlink:href="http://relaxng.org/spec-20011203.html#interleave-restrictions" xlink:show="new" xlink:type="simple"><textual class="po-textual">restriction on interleave</textual></link><textual class="po-textual"> and the schema is approximate. In this specific case, we could
                    enumerate the six possible combinations but the exercise would quickly become verbose if the number of items
                    grew:</textual><programlisting class="po-block e379 e379" xml:space="preserve"><textual class="po-textual">emp-map = element χ:map { 
      (age, firstName, lastName)  
    | (age, lastName, firstName) 
    | (firstName, age, lastName)  
    | (firstName, lastName, age) 
    | (lastName, age, firstName)  
    | (lastName, firstName, age) 
}</textual></programlisting></para></note><para class="po-block e380 e380"><textual class="po-textual">A Schematron schema for the χίμαιραλ serialization could be developed based on XPath expressions similar to those that have been shown in the previous section.</textual></para><para class="po-block e381 e381"><textual class="po-textual">Again, it would be interesting to support maps directly as first class citizens in XML schema languages.</textual></para><para class="po-block e382 e382"><textual class="po-textual">The ability to use Schematron on XDM maps depends directly on the ability to browse maps using patterns and path expressions in XPath and XSLT (see above)...</textual></para><para class="po-block e383 e383"><textual class="po-textual">The main impact on RELAX NG would be to add </textual><code class="po-atom e384 e384"><textual class="po-textual">map</textual></code><textual class="po-textual"> and </textual><code class="po-atom e385 e385"><textual class="po-textual">item</textual></code><textual class="po-textual"> patterns and the schema could look
                like:</textual><programlisting class="po-block e386 e386" xml:space="preserve"><textual class="po-textual">namespace χ = "http://χίμαιραλ.com#"

start = element χ:data-model { top-level-map }

# Top level map: departments
top-level-map =
    map  {
        entry xsd:NMTOKEN {
            emp-array
        }*
    }

# List of employees
emp-array =
    map {
        entry xsd:positiveInteger {
            emp-map
        }*
    }

# Description of an employee
emp-map = map { age, firstName, lastName  }

age =
    entry age {
            xsd:positiveInteger
        }
    }

firstName =
    entry firstName {
             xsd:token
        }
    }

lastName =
    entry lastName {
            xsd:token
        }
    }
</textual></programlisting></para><para class="po-block e387 e387"><textual class="po-textual">Sequences could probably be supported without adding a new pattern but would require to relax some restrictions to allow the description of sequences mixing atomic values, maps and
                nodes (in Relax NG, sequences of atomic values are already possible in list datatypes, sequences of nodes are of course available to describe node contents but these two type of
                sequences cannot be mixed).</textual></para></section></section><section class="po-hcontainer e388 e388"><title class="po-block e389 e389"><textual class="po-textual">Conclusion</textual></title><para class="po-block e390 e390"><textual class="po-textual">According to the definition of chimeras in genetics from Wikipedia quoted in the introduction, </textual><citation class="po-atom e391 e391"><textual class="po-textual">chimeras are formed from at least four parent cells (two fertilized eggs or early
                embryos fused together). Each population of cells keeps its own character and the resulting organism is a mixture of tissues</textual></citation><textual class="po-textual">.</textual></para><para class="po-block e392 e392"><textual class="po-textual">The current XDM proposals have added to the XML data model a foreign model to represent maps. This new model is a superset of the JSON data model. The two data models keep their own
            character and the resulting model is a mixture of information items.</textual></para><para class="po-block e393 e393"><textual class="po-textual">It's far to say that the current XDM proposal is a chimera, something described as </textual><citation class="po-atom e394 e394"><textual class="po-textual">usually ugly, foolish or impossible fantasies</textual></citation><textual class="po-textual"> by Jeni Tennison.</textual></para><para class="po-block e395 e395"><textual class="po-textual">I hope that the proposals sketched in this paper will help to address this situation and fully integrate these new information items in the XML echosystem.</textual></para></section></article></classedDocument>