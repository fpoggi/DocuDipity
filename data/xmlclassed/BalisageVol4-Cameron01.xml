<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Parallel Bit Stream Technology as a Foundation for XML Parsing Performance</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">International Symposium on Processing XML Efficiently: Overcoming Limits on Space, Time, or Bandwidth</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 10, 2009</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">By first transforming the octets (bytes) of XML texts into eight parallel bit
            streams, the SIMD features of commodity processors can be exploited for parallel
            processing of blocks of 128 input bytes at a time. Established transcoding and parsing
            techniques are reviewed followed by new techniques including parsing with bitstream
            addition. Further opportunities are discussed in light of expected advances in CPU
            architecture and compiler technology. Implications for various APIs and information
            models are presented as well opportunities for collaborative open-source
         development.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Rob</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Cameron</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Dr. Rob Cameron is Professor and Director of Computing Science at Simon Fraser
               University. With a broad spectrum of research interests related to programming
               languages, software engineering and sociotechnical design of public computing
               infrastructure, he has recently been focusing on high performance text processing
               using parallel bit stream technology and its applications to XML. He is also a
               patentleft evangelist, advocating university-based technology transfer models
               dedicated to free use in open source. </textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Professor of Computing Science</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">Simon Fraser University</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">cameron@cs.sfu.ca</textual></email></author><author class="po-record e18 e18"><personname class="po-record e19 e19"><firstname class="po-field e20 e20"><textual class="po-textual">Ken</textual></firstname><surname class="po-field e21 e21"><textual class="po-textual">Herdy</textual></surname></personname><personblurb class="po-container e22 e22"><para class="po-block e23 e23"><textual class="po-textual"> Ken Herdy completed an Advanced Diploma of Technology in Geographical Information
               Systems at the British Columbia Institute of Technology in 2003 and earned a Bachelor
               of Science in Computing Science with a Certificate in Spatial Information Systems at
               Simon Fraser University in 2005. </textual></para><para class="po-block e24 e24"><textual class="po-textual"> Ken is currently pursuing graduate studies in Computing Science at Simon Fraser
               University with industrial scholarship support from the Natural Sciences and
               Engineering Research Council of Canada, the Mathematics of Information Technology and
               Complex Systems NCE, and the BC Innovation Council. His research focus is an analysis
               of the principal techniques that may be used to improve XML processing performance in
               the context of the Geography Markup Language (GML). </textual></para></personblurb><affiliation class="po-record e25 e25"><jobtitle class="po-field e26 e26"><textual class="po-textual">Graduate Student, School of Computing Science</textual></jobtitle><orgname class="po-block e27 e27"><textual class="po-textual">Simon Fraser University </textual></orgname></affiliation><email class="po-field e28 e28"><textual class="po-textual">ksherdy@cs.sfu.ca</textual></email></author><author class="po-record e29 e29"><personname class="po-record e30 e30"><firstname class="po-field e31 e31"><textual class="po-textual">Ehsan</textual></firstname><surname class="po-field e32 e32"><textual class="po-textual">Amiri</textual></surname></personname><personblurb class="po-container e33 e33"><para class="po-block e34 e34"><textual class="po-textual">Ehsan Amiri is a PhD student of Computer Science at Simon Fraser University.
               Before that he studied at Sharif University of Technology, Tehran, Iran. While his
               graduate research has been focused on theoretical problems like fingerprinting, Ehsan
               has worked on some software projects like development of a multi-node firewall as
               well. More recently he has been developing compiler technology for automatic
               generation of bit stream processing code. </textual></para></personblurb><affiliation class="po-record e35 e35"><jobtitle class="po-field e36 e36"><textual class="po-textual">Graduate Student, School of Computing Science</textual></jobtitle><orgname class="po-block e37 e37"><textual class="po-textual">Simon Fraser University</textual></orgname></affiliation><email class="po-field e38 e38"><textual class="po-textual">eamiri@cs.sfu.ca</textual></email></author><legalnotice class="po-container e39 e39"><para class="po-block e40 e40"><textual class="po-textual">Copyright © 2009 Robert D. Cameron, Kenneth S. Herdy and Ehsan Amiri.
            This work is licensed under a Creative Commons Attribution-Noncommercial-No Derivative
            Works 2.5 Canada License.</textual></para></legalnotice></info><section class="po-hcontainer e41 e41"><title class="po-block e42 e42"><textual class="po-textual">Introduction</textual></title><para class="po-block e43 e43"><textual class="po-textual"> While particular XML applications may benefit from special-purpose hardware such as XML
         chips [</textual><xref class="po-milestone e44 e44" linkend="XMLChip09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] or appliances [</textual><xref class="po-milestone e45 e45" linkend="Datapower09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], the bulk
         of the world's XML processing workload will continue to be handled by XML software stacks
         on commodity processors. Exploiting the SIMD capabilities of such processors such as the
         SSE instructions of x86 chips, parallel bit stream technology offers the potential of
         dramatic improvement over byte-at-a-time processing for a variety of XML processing tasks.
         Character set issues such as Unicode validation and transcoding [</textual><xref class="po-milestone e46 e46" linkend="PPoPP08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], normalization of line breaks and white space and XML character validation can be
         handled fully in parallel using this representation. Lexical item streams, such as the bit
         stream marking the positions of opening angle brackets, can also be formed in parallel.
         Bit-scan instructions of commodity processors may then be used on lexical item streams to
         implement rapid single-instruction scanning across variable-length multi-byte text blocks
         as in the Parabix XML parser [</textual><xref class="po-milestone e47 e47" linkend="CASCON08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Overall, these techniques may be
         combined to yield end-to-end performance that may be 1.5X to 15X faster than alternatives
            [</textual><xref class="po-milestone e48 e48" linkend="SVGOpen08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e49 e49"><textual class="po-textual">Continued research in parallel bit stream techniques as well as more conventional
         application of SIMD techniques in XML processing offers further prospects for improvement
         of core XML components as well as for tackling performance-critical tasks further up the
         stack. A newly prototyped technique for parallel tag parsing using bitstream addition is
         expected to improve parsing performance even beyond that achieved using sequential bit
         scans. Several techniques for improved symbol table performance are being investigated,
         including parallel hash value calculation and length-based sorting using the cheap length
         determination afforded by bit scans. To deliver the benefits of parallel bit stream
         technology to the Java world, we are developing Array Set Model (ASM) representations of
         XML Infoset and other XML information models for efficient transmission across the JNI
         boundary.</textual></para><para class="po-block e50 e50"><textual class="po-textual">Amplifying these software advances, continuing hardware advances in commodity processors
         increase the relative advantage of parallel bit stream techniques over traditional
         byte-at-a-time processors. For example, the Intel Core architecture improved SSE processing
         to give superscalar execution of bitwise logic operations (3 instructions per cycle vs. 1
         in Pentium 4). Upcoming 256-bit AVX technology extends the register set and replaces
         destructive two-operand instructions with a nondestructive three-operand form. General
         purpose programming on graphic processing units (GPGPU) such as the upcoming 512-bit
         Larrabee processor may also be useful for XML applications using parallel bit streams. New
         instruction set architectures may also offer dramatic improvements in core algorithms.
         Using the relatively simple extensions to support the principle of inductive doubling, a 3X
         improvement in several core parallel bit stream algorithms may be achieved [</textual><xref class="po-milestone e51 e51" linkend="ASPLOS09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Other possibilities include direct implementation of parallel
         extract and parallel deposit (pex/pdep) instructions [</textual><xref class="po-milestone e52 e52" linkend="Pex06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and
         bit-level interleave operations as in Larrabee, each of which would have important
         application to parallel bit stream processing.</textual></para><para class="po-block e53 e53"><textual class="po-textual">Further prospects for XML performance improvement arise from leveraging the
         intraregister parallelism of parallel bit stream technology to exploit the interchip
         parallelism of multicore computing. Parallel bit stream techniques can support multicore
         parallelism in both data partitioning and task partitioning models. For example, the
         datasection partitioning approach of Wu, Zhang, Yu and Li may be used to partition blocks
         for speculative parallel parsing on separate cores followed by a postprocessing step to
         join partial S-trees [</textual><xref class="po-milestone e54 e54" linkend="Wu08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e55 e55"><textual class="po-textual">In our view, the established and expected performance advantages of parallel bit stream
         technology over traditional byte-at-a-time processing are so compelling that parallel bit
         stream technology should ultimately form the foundation of every high-performance XML
         software stack. We envision a common high-performance XML kernel that may be customized to
         a variety of processor architectures and that supports a wide range of existing and new XML
         APIs. Widespread deployment of this technology should greatly benefit the XML community in
         addressing both the deserved and undeserved criticism of XML on performance grounds. A
         further benefit of improved performance is a substantial greening of XML technologies.</textual></para><para class="po-block e56 e56"><textual class="po-textual">To complement our research program investigating fundamental algorithms and issues in
         high-performance XML processing, our work also involves development of open source software
         implementing these algorithms, with a goal of full conformance to relevant specifications.
         From the research perspective, this approach is valuable in ensuring that the full
         complexity of required XML processing is addressed in reporting and assessing processing
         results. However, our goal is also to use this open source software as a basis of
         technology transfer. A Simon Fraser University spin-off company, called International
         Characters, Inc., has been created to commercialize the results of this work using a
         patent-based open source model.</textual></para><para class="po-block e57 e57"><textual class="po-textual">To date, we have not yet been successful in establishing a broader community of
         participation with our open source code base. Within open-source communities, there is
         often a general antipathy towards software patents; this may limit engagement with our
         technology, even though it has been dedicated for free use in open source. </textual></para><para class="po-block e58 e58"><textual class="po-textual">A further complication is the inherent difficulty of SIMD programming in general, and
         parallel bit stream programming in particular. Considerable work is required with each new
         algorithmic technique being investigated as well as in retargetting our techniques for each
         new development in SIMD and multicore processor technologies. To address these concerns, we
         have increasingly shifted the emphasis of our research program towards compiler technology
         capable of generating parallel bit stream code from higher-level specifications.</textual></para></section><section class="po-hcontainer e59 e59"><title class="po-block e60 e60"><textual class="po-textual">A Catalog of Parallel Bit Streams for XML</textual></title><section class="po-hcontainer e61 e61"><title class="po-block e62 e62"><textual class="po-textual">Introduction</textual></title><para class="po-block e63 e63"><textual class="po-textual">In this section, we introduce the fundamental concepts of parallel bit stream
            technology and present a comprehensive catalog of parallel bit streams for use in XML
            processing. In presenting this catalog, the focus is on the specification of the bit
            streams as data streams in one-to-one correspondence with the character code units of an
            input XML stream. The goal is to define these bit streams in the abstract without
            initially considering memory layouts, register widths or other issues related to
            particular target architectures. In cataloging these techniques, we also hope to convey
            a sense of the breadth of applications of parallel bit stream technology to XML
            processing tasks. </textual></para></section><section class="po-hcontainer e64 e64"><title class="po-block e65 e65"><textual class="po-textual">Basis Bit Streams</textual></title><para class="po-block e66 e66"><textual class="po-textual">Given a byte-oriented text stream represented in UTF-8, for example, we define a
            transform representation of this text consisting of a set of eight parallel bit streams
            for the individual bits of each byte. Thus, the </textual><code class="po-atom e67 e67"><textual class="po-textual">Bit0</textual></code><textual class="po-textual"> stream is the stream
            of bits consisting of bit 0 of each byte in the input byte stream, </textual><code class="po-atom e68 e68"><textual class="po-textual">Bit1</textual></code><textual class="po-textual"> is
            the bit stream consisting of bit 1 of each byte in the input stream and so on. The set
            of streams </textual><code class="po-atom e69 e69"><textual class="po-textual">Bit0</textual></code><textual class="po-textual"> through </textual><code class="po-atom e70 e70"><textual class="po-textual">Bit7</textual></code><textual class="po-textual"> are known as the </textual><emphasis class="po-inline e71 e71"><textual class="po-textual">basis
               streams</textual></emphasis><textual class="po-textual"> of the parallel bit stream representation. The following table
            shows an example XML character stream together with its representation as a set of 8
            basis streams. </textual><table class="po-container e72 e72"><caption class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">XML Character Stream Transposition.</textual></para></caption><colgroup class="po-null e75 e75" span="1"><col align="left" class="po-meta e76 e76" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e77 e77" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e78 e78" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e79 e79" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e80 e80" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e81 e81" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e82 e82"><tr class="po-table e83 e83" valign="top"><td class="po-block e84 e84"><textual class="po-textual">Input Data</textual></td><td class="po-block e85 e85"><textual class="po-textual">
                        </textual><code class="po-atom e86 e86"><textual class="po-textual">&lt;</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e87 e87"><textual class="po-textual">
                        </textual><code class="po-atom e88 e88"><textual class="po-textual">t</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e89 e89"><textual class="po-textual">
                        </textual><code class="po-atom e90 e90"><textual class="po-textual">a</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e91 e91"><textual class="po-textual">
                        </textual><code class="po-atom e92 e92"><textual class="po-textual">g</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e93 e93"><textual class="po-textual">
                        </textual><code class="po-atom e94 e94"><textual class="po-textual">/</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e95 e95"><textual class="po-textual">
                        </textual><code class="po-atom e96 e96"><textual class="po-textual">&gt;</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e97 e97" valign="top"><td class="po-block e98 e98"><textual class="po-textual">ASCII</textual></td><td class="po-block e99 e99"><textual class="po-textual">
                        </textual><code class="po-atom e100 e100"><textual class="po-textual">00111100</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e101 e101"><textual class="po-textual">
                        </textual><code class="po-atom e102 e102"><textual class="po-textual">01110100</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e103 e103"><textual class="po-textual">
                        </textual><code class="po-atom e104 e104"><textual class="po-textual">01100001</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e105 e105"><textual class="po-textual">
                        </textual><code class="po-atom e106 e106"><textual class="po-textual">01100111</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e107 e107"><textual class="po-textual">
                        </textual><code class="po-atom e108 e108"><textual class="po-textual">00101111</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e109 e109"><textual class="po-textual">
                        </textual><code class="po-atom e110 e110"><textual class="po-textual">00111110</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e111 e111" valign="top"><td class="po-block e112 e112"><textual class="po-textual">Bit0</textual></td><td class="po-block e113 e113"><textual class="po-textual">
                        </textual><code class="po-atom e114 e114"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e115 e115"><textual class="po-textual">
                        </textual><code class="po-atom e116 e116"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e117 e117"><textual class="po-textual">
                        </textual><code class="po-atom e118 e118"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e119 e119"><textual class="po-textual">
                        </textual><code class="po-atom e120 e120"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e121 e121"><textual class="po-textual">
                        </textual><code class="po-atom e122 e122"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e123 e123"><textual class="po-textual">
                        </textual><code class="po-atom e124 e124"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e125 e125" valign="top"><td class="po-block e126 e126"><textual class="po-textual">Bit1</textual></td><td class="po-block e127 e127"><textual class="po-textual">
                        </textual><code class="po-atom e128 e128"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e129 e129"><textual class="po-textual">
                        </textual><code class="po-atom e130 e130"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e131 e131"><textual class="po-textual">
                        </textual><code class="po-atom e132 e132"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e133 e133"><textual class="po-textual">
                        </textual><code class="po-atom e134 e134"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e135 e135"><textual class="po-textual">
                        </textual><code class="po-atom e136 e136"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e137 e137"><textual class="po-textual">
                        </textual><code class="po-atom e138 e138"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e139 e139" valign="top"><td class="po-block e140 e140"><textual class="po-textual">Bit2</textual></td><td class="po-block e141 e141"><textual class="po-textual">
                        </textual><code class="po-atom e142 e142"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e143 e143"><textual class="po-textual">
                        </textual><code class="po-atom e144 e144"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e145 e145"><textual class="po-textual">
                        </textual><code class="po-atom e146 e146"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e147 e147"><textual class="po-textual">
                        </textual><code class="po-atom e148 e148"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e149 e149"><textual class="po-textual">
                        </textual><code class="po-atom e150 e150"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e151 e151"><textual class="po-textual">
                        </textual><code class="po-atom e152 e152"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e153 e153" valign="top"><td class="po-block e154 e154"><textual class="po-textual">Bit3</textual></td><td class="po-block e155 e155"><textual class="po-textual">
                        </textual><code class="po-atom e156 e156"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e157 e157"><textual class="po-textual">
                        </textual><code class="po-atom e158 e158"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e159 e159"><textual class="po-textual">
                        </textual><code class="po-atom e160 e160"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e161 e161"><textual class="po-textual">
                        </textual><code class="po-atom e162 e162"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e163 e163"><textual class="po-textual">
                        </textual><code class="po-atom e164 e164"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e165 e165"><textual class="po-textual">
                        </textual><code class="po-atom e166 e166"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e167 e167" valign="top"><td class="po-block e168 e168"><textual class="po-textual">Bit4</textual></td><td class="po-block e169 e169"><textual class="po-textual">
                        </textual><code class="po-atom e170 e170"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e171 e171"><textual class="po-textual">
                        </textual><code class="po-atom e172 e172"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e173 e173"><textual class="po-textual">
                        </textual><code class="po-atom e174 e174"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e175 e175"><textual class="po-textual">
                        </textual><code class="po-atom e176 e176"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e177 e177"><textual class="po-textual">
                        </textual><code class="po-atom e178 e178"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e179 e179"><textual class="po-textual">
                        </textual><code class="po-atom e180 e180"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e181 e181" valign="top"><td class="po-block e182 e182"><textual class="po-textual">Bit5</textual></td><td class="po-block e183 e183"><textual class="po-textual">
                        </textual><code class="po-atom e184 e184"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e185 e185"><textual class="po-textual">
                        </textual><code class="po-atom e186 e186"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e187 e187"><textual class="po-textual">
                        </textual><code class="po-atom e188 e188"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e189 e189"><textual class="po-textual">
                        </textual><code class="po-atom e190 e190"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e191 e191"><textual class="po-textual">
                        </textual><code class="po-atom e192 e192"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e193 e193"><textual class="po-textual">
                        </textual><code class="po-atom e194 e194"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e195 e195" valign="top"><td class="po-block e196 e196"><textual class="po-textual">Bit6</textual></td><td class="po-block e197 e197"><textual class="po-textual">
                        </textual><code class="po-atom e198 e198"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e199 e199"><textual class="po-textual">
                        </textual><code class="po-atom e200 e200"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e201 e201"><textual class="po-textual">
                        </textual><code class="po-atom e202 e202"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e203 e203"><textual class="po-textual">
                        </textual><code class="po-atom e204 e204"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e205 e205"><textual class="po-textual">
                        </textual><code class="po-atom e206 e206"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e207 e207"><textual class="po-textual">
                        </textual><code class="po-atom e208 e208"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e209 e209" valign="top"><td class="po-block e210 e210"><textual class="po-textual">Bit7</textual></td><td class="po-block e211 e211"><textual class="po-textual">
                        </textual><code class="po-atom e212 e212"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e213 e213"><textual class="po-textual">
                        </textual><code class="po-atom e214 e214"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e215 e215"><textual class="po-textual">
                        </textual><code class="po-atom e216 e216"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e217 e217"><textual class="po-textual">
                        </textual><code class="po-atom e218 e218"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e219 e219"><textual class="po-textual">
                        </textual><code class="po-atom e220 e220"><textual class="po-textual">1</textual></code><textual class="po-textual">
                     </textual></td><td class="po-block e221 e221"><textual class="po-textual">
                        </textual><code class="po-atom e222 e222"><textual class="po-textual">0</textual></code><textual class="po-textual">
                     </textual></td></tr></tbody></table><textual class="po-textual">
         </textual></para><para class="po-block e223 e223"><textual class="po-textual"> Depending on the features of a particular processor architecture, there are a number
            of algorithms for transposition to parallel bit stream form. Several of these algorithms
            employ a three-stage structure. In the first stage, the input byte stream is divided
            into a pair of half-length streams consisting of four bits for each byte, for example,
            one stream for the high nybble of each byte and another for the low nybble of each byte.
            In the second stage, these streams of four bits per byte are each divided into streams
            consisting of two bits per original byte, for example streams for the
            </textual><code class="po-atom e224 e224"><textual class="po-textual">Bit0/Bit1</textual></code><textual class="po-textual">, </textual><code class="po-atom e225 e225"><textual class="po-textual">Bit2/Bit3</textual></code><textual class="po-textual">, </textual><code class="po-atom e226 e226"><textual class="po-textual">Bit4/Bit5</textual></code><textual class="po-textual">, and
               </textual><code class="po-atom e227 e227"><textual class="po-textual">Bit6/Bit7</textual></code><textual class="po-textual"> pairs. In the final stage, the streams are further subdivided
            in the individual bit streams. </textual></para><para class="po-block e228 e228"><textual class="po-textual"> Using SIMD capabilities, this process is quite efficient, with an amortized cost of
            1.1 CPU cycles per input byte on Intel Core 2 with SSE, or 0.6 CPU cycles per input byte
            on Power PC G4 with Altivec. With future advances in processor technology, this
            transposition overhead is expected to reduce, possibly taking advantage of upcoming
            parallel extract (pex) instructions on Intel technology. In the ideal, only 24
            instructions are needed to transform a block of 128 input bytes using 128-bit SSE
            registers using the inductive doubling instruction set architecture, representing an
            overhead of less than 0.2 instructions per input byte. </textual></para></section><section class="po-hcontainer e229 e229"><title class="po-block e230 e230"><textual class="po-textual">General Streams</textual></title><para class="po-block e231 e231"><textual class="po-textual">This section describes bit streams which support basic processing operations.</textual></para><section class="po-hcontainer e232 e232"><title class="po-block e233 e233"><textual class="po-textual">Deletion Mask Streams</textual></title><para class="po-block e234 e234"><textual class="po-textual">DelMask (deletion mask) streams marks character code unit positions for deletion.
               Since the deletion operation is dependency free across many stages of XML processing,
               it is possible to simply mark and record deletion positions as deletion mask streams for future processing. A single
               invocation of a SIMD based parallel deletion algorithm can then perform the deletion of
               positions accumulated across a number of stages through a bitwise ORing of deletion
               masks. For example, deletion arises in the replacement of predefined entities with a
               single character, such as in the replacement of the &amp;amp; entity, with the
               &amp; character. Deletion also arises in XML
               end-of-line handling, and CDATA section delimeter processing. Several algorithms to
               delete bits at positions marked by DelMask are possible [</textual><xref class="po-milestone e235 e235" linkend="u8u16"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. </textual></para><para class="po-block e236 e236"><textual class="po-textual">The following table provides an example of generating a DelMask in the context of
               bit stream based parsing of well-formed character references and predefined entities.
               The result is the generation of a DelMask stream. </textual><table class="po-container e237 e237"><caption class="po-container e238 e238"><para class="po-block e239 e239"><textual class="po-textual">DelMask Stream Generation</textual></para></caption><colgroup class="po-null e240 e240" span="1"><col align="left" class="po-meta e241 e241" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e242 e242" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e243 e243"><tr class="po-table e244 e244" valign="top"><td class="po-block e245 e245"><textual class="po-textual">Input Data</textual></td><td class="po-block e246 e246"><textual class="po-textual">
                           </textual><code class="po-atom e247 e247"><textual class="po-textual">&amp;gt; &amp;#13; &amp;#x0a;</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e248 e248" valign="top"><td class="po-block e249 e249"><textual class="po-textual">GenRefs</textual></td><td class="po-block e250 e250"><textual class="po-textual">
                           </textual><code class="po-atom e251 e251"><textual class="po-textual">_11______________</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e252 e252" valign="top"><td class="po-block e253 e253"><textual class="po-textual">DecRefs</textual></td><td class="po-block e254 e254"><textual class="po-textual">
                           </textual><code class="po-atom e255 e255"><textual class="po-textual">_______11________</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e256 e256" valign="top"><td class="po-block e257 e257"><textual class="po-textual">HexRefs</textual></td><td class="po-block e258 e258"><textual class="po-textual">
                           </textual><code class="po-atom e259 e259"><textual class="po-textual">______________11_</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e260 e260" valign="top"><td class="po-block e261 e261"><textual class="po-textual">DelMask</textual></td><td class="po-block e262 e262"><textual class="po-textual">
                           </textual><code class="po-atom e263 e263"><textual class="po-textual">111__1111__11111_</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e264 e264" valign="top"><td class="po-block e265 e265"><textual class="po-textual">ErrorFlag</textual></td><td class="po-block e266 e266"><textual class="po-textual">
                           </textual><code class="po-atom e267 e267"><textual class="po-textual">_________________</textual></code><textual class="po-textual">
                        </textual></td></tr></tbody></table><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e268 e268"><title class="po-block e269 e269"><textual class="po-textual">Error Flag Streams </textual></title><para class="po-block e270 e270"><textual class="po-textual">Error flag streams indicates the character code unit positions of syntactical
               errors. XML processing examples which benefit from the marking of error positions
               include UTF-8 character sequence validation and XML parsing [</textual><xref class="po-milestone e271 e271" linkend="u8u16"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e272 e272"><textual class="po-textual">The following table provides an example of using bit streams to parse character
               references and predefined entities which fail to meet the XML 1.0 well-formedness
               constraints. The result is the generation of an error flag stream that marks the
               positions of mal-formed decimal and hexical character references respectively. </textual><table class="po-container e273 e273"><caption class="po-container e274 e274"><para class="po-block e275 e275"><textual class="po-textual">Error Flag Stream Generation</textual></para></caption><colgroup class="po-null e276 e276" span="1"><col align="left" class="po-meta e277 e277" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e278 e278" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e279 e279"><tr class="po-table e280 e280" valign="top"><td class="po-block e281 e281"><textual class="po-textual">Input Data</textual></td><td class="po-block e282 e282"><textual class="po-textual">
                           </textual><code class="po-atom e283 e283"><textual class="po-textual">&amp;gt; &amp;#, &amp;#x; </textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e284 e284" valign="top"><td class="po-block e285 e285"><textual class="po-textual">GenRefs</textual></td><td class="po-block e286 e286"><textual class="po-textual">
                           </textual><code class="po-atom e287 e287"><textual class="po-textual">_11___________</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e288 e288" valign="top"><td class="po-block e289 e289"><textual class="po-textual">DecRefs</textual></td><td class="po-block e290 e290"><textual class="po-textual">
                           </textual><code class="po-atom e291 e291"><textual class="po-textual">______________</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e292 e292" valign="top"><td class="po-block e293 e293"><textual class="po-textual">HexRefs</textual></td><td class="po-block e294 e294"><textual class="po-textual">
                           </textual><code class="po-atom e295 e295"><textual class="po-textual">______________</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e296 e296" valign="top"><td class="po-block e297 e297"><textual class="po-textual">DelMask</textual></td><td class="po-block e298 e298"><textual class="po-textual">
                           </textual><code class="po-atom e299 e299"><textual class="po-textual">111__11__111__</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e300 e300" valign="top"><td class="po-block e301 e301"><textual class="po-textual">ErrorFlag</textual></td><td class="po-block e302 e302"><textual class="po-textual">
                           </textual><code class="po-atom e303 e303"><textual class="po-textual">_______1____1_</textual></code><textual class="po-textual">
                        </textual></td></tr></tbody></table><textual class="po-textual">
            </textual></para></section></section><section class="po-hcontainer e304 e304"><title class="po-block e305 e305"><textual class="po-textual">Lexical Item Streams</textual></title><para class="po-block e306 e306"><textual class="po-textual">Lexical item streams differ from traditional streams of tokens in that they are bit
            streams that mark the positions of tokens, whitespace or delimiters. Additional bit
            streams, such as the reference streams and callout streams, are subsequently constructed
            based on the information held within the set of lexical items streams. Differentiation
            between the actual tokens that may occur at a particular point (e.g., the different XML
            tokens that begin “&lt;”) may be performed using multicharacter recognizers on the
            bytestream representation [</textual><xref class="po-milestone e307 e307" linkend="CASCON08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e308 e308"><textual class="po-textual">A key role of lexical item streams in XML parsing is to facilitate fast scanning
            operations. For example, a left angle bracket lexical item stream may be formed to
            identify those character code unit positions at which a “&lt;” character occurs.
            Hardware register bit scan operations may then be used by the XML parser on the left
            angle bracket stream to efficiently identify the position of the next “&lt;”. Based
            on the capabilities of current commodity processors, a single register bit scan
            operation may effectively scan up to 64 byte positions with a single instruction.</textual></para><para class="po-block e309 e309"><textual class="po-textual">Overall, the construction of the full set of lexical item stream computations
            requires approximately 1.0 CPU cycles per byte when implemented for 128 positions at a
            time using 128-bit SSE registers on Intel Core2 processors [</textual><xref class="po-milestone e310 e310" linkend="CASCON08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
            The following table defines the core lexical item streams defined by the Parabix XML
            parser.</textual></para><para class="po-block e311 e311"><textual class="po-textual">
            </textual><table class="po-container e312 e312"><caption class="po-container e313 e313"><para class="po-block e314 e314"><textual class="po-textual">Lexical item stream descriptions.</textual></para></caption><tbody class="po-table e315 e315"><tr class="po-table e316 e316"><td align="left" class="po-block e317 e317"><textual class="po-textual"> LAngle </textual></td><td align="left" class="po-block e318 e318"><textual class="po-textual"> Marks the position of any left angle bracket character.</textual></td></tr><tr class="po-table e319 e319"><td align="left" class="po-block e320 e320"><textual class="po-textual"> RAngle </textual></td><td align="left" class="po-block e321 e321"><textual class="po-textual"> Marks the position of any right angle bracket character.</textual></td></tr><tr class="po-table e322 e322"><td align="left" class="po-block e323 e323"><textual class="po-textual"> LBracket </textual></td><td align="left" class="po-block e324 e324"><textual class="po-textual"> Marks the position of any left square bracker character.</textual></td></tr><tr class="po-table e325 e325"><td align="left" class="po-block e326 e326"><textual class="po-textual"> RBracket </textual></td><td align="left" class="po-block e327 e327"><textual class="po-textual"> Marks the position of any right square bracket
                     character.</textual></td></tr><tr class="po-table e328 e328"><td align="left" class="po-block e329 e329"><textual class="po-textual"> Exclam </textual></td><td align="left" class="po-block e330 e330"><textual class="po-textual"> Marks the position of any exclamation mark character.</textual></td></tr><tr class="po-table e331 e331"><td align="left" class="po-block e332 e332"><textual class="po-textual"> QMark </textual></td><td align="left" class="po-block e333 e333"><textual class="po-textual"> Marks the position of any question mark character.</textual></td></tr><tr class="po-table e334 e334"><td align="left" class="po-block e335 e335"><textual class="po-textual"> Hyphen </textual></td><td align="left" class="po-block e336 e336"><textual class="po-textual"> Marks the position of any hyphen character.</textual></td></tr><tr class="po-table e337 e337"><td align="left" class="po-block e338 e338"><textual class="po-textual"> Equals </textual></td><td align="left" class="po-block e339 e339"><textual class="po-textual"> Marks the position of any equal sign character.</textual></td></tr><tr class="po-table e340 e340"><td align="left" class="po-block e341 e341"><textual class="po-textual"> SQuote </textual></td><td align="left" class="po-block e342 e342"><textual class="po-textual"> Marks the position of any single quote character.</textual></td></tr><tr class="po-table e343 e343"><td align="left" class="po-block e344 e344"><textual class="po-textual"> DQuote </textual></td><td align="left" class="po-block e345 e345"><textual class="po-textual"> Marks the position of any double quote character.</textual></td></tr><tr class="po-table e346 e346"><td align="left" class="po-block e347 e347"><textual class="po-textual"> Slash </textual></td><td align="left" class="po-block e348 e348"><textual class="po-textual"> Marks the position of any forward slash character</textual></td></tr><tr class="po-table e349 e349"><td align="left" class="po-block e350 e350"><textual class="po-textual"> NameScan </textual></td><td align="left" class="po-block e351 e351"><textual class="po-textual"> Marks the position of any XML name character.</textual></td></tr><tr class="po-table e352 e352"><td align="left" class="po-block e353 e353"><textual class="po-textual"> WS </textual></td><td align="left" class="po-block e354 e354"><textual class="po-textual"> Marks the position of any XML 1.0 whitespace character.</textual></td></tr><tr class="po-table e355 e355"><td align="left" class="po-block e356 e356"><textual class="po-textual"> PI_start </textual></td><td align="left" class="po-block e357 e357"><textual class="po-textual"> Marks the position of the start of any processing instruction
                        at the '?' character position.</textual></td></tr><tr class="po-table e358 e358"><td align="left" class="po-block e359 e359"><textual class="po-textual"> PI_end </textual></td><td align="left" class="po-block e360 e360"><textual class="po-textual"> Marks the position of any end of any processing instruction
                        at the '&gt;' character position.</textual></td></tr><tr class="po-table e361 e361"><td align="left" class="po-block e362 e362"><textual class="po-textual"> CtCD_start </textual></td><td align="left" class="po-block e363 e363"><textual class="po-textual"> Marks the position of the start of any comment or CDATA
                        section at the '!' character position.</textual></td></tr><tr class="po-table e364 e364"><td align="left" class="po-block e365 e365"><textual class="po-textual"> EndTag_start </textual></td><td align="left" class="po-block e366 e366"><textual class="po-textual"> Marks the position of any end tag at the '/' character
                        position.</textual></td></tr><tr class="po-table e367 e367"><td align="left" class="po-block e368 e368"><textual class="po-textual"> CD_end </textual></td><td align="left" class="po-block e369 e369"><textual class="po-textual"> Marks the position of the end of any CDATA section at the '&gt;'
                        character position. </textual></td></tr><tr class="po-table e370 e370"><td align="left" class="po-block e371 e371"><textual class="po-textual"> DoubleHyphen </textual></td><td align="left" class="po-block e372 e372"><textual class="po-textual"> Marks the position of any double hyphen character.</textual></td></tr><tr class="po-table e373 e373"><td align="left" class="po-block e374 e374"><textual class="po-textual"> RefStart </textual></td><td align="left" class="po-block e375 e375"><textual class="po-textual"> Marks the position of any ampersand character.</textual></td></tr><tr class="po-table e376 e376"><td align="left" class="po-block e377 e377"><textual class="po-textual"> Hash </textual></td><td align="left" class="po-block e378 e378"><textual class="po-textual"> Marks the position of any hash character.</textual></td></tr><tr class="po-table e379 e379"><td align="left" class="po-block e380 e380"><textual class="po-textual"> x </textual></td><td align="left" class="po-block e381 e381"><textual class="po-textual"> Marks the position of any 'x' character.</textual></td></tr><tr class="po-table e382 e382"><td align="left" class="po-block e383 e383"><textual class="po-textual"> Digit </textual></td><td align="left" class="po-block e384 e384"><textual class="po-textual"> Marks the position of any digit.</textual></td></tr><tr class="po-table e385 e385"><td align="left" class="po-block e386 e386"><textual class="po-textual"> Hex </textual></td><td align="left" class="po-block e387 e387"><textual class="po-textual"> Marks the position of any hexidecimal character.</textual></td></tr><tr class="po-table e388 e388"><td align="left" class="po-block e389 e389"><textual class="po-textual"> Semicolon </textual></td><td align="left" class="po-block e390 e390"><textual class="po-textual"> Marks the position of any semicolon character.</textual></td></tr></tbody></table><textual class="po-textual">
         </textual></para><para class="po-block e391 e391"><textual class="po-textual"> The following illustrates a number of the lexical item streams. </textual></para><para class="po-block e392 e392"><textual class="po-textual">
            </textual><table class="po-container e393 e393"><caption class="po-container e394 e394"><para class="po-block e395 e395"><textual class="po-textual">Lexical Item Streams</textual></para></caption><colgroup class="po-null e396 e396" span="1"><col align="left" class="po-meta e397 e397" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e398 e398" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e399 e399"><tr class="po-table e400 e400" valign="top"><td class="po-block e401 e401"><textual class="po-textual">Input Data</textual></td><td class="po-block e402 e402"><textual class="po-textual">
                        </textual><code class="po-atom e403 e403"><textual class="po-textual">&lt;tag&gt;&lt;tag&gt; text &amp;lt;
                           &amp;#x3e; &lt;/tag&gt;&lt;/tag&gt;</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e404 e404" valign="top"><td class="po-block e405 e405"><textual class="po-textual">LAngle</textual></td><td class="po-block e406 e406"><textual class="po-textual">
                        </textual><code class="po-atom e407 e407"><textual class="po-textual">1____1______________________1_____1_____</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e408 e408" valign="top"><td class="po-block e409 e409"><textual class="po-textual">RAngle</textual></td><td class="po-block e410 e410"><textual class="po-textual">
                        </textual><code class="po-atom e411 e411"><textual class="po-textual">____1____1_______________________1_____1</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e412 e412" valign="top"><td class="po-block e413 e413"><textual class="po-textual">WS</textual></td><td class="po-block e414 e414"><textual class="po-textual">
                        </textual><code class="po-atom e415 e415"><textual class="po-textual">__________1____1____1______1____________</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e416 e416" valign="top"><td class="po-block e417 e417"><textual class="po-textual">RefStart</textual></td><td class="po-block e418 e418"><textual class="po-textual">
                        </textual><code class="po-atom e419 e419"><textual class="po-textual">________________1____1__________________</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e420 e420" valign="top"><td class="po-block e421 e421"><textual class="po-textual">Hex</textual></td><td class="po-block e422 e422"><textual class="po-textual">
                        </textual><code class="po-atom e423 e423"><textual class="po-textual">__1____1____1___________11_____1_____1__</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e424 e424" valign="top"><td class="po-block e425 e425"><textual class="po-textual">Semicolon</textual></td><td class="po-block e426 e426"><textual class="po-textual">
                        </textual><code class="po-atom e427 e427"><textual class="po-textual">___________________1______1_____________</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e428 e428" valign="top"><td class="po-block e429 e429"><textual class="po-textual">Slash</textual></td><td class="po-block e430 e430"><textual class="po-textual">
                        </textual><code class="po-atom e431 e431"><textual class="po-textual">_____________________________1_____1____</textual></code><textual class="po-textual">
                     </textual></td></tr></tbody></table><textual class="po-textual">
         </textual></para></section><section class="po-hcontainer e432 e432"><title class="po-block e433 e433"><textual class="po-textual">UTF-8 Byte Classification, Scope and Validation Streams</textual></title><para class="po-block e434 e434"><textual class="po-textual"> An XML parser must accept the UTF-8 encoding of Unicode [</textual><xref class="po-milestone e435 e435" linkend="XML10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
            It is a fatal error if an XML document determined to be in UTF-8 contains byte sequences
            that are not legal in that encoding. UTF-8 byte classification, scope, XML character
            validation and error flag bit streams are defined to validate UTF-8 byte sequences and
            support transcoding to UTF-16.</textual></para><section class="po-hcontainer e436 e436"><title class="po-block e437 e437"><textual class="po-textual">UTF-8 Byte Classification Streams</textual></title><para class="po-block e438 e438"><textual class="po-textual">UTF-8 byte classification bit streams classify UTF-8 bytes based on their role in
               forming single and multibyte sequences. The u8Prefix and u8Suffix bit streams
               identify bytes that represent, respectively, prefix or suffix bytes of multibyte
               UTF-8 sequences. The u8UniByte bit stream identifies those bytes that may be
               considered single-byte sequences. The u8Prefix2, u8Prefix3, and u8Prefix4 refine the
               u8Prefix respectively indicating prefixes of two, three or four byte
            sequences respectively.</textual></para></section><section class="po-hcontainer e439 e439"><title class="po-block e440 e440"><textual class="po-textual">UTF-8 Scope Streams</textual></title><para class="po-block e441 e441"><textual class="po-textual"> Scope streams represent expectations established by UTF-8 prefix bytes. For
               example, the u8Scope22 bit stream represents the positions at which the second byte of a
               two-byte sequence is expected based on the occurrence of a two-byte prefix in the
               immediately preceding position. The u8scope32, u8Scope33, u8Scope42, u8scope43, and
               u8Scope44 complete the set of UTF-8 scope streams.</textual></para><para class="po-block e442 e442"><textual class="po-textual"> The following example demonstrates the UTF-8 character encoding validation
               process using parallel bit stream techniques. The result of this validation process
               is an error flag stream identifying the positions at which errors occur.</textual></para><para class="po-block e443 e443"><textual class="po-textual">
               </textual><table class="po-container e444 e444"><caption class="po-container e445 e445"><para class="po-block e446 e446"><textual class="po-textual">UTF-8 Scope Streams</textual></para></caption><colgroup class="po-null e447 e447" span="1"><col align="left" class="po-meta e448 e448" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e449 e449" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e450 e450"><tr class="po-table e451 e451" valign="top"><td class="po-block e452 e452"><textual class="po-textual">Input Data</textual></td><td class="po-block e453 e453"><code class="po-atom e454 e454"><textual class="po-textual">A Text in Farsi: ى ك  م ت ن  ف ا ر س ى</textual></code></td></tr><tr class="po-table e455 e455" valign="top"><td class="po-block e456 e456"><textual class="po-textual">High Nybbles</textual></td><td class="po-block e457 e457"><textual class="po-textual">
                           </textual><code class="po-atom e458 e458"><textual class="po-textual">42567726624677632D8DBDBDAD82D8DAD82D8D8</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e459 e459" valign="top"><td class="po-block e460 e460"><textual class="po-textual">Low Nybbles</textual></td><td class="po-block e461 e461"><textual class="po-textual">
                           </textual><code class="po-atom e462 e462"><textual class="po-textual">10458409E061239A099838187910968A9509399</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e463 e463" valign="top"><td class="po-block e464 e464"><textual class="po-textual">u8Unibyte</textual></td><td class="po-block e465 e465"><textual class="po-textual">
                           </textual><code class="po-atom e466 e466"><textual class="po-textual">11111111111111111__________1______1____</textual></code><textual class="po-textual">
                           
                        </textual></td></tr><tr class="po-table e467 e467" valign="top"><td class="po-block e468 e468"><textual class="po-textual">u8Prefix</textual></td><td class="po-block e469 e469"><textual class="po-textual">
                           </textual><code class="po-atom e470 e470"><textual class="po-textual">_________________1_1_1_1_1__1_1_1__1_1_</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e471 e471" valign="top"><td class="po-block e472 e472"><textual class="po-textual">u8Suffix</textual></td><td class="po-block e473 e473"><textual class="po-textual">
                           </textual><code class="po-atom e474 e474"><textual class="po-textual">__________________1_1_1_1_1__1_1_1__1_1</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e475 e475" valign="top"><td class="po-block e476 e476"><textual class="po-textual">u8Prefix2</textual></td><td class="po-block e477 e477"><textual class="po-textual">
                           </textual><code class="po-atom e478 e478"><textual class="po-textual">_________________1_1_1_1_1__1_1_1__1_1_</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e479 e479" valign="top"><td class="po-block e480 e480"><textual class="po-textual">u8Scope22</textual></td><td class="po-block e481 e481"><textual class="po-textual">
                           </textual><code class="po-atom e482 e482"><textual class="po-textual">__________________1_1_1_1_1__1_1_1__1_1</textual></code><textual class="po-textual">
                           
                        </textual></td></tr><tr class="po-table e483 e483" valign="top"><td class="po-block e484 e484"><textual class="po-textual">ErrorFlag</textual></td><td class="po-block e485 e485"><textual class="po-textual">
                           </textual><code class="po-atom e486 e486"><textual class="po-textual">_______________________________________</textual></code><textual class="po-textual">
                        </textual></td></tr></tbody></table><textual class="po-textual">
               

            </textual></para></section><section class="po-hcontainer e487 e487"><title class="po-block e488 e488"><textual class="po-textual">UTF-8 Validation Streams</textual></title><para class="po-block e489 e489"><textual class="po-textual"> Proper formation of UTF-8 byte sequences requires that the correct number of
               suffix bytes always follow a UTF-8 prefix byte, and that certain illegal byte
               combinations are ruled out. For example, sequences beginning with the prefix bytes
               0xF5 through 0xFF are illegal as they would represent code point values above 10FFFF.
               In addition, there are constraints on the first suffix byte following certain special
               prefixes, namely that a suffix following the prefix 0xE0 must fall in the range
               0xA0–0xBF, a suffix following the prefix 0xED must fall in the range 0x80–0x9F, a
               suffix following the prefix 0xF0 must fall in the range 0x90–0xBF and a suffix
               following the prefix 0xF4 must fall in the range 0x80–0x8F. The task of ensuring that
               each of these constraints hold is known as UTF-8 validation. The bit streams xE0,
               xED, xF0, xF4, xA0_xBF, x80_x9F, x90_xBF, and x80_x8F are constructed to flag the
               aforementioned UTF-8 validation errors. The result of UTF-8 validation is a UTF-8
               error flag bit stream contructed as the ORing of a series of UTF-8 validation tests.
            </textual></para></section><section class="po-hcontainer e490 e490"><title class="po-block e491 e491"><textual class="po-textual">XML Character Validation Streams</textual></title><para class="po-block e492 e492"><textual class="po-textual">The UTF-8 character sequences </textual><emphasis class="po-inline e493 e493"><textual class="po-textual">0xEF 0xBF 0xBF</textual></emphasis><textual class="po-textual"> and
                  </textual><emphasis class="po-inline e494 e494"><textual class="po-textual">0xEF 0xBF 0xBE</textual></emphasis><textual class="po-textual"> correspond to the Unicode code points 0xFFFE
               and 0xFFFF respectively. In XML 1.0, 0xFFFE and 0xFFFF represent characters outside
               the legal XML character ranges. As such, bit streams which mark 0xEF, 0xBF, and 0xBE
               character are constructed to flag illegal UTF-8 character sequences. </textual></para></section><section class="po-hcontainer e495 e495"><title class="po-block e496 e496"><textual class="po-textual">UTF-8 to UTF-16 Transcoding</textual></title><para class="po-block e497 e497"><textual class="po-textual">UTF-8 is often preferred for storage and data exchange, it is suitable for
               processing, but it is significantly more complex to process than UTF-16 [</textual><xref class="po-milestone e498 e498" linkend="Unicode"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. As such, XML documents are typically encoded in UTF-8 for
               serialization and transport, and subsequently transcoded to UTF-16 for processing
               with programming languages such as Java and C#. Following the parallel bit stream
               methods developed for the u8u16 transcoder, a high-performance standalone UTF-8 to
               UTF-16 transcoder [</textual><xref class="po-milestone e499 e499" linkend="u8u16"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], transcoding to UTF-16 may be achieved by
               computing a series of 16 bit streams. One stream for each of the individual bits of a
               UTF-16 code unit. </textual></para><para class="po-block e500 e500"><textual class="po-textual">The bit streams for UTF-16 are conveniently divided into groups: the eight streams
               u16Hi0, u16Hi1, ..., u16Hi7 for the high byte of each UTF-16 code unit and the eight
               streams u16Lo1, ..., u16Lo7 for the low byte. Upon conversion of the parallel bit
               stream data back to byte streams, eight sequential byte streams U16h0, U16h1, ...,
               U16Hi7 are used for the high byte of each UTF-16 code unit, while U16Lo0, U16Lo1,...,
               U16Lo7 are used for the corresponding low byte. Interleaving these streams then
               produces the full UTF-16 doublebyte stream.</textual></para></section><section class="po-hcontainer e501 e501"><title class="po-block e502 e502"><textual class="po-textual">UTF-8 Indexed UTF-16 Streams</textual></title><para class="po-block e503 e503"><textual class="po-textual">UTF-16 bit streams are initially defined in UTF-8 indexed form. That is, with sets
               of bits in one-to-one correspondence with UTF-8 bytes. However, only one set of
               UTF-16 bits is required for encoding two or three-byte UTF-8 sequences and only two
               sets are required for surrogate pairs corresponding to four-byte UTF-8 sequences. The
               u8LastByte (u8UniByte , u8Scope22 , u8Scope33 , and u8Scope44 ) and u8Scope42 streams
               mark the positions at which the correct UTF-16 bits are computed. The bit sets at
               other positions must be deleted to compress the streams to the UTF-16 indexed form.
            </textual></para></section></section><section class="po-hcontainer e504 e504"><title class="po-block e505 e505"><textual class="po-textual">Control Character Streams</textual></title><para class="po-block e506 e506"><textual class="po-textual">The control character bit streams marks ASCII control characters in the range
            0x00-0x1F. Additional control character bit streams mark the tab, carriage return, line
            feed, and space character. In addition, a bit stream to mark carriage return line
            combinations is also constructed. Presently, control character bit streams support the
            operations of XML 1.0 character validation and XML end-of-line handling.</textual></para><section class="po-hcontainer e507 e507"><title class="po-block e508 e508"><textual class="po-textual">XML Character Validation</textual></title><para class="po-block e509 e509"><textual class="po-textual">Legal characters in XML are the tab, carriage return, and line feed characters,
               together with all Unicode characters and excluding the surrogate blocks, as well as hexadecimal OxFFFE and
               OxFFFF [</textual><xref class="po-milestone e510 e510" linkend="XML10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The x00_x1F bit stream is constructed and used in
               combination with the additional control character bit streams to flags the positions
               of illegal control characters.</textual></para></section><section class="po-hcontainer e511 e511"><title class="po-block e512 e512"><textual class="po-textual">XML 1.0 End-of-line Handling</textual></title><para class="po-block e513 e513"><textual class="po-textual">In XML 1.0 the two-character sequence CR LF (carriage return, line feed) as well as
               any CR character not followed by a LF character must be converted to a single LF
               character [</textual><xref class="po-milestone e514 e514" linkend="XML10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e515 e515"><textual class="po-textual">By defining carriage return, line feed, and carriage return line feed bit streams,
               dentoted CR, LF and CRLF respectively, end-of-line normalization processing can be
               performed in parallel using only a small number of logical and shift operations.</textual></para><para class="po-block e516 e516"><textual class="po-textual">The following example demonstrates the generation of the CRLF deletion mask. In
               this example, the position of all CR characters followed by LF characters are marked
               for deletion. Isolated carriage returns are then replaced with LF characters.
               Completion of this process satisfies the XML 1.0 end-of-line handling requirements.
               For clarity, this example encodes input data carriage returns as
               </textual><emphasis class="po-inline e517 e517"><textual class="po-textual">C</textual></emphasis><textual class="po-textual"> characters, whereas line feed characters are shown as
                  </textual><emphasis class="po-inline e518 e518"><textual class="po-textual">L</textual></emphasis><textual class="po-textual"> characters.</textual></para><para class="po-block e519 e519"><textual class="po-textual">
               </textual><table class="po-container e520 e520"><caption class="po-container e521 e521"><para class="po-block e522 e522"><textual class="po-textual">XML 1.0 End-of-line Handling</textual></para></caption><colgroup class="po-null e523 e523" span="1"><col align="left" class="po-meta e524 e524" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e525 e525"><tr class="po-table e526 e526" valign="top"><td class="po-block e527 e527"><textual class="po-textual">Input Data</textual></td><td class="po-block e528 e528"><textual class="po-textual">
                           </textual><code class="po-atom e529 e529"><textual class="po-textual">first line C second line CL third line L one more C nothing
                           left</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e530 e530" valign="top"><td class="po-block e531 e531"><textual class="po-textual">CR</textual></td><td class="po-block e532 e532"><textual class="po-textual">
                           </textual><code class="po-atom e533 e533"><textual class="po-textual">-----------1-------------1------------------------1-------------</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e534 e534" valign="top"><td class="po-block e535 e535"><textual class="po-textual">LF</textual></td><td class="po-block e536 e536"><textual class="po-textual">
                           </textual><code class="po-atom e537 e537"><textual class="po-textual">--------------------------1------------1------------------------</textual></code><textual class="po-textual">
                        </textual></td></tr><tr class="po-table e538 e538" valign="top"><td class="po-block e539 e539"><textual class="po-textual">DelMask</textual></td><td class="po-block e540 e540"><textual class="po-textual">
                           </textual><code class="po-atom e541 e541"><textual class="po-textual">--------------------------1-------------------------------------</textual></code><textual class="po-textual">
                        </textual></td></tr></tbody></table><textual class="po-textual">

            </textual></para></section></section><section class="po-hcontainer e542 e542"><title class="po-block e543 e543"><textual class="po-textual">Call Out Streams</textual></title><para class="po-block e544 e544"><textual class="po-textual"> Call out bit streams mark the extents of XML markup structures such as comments,
            processing instruction and CDATA sections as well as physical structures such as character and
            entity references and general references.  Call out streams are also formed for logical markup structures such
            start tags, end tags and empty element tags. </textual></para><section class="po-hcontainer e545 e545"><title class="po-block e546 e546"><textual class="po-textual">Comment, Processing Instruction and CDATA Section Call Out Streams</textual></title><para class="po-block e547 e547"><textual class="po-textual">Comments, processing instructions and CDATA sections call out streams, Ct_Span,
               PI_Span and CD_Span respectively, define sections of an XML document which 
               contain markup that is not interpreted by an XML processor. As such, the union of
               Ct_Span, PI_Span and CD_Span streams defines the regions of non-interpreteable markup. 
               The stream formed by this union is termed the CtCDPI_Mask.</textual></para><para class="po-block e548 e548"><textual class="po-textual">The following tables provides an example of constructing the CtCDPI_Mask. </textual></para><table class="po-container e549 e549"><caption class="po-container e550 e550"><para class="po-block e551 e551"><textual class="po-textual">CtCDPI Mask Generation</textual></para></caption><colgroup class="po-null e552 e552" span="1"><col align="left" class="po-meta e553 e553" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e554 e554" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e555 e555"><tr class="po-table e556 e556" valign="top"><td class="po-block e557 e557"><textual class="po-textual">Input Data</textual></td><td class="po-block e558 e558"><code class="po-atom e559 e559"><textual class="po-textual">&lt;?php?&gt; &lt;!-- example --&gt; &lt;![CDATA[ shift: a&lt;&lt;1 ]]&gt;</textual></code></td></tr><tr class="po-table e560 e560" valign="top"><td class="po-block e561 e561"><textual class="po-textual">CD_Span</textual></td><td class="po-block e562 e562"><code class="po-atom e563 e563"><textual class="po-textual">___________________________1111111111111111111111_</textual></code></td></tr><tr class="po-table e564 e564" valign="top"><td class="po-block e565 e565"><textual class="po-textual">Ct_Span</textual></td><td class="po-block e566 e566"><code class="po-atom e567 e567"><textual class="po-textual">___________111111111111___________________________</textual></code></td></tr><tr class="po-table e568 e568" valign="top"><td class="po-block e569 e569"><textual class="po-textual">PI_Span</textual></td><td class="po-block e570 e570"><code class="po-atom e571 e571"><textual class="po-textual">_11111____________________________________________</textual></code></td></tr><tr class="po-table e572 e572" valign="top"><td class="po-block e573 e573"><textual class="po-textual">CtCDPI_Mask</textual></td><td class="po-block e574 e574"><code class="po-atom e575 e575"><textual class="po-textual">_111111__111111111111111__111111111111111111111111</textual></code></td></tr><tr class="po-table e576 e576" valign="top"><td class="po-block e577 e577"><textual class="po-textual">ErrorFlag</textual></td><td class="po-block e578 e578"><code class="po-atom e579 e579"><textual class="po-textual">__________________________________________________</textual></code></td></tr></tbody></table><para class="po-block e580 e580"><textual class="po-textual"> With the removal of all non-interpreteable markup, several phases of parallel bit
               stream based SIMD operations may follow operating on up to 128 byte positions on
               current commondity processors and assured of XML markup relevancy. For
               example, with the extents identification of comments, processing instructions and
               CDATA sections, XML names may be identified and length sorted for efficient symbol
               table construction. </textual></para><para class="po-block e581 e581"><textual class="po-textual"> As an aside, comments and CDATA sections must first be validated to ensure
               that comments do not contain "--" sequences and that CDATA sections do not contain illegal
               "]]&gt;" sequences prior to ignorable markup stream generation.</textual></para></section><section class="po-hcontainer e582 e582"><title class="po-block e583 e583"><textual class="po-textual">Reference Call Out Streams</textual></title><para class="po-block e584 e584"><textual class="po-textual">The reference call out streams are the GenRefs, DecRefs, and HexRefs streams. This
               subset of the call out streams marks the extents of all but the closing semicolon of
               general and character references.</textual></para><para class="po-block e585 e585"><textual class="po-textual">Predefined character
               (&amp;lt;,&amp;gt;,&amp;amp;,&amp;apos;,&amp;quot;) and numeric character
               references (&amp;#nnnn;, &amp;#xhhhh;) must be replaced by a single character
                  [</textual><xref class="po-milestone e586 e586" linkend="XML10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. As previously shown, this subset of call out streams enables the construction of a DelMask for
               references.</textual></para></section><section class="po-hcontainer e587 e587"><title class="po-block e588 e588"><textual class="po-textual">Tag Call Out Streams</textual></title><para class="po-block e589 e589"><textual class="po-textual">Whereas sequential bit scans over lexical item streams form the basis of XML
               parsing, in the current Parabix parser a new method of parallel parsing has been
               developed and prototyped using the concept of bitstream addition. Fundamental to this
               method is the concept of a </textual><emphasis class="po-inline e590 e590"><textual class="po-textual">cursor</textual></emphasis><textual class="po-textual"> stream, a bit stream marking
               the positions of multiple parallel parses currently in process. </textual></para><para class="po-block e591 e591"><textual class="po-textual">The results of parallel parsing using the bit stream addition technique produces a
               set of tag call out bit streams. These streams mark the extents of each start tag,
               end tag and empty element tag. Within tags, additional streams mark start
               and end positions for tag names, as well as attribute names and values. An error flag
               stream marks the positions of any syntactic errors encountered during parsing.</textual></para><para class="po-block e592 e592"><textual class="po-textual"> The set of tag call out streams consists of the ElemNames, AttNames, AttVals, Tags,
               EmptyTagEnds and EndTags bit streams. The following example demonstrates the bit
               stream output produced which from parallel parsing using bit stream addition. </textual></para><table class="po-container e593 e593"><caption class="po-container e594 e594"><para class="po-block e595 e595"><textual class="po-textual">Tag Call Out Streams</textual></para></caption><colgroup class="po-null e596 e596" span="1"><col align="left" class="po-meta e597 e597" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e598 e598" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e599 e599"><tr class="po-table e600 e600" valign="top"><td class="po-block e601 e601"><textual class="po-textual">Input Data</textual></td><td class="po-block e602 e602"><textual class="po-textual">
                        </textual><code class="po-atom e603 e603"><textual class="po-textual">&lt;root&gt;&lt;t1&gt;text&lt;/t1&gt;&lt;t2
                           a1='foo' a2 =
                           'fie'&gt;more&lt;/t2&gt;&lt;tag3
                           att3='b'/&gt;&lt;/root&gt;</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e604 e604" valign="top"><td class="po-block e605 e605"><textual class="po-textual">ElemNames</textual></td><td class="po-block e606 e606"><textual class="po-textual">
                        </textual><code class="po-atom e607 e607"><textual class="po-textual">_1111__11___________11_______________________________1111__________________</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e608 e608" valign="top"><td class="po-block e609 e609"><textual class="po-textual">AttNames</textual></td><td class="po-block e610 e610"><textual class="po-textual">
                        </textual><code class="po-atom e611 e611"><textual class="po-textual">_______________________11_______11________________________1111_____________</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e612 e612" valign="top"><td class="po-block e613 e613"><textual class="po-textual">AttrVals</textual></td><td class="po-block e614 e614"><textual class="po-textual">
                        </textual><code class="po-atom e615 e615"><textual class="po-textual">__________________________11111______11111_____________________111_________</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e616 e616" valign="top"><td class="po-block e617 e617"><textual class="po-textual">EmptyTagEnds</textual></td><td class="po-block e618 e618"><textual class="po-textual">
                        </textual><code class="po-atom e619 e619"><textual class="po-textual">___________________________________________________________________1_______</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e620 e620" valign="top"><td class="po-block e621 e621"><textual class="po-textual">EndTags</textual></td><td class="po-block e622 e622"><textual class="po-textual">
                        </textual><code class="po-atom e623 e623"><textual class="po-textual">_______________111______________________________111__________________11111_</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e624 e624" valign="top"><td class="po-block e625 e625"><textual class="po-textual">Start/EmptyTags</textual></td><td class="po-block e626 e626"><textual class="po-textual">
                        </textual><code class="po-atom e627 e627"><textual class="po-textual">_1111__11___________1111111111111111111111___________11111111111111________</textual></code><textual class="po-textual">
                     </textual></td></tr><tr class="po-table e628 e628" valign="top"><td class="po-block e629 e629"><textual class="po-textual">ErrorFlag</textual></td><td class="po-block e630 e630"><textual class="po-textual">
                        </textual><code class="po-atom e631 e631"><textual class="po-textual">___________________________________________________________________________</textual></code><textual class="po-textual">
                     </textual></td></tr></tbody></table></section></section></section><section class="po-hcontainer e632 e632"><title class="po-block e633 e633"><textual class="po-textual">SIMD Beyond Bitstreams: Names and Numbers</textual></title><para class="po-block e634 e634"><textual class="po-textual">Whereas the fundamental innovation of our work is the use of SIMD technology in
         implementing parallel bit streams for XML, there are also important ways in which more
         traditional byte-oriented SIMD operations can be useful in accelerating other aspects of
         XML processing.</textual></para><section class="po-hcontainer e635 e635"><title class="po-block e636 e636"><textual class="po-textual">Name Lookup</textual></title><para class="po-block e637 e637"><textual class="po-textual">Efficient symbol table mechanisms for looking up element and attribute names is
            important for almost all XML processing applications. It is also an important technique
            merely for assessing well-formedness of an XML document; rather than validating the
            character-by-character composition of each occurrence of an XML name as it is
            encountered, it is more efficient to validate all but the first occurrence by first
            determining whether the name already exists in a table of prevalidated names.</textual></para><para class="po-block e638 e638"><textual class="po-textual">The first symbol table mechanism deployed in the Parabix parser simply used the
            hashmaps of the C++ standard template library, without deploying any SIMD technology.
            However, with the overhead of character validation, transcoding and parsing dramatically
            reduced by parallel bit stream technology, we found that symbol lookups then accounted
            for about half of the remaining execution time in a statistics gathering application
               [</textual><xref class="po-milestone e639 e639" linkend="CASCON08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Thus, symbol table processing was identified as a major
            target for further performance improvement. </textual></para><para class="po-block e640 e640"><textual class="po-textual"> Our first effort to improve symbol table performance was to employ the splash tables
            with cuckoo hashing as described by Ross [</textual><xref class="po-milestone e641 e641" linkend="Ross06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], using SIMD
            technology for parallel bucket processing. Although this technique did turn out to have
            the advantage of virtually constant-time performance even for very large vocabularies,
            it was not particularly helpful for the relatively small vocabularies typically found in
            XML document processing. </textual></para><para class="po-block e642 e642"><textual class="po-textual"> However, a second approach has been found to be quite useful, taking advantage of
            parallel bit streams for cheap determination of symbol length. In essence, the length of
            a name can be determined very cheaply using a single bit scan operation. This then makes
            it possible to use length-sorted symbol table processing, as follows. First, the
            occurrences of all names are stored in arrays indexed by length. Then the length-sorted
            arrays may each be inserted into the symbol table in turn. The advantage of this is that
            a separate loop may be written for each length. Length sorting makes for very efficient
            name processing. For example hash value computations and name comparisons can be made by
            loading multibyte values and performing appropriate shifting and masking operations,
            without the need for a byte-at-a-time loop. In initial experiments, this length-sorting
            approach was found to reduce symbol lookup cost by a factor of two. </textual></para><para class="po-block e643 e643"><textual class="po-textual"> Current research includes the application of SIMD technology to further enhance the
            performance of length-sorted lookup. We have identified a promising technique for
            parallel processing of multiple name occurrences using a parallel trie lookup technique.
            Given an array of occurrences of names of a particular length, the first one, two or
            four bytes of each name are gathered and stored in a linear array. SIMD techniques are
            then used to compare these prefixes with the possible prefixes for the current position
            within the trie. In general, a very small number of possibilities exist for each trie
            node, allowing for fast linear search through all possibilities. Typically, the
            parallelism is expected to exceed the number of possibilities to search through at each
            node. With length-sorting to separate the top-level trie into many small subtries, we
            expect only a single step of symbol lookup to be needed in most practical instances. </textual></para><para class="po-block e644 e644"><textual class="po-textual">The gather step of this algorithm is actually a common technique in SIMD processing.
            Instruction set support for gather operations is a likely future direction for SIMD
            technology.</textual></para></section><section class="po-hcontainer e645 e645"><title class="po-block e646 e646"><textual class="po-textual">Numeric Processing</textual></title><para class="po-block e647 e647"><textual class="po-textual"> Many XML applications involve numeric data fields as attribute values or element
            content. Although most current XML APIs uniformly return information to applications in
            the form of character strings, it is reasonable to consider direct API support for
            numeric conversions within a high-performance XML engine. With string to numeric
            conversion such a common need, why leave it to application programmers? </textual></para><para class="po-block e648 e648"><textual class="po-textual"> High-performance string to numeric conversion using SIMD operations also can
            considerably outperform the byte-at-a-time loops that most application programmers or
            libraries might employ. A first step is reduction of ASCII bytes to corresponding
            decimal nybbles using a SIMD packing operation. Then an inductive doubling algorithm
            using SIMD operations may be employed. First, 16 sets of adjacent nybble values in the
            range 0-9 can be combined in just a few SIMD operations to 16 byte values in the range
            0-99. Then 8 sets of byte values may similarly be combined with further SIMD processing
            to produce doublebyte values in the range 0-9999. Further combination of doublebyte
            values into 32-bit integers and so on can also be performed using SIMD operations. </textual></para><para class="po-block e649 e649"><textual class="po-textual"> Using appropriate gather operations to bring numeric strings into appropriate array
            structures, an XML engine could offer high-performance numeric conversion services to
            XML application programmers. We expect this to be an important direction for our future
            work, particularly in support of APIs that focus on direct conversion of XML data into
            business objects. </textual></para></section></section><section class="po-hcontainer e650 e650"><title class="po-block e651 e651"><textual class="po-textual">APIs and Parallel Bit Streams</textual></title><section class="po-hcontainer e652 e652"><title class="po-block e653 e653"><textual class="po-textual">The ILAX Streaming API</textual></title><para class="po-block e654 e654"><textual class="po-textual">The In-Line API for XML (ILAX) is the base API provided with the Parabix parser. It
            is intended for low-level extensions compiled right into the engine, with minimum
            possible overhead. It is similar to streaming event-based APIs such as SAX, but
            implemented by inline substitution rather than using callbacks. In essence, an extension
            programmer provides method bodies for event-processing methods declared internal to the
            Parabix parsing engine, compiling the event processing code directly with the core code
            of the engine. </textual></para><para class="po-block e655 e655"><textual class="po-textual"> Although ILAX can be used directly for application programming, its primary use is
            for implementing engine extensions that support higher-level APIs. For example, the
            implementation of C or C++ based streaming APIs based on the Expat [</textual><xref class="po-milestone e656 e656" linkend="Expat"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] or general SAX models can be quite directly implemented. C/C++ DOM
            or other tree-based APIs can also be fairly directly implemented. However, delivering
            Parabix performance to Java-based XML applications is challenging due to the
            considerable overhead of crossing the Java Native Interface (JNI) boundary. This issue
            is addressed with the Array Set Model (ASM) concept discussed in the following section. </textual></para><para class="po-block e657 e657"><textual class="po-textual"> With the recent development of parallel parsing using bitstream addition, it is
            likely that the underlying ILAX interface of Parabix will change. In essence, ILAX
            suffers the drawback of all event-based interfaces: they are fundamentally sequential in
            number. As research continues, we expect efficient parallel methods building on parallel
            bit stream foundations to move up the stack of XML processing requirements. Artificially
            imposing sequential processing is thus expected to constrain further advances in XML
            performance. </textual></para></section><section class="po-hcontainer e658 e658"><title class="po-block e659 e659"><textual class="po-textual">Efficient XML in Java Using Array Set Models</textual></title><para class="po-block e660 e660"><textual class="po-textual"> In our GML-to-SVG case study, we identified the lack of high-performance XML
            processing solutions for Java to be of particular interest. Java byte code does not
            provide access to the SIMD capabilities of the underlying machine architecture. Java
            just-in-time compilers might be capable of using some SIMD facilities, but there is no
            real prospect of conventional compiler technology translating byte-at-a-time algorithms
            into parallel bit stream code. So the primary vehicle for delivering high-performance
            XML processing is to call native parallel bit stream code written in C through JNI
            capabilities. </textual></para><para class="po-block e661 e661"><textual class="po-textual">However, each JNI call is expensive, so it is desirable to minimize the number of
            calls and get as much work done during each call as possible. This mitigates against
            direct implementation of streaming APIs in Java through one-to-one mappings to an
            underlying streaming API in C. Instead, we have concentrated on gathering information on
            the C side into data structures that can then be passed to the Java side. However, using
            either C pointer-based structures or C++ objects is problematic because these are
            difficult to interpret on the Java side and are not amenable to Java's automatic storage
            management system. Similarly, Java objects cannot be conveniently created on the C side.
            However, it is possible to transfer arrays of simple data values (bytes or integers)
            between C and Java, so that makes a reasonable focus for bulk data communication between
            C and Java. </textual></para><para class="po-block e662 e662"><emphasis class="po-inline e663 e663"><textual class="po-textual">Array Set Models</textual></emphasis><textual class="po-textual"> are array-based representations of information
            representing an XML document in accord with XML InfoSet [</textual><xref class="po-milestone e664 e664" linkend="InfoSet"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] or
            other XML data models relevant to particular APIs. As well as providing a mechanism for
            efficient bulk data communication across the JNI boundary, ASMs potentially have a
            number of other benefits in high-performance XML processing. </textual><itemizedlist class="po-table e665 e665"><listitem class="po-container e666 e666"><para class="po-block e667 e667"><textual class="po-textual">Prefetching. Commodity processors commonly support hardware and/or software
                     prefetching to ensure that data is available in a processor cache when it is
                     needed. In general, prefetching is most effective in conjunction with the
                     continuous sequential memory access patterns associated with array
                  processing.</textual></para></listitem><listitem class="po-container e668 e668"><para class="po-block e669 e669"><textual class="po-textual">DMA. Some processing environments provide Direct Memory Access (DMA)
                     controllers for block data movement in parallel with computation. For example,
                     the Cell Broadband Engine uses DMA controllers to move the data to and from the
                     local stores of the synergistic processing units. Arrays of contiguous data
                     elements are well suited to bulk data movement using DMA.</textual></para></listitem><listitem class="po-container e670 e670"><para class="po-block e671 e671"><textual class="po-textual">SIMD. Single Instruction Multiple Data (SIMD) capabilities of modern
                     processor instruction sets allow simultaneous application of particular
                     instructions to sets of elements from parallel arrays. For effective use of
                     SIMD capabilities, an SoA (Structure of Arrays) model is preferrable to an AoS
                     (Array of Structures) model. </textual></para></listitem><listitem class="po-container e672 e672"><para class="po-block e673 e673"><textual class="po-textual">Multicore processors. Array-oriented processing can enable the effective
                     distribution of work to the individual cores of a multicore system in two
                     distinct ways. First, provided that sequential dependencies can be minimized or
                     eliminated, large arrays can be divided into separate segments to be processed
                     in parallel on each core. Second, pipeline parallelism can be used to implement
                     efficient multipass processing with each pass consisting of a processing kernel
                     with array-based input and array-based output. </textual></para></listitem><listitem class="po-container e674 e674"><para class="po-block e675 e675"><textual class="po-textual">Streaming buffers for large XML documents. In the event that an XML document
                     is larger than can be reasonably represented entirely within processor memory,
                     a buffer-based streaming model can be applied to work through a document using
                     sliding windows over arrays of elements stored in document order. </textual></para></listitem></itemizedlist><textual class="po-textual">
         </textual></para><section class="po-hcontainer e676 e676"><title class="po-block e677 e677"><textual class="po-textual">Saxon-B TinyTree Example</textual></title><para class="po-block e678 e678"><textual class="po-textual">As a first example of the ASM concept, current work includes a proof-of-concept to
               deliver a high-performance replacement for building the TinyTree data structure used
               in Saxon-B 6.5.5, an open-source XSLT 2.0 processor written in Java [</textual><xref class="po-milestone e679 e679" linkend="Saxon"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Although XSLT stylesheets may be cached for performance, the
               caching of source XML documents is typically not possible. A new TinyTree object to
               represent the XML source document is thus commonly constructed with each new query so
               that the overall performance of simple queries on large source XML documents is
               highly dependent on TinyTree build time. Indeed, in a study of Saxon-SA, the
               commercial version of Saxon, query time was shown to be dominated by TinyTree build
               time [</textual><xref class="po-milestone e680 e680" linkend="Kay08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Similar performance results are demonstrable for the
               Saxon-B XSLT processor as well. </textual></para><para class="po-block e681 e681"><textual class="po-textual"> The Saxon-B processor studied is a pure Java solution, converting a SAX (Simple
               API for XML) event stream into the TinyTree Java object using the efficient Aelfred
               XML parser [</textual><xref class="po-milestone e682 e682" linkend="AElfred"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The TinyTree structure is itself an
               array-based structure mapping well suited to the ASM concept. It consists of six
               parallel arrays of integers indexed on node number and containing one entry for each
               node in the source document, with the exception of attribute and namespace nodes
                  [</textual><xref class="po-milestone e683 e683" linkend="Saxon"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Four of the arrays respectively provide node kind, name
               code, depth, and next sibling information for each node, while the two others are
               overloaded for different purposes based on node kind value. For example, in the
               context of a text node , one of the overloaded arrays holds the text buffer offset
               value whereas the other holds the text buffer length value. Attributes and namespaces
               are represented using similiar parallel array of values. The stored TinyTree values
               are primarily primitive Java types, however, object types such as Java Strings and
               Java StringBuffers are also used to hold attribute values and comment values
               respectively. </textual></para><para class="po-block e684 e684"><textual class="po-textual"> In addition to the TinyTree object, Saxon-B maintains a NamePool object which
               represents a collection of XML name triplets. Each triplet is composed of a Namespace
               URI, a Namespace prefix and a local name and encoded as an integer value known as a
               namecode. Namecodes permit efficient name search and look-up using integer
               comparison. Namecodes may also be subsequently decoded to recover namespace and local
               name information. </textual></para><para class="po-block e685 e685"><textual class="po-textual"> Using the Parabix ILAX interface, a high-performance reimplementation of TinyTree
               and NamePool data structures was built to compare with the Saxon-B implementation. In
               fact, two functionally equivalent versions of the ASM java class were constructed. An
               initial version was constructed based on a set of primitive Java arrays constructed
               and allocated in the Java heap space via JNI New&lt;PrimitiveType&gt;Array
               method call. In this version, the JVM garbage collector is aware of all memory
               allocated in the native code. However, in this approach, large array copy operations
               limited overall performance to approximately a 2X gain over the Saxon-B build time. </textual></para><para class="po-block e686 e686"><textual class="po-textual">To further address the performance penalty imposed by copying large array values,
               a second version of the ASM Java object was constructed based on natively backed
               Direct Memory Byte Buffers [</textual><xref class="po-milestone e687 e687" linkend="JNI"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. In this version the JVM garbage
               collector is unaware any native memory resources backing the Direct Memory Byte
               Buffers. Large JNI-based copy operations are avoided; however, system memory must be
               explicitly deallocated via a Java native method call. Using this approach, our
               preliminary results show an approximate total 2.5X gain over Saxon-B build time.
            </textual></para></section></section></section><section class="po-hcontainer e688 e688"><title class="po-block e689 e689"><textual class="po-textual">Compiler Technology</textual></title><para class="po-block e690 e690"><textual class="po-textual"> An important focus of our recent work is on the development of compiler technology to
         automatically generate the low-level SIMD code necessary to implement bit stream processing
         given suitable high-level specifications. This has several potential benefits. First, it
         can eliminate the tedious and error-prone programming of bit stream operations in terms of
         register-at-a-time SIMD operations. Second, compilation technology can automatically employ
         a variety of performance improvement techniques that are difficult to apply manually. These
         include algorithms for instruction scheduling and register allocation as well as
         optimization techniques for common subexpression expression elimination and register
         rematerialization among others. Third, compiler technology makes it easier to make changes
         to the low-level code for reasons of perfective or adaptive maintenance.</textual></para><para class="po-block e691 e691"><textual class="po-textual">Beyond these reasons, compiler technology also offers the opportunity for retargetting
         the generation of code to accommodate different processor architectures and API
         requirements. Strategies for efficient parallel bit stream code can vary considerably
         depending on processor resources such as the number of registers available, the particular
         instruction set architecture supported, the size of L1 and L2 data caches, the number of
         available cores and so on. Separate implementation of custom code for each processor
         architecture would thus be likely to be prohibitively expensive, prone to errors and
         inconsistencies and difficult to maintain. Using compilation technology, however, the idea
         would be to implement a variety of processor-specific back-ends all using a common front
         end based on parallel bit streams. </textual></para><section class="po-hcontainer e692 e692"><title class="po-block e693 e693"><textual class="po-textual">Character Class Compiler</textual></title><para class="po-block e694 e694"><textual class="po-textual">The first compiler component that we have implemented is a character class compiler,
            capable of generation all the bit stream logic necessary to produce a set of lexical
            item streams each corresponding to some particular set of characters to be recognized.
            By taking advantage of common patterns between characters within classes, and special
            optimization logic for recognizing character-class ranges, our existing compiler is able
            to generate well-optimized code for complex sets of character classes involving numbers
            of special characters as well as characters within specific sets of ranges. </textual></para></section><section class="po-hcontainer e695 e695"><title class="po-block e696 e696"><textual class="po-textual">Regular Expression Compilation</textual></title><para class="po-block e697 e697"><textual class="po-textual">Based on the character class compiler, we are currently investigating the
            construction of a regular expression compiler that can implement bit-stream based
            parallel regular-expression matching similar to that describe previously for parallel
            parsing by bistream addition. This compiler works with the assumption that bitstream
            regular-expression definitions are deterministic; no backtracking is permitted with the
            parallel bit stream representation. In XML applications, this compiler is primarily
            intended to enforce regular-expression constraints on string datatype specifications
            found in XML schema. </textual></para></section><section class="po-hcontainer e698 e698"><title class="po-block e699 e699"><textual class="po-textual">Unbounded Bit Stream Compilation</textual></title><para class="po-block e700 e700"><textual class="po-textual">The Catalog of XML Bit Streams presented earlier consist of a set of abstract,
            unbounded bit streams, each in one-to-one correspondence with input bytes of a text
            file. Determining how these bit streams are implemented using fixed-width SIMD
            registers, and possibly processed in fixed-length buffers that represent some multiple
            of the register width is a source of considerable programming complexity. The general
            goal of our compilation strategy in this case is to allow operations to be programmed in
            terms of unbounded bit streams and then automatically reduced to efficient low-level
            code with the application of a systematic code generation strategy for handling block
            and buffer boundary crossing. This is work currently in progress. </textual></para></section></section><section class="po-hcontainer e701 e701"><title class="po-block e702 e702"><textual class="po-textual">Conclusion</textual></title><para class="po-block e703 e703"><textual class="po-textual">Parallel bit stream technology offers the opportunity to dramatically speed up the core
         XML processing components used to implement virtually any XML API. Character validation and
         transcoding, whitespace processing, and parsing up to including the full validation of tag
         syntax can be handled fully in parallel using bit stream methods. Bit streams to mark the
         positions of all element names, attribute names and attribute values can also be produced,
         followed by fast bit scan operations to generate position and length values. Beyond bit
         streams, byte-oriented SIMD processing of names and numerals can also accelerate
         performance beyond sequential byte-at-a-time methods. </textual></para><para class="po-block e704 e704"><textual class="po-textual">Advances in processor architecture are likely to further amplify the performance of
         parallel bit stream technology over traditional byte-at-a-time processing over the next
         decade. Improvements to SIMD register width, register complement and operation format can
         all result in further gains. New SIMD instruction set features such as inductive doubling
         support, parallel extract and deposit instructions, bit interleaving and scatter/gather
         capabilities should also result in significant speed-ups. Leveraging the intraregister
         parallelism of parallel bit stream technology within SIMD registers to take of intrachip
         parallelism on multicore processors should accelerate processing further. </textual></para><para class="po-block e705 e705"><textual class="po-textual">Technology transfer using a patent-based open-source business model is a further goal of
         our work with a view to widespread deployment of parallel bit stream technology in XML
         processing stacks implementing a variety of APIs. The feasibility of substantial
         performance improvement in replacement of technology implementing existing APIs has been
         demonstrated even in complex software architectures involving delivery of performance
         benefits across the JNI boundary. We are seeking to accelerate these deployment efforts
         both through the development of compiler technology to reliably apply these methods to a
         variety of architectures as well as to identify interested collaborators using open-source
         or commercial models. </textual></para></section><section class="po-hcontainer e706 e706"><title class="po-block e707 e707"><textual class="po-textual">Acknowledgments</textual></title><para class="po-block e708 e708"><textual class="po-textual">This work is supported in part by research grants and scholarships from the Natural
         Sciences and Engineering Research Council of Canada, the Mathematics of Information
         Technology and Complex Systems Network and the British Columbia Innovation Council. </textual></para><para class="po-block e709 e709"><textual class="po-textual">We thank our colleague Dan Lin (Linda) for her work in high-performance symbol table
         processing. </textual></para></section><bibliography class="po-hcontainer e710 e710"><title class="po-block e711 e711"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e712 e712" xml:id="XMLChip09" xreflabel="Leventhal and Lemoine 2009"><textual class="po-textual">Leventhal, Michael and
         Eric Lemoine 2009. The XML chip at 6 years. Proceedings of International Symposium on
         Processing XML Efficiently 2009, Montréal. doi: </textual><biblioid class="po-atom e713 doi e713"><textual class="po-textual">10.4242/BalisageVol4.Leventhal01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e714 e714" xml:id="Datapower09" xreflabel="Salz, Achilles and Maze 2009"><textual class="po-textual">Salz, Richard,
         Heather Achilles, and David Maze. 2009. Hardware and software trade-offs in the IBM
         DataPower XML XG4 processor card. Proceedings of International Symposium on Processing XML
         Efficiently 2009, Montréal. doi: </textual><biblioid class="po-atom e715 doi e715"><textual class="po-textual">10.4242/BalisageVol4.Salz01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e716 e716" xml:id="PPoPP08" xreflabel="Cameron 2007"><textual class="po-textual">Cameron, Robert D. 2007. A Case Study
         in SIMD Text Processing with Parallel Bit Streams UTF-8 to UTF-16 Transcoding. Proceedings
         of 13th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming 2008, Salt
         Lake City, Utah. On the Web at </textual><link class="po-inline e717 e717" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://research.ihost.com/ppopp08/</textual></link><textual class="po-textual">. doi: </textual><biblioid class="po-atom e718 doi e718"><textual class="po-textual">10.1145/1345206.1345222</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e719 e719" xml:id="CASCON08" xreflabel="Cameron, Herdy and Lin 2008"><textual class="po-textual">Cameron, Robert D.,
         Kenneth S Herdy, and Dan Lin. 2008. High Performance XML Parsing Using Parallel Bit Stream
         Technology. Proceedings of CASCON 2008. 13th ACM SIGPLAN Symposium on Principles and
         Practice of Parallel Programming 2008, Toronto. doi: </textual><biblioid class="po-atom e720 doi e720"><textual class="po-textual">10.1145/1463788.1463811</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e721 e721" xml:id="SVGOpen08" xreflabel="Herdy, Burggraf and Cameron 2008"><textual class="po-textual">Herdy, Kenneth
         S., Robert D. Cameron and David S. Burggraf. 2008. High Performance GML to SVG
         Transformation for the Visual Presentation of Geographic Data in Web-Based Mapping Systems.
         Proceedings of SVG Open 6th International Conference on Scalable Vector Graphics,
         Nuremburg. On the Web at
            </textual><link class="po-inline e722 e722" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.svgopen.org/2008/papers/74-HighPerformance_GML_to_SVG_Transformation_for_the_Visual_Presentation_of_Geographic_Data_in_WebBased_Mapping_Systems/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e723 e723" xml:id="Ross06" xreflabel="Ross 2006"><textual class="po-textual">Ross, Kenneth A. 2006. Efficient hash
         probes on modern processors. Proceedings of ICDE, 2006. ICDE 2006, Atlanta. On the Web at
            </textual><link class="po-inline e724 e724" xlink:actuate="onRequest" xlink:href="http://www1.cs.columbia.edu/~kar/pubsk/icde2007.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www1.cs.columbia.edu/~kar/pubsk/icde2007.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e725 e725" xml:id="ASPLOS09" xreflabel="Cameron and Lin 2009"><textual class="po-textual">Cameron, Robert D. and Dan
         Lin. 2009. Architectural Support for SWAR Text Processing with Parallel Bit Streams: The
         Inductive Doubling Principle. Proceedings of ASPLOS 2009, Washington, DC. doi: </textual><biblioid class="po-atom e726 doi e726"><textual class="po-textual">10.1145/1508244.1508283</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e727 e727" xml:id="Wu08" xreflabel="Wu et al. 2008"><textual class="po-textual">Wu, Yu, Qi Zhang, Zhiqiang Yu and
         Jianhui Li. 2008. A Hybrid Parallel Processing for XML Parsing and Schema Validation.
         Proceedings of Balisage 2008, Montréal. On the Web at
            </textual><link class="po-inline e728 e728" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol1/html/Wu01/BalisageVol1-Wu01.html</textual></link><textual class="po-textual">. doi: </textual><biblioid class="po-atom e729 doi e729"><textual class="po-textual">10.4242/BalisageVol1.Wu01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e730 e730" xml:id="u8u16" xreflabel="Cameron 2008"><textual class="po-textual">u8u16 - A High-Speed UTF-8 to UTF-16
         Transcoder Using Parallel Bit Streams Technical Report 2007-18. 2007. School of Computing
         Science Simon Fraser University, June 21 2007.</textual></bibliomixed><bibliomixed class="po-block e731 e731" xml:id="XML10" xreflabel="XML 1.0"><textual class="po-textual">Extensible Markup Language (XML) 1.0 (Fifth
         Edition) W3C Recommendation 26 November 2008. On the Web at
            </textual><link class="po-inline e732 e732" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/REC-xml/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e733 e733" xml:id="Unicode" xreflabel="Unicode"><textual class="po-textual">The Unicode Consortium. 2009. On the Web at
            </textual><link class="po-inline e734 e734" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://unicode.org/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e735 e735" xml:id="Pex06" xreflabel="Hilewitz and Lee 2006"><textual class="po-textual"> Hilewitz, Y. and Ruby B. Lee.
         2006. Fast Bit Compression and Expansion with Parallel Extract and Parallel Deposit
         Instructions. Proceedings of the IEEE 17th International Conference on Application-Specific
         Systems, Architectures and Processors (ASAP), pp. 65-72, September 11-13, 2006. doi: </textual><biblioid class="po-atom e736 doi e736"><textual class="po-textual">10.1109/ASAP.2006.33</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e737 e737" xml:id="InfoSet" xreflabel="XML Infoset"><textual class="po-textual">XML Information Set (Second Edition) W3C
         Recommendation 4 February 2004. On the Web at
         </textual><link class="po-inline e738 e738" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml-infoset/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e739 e739" xml:id="Saxon" xreflabel="Saxon"><textual class="po-textual">SAXON The XSLT and XQuery Processor. On the Web
         at </textual><link class="po-inline e740 e740" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://saxon.sourceforge.net/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e741 e741" xml:id="Kay08" xreflabel="Kay 2008"><textual class="po-textual"> Kay, Michael Y. 2008. Ten Reasons Why Saxon
         XQuery is Fast, IEEE Data Engineering Bulletin, December 2008.</textual></bibliomixed><bibliomixed class="po-block e742 e742" xml:id="AElfred" xreflabel="Ælfred"><textual class="po-textual"> The Ælfred XML Parser. On the Web at
            </textual><link class="po-inline e743 e743" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://saxon.sourceforge.net/aelfred.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e744 e744" xml:id="JNI" xreflabel="Hitchens 2002"><textual class="po-textual">Hitchens, Ron. Java NIO. O'Reilly, 2002.</textual></bibliomixed><bibliomixed class="po-block e745 e745" xml:id="Expat" xreflabel="Expat"><textual class="po-textual">The Expat XML Parser.
            </textual><link class="po-inline e746 e746" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://expat.sourceforge.net/</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>